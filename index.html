<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EO - Enhanced Database</title>
    <link id="dynamicFavicon" rel="icon" type="image/svg+xml" href="assets/eo-icons/eo-bracket-light.svg">
    <link id="dynamicAppleIcon" rel="apple-touch-icon" href="assets/eo-icons/eo-bracket-light.svg">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/@phosphor-icons/web"></script>
    <script src="formula_engine.js"></script>
    <script src="formula_field_service.js"></script>
    <script src="eo_lean_context.js"></script>
    <style>
        :root {
            --primary: #111827;
            --primary-dark: #0f172a;
            --surface: #ffffff;
            --muted-surface: #f4f5f7;
            --border: #e5e7eb;
            --border-strong: #0f172a;
            --text: #0b1324;
            --text-secondary: #4b5563;
            --sidebar-width: 260px;
            --sidebar-collapsed-width: 64px;
            --mobile-padding: 16px;
            --mobile-bottom-bar-height: 72px;
        }

        * { box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            margin: 0;
            background: var(--muted-surface);
            color: var(--text);
        }

        .mobile-topbar {
            display: none;
            align-items: center;
            gap: 10px;
            padding: 12px var(--mobile-padding);
            position: sticky;
            top: 0;
            z-index: 50;
            background: var(--surface);
            border-bottom: 1px solid var(--border);
        }

        .mobile-topbar-title {
            font-weight: 700;
            font-size: 16px;
            letter-spacing: -0.01em;
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .mobile-icon-btn {
            width: 40px;
            height: 40px;
            border-radius: 10px;
            border: 1px solid var(--border);
            background: var(--surface);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: var(--text);
        }

        .mobile-bottom-bar {
            display: none;
            position: fixed;
            inset: auto 0 0;
            height: var(--mobile-bottom-bar-height);
            background: var(--surface);
            border-top: 1px solid var(--border);
            z-index: 40;
            padding: 10px var(--mobile-padding);
            grid-template-columns: repeat(4, 1fr) 64px;
            gap: 10px;
            box-shadow: 0 -6px 24px rgba(15, 23, 42, 0.08);
        }

        .mobile-bottom-action {
            display: inline-flex;
            flex-direction: column;
            gap: 6px;
            align-items: center;
            justify-content: center;
            padding: 8px;
            border-radius: 12px;
            border: 1px solid var(--border);
            background: var(--muted-surface);
            color: var(--text-secondary);
            font-size: 12px;
            font-weight: 600;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .mobile-bottom-action.active {
            border-color: var(--primary);
            background: #e0e7ff;
            color: var(--primary);
        }

        .mobile-fab {
            position: fixed;
            right: var(--mobile-padding);
            bottom: calc(var(--mobile-bottom-bar-height) + 12px);
            width: 56px;
            height: 56px;
            border-radius: 50%;
            border: none;
            background: linear-gradient(135deg, #3b82f6, #1d4ed8);
            color: #fff;
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 22px;
            box-shadow: 0 10px 30px rgba(37, 99, 235, 0.35);
            z-index: 45;
            cursor: pointer;
        }

        i.ph {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            line-height: 1;
        }
        
        /* LAYOUT */
        .app-container {
            display: grid;
            grid-template-areas: "sidebar header" "sidebar main";
            grid-template-columns: var(--sidebar-width) 1fr;
            grid-template-rows: auto 1fr;
            height: 100vh;
            transition: grid-template-columns 0.3s ease;
            background: var(--muted-surface);
        }
        .app-container.sidebar-collapsed { grid-template-columns: var(--sidebar-collapsed-width) 1fr; }
        .app-sidebar {
            grid-area: sidebar;
            background: #0f172a;
            color: white;
            border-right: 1px solid #111827;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        .app-header {
            grid-area: header;
            background: var(--surface);
            border-bottom: 1px solid var(--border);
            z-index: 10;
        }

        .world-toolbar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            padding: 14px 18px;
            border-bottom: 1px solid var(--border);
        }

        .world-toolbar-info {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .world-pill {
            display: inline-flex;
            align-items: center;
            gap: 10px;
            padding: 8px 12px;
            border-radius: 12px;
            border: 1px solid var(--border);
            background: var(--muted-surface);
            color: var(--text);
            font-weight: 600;
        }

        .world-pill i {
            color: #2563eb;
        }

        .world-toolbar-hint {
            margin: 0;
            color: var(--text-secondary);
            font-size: 13px;
        }

        .world-toolbar-actions {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .world-toolbar-actions .btn-sm {
            min-width: auto;
        }

        .view-toolbar-note {
            padding: 10px 18px;
            color: var(--text-secondary);
            font-size: 13px;
            border-bottom: 1px solid var(--border);
            background: #f9fafb;
        }
        .app-main {
            grid-area: main;
            overflow: auto;
            background: var(--muted-surface);
            padding: 16px 20px 24px;
        }

        .view-workspace { display: flex; flex-direction: column; gap: 4px; min-height: calc(100vh - 140px); }
        .view-tabs-rail { padding: 0 6px 0 6px; }
        
        /* SIDEBAR */
        .sidebar-header {
            padding: 18px 16px 18px 20px;
            border-bottom: 1px solid #2a2e38;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
        }
        .sidebar-collapsed .sidebar-header { padding: 18px 10px; justify-content: center; }
        .sidebar-brand-logo {
            width: 52px;
            height: 52px;
            padding: 10px;
            border-radius: 14px;
            background: #0b1020;
            border: 1px solid #1f2937;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 8px 26px rgba(0, 0, 0, 0.2);
            transition: opacity 0.2s, width 0.2s, padding 0.2s, margin 0.2s;
        }
        .sidebar-brand-logo img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            border-radius: 10px;
            background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.12), rgba(255,255,255,0));
        }
        .sidebar-collapsed .sidebar-brand-logo { opacity: 0; width: 0; padding: 0; margin: 0; overflow: hidden; }
        .sidebar-toggle {
            background: transparent;
            border: 1px solid #2f343d;
            color: #e5e7eb;
            padding: 8px;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .sidebar-toggle:hover { background: rgba(255,255,255,0.05); color: #fff; border-color: #fff; }
        .sidebar-section { padding: 16px 12px 12px 12px; display: flex; flex-direction: column; gap: 8px; }
        .sidebar-section.grow { flex: 1; overflow-y: auto; }
        .sidebar-section-title {
            font-size: 11px;
            font-weight: 700;
            text-transform: uppercase;
            color: #6b7280;
            letter-spacing: 0.05em;
            padding: 8px 12px 6px;
            margin-bottom: 6px;
            transition: opacity 0.2s;
        }
        .sidebar-collapsed .sidebar-section-title { opacity: 0; height: 0; overflow: hidden; margin: 0; }

        .world-switcher {
            padding: 12px 12px 0 12px;
            border-bottom: 1px solid #111827;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .world-switcher-row {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .world-badge {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 8px 10px;
            background: rgba(255,255,255,0.04);
            border: 1px solid #1f2937;
            border-radius: 10px;
            color: #e5e7eb;
            flex: 1;
        }

        .world-badge small {
            display: block;
            color: #9ca3af;
            font-size: 11px;
            font-weight: 700;
            letter-spacing: 0.05em;
            text-transform: uppercase;
        }

        .world-actions {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .world-select {
            width: 100%;
            padding: 8px 10px;
            border-radius: 10px;
            border: 1px solid #1f2937;
            background: #0b1221;
            color: #e5e7eb;
        }

        .btn-ghost {
            background: transparent;
            border: 1px solid #1f2937;
            color: #e5e7eb;
        }

        .sidebar-collapsed .world-switcher {
            padding: 12px 8px;
            align-items: center;
        }

        .sidebar-collapsed .world-badge {
            justify-content: center;
            padding: 10px;
        }

        .sidebar-collapsed .world-badge div { display: none; }

        .sidebar-collapsed .world-actions {
            flex-direction: column;
            align-items: center;
            gap: 6px;
        }

        .sidebar-collapsed .world-actions .world-select { display: none; }

        .sidebar-collapsed #addWorldBtn {
            width: 100%;
            display: flex;
            justify-content: center;
        }

        .btn-ghost:hover {
            border-color: #fff;
            color: #fff;
        }
        
        .set-item {
            margin-bottom: 4px;
        }
        
        .set-header {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 12px;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.15s;
            color: #cbd5e1;
            border: 1px solid transparent;
        }
        .set-header:hover { background: rgba(255,255,255,0.04); border-color: rgba(255,255,255,0.08); color: #fff; }
        .set-header.active { background: #111827; color: #ffffff; border-color: #111827; box-shadow: none; }
        .set-icon, .view-item-icon {
            font-size: 18px;
            width: 32px;
            height: 32px;
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.06);
            border: 1px solid rgba(255, 255, 255, 0.08);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }
        .set-icon i, .view-item-icon i { font-size: 18px; }
        .set-header.active .set-icon { background: rgba(255, 255, 255, 0.12); border-color: rgba(255, 255, 255, 0.18); }
        .world-badge .set-icon { background: rgba(255, 255, 255, 0.08); border-color: rgba(255, 255, 255, 0.12); }
        .set-name { flex: 1; transition: opacity 0.2s; font-weight: 600; letter-spacing: -0.01em; }
        .set-expand-icon {
            font-size: 12px;
            transition: transform 0.2s;
            opacity: 0.7;
        }
        .set-item.expanded .set-expand-icon { transform: rotate(90deg); }
        .sidebar-collapsed .set-name { opacity: 0; width: 0; overflow: hidden; }
        .sidebar-collapsed .set-expand-icon { display: none; }
        .sidebar-collapsed .set-header { justify-content: center; padding: 10px; }
        
        .views-list {
            max-height: 0;
            overflow: hidden;
            opacity: 0;
            transition: max-height 0.3s ease, opacity 0.3s ease;
            margin-left: 32px;
            margin-top: 6px;
        }
        .set-item.expanded .views-list {
            max-height: 500px;
            opacity: 1;
        }
        .sidebar-collapsed .views-list { display: none; }
        
        .view-item {
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.15s;
            margin-bottom: 3px;
            display: flex;
            align-items: center;
            gap: 8px;
            color: #9ca3af;
            position: relative;
        }
        .view-item:hover { background: #252931; color: #e5e7eb; }
        .view-item.active { background: #2f343d; color: #ffffff; font-weight: 600; }
        .view-item-icon { font-size: 16px; opacity: 0.9; color: #cbd5e1; }
        
        .add-view-btn {
            padding: 6px 12px;
            font-size: 13px;
            color: #6b7280;
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.15s;
            margin-top: 6px;
        }
        .add-view-btn:hover { background: #252931; color: #e5e7eb; }

        .new-set-btn {
            margin-top: auto;
            padding: 14px 12px;
            display: flex;
            align-items: center;
            gap: 10px;
            color: #6b7280;
            font-weight: 600;
            border: none;
            background: transparent;
            cursor: pointer;
            transition: color 0.15s ease;
        }
        .new-set-btn:hover { color: #9ca3af; }

        .knowledge-nav { display: flex; flex-direction: column; gap: 8px; margin-bottom: 6px; }
        .knowledge-nav-btn {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 12px;
            border-radius: 10px;
            border: 1px solid var(--border);
            background: var(--surface);
            color: var(--text);
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s ease;
        }
        .knowledge-nav-btn:hover { background: var(--muted-surface); }
        .knowledge-nav-btn.active { border-color: #3b82f6; color: #1d4ed8; background: #e0e7ff; }
        .knowledge-nav-btn i { color: inherit; }

        /* TOOLBAR */
        .toolbar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 16px;
            flex-wrap: wrap;
            padding: 16px 28px;
            background: var(--surface);
            border-bottom: 1px solid var(--border);
        }

        .toolbar-left {
            display: flex;
            align-items: center;
            gap: 12px;
            flex: 1;
            min-width: 0;
            flex-wrap: wrap;
        }

        .toolbar-inline-actions {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
        }

        .toolbar-actions {
            display: flex;
            align-items: center;
            gap: 12px;
            flex-wrap: wrap;
            justify-content: flex-end;
        }

        .primary-actions {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
        }

        .toolbar-menu { position: relative; }
        .toolbar-menu.open .toolbar-menu-panel { display: flex; }

        .toolbar-menu-toggle {
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .toolbar-menu-panel {
            display: none;
            position: absolute;
            right: 0;
            top: calc(100% + 10px);
            min-width: 240px;
            padding: 10px;
            border-radius: 12px;
            border: 1px solid var(--border);
            background: var(--surface);
            box-shadow: 0 12px 40px rgba(15, 23, 42, 0.15);
            flex-direction: column;
            gap: 6px;
            z-index: 15;
        }

        .toolbar-menu-divider {
            height: 1px;
            background: var(--border);
            margin: 2px 0;
        }

        .toolbar-menu-item {
            width: 100%;
            justify-content: flex-start;
            gap: 10px;
            color: var(--text-secondary);
            border: 1px solid var(--border);
            background: var(--muted-surface);
        }

        .toolbar-menu-item:hover {
            background: var(--surface);
            color: var(--text);
            border-color: var(--text);
        }

        .toolbar .sort-sequence-badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 8px;
            border-radius: 8px;
            background: #f3f4f6;
            color: #4b5563;
            font-size: 13px;
        }

        .view-type-switcher {
            display: flex;
            gap: 8px;
        }

        .view-type-btn {
            padding: 8px 14px;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.15s;
            border: 1px solid var(--border);
            background: var(--surface);
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: none;
        }

        .view-type-btn:hover { background: var(--muted-surface); border-color: var(--text); color: var(--text); }
        .view-type-btn.active { background: var(--primary); color: #ffffff; border-color: var(--primary); }
        
        /* CELLS */
        .cell-editable {
            min-height: 36px;
            padding: 12px 16px;
            cursor: text;
            border-right: 1px solid #f0f0f0;
            transition: all 0.2s ease;
            position: relative;
        }
        .cell-editable:hover:not(.cell-editing):not(.cell-selected) {
            background: linear-gradient(to right, transparent, rgba(59, 130, 246, 0.03), transparent);
            cursor: pointer;
            border-left: 2px solid rgba(59, 130, 246, 0.15);
        }
        .cell-static {
            min-height: 36px;
            padding: 12px 16px;
            border-right: 1px solid #f0f0f0;
            background: #f9fafb;
            color: #4b5563;
            font-weight: 600;
            letter-spacing: -0.01em;
        }
        .cell-selected {
            outline: 2px solid #3b82f6 !important;
            outline-offset: -2px;
            background: #eff6ff !important;
            position: relative;
            z-index: 1;
        }
        .cell-editing {
            outline: 2px solid #3b82f6 !important;
            outline-offset: -2px;
            background: white !important;
            box-shadow: 0 0 0 4px rgba(59, 130, 246, 0.12) !important;
            z-index: 2;
        }
        .cell-recently-changed { animation: none; }
        @keyframes flash-yellow { 0% { background-color: #fef3c7; } 100% { background-color: transparent; } }
        .cell-keyboard-focus {
            outline: 2px dashed #3b82f6;
            outline-offset: -2px;
        }
        .cell-loading {
            position: relative;
            pointer-events: none;
        }
        .cell-loading::after {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.6), transparent);
            animation: shimmer 1.5s infinite;
        }
        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }
        
        /* TABLE HEADERS */
        .column-header {
            background: var(--surface);
            padding: 12px 16px;
            font-weight: 600;
            font-size: 11px;
            letter-spacing: 0.5px;
            text-transform: uppercase;
            color: #666;
            border-bottom: 1px solid var(--border);
            cursor: grab;
            transition: background 0.15s, box-shadow 0.15s;
            user-select: none;
            position: relative;
        }
        .column-header.column-grab-ready {
            cursor: grabbing;
            background: var(--muted-surface);
            box-shadow: inset 0 0 0 1px var(--border);
        }
        .column-resizer {
            position: absolute;
            top: 0;
            right: -4px;
            bottom: 0;
            width: 8px;
            cursor: col-resize;
            z-index: 5;
        }
        body.resizing {
            cursor: col-resize;
        }
        .column-header:hover { background: var(--muted-surface); }

        body.column-grab-ready { cursor: grab; }
        body.column-dragging { cursor: grabbing; }
        .column-being-dragged { opacity: 0.5; }

        .column-drag-ghost {
            position: fixed;
            pointer-events: none;
            background: white;
            border: 1px dashed #cbd5e1;
            border-radius: 8px;
            padding: 10px 14px;
            box-shadow: 0 10px 30px rgba(15, 23, 42, 0.15);
            opacity: 0.95;
            z-index: 1200;
            transform: translate3d(0, 0, 0);
        }

        .column-drop-before::before,
        .column-drop-after::after {
            content: '';
            position: absolute;
            top: 6px;
            bottom: 6px;
            width: 3px;
            background: #cbd5e1;
            border-radius: 999px;
        }
        .column-drop-before::before { left: -2px; }
        .column-drop-after::after { right: -2px; }

        table { width: auto; border-collapse: collapse; table-layout: fixed; }
        thead { background: #f9fafb; border-bottom: 1px solid #e5e7eb; }
        th {
            padding: 12px 16px;
            text-align: left;
            font-size: 12px;
            font-weight: 700;
            text-transform: uppercase;
            color: #6b7280;
            letter-spacing: 0.05em;
            min-width: 80px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            cursor: pointer;
        }

        th .sort-indicator {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            margin-left: 8px;
            color: var(--text-secondary);
            font-weight: 500;
            font-size: 12px;
        }

        th .sort-indicator .order-badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-width: 18px;
            height: 18px;
            padding: 0 6px;
            border-radius: 999px;
            background: #e5e7eb;
            color: #111827;
            font-size: 11px;
            font-weight: 700;
        }

        th .sort-indicator .direction-icon { font-size: 10px; }

        th .sort-indicator.muted { opacity: 0.5; }
        tbody tr {
            border-bottom: 1px solid #f3f4f6;
            transition: all 0.1s ease;
        }
        tbody tr:hover { background: #fafafa; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.02); }
        tbody tr:hover td:first-child { color: #3b82f6; font-weight: 700; }
        tbody tr:last-child { border-bottom: none; }
        td {
            padding: 16px;
            font-size: 14px;
            color: #1f2937;
            vertical-align: middle;
            min-width: 80px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        td:first-child {
            color: #9ca3af;
            font-weight: 600;
            font-size: 13px;
            min-width: 60px;
        }
        tr:hover { background-color: #fafafa; }

        #dataTable thead th,
        #dataTable tbody td { background-clip: padding-box; transition: background-color 0.2s ease; }
        #dataTable thead th:nth-child(odd),
        #dataTable tbody td:nth-child(odd) { box-shadow: inset 0 0 0 9999px rgba(15, 23, 42, 0.012); }
        #dataTable thead th:nth-child(even),
        #dataTable tbody td:nth-child(even) { box-shadow: inset 0 0 0 9999px rgba(15, 23, 42, 0.024); }
        #dataTable tbody tr:nth-child(odd) { background-color: rgba(15, 23, 42, 0.02); }
        #dataTable tbody tr:nth-child(even) { background-color: rgba(15, 23, 42, 0.03); }
        #dataTable tbody tr:hover td { background: #f4f6fb; }
        #dataTable th:not(:last-child), #dataTable td:not(:last-child) { border-right: 1px solid #eef2f7; }
        .table-footer {
            display: flex;
            justify-content: flex-end;
            align-items: center;
            gap: 8px;
            padding: 10px 16px;
            background: #f9fafb;
            border-top: 1px solid #e5e7eb;
            color: #4b5563;
            font-size: 13px;
        }
        .record-counter {
            font-weight: 700;
            color: #111827;
        }

        /* Enhanced select dropdown */
        .custom-select-dropdown {
            position: absolute;
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            z-index: 1000;
            min-width: 250px;
            max-width: 400px;
            max-height: 400px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .custom-select-search {
            padding: 8px 12px;
            border: none;
            border-bottom: 1px solid #e5e7eb;
            font-size: 14px;
            outline: none;
        }

        .custom-select-search:focus { border-bottom-color: #3b82f6; }

        .custom-select-options { overflow-y: auto; flex: 1; }

        .custom-select-option {
            padding: 10px 16px;
            font-size: 14px;
            cursor: pointer;
            transition: background 0.1s;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .custom-select-option:hover { background: #f3f4f6; }
        .custom-select-option.highlighted { background: #eff6ff; color: #1e40af; }
        .custom-select-option.selected { background: #3b82f6; color: white; font-weight: 600; }

        .custom-select-option-icon {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
        }

        .custom-select-option-text { flex: 1; }

        .custom-select-option-badge {
            font-size: 11px;
            padding: 2px 6px;
            border-radius: 4px;
            background: #f3f4f6;
            color: #6b7280;
        }

        .custom-select-empty {
            padding: 40px 20px;
            text-align: center;
            color: #9ca3af;
        }

        .custom-select-empty-icon {
            font-size: 32px;
            margin-bottom: 8px;
            opacity: 0.5;
        }

        .custom-select-footer {
            border-top: 1px solid #e5e7eb;
            padding: 8px;
            display: flex;
            gap: 4px;
        }

        .custom-select-footer button {
            flex: 1;
            padding: 6px 12px;
            font-size: 13px;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            background: white;
            cursor: pointer;
            transition: all 0.15s;
        }

        .custom-select-footer button:hover { background: #f3f4f6; border-color: #d1d5db; }

        .search-match {
            background: #fef3c7;
            font-weight: 600;
            padding: 0 2px;
            border-radius: 2px;
        }

        .table-scroll {
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
        }
        
        /* CARD VIEW */
        .cards-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 16px;
        }
        
        .card {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 16px;
            cursor: pointer;
            transition: all 0.15s ease;
            box-shadow: none;
        }

        .card:hover {
            transform: translateY(-2px);
            border-color: var(--border-strong);
        }
        
        .card-title {
            font-size: 16px;
            font-weight: 600;
            color: #111827;
            margin-bottom: 12px;
        }
        
        .card-field {
            margin-bottom: 8px;
            font-size: 13px;
        }
        
        .card-field-label {
            color: #6b7280;
            font-weight: 500;
            margin-bottom: 2px;
        }
        
        .card-field-value {
            color: #111827;
        }
        
        /* KANBAN VIEW */
        .kanban-board {
            display: flex;
            gap: 16px;
            padding: 8px;
            overflow-x: auto;
            min-height: calc(100vh - 200px);
        }
        
        .kanban-column {
            min-width: 300px;
            background: var(--muted-surface);
            border-radius: 10px;
            padding: 12px;
            display: flex;
            flex-direction: column;
            border: 1px solid var(--border);
        }
        
        .kanban-column-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 12px;
            margin-bottom: 12px;
            border-radius: 8px;
            background: var(--surface);
            border: 1px solid var(--border);
        }
        
        .kanban-column-title {
            font-weight: 600;
            font-size: 14px;
            color: #374151;
        }
        
        .kanban-column-count {
            font-size: 12px;
            color: #6b7280;
            background: #f3f4f6;
            padding: 2px 8px;
            border-radius: 4px;
        }
        
        .kanban-cards {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 8px;
            min-height: 100px;
        }
        
        .kanban-card {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 12px;
            cursor: move;
            transition: all 0.15s ease;
        }

        .kanban-card:hover {
            border-color: var(--border-strong);
        }
        
        .kanban-card.dragging {
            opacity: 0.5;
            transform: rotate(2deg);
        }
        
        .kanban-column.drag-over {
            background: #e0f2fe;
        }
        
        .kanban-empty-state {
            text-align: center;
            padding: 40px 20px;
            color: #9ca3af;
            font-size: 14px;
        }

        /* GRAPH VIEW */
        .graph-container {
            width: 100%;
            height: 100%;
            min-height: 600px;
            background: #fafbfc;
            border-radius: 8px;
            overflow: hidden;
        }

        .graph-node:hover circle {
            fill: #2563eb;
            stroke: #1e3a8a;
        }

        /* CONTEXT MENU */
        .context-menu {
            position: fixed;
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15);
            z-index: 1000;
            min-width: 200px;
            overflow: hidden;
        }
        .context-menu-item {
            padding: 10px 16px;
            font-size: 14px;
            cursor: pointer;
            transition: background 0.15s;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .context-menu-item:hover { background: #f3f4f6; }
        .context-menu-item.danger:hover { background: #fee2e2; color: #dc2626; }
        .context-menu-separator { height: 1px; background: #e5e7eb; margin: 4px 0; }
        
        /* MODALS */
        .modal-overlay { backdrop-filter: blur(2px); animation: fadeIn 0.2s ease; }
        .modal-container { border-radius: 8px; box-shadow: 0 20px 50px rgba(0, 0, 0, 0.2); animation: slideUp 0.25s cubic-bezier(0.16, 1, 0.3, 1); }
        #expandedRecordModal .modal-container { height: 90vh; }
        #addFieldModal .modal-container { max-width: 540px; width: 100%; border-radius: 10px; }
        #addFieldModal .modal-container, #addFieldModal .modal-body { overflow: visible; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes slideUp { from { transform: translateY(20px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
        .modal-header { padding: 24px 24px 16px 24px; border-bottom: 1px solid #f0f0f0; }
        .modal-body { padding: 24px; }
        .modal-footer { padding: 16px 24px; border-top: 1px solid #f0f0f0; background: #fafafa; }
        #addFieldModal .modal-header { padding: 16px 18px 10px 18px; }
        #addFieldModal .modal-body { padding: 16px 18px 18px 18px; }
        #addFieldModal .modal-footer { padding: 14px 18px; background: #f8fafc; }
        .icon-picker-shell { max-height: 90vh; display: flex; flex-direction: column; }
        .icon-picker-body { display: flex; flex-direction: column; gap: 12px; flex: 1; }
        .icon-picker-controls { display: flex; align-items: center; gap: 12px; flex-wrap: wrap; }
        .icon-picker-search { flex: 1 1 260px; }
        .icon-picker-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(44px, 1fr)); gap: 8px; max-height: 60vh; overflow: auto; padding-right: 4px; }
        .icon-pagination { display: flex; align-items: center; gap: 12px; margin-left: auto; font-size: 13px; color: #475569; }
        .icon-pagination-count { font-weight: 700; }
        .icon-pagination-buttons { display: inline-flex; align-items: center; gap: 6px; }
        .icon-page-btn { padding: 6px 10px; border-radius: 8px; border: 1px solid #e2e8f0; background: #fff; font-weight: 600; color: #0f172a; cursor: pointer; transition: all 0.15s ease; }
        .icon-page-btn:hover { background: #f8fafc; border-color: #cbd5e1; }
        .icon-page-btn:disabled { opacity: 0.55; cursor: not-allowed; background: #f8fafc; }
        .icon-option { display: flex; align-items: center; justify-content: center; padding: 6px; border-radius: 12px; border: 1px solid #e2e8f0; background: #ffffff; cursor: pointer; transition: all 0.12s ease; box-shadow: 0 2px 6px rgba(15, 23, 42, 0.04); }
        .icon-option:hover { border-color: #cbd5e1; background: #f8fafc; transform: translateY(-1px); }
        .icon-option.active { border-color: #2563eb; background: #eff6ff; color: #1d4ed8; box-shadow: 0 0 0 2px rgba(37,99,235,0.15); }
        .icon-option .icon-chip { width: 36px; height: 36px; border-radius: 50%; display: inline-flex; align-items: center; justify-content: center; background: #f8fafc; color: #0f172a; border: 1px solid #e2e8f0; font-size: 18px; }
        .icon-option.active .icon-chip { background: #e0ecff; border-color: #bfdbfe; color: #1d4ed8; }
        .sr-only { position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0, 0, 0, 0); white-space: nowrap; border: 0; }

        .icon-selector { display: flex; align-items: center; gap: 10px; padding: 10px 12px; border: 1px solid #e2e8f0; border-radius: 8px; background: #f8fafc; cursor: pointer; transition: all 0.15s ease; }
        .icon-selector:hover { border-color: #cbd5e1; background: #f1f5f9; box-shadow: inset 0 0 0 1px #e2e8f0; }
        .icon-selector-icon { width: 40px; height: 40px; border-radius: 10px; background: #ffffff; border: 1px solid #e2e8f0; display: inline-flex; align-items: center; justify-content: center; font-size: 22px; color: #0f172a; }
        .icon-selector-text { flex: 1; min-width: 0; }
        .icon-selector-label { font-size: 13px; color: #475569; }
        .icon-selector-token { font-size: 12px; color: #64748b; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .icon-selector-chevron { color: #94a3b8; font-size: 12px; }
        .config-section { max-height: 0; overflow: hidden; opacity: 0; transition: max-height 0.3s ease, opacity 0.3s ease, margin 0.3s ease; margin-top: 0; }
        .config-section.visible { max-height: 500px; opacity: 1; margin-top: 16px; }

        /* POPUP CONFIGURATOR */
        .popup-config-shell { max-width: 1200px; width: 100%; max-height: 90vh; overflow: hidden; display: flex; flex-direction: column; padding: 20px 24px; }
        .popup-config-header { display: flex; justify-content: space-between; align-items: flex-start; gap: 16px; padding: 0 0 12px 0; border-bottom: 1px solid #e2e8f0; background: transparent; }
        .popup-config-tabs { display: flex; gap: 4px; padding: 12px 0; border-bottom: 1px solid #e2e8f0; background: transparent; }
        .popup-config-tab { padding: 10px 14px; border: none; background: transparent; cursor: pointer; font-weight: 600; color: #6b7280; border-bottom: 2px solid transparent; display: inline-flex; gap: 8px; align-items: center; border-radius: 8px 8px 0 0; transition: all 0.2s ease; }
        .popup-config-tab:hover { color: #0f172a; background: #f8fafc; }
        .popup-config-tab.active { color: #1d4ed8; border-bottom-color: #1d4ed8; background: #eff6ff; }
        .popup-config-body { display: grid; grid-template-columns: 1fr 320px; gap: 20px; padding: 16px 0 0 0; background: #fff; flex: 1; overflow: hidden; }
        .popup-tab-panel { display: none; height: 100%; overflow: hidden; }
        .popup-tab-panel.active { display: block; }
        .popup-panel-scroll { height: 100%; overflow: auto; padding-right: 6px; }
        .popup-quick-filters { display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 14px; }
        .popup-filter { padding: 8px 12px; border-radius: 8px; border: 1px solid #e2e8f0; background: #fff; cursor: pointer; color: #475569; font-weight: 600; transition: all 0.15s ease; }
        .popup-filter:hover { border-color: #cbd5e1; background: #f8fafc; }
        .popup-filter.active { background: #eef2ff; border-color: #1d4ed8; color: #1d4ed8; }
        .popup-info { display: flex; gap: 10px; padding: 12px; background: #eef2ff; border: 1px solid #c7d2fe; border-radius: 8px; color: #1e3a8a; margin-bottom: 14px; font-size: 14px; }
        .popup-field-card { border: 1px solid #e2e8f0; border-radius: 6px; padding: 16px; display: flex; align-items: center; gap: 12px; margin-bottom: 12px; background: #fff; transition: all 0.2s ease; }
        .popup-field-card:hover { border-color: #cbd5e1; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04); }
        .popup-field-card.dragging { opacity: 0.6; }
        .popup-field-card.drag-over { border-color: #1d4ed8; background: #eef2ff; }
        .popup-field-card .drag-handle { cursor: grab; color: #94a3b8; font-size: 18px; }
        .popup-field-icon { width: 38px; height: 38px; border-radius: 10px; border: 1px solid #e2e8f0; background: #f8fafc; display: inline-flex; align-items: center; justify-content: center; font-size: 18px; color: #0f172a; }
        .popup-field-meta { flex: 1; min-width: 0; }
        .popup-field-name { font-weight: 700; color: #0f172a; display: flex; gap: 6px; align-items: center; }
        .popup-field-type { font-size: 13px; color: #64748b; }
        .field-type { font-size: 11px; color: #64748b; text-transform: uppercase; letter-spacing: 0.05em; font-weight: 500; }
        .popup-badge { display: inline-flex; align-items: center; gap: 4px; padding: 4px 8px; border-radius: 999px; background: #f8fafc; border: 1px solid #e2e8f0; font-size: 12px; color: #475569; font-weight: 600; }
        .popup-badge.warn { background: #fef3c7; border-color: #fde68a; color: #b45309; }
        .popup-toggle { width: 46px; height: 26px; border-radius: 999px; background: #e5e7eb; position: relative; cursor: pointer; transition: all 0.2s ease; }
        .popup-toggle::after { content: ''; position: absolute; width: 20px; height: 20px; border-radius: 50%; background: #fff; top: 3px; left: 3px; box-shadow: 0 2px 8px rgba(0,0,0,0.12); transition: all 0.2s ease; }
        .popup-toggle.active { background: #1d4ed8; }
        .popup-toggle.active::after { transform: translateX(20px); }
        .popup-side { display: flex; flex-direction: column; gap: 16px; height: 100%; }
        .popup-card { background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 8px; padding: 16px; }
        .popup-card h4 { margin: 0 0 8px 0; font-size: 14px; color: #0f172a; font-weight: 700; }
        .popup-stat-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; }
        .popup-stat { background: #fff; border: 1px solid #e2e8f0; border-radius: 8px; padding: 12px; }
        .popup-stat .value { font-size: 24px; font-weight: 800; color: #0f172a; }
        .popup-stat .label { font-size: 12px; color: #6b7280; }
        .popup-preview { border: 1px solid #e2e8f0; border-radius: 8px; background: #fafafa; padding: 14px; }
        .popup-preview-header { font-weight: 700; margin-bottom: 10px; color: #0f172a; display: flex; justify-content: space-between; align-items: center; }
        .popup-preview-fields { display: grid; gap: 10px; }
        .popup-preview-fields.cols-1 { grid-template-columns: 1fr; }
        .popup-preview-fields.cols-2 { grid-template-columns: repeat(2, 1fr); }
        .popup-preview-fields.cols-3 { grid-template-columns: repeat(3, 1fr); }
        .popup-preview-fields.cols-4 { grid-template-columns: repeat(4, 1fr); }
        .popup-preview-field { background: #fff; border: 1px solid #e5e7eb; border-radius: 8px; padding: 10px; }
        .popup-preview-field .label { font-size: 11px; color: #6b7280; text-transform: uppercase; letter-spacing: 0.05em; margin-bottom: 4px; }
        .popup-preview-field .value { font-size: 13px; color: #0f172a; }
        .popup-layout-options { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; }
        .popup-layout-option { border: 2px solid #e2e8f0; border-radius: 8px; padding: 12px; cursor: pointer; text-align: center; transition: all 0.15s ease; background: #fff; }
        .popup-layout-option.active { border-color: #1d4ed8; background: #eef2ff; color: #1d4ed8; }
        .popup-event-stream { display: flex; flex-direction: column; gap: 10px; }
        .popup-event { border: 1px solid #e2e8f0; border-radius: 8px; padding: 12px; background: #fff; }
        .popup-event-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px; color: #0f172a; font-weight: 700; font-size: 14px; }
        .popup-event-time { color: #94a3b8; font-size: 12px; font-weight: 600; }
        .popup-conditions { display: grid; gap: 10px; }
        .popup-condition-card { border: 1px solid #e2e8f0; border-radius: 8px; padding: 12px; background: #fff; }
        .popup-condition-title { font-weight: 700; color: #0f172a; margin-bottom: 8px; display: flex; align-items: center; gap: 8px; }
        .popup-condition-row { display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 8px; margin-bottom: 10px; }
        .popup-pill { display: inline-flex; align-items: center; gap: 6px; padding: 6px 10px; border-radius: 999px; background: #f3f4f6; color: #475569; font-weight: 600; font-size: 12px; }
        .popup-template-buttons { display: flex; flex-direction: column; gap: 8px; }
        @media (max-width: 1100px) { .popup-config-body { grid-template-columns: 1fr; } .popup-side { order: -1; flex-direction: row; overflow-x: auto; } .popup-side .popup-card { min-width: 240px; } }
        
        /* BUTTONS */
        .btn {
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.15s ease;
            border: 1px solid var(--border);
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }
        .btn-primary {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
            box-shadow: none;
        }
        .btn-primary:hover { background: transparent; color: var(--text); border-color: var(--text); box-shadow: none; }
        .btn-secondary { background: transparent; border: 1px solid var(--border); color: var(--text-secondary); box-shadow: none; }
        .btn-secondary:hover { background: var(--muted-surface); border-color: var(--text); color: var(--text); }
        .btn-danger { background: #ef4444; color: white; }
        .btn-danger:hover { background: #dc2626; }
        .btn-sm { padding: 6px 12px; font-size: 13px; }
        
        /* BADGES */
        .badge {
            display: inline-flex;
            align-items: center;
            padding: 3px 10px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            white-space: nowrap;
        }
        .badge-green { background-color: #d1fae5; color: #065f46; }
        .badge-yellow { background-color: #fef3c7; color: #92400e; }
        .badge-red { background-color: #fee2e2; color: #991b1b; }
        .badge-blue { background-color: #dbeafe; color: #1e40af; }
        .badge-purple { background-color: #e9d5ff; color: #6b21a8; }
        .badge-gray { background-color: #f3f4f6; color: #374151; }
        .badge-cyan { background-color: #cffafe; color: #155e75; }
        .badge-pink { background-color: #fce7f3; color: #9f1239; }
        
        /* FIELD TYPE DROPDOWN */
        .field-type-select { position: relative; }
        .field-type-trigger {
            width: 100%;
            padding: 12px 14px;
            border: 1px solid #cbd5e1;
            border-radius: 10px;
            background: white;
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            transition: all 0.2s;
            min-height: 64px;
        }
        .field-type-trigger:hover { border-color: #94a3b8; box-shadow: 0 6px 18px rgba(15, 23, 42, 0.05); }
        .field-type-trigger.active { border-color: #3b82f6; box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.12), 0 10px 30px rgba(15, 23, 42, 0.12); }
        .field-type-trigger-content { display: flex; align-items: center; gap: 12px; }
        .field-type-trigger-icon { width: 36px; height: 36px; display: flex; align-items: center; justify-content: center; background: #f1f5f9; border-radius: 10px; font-size: 20px; }
        .field-type-trigger-text { display: flex; flex-direction: column; gap: 3px; text-align: left; }
        .field-type-trigger-arrow { color: #64748b; font-size: 13px; }
        .field-type-dropdown {
            position: absolute;
            top: calc(100% + 10px);
            left: 50%;
            transform: translateX(-50%);
            width: min(760px, calc(100vw - 48px));
            padding: 12px;
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 14px;
            box-shadow: 0 20px 40px rgba(15, 23, 42, 0.16);
            max-height: 520px;
            overflow-y: auto;
            z-index: 1000;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(230px, 1fr));
            gap: 10px;
        }
        .field-type-dropdown.hidden { display: none; }
        .field-type-option {
            padding: 12px;
            display: flex;
            align-items: flex-start;
            gap: 12px;
            cursor: pointer;
            transition: all 0.15s ease;
            border: 1px solid #e2e8f0;
            border-radius: 12px;
            background: white;
        }
        .field-type-option:hover { background: #f8fafc; box-shadow: 0 12px 30px rgba(15, 23, 42, 0.08); }
        .field-type-option.selected { background: #eff6ff; border: 1px solid #3b82f6; box-shadow: 0 14px 32px rgba(59, 130, 246, 0.18); }
        .field-type-icon { width: 36px; height: 36px; display: flex; align-items: center; justify-content: center; background: #f1f5f9; border-radius: 10px; font-size: 20px; }
        .field-type-option.selected .field-type-icon { background: #3b82f6; color: white; }
        .field-type-info { display: flex; flex-direction: column; gap: 3px; min-width: 0; }
        .field-type-name { font-size: 14px; font-weight: 700; color: #0f172a; }
        .field-type-description { font-size: 12px; color: #64748b; line-height: 1.5; }
        .field-type-check { margin-left: auto; color: #3b82f6; font-weight: 700; font-size: 14px; }
        
        /* FILTER BUILDER */
        .filter-group { background: #f9fafb; border: 2px solid #e5e7eb; border-radius: 8px; padding: 16px; margin-bottom: 12px; }
        .filter-group-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px; }
        .filter-operator-toggle { display: flex; background: white; border: 1px solid #e5e7eb; border-radius: 6px; overflow: hidden; }
        .filter-operator-toggle button {
            padding: 4px 12px;
            font-size: 12px;
            font-weight: 600;
            border: none;
            background: transparent;
            cursor: pointer;
            transition: all 0.15s;
        }
        .filter-operator-toggle button.active { background: #3b82f6; color: white; }
        .filter-rule { display: grid; grid-template-columns: 1fr 1fr 1fr auto; gap: 8px; align-items: center; padding: 8px; background: white; border-radius: 6px; margin-bottom: 8px; }
        
        /* UTILITIES */
          .form-label { display: block; font-size: 13px; font-weight: 600; color: #374151; margin-bottom: 8px; }
          .form-hint { font-size: 12px; color: #6b7280; margin-top: 6px; }
          .form-error { font-size: 12px; color: #b91c1c; margin-top: 6px; }
          input[type="text"], input[type="number"], input[type="date"], input[type="email"], input[type="url"], select, textarea {
              width: 100%;
              padding: 8px 12px;
              border: 1px solid #cbd5e1;
              border-radius: 6px;
            font-size: 13px;
            transition: all 0.15s ease;
            background: white;
          }
          .formula-bar { display: flex; align-items: stretch; gap: 8px; background: #f8fafc; border: 1px solid #cbd5e1; border-radius: 10px; padding: 6px 8px; box-shadow: inset 0 1px 0 rgba(255,255,255,0.6); }
          .formula-bar-prefix { display: inline-flex; align-items: center; justify-content: center; font-weight: 700; color: #0f172a; padding: 6px 10px; background: white; border: 1px solid #e2e8f0; border-radius: 8px; box-shadow: 0 1px 2px rgba(15, 23, 42, 0.08); }
          .formula-bar-input { background: transparent; border: none; box-shadow: none; resize: vertical; font-family: 'SFMono-Regular', ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; padding: 6px 8px; }
          .formula-bar-input:focus { outline: none; box-shadow: none; border: none; }
          input:focus, select:focus, textarea:focus { outline: none; border-color: #3b82f6; box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1); }
          .input-error { border-color: #ef4444; box-shadow: 0 0 0 3px rgba(239, 68, 68, 0.15); }

          .view-type-option { position: relative; cursor: pointer; }
          .view-type-option input[type="radio"] { position: absolute; opacity: 0; pointer-events: none; }
          .view-type-option-content {
              display: flex;
              flex-direction: column;
              align-items: center;
              gap: 8px;
              padding: 16px;
              border: 2px solid #e5e7eb;
              border-radius: 8px;
              background: white;
              transition: all 0.15s ease;
          }
          .view-type-option-content i { font-size: 24px; color: #6b7280; }
          .view-type-option-content span { font-size: 13px; font-weight: 500; color: #374151; }
          .view-type-option:hover .view-type-option-content { border-color: #3b82f6; background: #f0f9ff; }
          .view-type-option input[type="radio"]:checked + .view-type-option-content {
              border-color: #3b82f6;
              background: #eff6ff;
          }
          .view-type-option input[type="radio"]:checked + .view-type-option-content i { color: #3b82f6; }

          ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: #f3f4f6; }
        ::-webkit-scrollbar-thumb { background: #d1d5db; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #9ca3af; }
        
        .toast {
            position: fixed;
            bottom: 24px;
            right: 24px;
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            padding: 16px 20px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            z-index: 2000;
            animation: slideInToast 0.3s ease;
        }
        @keyframes slideInToast { from { transform: translateX(400px); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
        
        .side-panel {
            position: fixed;
            right: 0;
            top: 0;
            height: 100vh;
            width: 420px;
            background: white;
            box-shadow: -4px 0 24px rgba(0, 0, 0, 0.12);
            transform: translateX(100%);
            transition: transform 0.3s ease;
            z-index: 1000;
            display: flex;
            flex-direction: column;
        }
        .side-panel.open { transform: translateX(0); }

        .csv-helper-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
            gap: 12px;
        }

        .csv-helper-card {
            border: 1px solid #e5e7eb;
            border-radius: 10px;
            padding: 12px;
            background: white;
        }

        #csvPreviewContainer {
            overflow: auto;
            max-height: 340px;
        }

        .csv-preview-table {
            width: 100%;
            min-width: max-content;
            border-collapse: collapse;
            font-size: 12px;
            border: 1px solid #e5e7eb;
        }

        .csv-preview-table th, .csv-preview-table td {
            border: 1px solid #e5e7eb;
            padding: 6px 8px;
            text-align: left;
            background: white;
        }

        .csv-preview-table th { background: #f9fafb; font-weight: 700; }

        .csv-match-pill {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 10px;
            border-radius: 9999px;
            background: #eef2ff;
            color: #4338ca;
            font-weight: 600;
            font-size: 12px;
        }

        .fuzzy-match-row {
            border: 1px solid #e5e7eb;
            border-radius: 10px;
            padding: 12px;
            margin-bottom: 10px;
            background: #fff;
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .fuzzy-match-row strong { display: block; font-size: 14px; }

        .fuzzy-score {
            font-weight: 700;
            color: #16a34a;
        }

        .panel-controls {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            margin-bottom: 12px;
        }
        
        .option-row { display: flex; gap: 8px; align-items: center; margin-bottom: 8px; }
        .option-row input { flex: 1; }
        .color-picker { display: flex; gap: 4px; flex-wrap: wrap; }
        .color-option {
            width: 24px;
            height: 24px;
            border-radius: 4px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.15s;
        }
        .color-option:hover { transform: scale(1.1); }
        .color-option.selected { border-color: #1e293b; }
        
        .field-editor { border: 1px solid #e5e7eb; border-radius: 6px; padding: 12px; transition: all 0.15s; }
        .field-editor:hover { border-color: #d1d5db; background: #fafafa; }
        .field-editor:focus-within { border-color: #3b82f6; box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1); }
        .field-editor input, .field-editor textarea, .field-editor select { width: 100%; padding: 8px 12px; border: 1px solid #e5e7eb; border-radius: 4px; font-size: 14px; }
        
        .record-tabs { display: flex; border-bottom: 1px solid #e5e7eb; padding: 0 24px; background: #fafafa; }
        .record-tab {
            padding: 12px 16px;
            font-size: 14px;
            font-weight: 500;
            color: #6b7280;
            cursor: pointer;
            border-bottom: 2px solid transparent;
            margin-bottom: -1px;
            transition: all 0.15s ease;
        }
        .record-tab:hover { color: #374151; }
        .record-tab.active { color: #2563eb; border-bottom-color: #2563eb; }

        .view-tabs {
            display: flex;
            align-items: flex-end;
            gap: 2px;
            padding: 0 10px;
            background: transparent;
            overflow-x: auto;
            position: relative;
            border-bottom: 1px solid #e5e7eb;
        }

        .view-tab {
            position: relative;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            border-bottom: 2px solid transparent;
            background: transparent;
            cursor: pointer;
            transition: all 0.15s ease;
            color: #6b7280;
            white-space: nowrap;
            flex-shrink: 0;
            user-select: none;
        }

        .view-tab:hover {
            background: #f9fafb;
            color: #374151;
        }

        .view-tab.active {
            background: transparent;
            border-bottom-color: #3b82f6;
            color: #111827;
        }

        .view-tab.tab-being-dragged {
            opacity: 0.6;
        }

        .view-tab.tab-drop-before::before,
        .view-tab.tab-drop-after::after {
            content: '';
            position: absolute;
            top: 6px;
            bottom: 6px;
            width: 3px;
            background: #cbd5e1;
            border-radius: 999px;
        }
        .view-tab.tab-drop-before::before { left: -4px; }
        .view-tab.tab-drop-after::after { right: -4px; }

        .view-tab-icon {
            color: inherit;
            font-size: 16px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            opacity: 0.7;
        }

        .view-tab.active .view-tab-icon {
            opacity: 1;
        }

        .view-tab-text { display: flex; align-items: center; gap: 4px; min-width: 0; }
        .view-tab-name { font-weight: 600; font-size: 12px; color: inherit; white-space: nowrap; }
        .view-tab-meta {
            font-size: 10px;
            color: #9ca3af;
            padding: 1px 7px;
            border-radius: 6px;
            background: #f3f4f6;
            letter-spacing: 0.01em;
        }

        .view-tab-actions {
            display: inline-flex;
            gap: 4px;
            margin-left: auto;
            padding-left: 8px;
            color: #6b7280;
            opacity: 0;
            transform: translateX(6px);
            transition: all 0.12s ease;
        }

        .view-tab:hover .view-tab-actions,
        .view-tab.active .view-tab-actions {
            opacity: 1;
            transform: translateX(0);
        }

        .view-tab-btn {
            border: 1px solid transparent;
            background: transparent;
            color: inherit;
            border-radius: 10px;
            padding: 6px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .view-tab-btn:hover { color: #111827; background: #ffffff; border-color: #d1d5db; }
        .view-tab-btn:disabled { opacity: 0.5; cursor: not-allowed; }

        .view-surface {
            background: #ffffff;
            border: 1px solid #e5e7eb;
            border-top: none;
            border-radius: 0 0 8px 8px;
            overflow: hidden;
            min-height: 420px;
            display: flex;
            flex-direction: column;
        }

        .view-stage-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            padding: 12px 16px;
            border-bottom: 1px solid #e5e7eb;
            background: linear-gradient(180deg, #ffffff 0%, #f8fafc 100%);
            flex-wrap: wrap;
        }

        .view-stage-title {
            display: flex;
            align-items: center;
            gap: 12px;
            min-width: 0;
        }

        .view-stage-pill {
            padding: 6px 10px;
            border-radius: 10px;
            border: 1px solid #e2e8f0;
            background: #f8fafc;
            color: #475569;
            font-size: 12px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.04em;
        }

        .view-stage-name { font-weight: 800; font-size: 16px; letter-spacing: -0.01em; color: #0f172a; }
        .view-stage-sub { color: #64748b; font-size: 13px; font-weight: 600; }

        .view-stage-actions { display: flex; flex-direction: column; gap: 10px; width: 100%; }
        .view-stage-actions .primary-actions { flex-wrap: wrap; }
        .view-stage-controls { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; min-width: 0; }
        .view-stage-inline-actions { display: inline-flex; align-items: center; gap: 6px; flex-wrap: wrap; }
        .toolbar-row { display: flex; align-items: center; gap: 10px; flex-wrap: wrap; justify-content: space-between; width: 100%; }
        .toolbar-row.scrollable { overflow-x: auto; padding-bottom: 4px; }
        .toolbar-group { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; min-width: 0; }
        .selection-group { display: inline-flex; align-items: center; gap: 8px; flex-wrap: wrap; }
        .selection-indicator { display: inline-flex; align-items: center; gap: 6px; padding: 6px 10px; border-radius: 999px; background: #eef2ff; color: #3730a3; font-weight: 700; font-size: 12px; }
        .selection-indicator.hidden { display: none; }
        .selection-indicator i { font-size: 14px; }

        .view-stage-body { padding: 14px 16px 18px; background: #ffffff; flex: 1; }

        .view-table-shell {
            border: 1px solid #e2e8f0;
            border-radius: 12px;
            overflow: hidden;
            background: #ffffff;
            box-shadow: inset 0 1px 0 rgba(255,255,255,0.7);
        }

        .selection-header { width: 46px; text-align: center; }
        .row-select-cell { width: 46px; text-align: center; }
        .row-select-cell input { width: 16px; height: 16px; }
        .row-selected td { background: #eef2ff; }
        .row-selected:hover td { background: #e0e7ff; }

        .json-tab {
            padding: 12px 20px;
            font-size: 14px;
            font-weight: 500;
            color: #6b7280;
            cursor: pointer;
            border-bottom: 2px solid transparent;
            background: transparent;
            border: none;
            transition: all 0.15s ease;
        }
        .json-tab:hover { color: #374151; background: #f9fafb; }
        .json-tab.active { color: #3b82f6; border-bottom-color: #3b82f6; }
        
        .json-key { color: #b45309; font-weight: 600; }
        .json-string { color: #15803d; }
        .json-number { color: #1e40af; }
        .json-boolean { color: #7c2d12; }
        .json-null { color: #991b1b; font-style: italic; }
        
        #jsonContent {
            line-height: 1.5;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        
        .profile-selector { display: flex; gap: 8px; padding: 12px 0; overflow-x: auto; }
        .profile-tab {
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s;
            border: 1px solid #e5e7eb;
            background: white;
            white-space: nowrap;
        }
        .profile-tab:hover { background: #f3f4f6; }
        .profile-tab.active { background: #8b5cf6; color: white; border-color: #8b5cf6; }
        
        .history-entry {
            border-left: 3px solid #e5e7eb;
            padding: 12px;
            margin-bottom: 8px;
            transition: all 0.15s ease;
            cursor: pointer;
            border-radius: 4px;
        }
        .history-entry:hover { border-left-color: #3b82f6; background-color: #f9fafb; }

        .mobile-sidebar-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.35);
            z-index: 30;
        }

        @media (min-width: 1100px) {
            .view-stage-actions { flex-direction: row; align-items: center; }
            .toolbar-row { flex: 1; }
            .toolbar-row.secondary { justify-content: flex-end; }
        }

        @media (max-width: 640px) {
            .toolbar-row { flex-direction: column; align-items: stretch; }
            .toolbar-row.secondary { gap: 12px; }
            .toolbar-row .toolbar-group, .selection-group { width: 100%; justify-content: space-between; }
        }

        @media (max-width: 1024px) {
            body { padding-bottom: var(--mobile-bottom-bar-height); }
            .mobile-topbar { display: flex; }
            .mobile-bottom-bar { display: grid; }
            .mobile-fab { display: inline-flex; }
            .app-header { display: none; }
            .app-main { padding: 12px var(--mobile-padding); }
        }

        @media (max-width: 768px) {
            .toolbar-actions button,
            .toolbar-menu-toggle { min-height: 44px; }
            .grid-table-wrapper { overflow-x: auto; -webkit-overflow-scrolling: touch; margin: 0 -16px; padding: 0 16px; }
            .grid-table { min-width: 720px; }
            .view-type-btn { padding: 10px 12px; }
        }

        @media (max-width: 1024px) {
            :root { --sidebar-width: 240px; }
            .app-container { grid-template-areas: "header" "main"; grid-template-columns: 1fr; grid-template-rows: auto 1fr; }
            .app-sidebar {
                position: fixed;
                inset: 0 auto 0 0;
                width: var(--sidebar-width);
                transform: translateX(-100%);
                transition: transform 0.3s ease;
                z-index: 40;
            }
            .mobile-sidebar-overlay { display: none; }
            .mobile-layout.sidebar-open-mobile .app-sidebar { transform: translateX(0); box-shadow: 8px 0 24px rgba(0,0,0,0.18); }
            .mobile-layout.sidebar-open-mobile .mobile-sidebar-overlay { display: block; }
            .app-header { position: sticky; top: 0; z-index: 20; }
            .toolbar { flex-direction: column; align-items: stretch; gap: 12px; }
            .toolbar .view-type-switcher { width: 100%; overflow-x: auto; padding-bottom: 4px; }
            .toolbar-left { width: 100%; flex-direction: column; align-items: flex-start; }
            .toolbar-inline-actions { width: 100%; }
            .toolbar-actions { width: 100%; justify-content: space-between; }
            .primary-actions { flex: 1; }
            .toolbar-actions, .primary-actions { flex-wrap: wrap; }
            .toolbar-actions button { flex: 1 1 calc(50% - 8px); min-width: 140px; }
            .toolbar-menu { width: 100%; display: flex; justify-content: flex-end; }
            .toolbar-menu-panel { width: min(100%, 360px); }
            .cards-grid { grid-template-columns: repeat(auto-fill, minmax(240px, 1fr)); }
            .kanban-board { min-height: auto; }
        }

        @media (max-width: 640px) {
            .toolbar-actions button { flex: 1 1 100%; }
            .toolbar-menu-toggle { width: 100%; justify-content: center; }
            .cards-grid { grid-template-columns: 1fr; }
            .kanban-column { min-width: 260px; }
        }
    </style>
</head>
<body>
    <div class="mobile-topbar" id="mobileTopbar">
        <button class="mobile-icon-btn" onclick="toggleSidebar()" aria-label="Toggle navigation">
            <i class="ph ph-list"></i>
        </button>
        <div class="mobile-topbar-title" id="mobileTopbarTitle">EO</div>
        <button class="mobile-icon-btn" onclick="triggerPrimaryAction()" aria-label="Add record">
            <i class="ph ph-plus"></i>
        </button>
    </div>

        <div class="app-container" id="appContainer">
        <!-- Sidebar -->
        <div class="app-sidebar">
            <div class="sidebar-header">
                <div class="sidebar-brand-logo" aria-label="EO bracket logo">
                    <img id="topCornerLogo" src="assets/eo-icons/eo-bracket-light.svg" alt="EO bracket logo" />
                </div>
                <button class="sidebar-toggle" onclick="toggleSidebar()">
                    <i class="ph ph-list text-lg"></i>
                </button>
            </div>
            <div class="world-switcher">
                <div class="world-badge">
                    <span class="set-icon"><i class="ph ph-globe-hemisphere-west"></i></span>
                    <div>
                        <small>World</small>
                        <div id="currentWorldLabel">Loading...</div>
                    </div>
                </div>
                <div class="world-actions">
                    <select id="worldSelect" class="world-select"></select>
                    <button id="addWorldBtn" class="sidebar-toggle" title="Add world"><i class="ph ph-plus"></i></button>
                </div>
            </div>
            <div class="sidebar-section">
                <div class="sidebar-section-title">Knowledge</div>
                <div class="knowledge-nav">
                    <button class="knowledge-nav-btn" id="entitiesNavBtn" onclick="openEntitiesPage()">
                        <i class="ph ph-archive"></i>
                        <span>Entities</span>
                    </button>
                    <button class="knowledge-nav-btn" id="definitionsNavBtn" onclick="openDefinitionsPage()">
                        <i class="ph ph-books"></i>
                        <span>Definitions</span>
                    </button>
                    <button class="knowledge-nav-btn" id="connectionsNavBtn" onclick="openConnectionsPage()">
                        <i class="ph ph-link-simple"></i>
                        <span>Connections</span>
                    </button>
                </div>
            </div>
            <div class="sidebar-section grow">
                <div class="sidebar-section-title">Sets</div>
                <div id="setsList"></div>
                <button onclick="openAddSetModal()" class="new-set-btn">
                    <span class="set-icon"><i class="ph ph-plus"></i></span>
                    <span class="set-name">New Set</span>
                </button>
            </div>
        </div>

        <div class="mobile-sidebar-overlay" id="mobileSidebarOverlay" onclick="closeMobileSidebar()"></div>

        <!-- Header -->
        <div class="app-header">
            <div class="world-toolbar">
                <div class="world-toolbar-info">
                    <div class="world-pill">
                        <i class="ph ph-globe-hemisphere-west"></i>
                        <span id="currentWorldHeaderLabel">Loading world...</span>
                    </div>
                    <p class="world-toolbar-hint">World-level settings live here. View settings stay on the workspace surface.</p>
                </div>
                <div class="world-toolbar-actions">
                    <button id="globalHistoryBtn" class="btn btn-secondary btn-sm">
                        <i class="ph ph-clock-counter-clockwise"></i>
                        Global changes
                    </button>
                    <button id="viewWorldJsonBtn" class="btn btn-secondary btn-sm">
                        <i class="ph ph-code"></i>
                        View JSON
                    </button>
                    <button id="importWorldBtn" class="btn btn-secondary btn-sm">
                        <i class="ph ph-upload-simple"></i>
                        Import world
                    </button>
                    <input type="file" id="worldJsonInput" accept="application/json" style="display:none" />
                    <button id="exportWorldBtn" class="btn btn-primary btn-sm">
                        <i class="ph ph-download-simple"></i>
                        Download world
                    </button>
                </div>
            </div>
            <div class="view-toolbar-note">Use the view surface for filters, sorts, and view-specific options within this world.</div>
        </div>

        <!-- Main Content -->
        <div class="app-main">
            <div class="view-workspace">
                <div class="view-tabs-rail">
                    <div id="viewTabs" class="view-tabs hidden"></div>
                </div>
                <div class="view-surface" id="viewSurface">
                    <div id="viewContainer"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="mobile-bottom-bar" id="mobileBottomBar">
        <button class="mobile-bottom-action" data-mobile-nav="grid" onclick="switchViewType('grid')">
            <i class="ph ph-table"></i>
            <span>Grid</span>
        </button>
        <button class="mobile-bottom-action" data-mobile-nav="card" onclick="switchViewType('card')">
            <i class="ph ph-cards-three"></i>
            <span>Card</span>
        </button>
        <button class="mobile-bottom-action" data-mobile-nav="kanban" onclick="switchViewType('kanban')">
            <i class="ph ph-kanban"></i>
            <span>Kanban</span>
        </button>
        <button class="mobile-bottom-action" onclick="document.getElementById('filterBtn')?.click()">
            <i class="ph ph-funnel"></i>
            <span>Filter</span>
        </button>
        <button class="mobile-bottom-action" onclick="document.getElementById('sortBtn')?.click()">
            <i class="ph ph-arrows-down-up"></i>
            <span>Sort</span>
        </button>
    </div>

    <button class="mobile-fab" id="mobileFab" onclick="triggerPrimaryAction()" aria-label="Quick add">
        <i class="ph ph-plus"></i>
    </button>

    <!-- All Modals from previous version -->
    <div id="confirmModal" class="hidden fixed inset-0 bg-black bg-opacity-20 modal-overlay flex items-center justify-center p-6 z-50">
        <div class="modal-container bg-white w-full max-w-md">
            <div class="modal-header">
                <h2 class="text-xl font-bold text-gray-900">Confirm Action</h2>
            </div>
            <div class="modal-body">
                <p class="text-gray-700" id="confirmMessage"></p>
            </div>
            <div class="modal-footer flex justify-end gap-2">
                <button id="confirmCancelBtn" class="btn btn-secondary">Cancel</button>
                <button id="confirmOkBtn" class="btn btn-danger">Confirm</button>
            </div>
        </div>
    </div>

    <div id="definitionModal" class="hidden fixed inset-0 bg-black bg-opacity-20 modal-overlay flex items-center justify-center p-6 z-50">
        <div class="modal-container bg-white w-full max-w-2xl">
            <div class="modal-header flex items-center justify-between">
                <div>
                    <h2 class="text-xl font-bold text-gray-900" id="definitionModalTitle">Add Definition</h2>
                    <p class="text-sm text-gray-500">Provide a definition for any entity type.</p>
                </div>
                <button class="text-gray-400 hover:text-gray-600 transition" onclick="closeDefinitionModal()" aria-label="Close">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>
            <div class="modal-body">
                <form id="definitionForm" class="grid grid-cols-1 md:grid-cols-2 gap-3">
                    <div>
                        <label class="form-label">Entity Type</label>
                        <select id="definitionEntityType" class="border rounded px-3 py-2 w-full">
                            <option value="">Select type</option>
                            <option value="Record">Record</option>
                            <option value="Field">Field</option>
                            <option value="Set">Set</option>
                            <option value="Connection">Connection</option>
                            <option value="ViewEntity">ViewEntity</option>
                        </select>
                    </div>
                    <div>
                        <label class="form-label">Entity ID</label>
                        <input id="definitionEntityId" type="text" class="border rounded px-3 py-2 w-full" placeholder="entity identifier" />
                    </div>
                    <div>
                        <label class="form-label">Term</label>
                        <input id="definitionTerm" type="text" class="border rounded px-3 py-2 w-full" placeholder="Human-readable term" />
                    </div>
                    <div>
                        <label class="form-label">Definition</label>
                        <input id="definitionDefinition" type="text" class="border rounded px-3 py-2 w-full" placeholder="What does this mean?" />
                    </div>
                    <div>
                        <label class="form-label">Notes</label>
                        <input id="definitionNotes" type="text" class="border rounded px-3 py-2 w-full" placeholder="Optional clarifications" />
                    </div>
                    <div>
                        <label class="form-label">Tags (comma separated)</label>
                        <input id="definitionTags" type="text" class="border rounded px-3 py-2 w-full" placeholder="demo, core" />
                    </div>
                </form>
            </div>
            <div class="modal-footer flex justify-end gap-2">
                <button class="btn btn-secondary" type="button" onclick="closeDefinitionModal()">Cancel</button>
                <button class="btn btn-primary" type="submit" form="definitionForm" id="definitionSubmit">Add Definition</button>
            </div>
        </div>
    </div>

    <div id="connectionFormatModal" class="hidden fixed inset-0 bg-black bg-opacity-20 modal-overlay flex items-center justify-center p-6 z-50">
        <div class="modal-container bg-white w-full max-w-2xl">
            <div class="modal-header flex items-center justify-between">
                <div>
                    <h2 class="text-xl font-bold text-gray-900" id="connectionFormatModalTitle">Add Connection Format</h2>
                    <p class="text-sm text-gray-500">Define operator + mode templates using the EO dictionary.</p>
                </div>
                <button class="text-gray-400 hover:text-gray-600 transition" onclick="closeModal('connectionFormatModal')" aria-label="Close">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>
            <div class="modal-body">
                <form id="connectionFormatForm" class="grid grid-cols-1 md:grid-cols-2 gap-3">
                    <div>
                        <label class="form-label">Operator</label>
                        <select id="connectionFormatOperator" class="border rounded px-3 py-2 w-full">
                            <option value="">Select operator</option>
                        </select>
                    </div>
                    <div>
                        <label class="form-label">Mode</label>
                        <select id="connectionFormatMode" class="border rounded px-3 py-2 w-full"></select>
                    </div>
                    <div>
                        <label class="form-label">Required Params (comma separated)</label>
                        <input id="connectionFormatRequired" type="text" class="border rounded px-3 py-2 w-full" placeholder="threshold, weight" />
                    </div>
                    <div>
                        <label class="form-label">Optional Params (comma separated)</label>
                        <input id="connectionFormatOptional" type="text" class="border rounded px-3 py-2 w-full" placeholder="notes" />
                    </div>
                    <div class="md:col-span-2">
                        <label class="form-label">Description</label>
                        <input id="connectionFormatDescription" type="text" class="border rounded px-3 py-2 w-full" placeholder="Describe how this format should be used" />
                    </div>
                </form>
            </div>
            <div class="modal-footer flex justify-end gap-2">
                <button class="btn btn-secondary" type="button" onclick="closeModal('connectionFormatModal')">Cancel</button>
                <button class="btn btn-primary" type="submit" form="connectionFormatForm" id="connectionFormatSubmit">Add Format</button>
            </div>
        </div>
    </div>

    <div id="connectionModal" class="hidden fixed inset-0 bg-black bg-opacity-20 modal-overlay flex items-center justify-center p-6 z-50">
        <div class="modal-container bg-white w-full max-w-3xl">
            <div class="modal-header flex items-center justify-between">
                <div>
                    <h2 class="text-xl font-bold text-gray-900" id="connectionModalTitle">Add Connection</h2>
                    <p class="text-sm text-gray-500">Choose a format to link specific entities.</p>
                </div>
                <button class="text-gray-400 hover:text-gray-600 transition" onclick="closeModal('connectionModal')" aria-label="Close">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>
            <div class="modal-body">
                <form id="connectionForm" class="grid grid-cols-1 md:grid-cols-2 gap-3">
                    <div>
                        <label class="form-label">Format</label>
                        <select id="connectionFormatSelect" class="border rounded px-3 py-2 w-full">
                            <option value="">Select a format</option>
                        </select>
                    </div>
                    <div class="flex items-end text-sm text-gray-600 gap-2">
                        <div class="mt-6" id="connectionFormatSummary">No format selected</div>
                    </div>
                    <div>
                        <label class="form-label">Subject Type</label>
                        <select id="connectionSubjectType" class="border rounded px-3 py-2 w-full">
                            <option value="">Select type</option>
                            <option value="Record">Record</option>
                            <option value="Field">Field</option>
                            <option value="Set">Set</option>
                            <option value="Connection">Connection</option>
                            <option value="ViewEntity">ViewEntity</option>
                        </select>
                    </div>
                    <div>
                        <label class="form-label">Subject ID</label>
                        <input id="connectionSubjectId" type="text" class="border rounded px-3 py-2 w-full" />
                    </div>
                    <div>
                        <label class="form-label">Operand Type</label>
                        <select id="connectionOperandType" class="border rounded px-3 py-2 w-full">
                            <option value="">Select type</option>
                            <option value="Record">Record</option>
                            <option value="Field">Field</option>
                            <option value="Set">Set</option>
                            <option value="Connection">Connection</option>
                            <option value="ViewEntity">ViewEntity</option>
                        </select>
                    </div>
                    <div>
                        <label class="form-label">Operand ID</label>
                        <input id="connectionOperandId" type="text" class="border rounded px-3 py-2 w-full" />
                    </div>
                    <div>
                        <label class="form-label">Description</label>
                        <input id="connectionDescription" type="text" class="border rounded px-3 py-2 w-full" placeholder="Optional" />
                    </div>
                    <div id="connectionParamFields" class="md:col-span-2 grid grid-cols-1 md:grid-cols-2 gap-3"></div>
                </form>
            </div>
            <div class="modal-footer flex justify-end gap-2">
                <button class="btn btn-secondary" type="button" onclick="closeModal('connectionModal')">Cancel</button>
                <button class="btn btn-primary" type="submit" form="connectionForm" id="connectionSubmit">Add Connection</button>
            </div>
        </div>
    </div>

    <div id="expandedRecordModal" class="hidden fixed inset-0 bg-black bg-opacity-20 modal-overlay flex items-center justify-center p-6 z-50">
        <div class="modal-container bg-white w-full max-w-5xl max-h-[90vh] overflow-hidden flex flex-col">
            <div class="modal-header flex items-center justify-between flex-shrink-0">
                <div class="flex items-center gap-4 flex-1">
                    <h2 class="text-2xl font-bold text-gray-900" id="expandedRecordTitle">Record Details</h2>
                    <div class="profile-selector" id="recordProfileSelector"></div>
                </div>
                <div class="flex items-center gap-2">
                    <button id="toggleHistorySidebarBtn" class="btn btn-secondary btn-sm">Hide History</button>
                    <button id="closeExpandedRecordBtn" class="text-gray-400 hover:text-gray-600 transition p-2">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                        </svg>
                    </button>
                </div>
            </div>
            <div class="flex-1 overflow-hidden">
                <div class="grid grid-cols-1 md:grid-cols-3 h-full">
                    <div id="expandedRecordMainWrapper" class="md:col-span-2 p-6 overflow-y-auto border-r border-gray-200">
                        <div id="expandedRecordMain"></div>
                    </div>
                    <div id="expandedRecordHistoryColumn" class="overflow-hidden bg-gray-50 flex flex-col">
                        <div class="record-tabs">
                            <div class="record-tab active" data-tab="history" onclick="switchRecordTab('history')">History</div>
                            <div class="record-tab" data-tab="connections" onclick="switchRecordTab('connections')">Connections</div>
                        </div>
                        <div class="flex-1 overflow-y-auto p-6" id="expandedRecordSidebar"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="filterModal" class="hidden fixed inset-0 bg-black bg-opacity-20 modal-overlay flex items-center justify-center p-6 z-50">
        <div class="modal-container bg-white w-full max-w-xl max-h-[90vh] overflow-hidden flex flex-col">
            <div class="modal-header flex items-center justify-between">
                <div>
                    <h2 class="text-xl font-bold text-gray-900">Filter View</h2>
                    <p class="text-sm text-gray-500 mt-1">Create advanced filter conditions</p>
                </div>
                <button id="closeFilterBtn" class="text-gray-400 hover:text-gray-600 transition p-2">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>
            <div class="flex-1 overflow-y-auto modal-body">
                <div id="filterGroupsContainer"></div>
                <button id="addFilterGroupBtn" class="btn btn-secondary btn-sm mt-4">+ Add Filter Group</button>
            </div>
            <div class="modal-footer flex justify-end gap-2">
                <button id="clearFiltersBtn" class="btn btn-secondary">Clear All</button>
                <button id="applyFiltersBtn" class="btn btn-primary">Apply Filters</button>
            </div>
        </div>
    </div>

    <div id="sortModal" class="hidden fixed inset-0 bg-black bg-opacity-20 modal-overlay flex items-center justify-center p-6 z-50">
        <div class="modal-container bg-white w-full max-w-3xl max-h-[80vh] overflow-hidden flex flex-col">
            <div class="modal-header flex items-center justify-between">
                <div>
                    <h2 class="text-xl font-bold text-gray-900">Sort View</h2>
                    <p class="text-sm text-gray-500 mt-1">Create a sorting sequence for this view</p>
                </div>
                <button id="closeSortBtn" class="text-gray-400 hover:text-gray-600 transition p-2">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>
            <div class="flex-1 overflow-y-auto modal-body space-y-3">
                <div id="sortRulesContainer" class="space-y-3"></div>
                <button id="addSortRuleBtn" class="btn btn-secondary btn-sm">+ Add Sort</button>
            </div>
            <div class="modal-footer flex justify-between gap-2">
                <div class="flex items-center gap-2 text-sm text-gray-500">
                    <span class="sort-sequence-badge"><i class="ph ph-arrow-line-up"></i>Earlier sorts run first</span>
                </div>
                <div class="flex gap-2">
                    <button id="clearSortsBtn" class="btn btn-secondary">Clear All</button>
                    <button id="applySortsBtn" class="btn btn-primary">Apply Sorts</button>
                </div>
            </div>
        </div>
    </div>

    <div id="popupSettingsModal" class="hidden fixed inset-0 bg-black bg-opacity-20 modal-overlay flex items-center justify-center p-6 z-50">
        <div class="modal-container bg-white popup-config-shell">
            <div class="popup-config-header">
                <div>
                    <h2 class="text-2xl font-bold text-gray-900">Modal Configuration</h2>
                    <p class="text-sm text-gray-600 mt-1">Curate which fields show in record modals, define conditional visibility, and preview layouts.</p>
                </div>
                <div class="flex items-center gap-2">
                    <button class="btn btn-secondary btn-sm" onclick="resetPopupLayout()">Reset</button>
                    <button id="closePopupSettingsBtn" class="btn btn-secondary btn-sm">Close</button>
                </div>
            </div>

            <div class="popup-config-tabs">
                <button class="popup-config-tab active" data-tab="popupFields" onclick="setPopupTab('popupFields')"> Fields <span class="popup-badge" id="popupFieldCountBadge">0</span></button>
                <button class="popup-config-tab" data-tab="popupLayout" onclick="setPopupTab('popupLayout')"> Layout</button>
                <button class="popup-config-tab" data-tab="popupConditions" onclick="setPopupTab('popupConditions')"> Conditions</button>
            </div>

            <div class="popup-config-body">
                <div class="popup-tab-panel active" id="popupFields">
                    <div class="popup-panel-scroll">
                        <div class="popup-quick-filters" id="popupFilters"></div>
                        <div class="popup-info"><span></span><span><strong>Drag to reorder</strong> and toggle visibility. Click the gear to set conditional rules per field.</span></div>
                        <div id="popupFieldList"></div>
                    </div>
                </div>

                <div class="popup-tab-panel" id="popupLayout">
                    <div class="popup-panel-scroll space-y-4">
                        <div class="popup-card">
                            <h4>Modal Size</h4>
                            <div class="popup-layout-options" id="popupSizeOptions"></div>
                        </div>
                        <div class="popup-card">
                            <h4>Column Layout</h4>
                            <div class="popup-layout-options" id="popupColumnOptions"></div>
                        </div>
                        <div class="popup-card">
                            <h4>Preview</h4>
                            <div id="popupPreview" class="popup-preview"></div>
                        </div>
                    </div>
                </div>

                <div class="popup-tab-panel" id="popupConditions">
                    <div class="popup-panel-scroll">
                        <div class="popup-info"><span></span><span><strong>Conditional visibility</strong> lets you keep modals focused and contextual.</span></div>
                        <div id="popupConditionsList" class="popup-conditions"></div>
                    </div>
                </div>

                <div class="popup-side">
                    <div class="popup-card">
                        <h4>Quick Stats</h4>
                        <div class="popup-stat-grid">
                            <div class="popup-stat">
                                <div class="value" id="popupVisibleCount">0</div>
                                <div class="label">Visible Fields</div>
                            </div>
                            <div class="popup-stat">
                                <div class="value" id="popupConditionalCount">0</div>
                                <div class="label">Conditional Rules</div>
                            </div>
                        </div>
                    </div>
                    <div class="popup-card">
                        <h4>Templates</h4>
                        <div class="popup-template-buttons">
                            <button class="btn btn-secondary btn-sm" onclick="applyPopupTemplate('minimal')"> Minimal View</button>
                            <button class="btn btn-secondary btn-sm" onclick="applyPopupTemplate('detailed')"> Detailed View</button>
                            <button class="btn btn-secondary btn-sm" onclick="applyPopupTemplate('compact')"> Compact View</button>
                        </div>
                    </div>
                    <div class="popup-card">
                        <h4>Recent Changes</h4>
                        <div id="popupRecentChanges" class="text-sm text-gray-600 space-y-1"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="addFieldModal" class="hidden fixed inset-0 bg-black bg-opacity-20 modal-overlay flex items-center justify-center p-6 z-50">
        <div class="modal-container bg-white w-full max-w-xl max-h-[90vh] overflow-hidden flex flex-col">
            <div class="modal-header flex items-center justify-between">
                <div>
                    <h2 class="text-xl font-bold text-gray-900">Add Field</h2>
                    <p class="text-sm text-gray-500 mt-1">Create a new field for your set</p>
                </div>
                <button id="closeAddFieldBtn" class="text-gray-400 hover:text-gray-600 transition p-2">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>
            <div class="flex-1 overflow-y-auto modal-body space-y-5">
                  <div>
                      <label class="form-label">Field Name</label>
                      <input type="text" id="newFieldName" placeholder="e.g., Status, Amount, Contact Person" autofocus aria-describedby="fieldNameError">
                      <p class="form-hint">A descriptive name for your field</p>
                      <p id="fieldNameError" class="form-error hidden" role="alert"></p>
                  </div>
                <div>
                    <label class="form-label">Field Type</label>
                    <div class="field-type-select">
                        <button type="button" id="fieldTypeTrigger" class="field-type-trigger">
                            <div class="field-type-trigger-content">
                                <span class="field-type-trigger-icon" aria-hidden="true"></span>
                                <div class="field-type-trigger-text">
                                    <div class="field-type-name" id="selectedFieldTypeName"></div>
                                    <div class="field-type-description" id="selectedFieldTypeDescription"></div>
                                </div>
                            </div>
                            <span class="field-type-trigger-arrow" aria-hidden="true"></span>
                        </button>
                        <div id="fieldTypeDropdown" class="field-type-dropdown hidden"></div>
                    </div>
                    <input type="hidden" id="newFieldType" value="TEXT">
                </div>
                <div id="singleSelectConfig" class="config-section">
                    <div class="bg-orange-50 border border-orange-200 rounded-lg p-4">
                        <label class="form-label">Options</label>
                        <div id="selectOptionsList" class="space-y-2 mb-3"></div>
                        <button onclick="addSelectOption()" class="btn btn-secondary btn-sm">+ Add Option</button>
                    </div>
                </div>
                <div id="linkToRecordConfig" class="config-section">
                    <div class="bg-blue-50 border border-blue-200 rounded-lg p-4">
                        <label class="form-label">Link to Set</label>
                        <select id="linkToSet"></select>
                        <p class="form-hint">Select which set to link to</p>
                    </div>
                </div>
                <div id="formulaFieldConfig" class="config-section">
                    <div class="bg-sky-50 border border-sky-200 rounded-lg p-4">
                        <label class="form-label">Formula</label>
                        <div class="space-y-2">
                            <div class="formula-bar">
                                <span class="formula-bar-prefix">=</span>
                                <textarea id="formulaExpression" class="formula-bar-input" rows="3" placeholder="Type formulas like {Client Name} or =SUM({Budget})"></textarea>
                            </div>
                            <div class="flex items-center gap-2">
                                <button type="button" class="btn btn-secondary btn-sm" onclick="launchFormulaEditorFromConfig()">
                                    <i class="ph ph-magic-wand"></i>
                                    Open Formula Editor
                                </button>
                                <span class="text-xs text-gray-600">Autocomplete, validation, and preview included.</span>
                            </div>
                        </div>
                        <p class="form-hint">Compose expressions using the JavaScript-style formula rules defined in the repo's formula engine.</p>
                    </div>
                </div>
            </div>
            <div class="modal-footer flex justify-end gap-2">
                <button id="cancelAddFieldBtn" class="btn btn-secondary">Cancel</button>
                <button id="saveAddFieldBtn" class="btn btn-primary">Add Field</button>
            </div>
        </div>
    </div>

    <div id="changeFieldTypeModal" class="hidden fixed inset-0 bg-black bg-opacity-20 modal-overlay flex items-center justify-center p-6 z-50">
        <div class="modal-container bg-white w-full max-w-xl max-h-[90vh] overflow-hidden flex flex-col">
            <div class="modal-header flex items-center justify-between">
                <div>
                    <h2 class="text-xl font-bold text-gray-900">Change Field Type</h2>
                    <p class="text-sm text-gray-500 mt-1">Update the type for <span id="changeFieldName" class="font-medium text-gray-900"></span></p>
                    <p id="changeFieldTypeSummary" class="text-xs text-gray-500 mt-1"></p>
                </div>
                <button id="closeChangeFieldTypeBtn" class="text-gray-400 hover:text-gray-600 transition p-2">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>
            <div class="flex-1 overflow-y-auto modal-body space-y-5">
                <div>
                    <label class="form-label">Field Type</label>
                    <div class="field-type-select">
                        <button type="button" id="changeFieldTypeTrigger" class="field-type-trigger">
                            <div class="field-type-trigger-content">
                                <span class="field-type-trigger-icon" aria-hidden="true"></span>
                                <div class="field-type-trigger-text">
                                    <div class="field-type-name" id="changeSelectedFieldTypeName"></div>
                                    <div class="field-type-description" id="changeSelectedFieldTypeDescription"></div>
                                </div>
                            </div>
                            <span class="field-type-trigger-arrow" aria-hidden="true"></span>
                        </button>
                        <div id="changeFieldTypeDropdown" class="field-type-dropdown hidden"></div>
                    </div>
                    <input type="hidden" id="changeFieldTypeInput" value="TEXT">
                </div>
                <div id="changeSingleSelectConfig" class="config-section">
                    <div class="bg-orange-50 border border-orange-200 rounded-lg p-4">
                        <label class="form-label">Options</label>
                        <div id="changeSelectOptionsList" class="space-y-2 mb-3"></div>
                        <button onclick="changeAddSelectOption()" class="btn btn-secondary btn-sm">+ Add Option</button>
                    </div>
                </div>
                <div id="changeLinkToRecordConfig" class="config-section">
                    <div class="bg-blue-50 border border-blue-200 rounded-lg p-4">
                        <label class="form-label">Link to Set</label>
                        <select id="changeLinkToSet"></select>
                        <p class="form-hint">Select which set to link to</p>
                    </div>
                </div>
                <div id="changeFormulaFieldConfig" class="config-section">
                    <div class="bg-sky-50 border border-sky-200 rounded-lg p-4">
                        <label class="form-label">Formula</label>
                        <div class="space-y-2">
                            <div class="formula-bar">
                                <span class="formula-bar-prefix">=</span>
                                <textarea id="changeFormulaExpression" class="formula-bar-input" rows="3" placeholder="Type formulas like {Client Name} or =SUM({Budget})"></textarea>
                            </div>
                            <div class="flex items-center gap-2">
                                <button type="button" class="btn btn-secondary btn-sm" onclick="launchFormulaEditorFromConfig('changeFormulaExpression')">
                                    <i class="ph ph-magic-wand"></i>
                                    Open Formula Editor
                                </button>
                                <span class="text-xs text-gray-600">Autocomplete, validation, and preview included.</span>
                            </div>
                        </div>
                        <p class="form-hint">Compose expressions using the JavaScript-style formula rules defined in the repo's formula engine.</p>
                    </div>
                </div>
            </div>
            <div class="modal-footer flex justify-end gap-2">
                <button id="cancelChangeFieldTypeBtn" class="btn btn-secondary">Cancel</button>
                <button id="saveChangeFieldTypeBtn" class="btn btn-primary">Update Type</button>
            </div>
        </div>
    </div>

    <div id="addWorldModal" class="hidden fixed inset-0 bg-black bg-opacity-20 modal-overlay flex items-center justify-center p-6 z-50">
        <div class="modal-container bg-white w-full max-w-md">
            <div class="modal-header">
                <h2 class="text-xl font-bold text-gray-900">Create World</h2>
            </div>
            <div class="modal-body space-y-4">
                <div>
                    <label class="form-label">World Name</label>
                    <input type="text" id="newWorldName" placeholder="e.g., Workspace Alpha">
                </div>
            </div>
            <div class="modal-footer flex justify-end gap-2">
                <button id="cancelAddWorldBtn" class="btn btn-secondary">Cancel</button>
                <button id="saveAddWorldBtn" class="btn btn-primary">Create</button>
            </div>
        </div>
    </div>

    <div id="addSetModal" class="hidden fixed inset-0 bg-black bg-opacity-20 modal-overlay flex items-center justify-center p-6 z-50">
        <div class="modal-container bg-white w-full max-w-md">
            <div class="modal-header">
                <h2 id="addSetModalTitle" class="text-xl font-bold text-gray-900">Create Set</h2>
            </div>
            <div class="modal-body space-y-4">
                <div>
                    <label class="form-label">World</label>
                    <select id="newSetWorld"></select>
                </div>
                <div>
                    <label class="form-label">Set Name</label>
                    <input type="text" id="newSetName" placeholder="e.g., Projects, Contacts">
                </div>
                <div>
                    <label class="form-label">Icon</label>
                    <div id="newSetIconSelector" class="icon-selector" role="button" tabindex="0">
                        <div id="newSetIconPreview" class="icon-selector-icon" aria-hidden="true"></div>
                        <div class="icon-selector-text">
                            <div class="icon-selector-label">Pick a visual icon</div>
                            <div id="newSetIconToken" class="icon-selector-token"></div>
                        </div>
                        <span class="icon-selector-chevron"></span>
                    </div>
                    <input type="hidden" id="newSetIcon" value="ph-squares-four">
                </div>
            </div>
            <div class="modal-footer flex justify-end gap-2">
                <button id="cancelAddSetBtn" class="btn btn-secondary">Cancel</button>
                <button id="saveAddSetBtn" class="btn btn-primary">Create</button>
            </div>
        </div>
    </div>

    <div id="addViewModal" class="hidden fixed inset-0 bg-black bg-opacity-20 modal-overlay flex items-center justify-center p-6 z-50">
        <div class="modal-container bg-white w-full max-w-xl">
            <div class="modal-header">
                <h2 id="addViewModalTitle" class="text-xl font-bold text-gray-900">Create View</h2>
            </div>
            <div class="modal-body space-y-4">
                <div>
                    <label class="form-label">View Name</label>
                    <input type="text" id="newViewName" placeholder="e.g., Active Items">
                </div>
                <div>
                    <label class="form-label">View Icon</label>
                    <div id="newViewIconSelector" class="icon-selector" role="button" tabindex="0">
                        <div id="newViewIconPreview" class="icon-selector-icon" aria-hidden="true"></div>
                        <div class="icon-selector-text">
                            <div class="icon-selector-label">Choose an icon visually</div>
                            <div id="newViewIconToken" class="icon-selector-token"></div>
                        </div>
                        <span class="icon-selector-chevron"></span>
                    </div>
                    <input type="hidden" id="newViewIcon" value="ph-table">
                </div>
                <div>
                    <label class="form-label">View Type</label>
                    <div class="grid grid-cols-2 gap-2">
                        <label class="view-type-option">
                            <input type="radio" name="newViewType" value="grid" checked>
                            <div class="view-type-option-content">
                                <i class="ph ph-table"></i>
                                <span>Table</span>
                            </div>
                        </label>
                        <label class="view-type-option">
                            <input type="radio" name="newViewType" value="card">
                            <div class="view-type-option-content">
                                <i class="ph ph-cards-three"></i>
                                <span>Cards</span>
                            </div>
                        </label>
                        <label class="view-type-option">
                            <input type="radio" name="newViewType" value="kanban">
                            <div class="view-type-option-content">
                                <i class="ph ph-kanban"></i>
                                <span>Kanban</span>
                            </div>
                        </label>
                        <label class="view-type-option">
                            <input type="radio" name="newViewType" value="graph">
                            <div class="view-type-option-content">
                                <i class="ph ph-graph"></i>
                                <span>Graph</span>
                            </div>
                        </label>
                    </div>
                </div>
                <div>
                    <label class="form-label">Nest Under</label>
                    <select id="newViewParent"></select>
                    <p class="form-hint">Optionally place this view under another view</p>
                </div>
                <div>
                    <label class="form-label">How do you want to start?</label>
                    <div class="space-y-3">
                        <label class="flex items-center gap-2 font-medium">
                            <input type="radio" name="viewCreationMode" value="blank" checked>
                            Blank View
                        </label>
                        <label class="flex items-start gap-2 font-medium">
                            <input type="radio" name="viewCreationMode" value="key">
                            <div class="flex-1">
                                <div>Create From Key</div>
                                <div class="mt-2">
                                    <select id="keyCandidateSelect" class="w-full" disabled>
                                        <option value="">Scanning for identity properties</option>
                                    </select>
                                    <p class="form-hint">We look for reused identifiers, links, and fuzzy matches to seed the shape.</p>
                                </div>
                            </div>
                        </label>
                    </div>
                </div>
            </div>
            <div class="modal-footer flex justify-end gap-2">
                <button id="cancelAddViewBtn" class="btn btn-secondary">Cancel</button>
                <button id="saveAddViewBtn" class="btn btn-primary">Create</button>
            </div>
        </div>
    </div>

    <div id="iconPickerModal" class="hidden fixed inset-0 bg-black bg-opacity-20 modal-overlay flex items-center justify-center p-6 z-50">
        <div class="modal-container bg-white w-full max-w-2xl icon-picker-shell">
            <div class="modal-header flex items-center justify-between">
                <h2 class="text-xl font-bold text-gray-900">Pick an icon</h2>
                <button id="closeIconPickerBtn" class="btn btn-secondary btn-sm">Close</button>
            </div>
            <div class="modal-body space-y-4 icon-picker-body">
                <div class="icon-picker-controls">
                    <input type="text" id="iconPickerSearch" placeholder="Search icons (e.g., table, folder)" class="w-full icon-picker-search">
                    <div id="iconPickerPagination" class="icon-pagination"></div>
                </div>
                <div id="iconPickerOptions" class="icon-picker-grid"></div>
            </div>
        </div>
    </div>

    <div id="kanbanConfigModal" class="hidden fixed inset-0 bg-black bg-opacity-20 modal-overlay flex items-center justify-center p-6 z-50">
        <div class="modal-container bg-white w-full max-w-md">
            <div class="modal-header">
                <h2 class="text-xl font-bold text-gray-900">Configure Kanban</h2>
            </div>
            <div class="modal-body space-y-4">
                <div>
                    <label class="form-label">Group By Field</label>
                    <select id="kanbanGroupField"></select>
                    <p class="form-hint">Select a single-select field to group records by</p>
                </div>
            </div>
            <div class="modal-footer flex justify-end gap-2">
                <button id="cancelKanbanConfigBtn" class="btn btn-secondary">Cancel</button>
                <button id="saveKanbanConfigBtn" class="btn btn-primary">Apply</button>
            </div>
        </div>
    </div>

    <div id="csvImportModal" class="hidden fixed inset-0 bg-black bg-opacity-20 modal-overlay flex items-center justify-center p-6 z-50">
        <div class="modal-container bg-white w-full max-w-4xl max-h-[90vh] overflow-hidden flex flex-col">
            <div class="modal-header flex items-center justify-between">
                <div>
                    <h2 class="text-xl font-bold text-gray-900">Import CSV</h2>
                    <p class="text-sm text-gray-500 mt-1">Choose a destination set before uploading, then map columns and preview fuzzy matches.</p>
                </div>
                <button id="closeCsvImportBtn" class="text-gray-400 hover:text-gray-600 transition p-2">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>
            <div class="flex-1 overflow-y-auto modal-body space-y-4">
                <div class="csv-helper-card">
                    <div class="flex items-center justify-between mb-2">
                        <div>
                            <h3 class="text-lg font-semibold">Destination</h3>
                            <p class="text-sm text-gray-500">Pick an existing set or create a new one before selecting a file.</p>
                        </div>
                    </div>
                    <div class="space-y-3">
                        <label class="flex items-center gap-2 font-medium">
                            <input type="radio" name="csvImportTargetMode" value="existing" checked>
                            Import into existing set
                        </label>
                        <div id="csvExistingSetPicker" class="pl-7 space-y-2">
                            <select id="csvTargetSetSelect"></select>
                            <p class="text-xs text-gray-500">We'll map columns to the selected set's fields.</p>
                        </div>
                        <label class="flex items-center gap-2 font-medium">
                            <input type="radio" name="csvImportTargetMode" value="new">
                            Create a new set from this CSV
                        </label>
                        <div id="csvNewSetFields" class="pl-7 space-y-2 hidden">
                            <input type="text" id="csvNewSetName" placeholder="e.g., Leads" class="w-full">
                            <p class="text-xs text-gray-500">We'll create fields from your headers automatically.</p>
                        </div>
                    </div>
                </div>

                <div class="csv-helper-grid">
                    <div class="csv-helper-card">
                        <label class="form-label">Upload CSV File</label>
                        <input type="file" id="csvFileInput" accept=".csv" />
                        <p class="form-hint">Headers are required. We will auto-map matching field names.</p>
                    </div>
                    <div class="csv-helper-card">
                        <label class="form-label">Or Paste CSV Text</label>
                        <textarea id="csvTextInput" rows="5" placeholder="name,industry\nAcme,Technology"></textarea>
                        <div class="mt-2 flex justify-end">
                            <button id="parseCsvTextBtn" class="btn btn-secondary btn-sm">Preview CSV</button>
                        </div>
                    </div>
                </div>

                <div class="csv-helper-card">
                    <div class="flex items-center justify-between mb-2">
                        <div>
                            <h3 class="text-lg font-semibold">Field Mapping</h3>
                            <p class="text-sm text-gray-500">Match CSV columns to fields in the current set.</p>
                        </div>
                        <span class="csv-match-pill" id="csvRowCountBadge">0 rows</span>
                    </div>
                    <div id="csvMappingContainer" class="space-y-2"></div>
                </div>

                <div class="csv-helper-card">
                    <div class="flex items-center justify-between mb-2">
                        <div>
                            <h3 class="text-lg font-semibold">Preview</h3>
                            <p class="text-sm text-gray-500">First few records with applied mapping.</p>
                        </div>
                        <button id="refreshCsvPreviewBtn" class="btn btn-secondary btn-sm">Refresh Preview</button>
                    </div>
                    <div id="csvPreviewContainer" class="overflow-auto"></div>
                </div>

                <div class="csv-helper-card">
                    <div class="flex items-center justify-between mb-2">
                        <div>
                            <h3 class="text-lg font-semibold">Fuzzy Match Suggestions</h3>
                            <p class="text-sm text-gray-500">We surface potential duplicates against existing records.</p>
                        </div>
                        <div class="text-xs text-gray-500">Score  0.6 shown</div>
                    </div>
                    <div id="csvMatchSuggestions" class="space-y-2"></div>
                </div>
            </div>
            <div class="modal-footer flex justify-end gap-2">
                <button id="cancelCsvImportBtn" class="btn btn-secondary">Cancel</button>
                <button id="runCsvImportBtn" class="btn btn-primary">Import Records</button>
            </div>
        </div>
    </div>

    <div id="columnRulesModal" class="hidden fixed inset-0 bg-black bg-opacity-20 modal-overlay flex items-center justify-center p-6 z-50">
        <div class="modal-container bg-white w-full max-w-xl max-h-[90vh] overflow-hidden flex flex-col">
            <div class="modal-header flex items-center justify-between">
                <div>
                    <h2 class="text-xl font-bold text-gray-900">Column Rules</h2>
                    <p class="text-sm text-gray-500 mt-1">Pick how we resolve multiple observations per property.</p>
                </div>
                <button id="closeColumnRulesBtn" class="text-gray-400 hover:text-gray-600 transition p-2">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>
            <div class="flex-1 overflow-y-auto modal-body space-y-4">
                <div class="flex items-center justify-between p-3 border border-gray-200 rounded-lg bg-white/50">
                    <div class="flex items-center gap-2">
                        <i class="ph ph-gear-six text-gray-500"></i>
                        <div>
                            <div class="text-sm font-semibold text-gray-900">Columns</div>
                            <div class="text-xs text-gray-500">Toggle view-only columns like the Record ID.</div>
                        </div>
                    </div>
                    <label class="flex items-center gap-2 cursor-pointer select-none">
                        <span class="text-sm text-gray-700">Record ID</span>
                        <input id="recordIdVisibilityToggle" type="checkbox" class="w-4 h-4 border-gray-300 rounded">
                    </label>
                </div>
                <div>
                    <label class="form-label">Property</label>
                    <select id="columnRulesFieldSelect"></select>
                </div>
                <div>
                    <label class="form-label">Rule</label>
                    <select id="columnRulesRuleSelect">
                        <option value="sup_all">Show all (Multiple Observations)</option>
                        <option value="prefer_newest">Prefer newest</option>
                        <option value="prefer_oldest">Prefer oldest</option>
                        <option value="prefer_set">Prefer value from set</option>
                        <option value="average_numeric">Average numeric</option>
                        <option value="median_numeric">Median numeric</option>
                        <option value="concat_text">Concatenate text</option>
                        <option value="first_non_null">First non-null</option>
                    </select>
                </div>
                <div id="columnRulesSetPicker" class="hidden">
                    <label class="form-label">Preferred Set</label>
                    <select id="columnRulesPreferredSet"></select>
                </div>
                <div class="rounded-lg border border-gray-200 p-3 bg-gray-50" id="columnRulesSummary"></div>
            </div>
            <div class="modal-footer flex justify-end gap-2">
                <button id="deleteColumnRuleBtn" class="btn btn-secondary">Clear Rule</button>
                <button id="saveColumnRuleBtn" class="btn btn-primary">Save Rule</button>
            </div>
        </div>
    </div>

    <div id="historyPanel" class="side-panel">
        <div class="bg-gradient-to-r from-indigo-600 to-purple-600 text-white p-6 flex-shrink-0">
            <div class="flex items-center justify-between mb-4">
                <div>
                    <h3 class="text-xl font-bold">Edit History</h3>
                    <p class="text-sm opacity-90 mt-1">Full audit trail</p>
                </div>
                <button id="closeHistoryBtn" class="text-white hover:bg-white hover:bg-opacity-20 p-2 rounded-lg transition">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>
            <input type="text" id="historySearch" class="w-full text-gray-900 rounded-lg" placeholder="Search history...">
        </div>
        <div class="flex-1 overflow-y-auto p-6" id="historyContent"></div>
    </div>

    <div id="fuzzyMatchPanel" class="side-panel">
        <div class="bg-gradient-to-r from-emerald-500 to-blue-600 text-white p-6 flex-shrink-0">
            <div class="flex items-center justify-between mb-4">
                <div>
                    <h3 class="text-xl font-bold">Fuzzy Matches</h3>
                    <p class="text-sm opacity-90 mt-1">Possible duplicate or related records</p>
                </div>
                <button id="closeFuzzyPanelBtn" class="text-white hover:bg-white hover:bg-opacity-20 p-2 rounded-lg transition">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>
            <div class="panel-controls">
                <label class="text-sm flex-1">Similarity threshold
                    <input id="fuzzyThresholdInput" type="range" min="0.4" max="0.95" step="0.01" value="0.65" class="w-full">
                </label>
                <button id="refreshFuzzyMatchesBtn" class="btn btn-secondary btn-sm">Recompute</button>
            </div>
        </div>
        <div class="flex-1 overflow-y-auto p-6" id="fuzzyMatchList"></div>
    </div>

    <!-- Cell History Modal -->
    <div id="cellHistoryModal" class="hidden fixed inset-0 bg-black bg-opacity-20 modal-overlay flex items-center justify-center p-6 z-50">
        <div class="modal-container bg-white w-full max-w-3xl max-h-[90vh] overflow-hidden flex flex-col">
            <div class="modal-header flex items-center justify-between">
                <div>
                    <h2 class="text-xl font-bold text-gray-900" id="cellHistoryTitle">Cell History</h2>
                    <p class="text-sm text-gray-500 mt-1" id="cellHistorySubtitle"></p>
                </div>
                <button class="text-gray-400 hover:text-gray-600 transition p-2" onclick="closeModal('cellHistoryModal')">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>
            <div class="p-6 overflow-auto" id="cellHistoryContent"></div>
        </div>
    </div>

    <!-- JSON Viewer Modal -->
    <div id="jsonViewerModal" class="hidden fixed inset-0 bg-black bg-opacity-20 modal-overlay flex items-center justify-center p-6 z-50">
        <div class="modal-container bg-white w-full max-w-6xl h-[90vh] max-h-[90vh] overflow-hidden flex flex-col">
            <div class="modal-header flex items-center justify-between">
                <div>
                    <h2 class="text-xl font-bold text-gray-900">JSON Data</h2>
                    <p class="text-sm text-gray-500 mt-1">View the complete data structure</p>
                </div>
                <button id="closeJsonViewerBtn" class="text-gray-400 hover:text-gray-600 transition p-2">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>
            <div class="flex border-b border-gray-200">
                <button class="json-tab active" data-tab="all" onclick="switchJsonTab('all')">All Data</button>
                <button class="json-tab" data-tab="sets" onclick="switchJsonTab('sets')">Sets</button>
                <button class="json-tab" data-tab="current" onclick="switchJsonTab('current')">Current Set</button>
                <button class="json-tab" data-tab="events" onclick="switchJsonTab('events')">Event Stream</button>
            </div>
            <div class="flex-1 overflow-hidden relative">
                <pre id="jsonContent" class="p-6 overflow-auto h-full text-sm bg-gray-50 font-mono"></pre>
                <button id="copyJsonBtn" class="absolute top-4 right-4 btn btn-secondary btn-sm">
                    <i class="ph ph-clipboard-text"></i>
                    Copy
                </button>
            </div>
        </div>
    </div>

    <script>
        const BRAND_ASSETS = {
            light: 'assets/eo-icons/eo-bracket-light.svg',
            dark: 'assets/eo-icons/eo-bracket-dark.svg'
        };

        function getTimeOfDayBrandMode() {
            const hour = new Date().getHours();
            return hour >= 6 && hour < 18 ? 'light' : 'dark';
        }

        function applyTimeBasedBranding() {
            const mode = getTimeOfDayBrandMode();
            const bracketAsset = BRAND_ASSETS[mode] || BRAND_ASSETS.light;

            const faviconLink = document.querySelector('link#dynamicFavicon');
            if (faviconLink) {
                faviconLink.href = bracketAsset;
            }

            const appleIcon = document.querySelector('link#dynamicAppleIcon');
            if (appleIcon) {
                appleIcon.href = bracketAsset;
            }

            const cornerLogo = document.getElementById('topCornerLogo');
            if (cornerLogo) {
                const darkAsset = BRAND_ASSETS.dark || bracketAsset;
                cornerLogo.src = darkAsset;
                cornerLogo.alt = 'EO bracket logo for dark mode';
                cornerLogo.dataset.brandMode = 'dark';
            }

            document.documentElement.dataset.brandMode = mode;
        }

        // STATE
        const state = {
            worlds: new Map(),
            entities: new Map(),
            currentWorldId: null,
            sets: new Map(),
            currentSetId: null,
            currentViewId: null,
            currentProfileId: 'default',
            eventStream: [],
            eventIdCounter: 1,
            currentUser: { type: 'Person', id: 'user_1', name: 'User' },
            operatorSet: {},
            connectionModes: {},
            connectionFormats: new Map(),
            leanContext: null, // Will be initialized in initializeApp
            interpretationRules: [],
            definitions: new Map(),
            entityFormState: { activeFilter: 'all', editingId: null },
            connections: new Map(),
            demoRefs: {},
            connectionBuilder: { targetSetId: null, targetRecordId: '', searchQuery: '', formatId: null, params: {} },
            currentSpecialView: null,
            definitionFormState: { editingId: null, activeFilter: 'all', showImportPanel: false },
            connectionFormState: { editingId: null, selectedFormatId: null },
            connectionFormatFormState: { editingId: null },
            sidebarCollapsed: false,
            sidebarOpenMobile: false,
            modalStack: [],
            currentRecordTab: 'history',
            recordHistoryVisible: true,
            openTabs: [],
            confirmCallback: null,
            selectOptions: [{ value: 'Option 1', color: 'blue' }],
            changeSelectOptions: [{ value: 'Option 1', color: 'blue' }],
            changeFormulaBlocks: [],
            changeLinkedSetId: '',
            changeFieldOriginalType: null,
            fieldTypeDropdownOpen: false,
            changeFieldTypeDropdownOpen: false,
            changeFieldContext: null,
            expandedSets: new Set(),
            draggedRecord: null,
            cellHistoryContext: null,
            setEditorContext: null,
            viewEditorContext: null,
            iconPickerTarget: null,
            iconPickerQuery: '',
            popupUi: { filter: 'all', activeTab: 'popupFields' },
            popupEventStream: [],
            popupDraggedField: null,
            iconPickerPage: 1,
            selectedRecordIds: new Set(),
            lastSelectedRecordId: null,
            selectedCell: null,
            lastSelectedCell: null,
            editingCell: null,
            csvImportState: { headers: [], rows: [], mappings: {}, previewRows: [], matches: [], targetMode: 'existing', targetSetId: null, newSetName: '' },
            fuzzyPanelState: { threshold: 0.65, matches: [] },
            formulaFieldService: null,
            fieldTypeHistory: new Map(),
            formulaEditor: {
                isOpen: false,
                fieldId: null,
                currentFormula: '',
                cursorPosition: 0,
                autocomplete: {
                    isVisible: false,
                    items: [],
                    selectedIndex: 0,
                    trigger: null,
                    filterText: ''
                },
                validation: {
                    isValid: true,
                    errors: [],
                    warnings: []
                },
                preview: {
                    result: null,
                    error: null
                },
                mode: 'code',
                visualBlocks: [],
                onSave: null
            }
        };

        function registerEntity(entity) {
            if (!entity || !entity.id || !entity.type) {
                throw new Error('Entities require an id and type');
            }
            if (!state.entities) state.entities = new Map();
            const existing = state.entities.get(entity.id) || {};
            const worldId = entity.worldId || existing.worldId || deriveWorldIdForEntity(entity);
            const payload = {
                ...existing,
                ...entity,
                worldId,
                entityType: entity.entityType || existing.entityType || entity.type,
                origin: entity.origin || existing.origin || 'system'
            };
            state.entities.set(entity.id, payload);
            return payload;
        }

        function deleteEntity(entityId) {
            if (!state.entities?.has(entityId)) return null;
            const existing = state.entities.get(entityId);
            state.entities.delete(entityId);
            return existing;
        }

        function getEntityView(filterFn) {
            const entities = Array.from(state.entities.values()).filter(entity => !entity.worldId || entity.worldId === state.currentWorldId);
            return typeof filterFn === 'function' ? entities.filter(filterFn) : entities;
        }

        const columnDragState = {
            timer: null,
            holdTimer: null,
            holdReady: false,
            draggedFieldId: null,
            dropFieldId: null,
            dropPosition: null,
            ghost: null,
            offsetX: 0,
            offsetY: 0,
            sourceElement: null,
            preventClick: false
        };

        const tabDragState = {
            draggingKey: null,
            dropKey: null,
            dropPosition: null
        };

        const COLUMN_WIDTH_MIN = 60;
        const COLUMN_WIDTH_MAX = 600;

        function clampColumnWidth(width) {
            if (isNaN(width)) return 150;
            return Math.min(COLUMN_WIDTH_MAX, Math.max(COLUMN_WIDTH_MIN, width));
        }

        const formulaEditorCSS = `
            .formula-editor-modal {
                position: fixed;
                inset: 0;
                background: rgba(0, 0, 0, 0.4);
                backdrop-filter: blur(4px);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 1000;
            }

            .formula-editor-container {
                background: white;
                border-radius: 12px;
                box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
                width: 90%;
                max-width: 900px;
                max-height: 90vh;
                display: flex;
                flex-direction: column;
                overflow: hidden;
            }

            .formula-editor-header {
                padding: 20px 24px;
                border-bottom: 1px solid #e5e7eb;
                display: flex;
                align-items: center;
                justify-content: space-between;
            }

            .formula-editor-tabs {
                display: flex;
                gap: 4px;
                border-bottom: 1px solid #e5e7eb;
                padding: 0 24px;
            }

            .formula-editor-tab {
                padding: 12px 16px;
                border: none;
                background: transparent;
                cursor: pointer;
                font-weight: 500;
                color: #6b7280;
                border-bottom: 2px solid transparent;
                transition: all 0.15s;
            }

            .formula-editor-tab:hover {
                color: #111827;
                background: #f9fafb;
            }

            .formula-editor-tab.active {
                color: #3b82f6;
                border-bottom-color: #3b82f6;
            }

            .formula-editor-body {
                flex: 1;
                overflow: hidden;
                display: flex;
                flex-direction: column;
            }

            .formula-input-wrapper {
                position: relative;
                padding: 16px 24px;
                border-bottom: 1px solid #e5e7eb;
                display: flex;
                gap: 12px;
                align-items: flex-start;
            }

            .formula-input-prefix {
                background: #0f172a;
                color: #e0f2fe;
                border-radius: 10px;
                padding: 12px 14px;
                font-weight: 700;
                box-shadow: 0 8px 24px rgba(15, 23, 42, 0.18);
            }

            .formula-input {
                width: 100%;
                min-height: 120px;
                padding: 12px 14px;
                border: 2px solid #e5e7eb;
                border-radius: 12px;
                font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
                font-size: 14px;
                line-height: 1.6;
                resize: vertical;
                transition: border-color 0.15s, box-shadow 0.15s;
            }

            .formula-input:focus {
                outline: none;
                border-color: #3b82f6;
                box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
            }

            .formula-input.error {
                border-color: #ef4444;
            }

            .formula-autocomplete {
                position: absolute;
                background: white;
                border: 1px solid #e5e7eb;
                border-radius: 8px;
                box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15);
                max-height: 300px;
                overflow-y: auto;
                z-index: 1001;
                min-width: 280px;
            }

            .autocomplete-item {
                padding: 10px 14px;
                cursor: pointer;
                transition: background 0.1s;
                border-bottom: 1px solid #f3f4f6;
            }

            .autocomplete-item:last-child {
                border-bottom: none;
            }

            .autocomplete-item:hover {
                background: #f9fafb;
            }

            .autocomplete-item.selected {
                background: #eff6ff;
                color: #1e40af;
            }

            .autocomplete-item-main {
                display: flex;
                align-items: center;
                gap: 8px;
                font-weight: 600;
                margin-bottom: 4px;
            }

            .autocomplete-item-icon {
                width: 20px;
                height: 20px;
                display: flex;
                align-items: center;
                justify-content: center;
                border-radius: 4px;
                font-size: 12px;
            }

            .autocomplete-item-icon.field {
                background: #dbeafe;
                color: #1e40af;
            }

            .autocomplete-item-icon.function {
                background: #fef3c7;
                color: #92400e;
            }

            .autocomplete-item-description {
                font-size: 12px;
                color: #6b7280;
                line-height: 1.4;
            }

            .autocomplete-item-syntax {
                font-size: 11px;
                font-family: 'Monaco', 'Menlo', monospace;
                color: #3b82f6;
                margin-top: 4px;
            }

            .formula-validation {
                padding: 12px 24px;
                border-bottom: 1px solid #e5e7eb;
            }

            .validation-message {
                display: flex;
                align-items: start;
                gap: 8px;
                padding: 8px 12px;
                border-radius: 6px;
                font-size: 13px;
                margin-bottom: 8px;
            }

            .validation-message:last-child {
                margin-bottom: 0;
            }

            .validation-message.error {
                background: #fee2e2;
                color: #991b1b;
                border: 1px solid #fecaca;
            }

            .validation-message.warning {
                background: #fef3c7;
                color: #92400e;
                border: 1px solid #fde68a;
            }

            .validation-message.success {
                background: #d1fae5;
                color: #065f46;
                border: 1px solid #a7f3d0;
            }

            .formula-preview {
                padding: 16px 24px;
                background: #f9fafb;
                border-bottom: 1px solid #e5e7eb;
            }

            .preview-label {
                font-size: 12px;
                font-weight: 600;
                color: #6b7280;
                text-transform: uppercase;
                letter-spacing: 0.05em;
                margin-bottom: 8px;
            }

            .preview-result {
                padding: 12px;
                background: white;
                border: 1px solid #e5e7eb;
                border-radius: 6px;
                font-family: 'Monaco', 'Menlo', monospace;
                font-size: 14px;
                color: #111827;
            }

            .preview-error {
                color: #dc2626;
            }

            .formula-helpers {
                flex: 1;
                overflow-y: auto;
                padding: 16px 24px;
            }

            .helper-section {
                margin-bottom: 24px;
            }

            .helper-section-title {
                font-weight: 600;
                font-size: 14px;
                color: #111827;
                margin-bottom: 12px;
                display: flex;
                align-items: center;
                gap: 8px;
            }

            .helper-items {
                display: grid;
                grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
                gap: 8px;
            }

            .helper-item {
                padding: 8px 12px;
                background: #f9fafb;
                border: 1px solid #e5e7eb;
                border-radius: 6px;
                cursor: pointer;
                transition: all 0.15s;
                font-size: 13px;
            }

            .helper-item:hover {
                background: #eff6ff;
                border-color: #3b82f6;
                color: #1e40af;
            }

            .helper-item-name {
                font-weight: 600;
                margin-bottom: 4px;
            }

            .helper-item-desc {
                font-size: 11px;
                color: #6b7280;
            }

            .formula-editor-footer {
                padding: 16px 24px;
                border-top: 1px solid #e5e7eb;
                display: flex;
                justify-content: space-between;
                align-items: center;
            }

            .formula-shortcuts {
                display: flex;
                gap: 16px;
                font-size: 12px;
                color: #6b7280;
            }

            .shortcut-hint {
                display: flex;
                align-items: center;
                gap: 4px;
            }

            .shortcut-key {
                padding: 2px 6px;
                background: #f3f4f6;
                border: 1px solid #d1d5db;
                border-radius: 4px;
                font-family: monospace;
                font-size: 11px;
            }

            .visual-formula-builder {
                padding: 24px;
            }

            .formula-blocks {
                display: flex;
                flex-direction: column;
                gap: 12px;
            }

            .formula-block {
                background: white;
                border: 2px solid #e5e7eb;
                border-radius: 8px;
                padding: 16px;
                display: flex;
                align-items: center;
                gap: 12px;
            }

            .formula-block-type {
                padding: 4px 8px;
                background: #f3f4f6;
                border-radius: 4px;
                font-size: 11px;
                font-weight: 600;
                text-transform: uppercase;
                color: #6b7280;
            }

            .formula-block-content {
                flex: 1;
                display: flex;
                align-items: center;
                gap: 8px;
            }

            .formula-block select,
            .formula-block input {
                padding: 6px 10px;
                border: 1px solid #d1d5db;
                border-radius: 4px;
                font-size: 14px;
            }

            .formula-block-actions {
                display: flex;
                gap: 4px;
            }

            .formula-block-action {
                padding: 6px;
                background: transparent;
                border: none;
                cursor: pointer;
                color: #6b7280;
                transition: color 0.15s;
            }

            .formula-block-action:hover {
                color: #111827;
            }

            .formula-block-action.delete:hover {
                color: #dc2626;
            }

            .add-block-btn {
                padding: 12px;
                border: 2px dashed #d1d5db;
                border-radius: 8px;
                background: transparent;
                color: #6b7280;
                cursor: pointer;
                transition: all 0.15s;
                font-weight: 500;
            }

            .add-block-btn:hover {
                border-color: #3b82f6;
                color: #3b82f6;
                background: #eff6ff;
            }
        `;

        if (!document.getElementById('formulaEditorStyles')) {
            const style = document.createElement('style');
            style.id = 'formulaEditorStyles';
            style.textContent = formulaEditorCSS;
            document.head.appendChild(style);
        }

        function getFieldWidth(field) {
            const numericWidth = parseInt(field?.width || '150', 10);
            return clampColumnWidth(numericWidth);
        }

        async function initializeFormulaSupport() {
            if (typeof FormulaFieldService === 'undefined' || typeof FormulaEngine === 'undefined') {
                console.warn('Formula libraries are not available. Formula fields will be disabled.');
                return;
            }

            // Future enhancements: evaluate spreadsheet-grade helpers like HyperFormula (Handsontable),
            // hot-formula-parser, or formula.js to deepen function coverage and cross-platform parity.

            try {
                const response = await fetch('formula_language.json');
                const spec = await response.json();
                window.FormulaLanguageSpec = spec;
                state.formulaFieldService = new FormulaFieldService({
                    spec,
                    engine: new FormulaEngine()
                });
                registerDemoFormulaHelpers();
                recomputeAllFormulas();
            } catch (error) {
                console.warn('Unable to initialize formula support', error);
            }
        }

        function registerDemoFormulaHelpers() {
            if (!state.formulaFieldService) return;

            const findUnitRecordByName = (unitName) => {
                if (!unitName) return null;
                const targetName = unitName.toString().trim().toLowerCase();
                const scopedSet = state.demoRefs?.temperature?.unitSetId
                    ? state.sets.get(state.demoRefs.temperature.unitSetId)
                    : null;
                const setsToScan = scopedSet ? [scopedSet] : Array.from(state.sets.values());

                for (const set of setsToScan) {
                    if (!set?.records?.size) continue;
                    for (const record of set.records.values()) {
                        if (typeof record.name === 'string' && record.name.trim().toLowerCase() === targetName) {
                            return record;
                        }
                    }
                }
                return null;
            };

            const findConversionRecord = (sourceUnitId, targetUnitId) => {
                if (!sourceUnitId || !targetUnitId) return null;
                const outbound = getConnectionView(edge =>
                    edge.subject?.type === 'Record' &&
                    edge.subject?.id === sourceUnitId &&
                    edge.params?.relationship === 'unit_conversion'
                );

                for (const connection of outbound) {
                    const conversionId = connection.operand?.id;
                    const pointsToTarget = getConnectionView(edge =>
                        edge.subject?.id === conversionId &&
                        edge.operand?.id === targetUnitId &&
                        edge.params?.relationship === 'unit_conversion'
                    ).length > 0;

                    if (pointsToTarget) {
                        const conversionRef = getRecordById(conversionId);
                        if (conversionRef?.record) return conversionRef.record;
                    }
                }

                return null;
            };

            const convertValueBetweenUnits = (value, sourceUnitId, targetUnitId) => {
                const numericValue = Number(value);
                if (Number.isNaN(numericValue) || !sourceUnitId || !targetUnitId) return null;
                if (sourceUnitId === targetUnitId) return numericValue;

                const conversion = findConversionRecord(sourceUnitId, targetUnitId);
                if (!conversion) return null;

                const preOffset = Number(conversion.pre_offset ?? 0);
                const scale = Number(conversion.scale ?? 1);
                const postOffset = Number(conversion.post_offset ?? 0);

                if ([preOffset, scale, postOffset].some(v => Number.isNaN(v))) return null;
                return (numericValue + preOffset) * scale + postOffset;
            };

            state.formulaFieldService.registerHelper('CONVERT_LINKED_VALUE', (readingId, targetUnitName) => {
                const readingRef = getRecordById(readingId);
                if (!readingRef?.record) return null;

                const targetUnit = findUnitRecordByName(targetUnitName);
                if (!targetUnit) return null;

                const sourceUnitId = readingRef.record.unit;
                return convertValueBetweenUnits(readingRef.record.value, sourceUnitId, targetUnit.id);
            }, {
                category: 'Lookup',
                description: 'Converts a linked numeric reading to the target unit by following conversion connections',
                return_type: 'number'
            });

            state.formulaFieldService.registerHelper('AVERAGE_TO_UNIT', (targetUnitName, primaryReadingId, secondaryReadingId) => {
                const targetUnit = findUnitRecordByName(targetUnitName);
                if (!targetUnit) return null;

                const readingIds = [primaryReadingId, secondaryReadingId].filter(Boolean);
                const convertedValues = readingIds
                    .map(id => {
                        const readingRef = getRecordById(id);
                        if (!readingRef?.record) return null;
                        return convertValueBetweenUnits(readingRef.record.value, readingRef.record.unit, targetUnit.id);
                    })
                    .filter(value => typeof value === 'number' && !Number.isNaN(value));

                if (!convertedValues.length) return null;
                const total = convertedValues.reduce((sum, value) => sum + value, 0);
                return total / convertedValues.length;
            }, {
                category: 'Math',
                description: 'Averages linked numeric readings after converting them to the requested unit through connection definitions',
                return_type: 'number'
            });
        }

        function recomputeAllFormulas() {
            state.sets.forEach(set => recomputeFormulasForSet(set));
        }

        function recomputeFormulasForSet(set) {
            if (!state.formulaFieldService || !set) return;
            const formulaFields = set.schema.filter(f => f.type === 'FORMULA');
            if (!formulaFields.length) return;
            set.records.forEach(record => {
                formulaFields.forEach(field => evaluateFormulaField(record, field, set.schema));
            });
        }

        function evaluateFormulaField(record, field, schema = []) {
            if (!state.formulaFieldService || !field?.config?.formula) return;
            const evaluation = state.formulaFieldService.evaluateForRecord(field.config.formula, record, schema);
            record.__formulaMeta = record.__formulaMeta || {};
            record.__formulaMeta[field.id] = evaluation;
            record[field.id] = evaluation.success ? evaluation.result : '';
        }

        function getFormulaSpec() {
            return window.FormulaLanguageSpec || { functions: {}, operators: [] };
        }

        function openFormulaEditor(fieldId = null, onSave = null) {
            const set = getCurrentSet();
            if (!set) return;

            const field = fieldId ? set.schema.find(f => f.id === fieldId) : null;

            state.formulaEditor = {
                ...state.formulaEditor,
                isOpen: true,
                fieldId,
                currentFormula: field?.config?.formula || document.getElementById('formulaExpression')?.value || '',
                cursorPosition: 0,
                autocomplete: {
                    isVisible: false,
                    items: [],
                    selectedIndex: 0,
                    trigger: null,
                    filterText: ''
                },
                validation: {
                    isValid: true,
                    errors: [],
                    warnings: []
                },
                preview: {
                    result: null,
                    error: null
                },
                mode: 'code',
                onSave,
                visualBlocks: field?.config?.visualBlocks || []
            };

            renderFormulaEditor();
        }

        function renderFormulaEditor() {
            const modal = `
                <div class="formula-editor-modal" id="formulaEditorModal">
                    <div class="formula-editor-container">
                        <div class="formula-editor-header">
                            <div>
                                <h2 class="text-xl font-bold">Formula Editor</h2>
                                <p class="text-sm text-gray-600 mt-1">Build formulas with autocomplete and live preview</p>
                            </div>
                            <button onclick="closeFormulaEditor()" class="text-gray-400 hover:text-gray-600">
                                <i class="ph ph-x text-xl"></i>
                            </button>
                        </div>
                        <div class="formula-editor-tabs">
                            <button 
                                class="formula-editor-tab ${state.formulaEditor.mode === 'code' ? 'active' : ''}"
                                onclick="switchFormulaMode('code')"
                            >
                                <i class="ph ph-code"></i>
                                Code Editor
                            </button>
                            <button 
                                class="formula-editor-tab ${state.formulaEditor.mode === 'visual' ? 'active' : ''}"
                                onclick="switchFormulaMode('visual')"
                            >
                                <i class="ph ph-flow-arrow"></i>
                                Visual Builder
                            </button>
                            <button 
                                class="formula-editor-tab"
                                onclick="showFormulaExamples()"
                            >
                                <i class="ph ph-lightbulb"></i>
                                Examples
                            </button>
                        </div>
                        <div class="formula-editor-body">
                            ${state.formulaEditor.mode === 'code' ? renderCodeEditor() : renderVisualBuilder()}
                        </div>
                        <div class="formula-editor-footer">
                            <div class="formula-shortcuts">
                                <div class="shortcut-hint">
                                    <span class="shortcut-key">{</span>
                                    <span>Field reference</span>
                                </div>
                                <div class="shortcut-hint">
                                    <span class="shortcut-key">Ctrl+Space</span>
                                    <span>Functions</span>
                                </div>
                                <div class="shortcut-hint">
                                    <span class="shortcut-key">Tab</span>
                                    <span>Accept suggestion</span>
                                </div>
                            </div>
                            <div class="flex gap-2">
                                <button onclick="closeFormulaEditor()" class="btn btn-secondary">Cancel</button>
                                <button onclick="saveFormula()" class="btn btn-primary">Save Formula</button>
                            </div>
                        </div>
                    </div>
                </div>
            `;

            document.getElementById('formulaEditorModal')?.remove();
            document.body.insertAdjacentHTML('beforeend', modal);

            setTimeout(() => {
                const input = document.getElementById('formulaInput');
                if (input) {
                    input.focus();
                    input.setSelectionRange(state.formulaEditor.currentFormula.length, state.formulaEditor.currentFormula.length);
                }
            }, 100);
        }

        function renderCodeEditor() {
            const validation = state.formulaEditor.validation;
            const preview = state.formulaEditor.preview;

            return `
                <div class="formula-input-wrapper">
                    <div class="formula-input-prefix">=</div>
                    <textarea
                        id="formulaInput"
                        class="formula-input ${!validation.isValid ? 'error' : ''}"
                        placeholder="Enter your formula... Type { for field references or Ctrl+Space for functions"
                        oninput="handleFormulaInput(event)"
                        onkeydown="handleFormulaKeydown(event)"
                    >${state.formulaEditor.currentFormula}</textarea>
                    ${state.formulaEditor.autocomplete.isVisible ? renderAutocomplete() : ''}
                </div>
                ${validation.errors.length > 0 || validation.warnings.length > 0 ? `
                    <div class="formula-validation">
                        ${validation.errors.map(error => `
                            <div class="validation-message error">
                                <i class="ph ph-warning-circle"></i>
                                <span>${error}</span>
                            </div>
                        `).join('')}
                        ${validation.warnings.map(warning => `
                            <div class="validation-message warning">
                                <i class="ph ph-warning"></i>
                                <span>${warning}</span>
                            </div>
                        `).join('')}
                    </div>
                ` : ''}
                ${state.formulaEditor.currentFormula ? `
                    <div class="formula-preview">
                        <div class="preview-label">Preview</div>
                        <div class="preview-result ${preview.error ? 'preview-error' : ''}">
                            ${preview.error || preview.result || 'Enter a formula to see preview'}
                        </div>
                    </div>
                ` : ''}
                <div class="formula-helpers">
                    ${renderFormulaHelpers()}
                </div>
            `;
        }

        function renderAutocomplete() {
            const { items, selectedIndex } = state.formulaEditor.autocomplete;
            if (!items.length) return '';

            const input = document.getElementById('formulaInput');
            if (!input) return '';

            return `
                <div class="formula-autocomplete" id="autocompleteMenu" style="top: 140px; left: 36px;">
                    ${items.map((item, index) => `
                        <div class="autocomplete-item ${index === selectedIndex ? 'selected' : ''}" onclick="selectAutocompleteItem(${index})">
                            <div class="autocomplete-item-main">
                                <div class="autocomplete-item-icon ${item.type}">
                                    ${item.type === 'field' ? '' : ''}
                                </div>
                                <span>${item.name}</span>
                            </div>
                            ${item.description ? `<div class="autocomplete-item-description">${item.description}</div>` : ''}
                            ${item.syntax ? `<div class="autocomplete-item-syntax">${item.syntax}</div>` : ''}
                        </div>
                    `).join('')}
                </div>
            `;
        }

        function renderFormulaHelpers() {
            const set = getCurrentSet();
            if (!set) return '';

            return `
                <div class="helper-section">
                    <div class="helper-section-title">
                        <i class="ph ph-file-text text-blue-600"></i>
                        <span>Available Fields</span>
                    </div>
                    <div class="helper-items">
                        ${set.schema.map(field => `
                            <div class="helper-item" onclick="insertField('${field.id}')">
                                <div class="helper-item-name">{${field.name}}</div>
                                <div class="helper-item-desc">${field.type}</div>
                            </div>
                        `).join('')}
                    </div>
                </div>
                <div class="helper-section">
                    <div class="helper-section-title">
                        <i class="ph ph-function text-yellow-600"></i>
                        <span>Common Functions</span>
                    </div>
                    <div class="helper-items">
                        ${renderCommonFunctions()}
                    </div>
                </div>
            `;
        }

        function renderCommonFunctions() {
            const common = [
                { name: 'IF', syntax: 'IF(condition, value1, value2)', desc: 'Conditional logic' },
                { name: 'SUM', syntax: 'SUM(number1, number2, ...)', desc: 'Add numbers' },
                { name: 'CONCATENATE', syntax: 'CONCATENATE(text1, text2, ...)', desc: 'Join text' },
                { name: 'DATESTR', syntax: 'DATESTR(date)', desc: 'Format date' },
                { name: 'ROUND', syntax: 'ROUND(value, precision)', desc: 'Round number' },
                { name: 'UPPER', syntax: 'UPPER(text)', desc: 'Uppercase text' }
            ];

            return common.map(fn => `
                <div class="helper-item" onclick="insertFunction('${fn.syntax}')">
                    <div class="helper-item-name">${fn.name}</div>
                    <div class="helper-item-desc">${fn.desc}</div>
                </div>
            `).join('');
        }

        function handleFormulaInput(event) {
            const input = event.target;
            const value = input.value;
            const cursorPos = input.selectionStart;

            state.formulaEditor.currentFormula = value;
            state.formulaEditor.cursorPosition = cursorPos;

            checkAutocompleteTrigger(value, cursorPos);
            validateFormula(value);
            updateFormulaPreview(value);
            renderFormulaEditor();
        }

        function checkAutocompleteTrigger(formula, cursorPos) {
            const beforeCursor = formula.substring(0, cursorPos);
            const fieldMatch = beforeCursor.match(/\{([^}]*)$/);
            if (fieldMatch) {
                const filterText = fieldMatch[1];
                showFieldAutocomplete(filterText);
                return;
            }

            const functionMatch = beforeCursor.match(/([A-Z_]+)\(([^)]*)$/i);
            if (functionMatch) {
                const functionName = functionMatch[1];
                showFunctionAutocomplete(functionName);
                return;
            }

            state.formulaEditor.autocomplete.isVisible = false;
        }

        function showFieldAutocomplete(filterText) {
            const set = getCurrentSet();
            if (!set || !state.formulaFieldService) return;

            const fields = state.formulaFieldService.getFieldSuggestions(set.schema, filterText);

            state.formulaEditor.autocomplete = {
                isVisible: fields.length > 0,
                items: fields.map(field => ({
                    type: 'field',
                    name: field.name,
                    value: `{${field.name}}`,
                    description: `${field.type} field`,
                    syntax: null
                })),
                selectedIndex: 0,
                trigger: 'field',
                filterText
            };
        }

        function showFunctionAutocomplete(functionName) {
            const functions = [];
            Object.values(getFormulaSpec().functions || {}).forEach(category => {
                category.forEach(fn => {
                    if (fn.name.toLowerCase().includes((functionName || '').toLowerCase())) {
                        functions.push({
                            type: 'function',
                            name: fn.name,
                            value: fn.syntax,
                            description: fn.description,
                            syntax: fn.syntax
                        });
                    }
                });
            });

            state.formulaEditor.autocomplete = {
                isVisible: functions.length > 0,
                items: functions,
                selectedIndex: 0,
                trigger: 'function',
                filterText: functionName
            };
        }

        function handleFormulaKeydown(event) {
            const autocomplete = state.formulaEditor.autocomplete;

            if (!autocomplete.isVisible) {
                if (event.key === ' ' && event.ctrlKey) {
                    event.preventDefault();
                    showFunctionAutocomplete('');
                    renderFormulaEditor();
                }
                return;
            }

            if (event.key === 'ArrowDown') {
                event.preventDefault();
                autocomplete.selectedIndex = Math.min(
                    autocomplete.selectedIndex + 1,
                    autocomplete.items.length - 1
                );
                renderFormulaEditor();
            } else if (event.key === 'ArrowUp') {
                event.preventDefault();
                autocomplete.selectedIndex = Math.max(autocomplete.selectedIndex - 1, 0);
                renderFormulaEditor();
            } else if (event.key === 'Enter' || event.key === 'Tab') {
                event.preventDefault();
                selectAutocompleteItem(autocomplete.selectedIndex);
            } else if (event.key === 'Escape') {
                event.preventDefault();
                autocomplete.isVisible = false;
                renderFormulaEditor();
            }
        }

        function selectAutocompleteItem(index) {
            const autocomplete = state.formulaEditor.autocomplete;
            const item = autocomplete.items[index];
            if (!item) return;

            const input = document.getElementById('formulaInput');
            if (!input) return;

            const formula = state.formulaEditor.currentFormula;
            const cursorPos = state.formulaEditor.cursorPosition;

            let newFormula = formula;
            let newCursorPos = cursorPos;

            if (autocomplete.trigger === 'field') {
                const beforeCursor = formula.substring(0, cursorPos);
                const afterCursor = formula.substring(cursorPos);
                const match = beforeCursor.match(/\{([^}]*)$/);

                if (match) {
                    const startPos = beforeCursor.length - match[0].length;
                    newFormula = formula.substring(0, startPos) + item.value + afterCursor;
                    newCursorPos = startPos + item.value.length;
                }
            } else if (autocomplete.trigger === 'function') {
                const beforeCursor = formula.substring(0, cursorPos);
                const afterCursor = formula.substring(cursorPos);
                const match = beforeCursor.match(/([A-Z_]+)\(([^)]*)$/i);

                if (match) {
                    const startPos = beforeCursor.length - match[0].length;
                    newFormula = formula.substring(0, startPos) + item.syntax + afterCursor;
                    newCursorPos = startPos + item.name.length + 1;
                }
            }

            state.formulaEditor.currentFormula = newFormula;
            state.formulaEditor.cursorPosition = newCursorPos;
            state.formulaEditor.autocomplete.isVisible = false;

            renderFormulaEditor();

            setTimeout(() => {
                input.focus();
                input.setSelectionRange(newCursorPos, newCursorPos);
            }, 0);
        }

        function insertField(fieldId) {
            const set = getCurrentSet();
            if (!set) return;
            const field = set.schema.find(f => f.id === fieldId);
            if (!field) return;

            const input = document.getElementById('formulaInput');
            const cursorPos = input?.selectionStart ?? state.formulaEditor.cursorPosition;
            const formula = state.formulaEditor.currentFormula;

            const insertion = `{${field.name}}`;
            const newFormula = formula.substring(0, cursorPos) + insertion + formula.substring(cursorPos);

            state.formulaEditor.currentFormula = newFormula;
            state.formulaEditor.cursorPosition = cursorPos + insertion.length;

            renderFormulaEditor();

            setTimeout(() => {
                const activeInput = document.getElementById('formulaInput');
                if (activeInput) {
                    activeInput.focus();
                    activeInput.setSelectionRange(state.formulaEditor.cursorPosition, state.formulaEditor.cursorPosition);
                }
            }, 0);
        }

        function insertFunction(syntax) {
            const input = document.getElementById('formulaInput');
            const cursorPos = input?.selectionStart ?? state.formulaEditor.cursorPosition;
            const formula = state.formulaEditor.currentFormula;

            const newFormula = formula.substring(0, cursorPos) + syntax + formula.substring(cursorPos);
            const firstParenPos = syntax.indexOf('(') + 1;
            const newCursorPos = cursorPos + firstParenPos;

            state.formulaEditor.currentFormula = newFormula;
            state.formulaEditor.cursorPosition = newCursorPos;

            renderFormulaEditor();

            setTimeout(() => {
                const activeInput = document.getElementById('formulaInput');
                if (activeInput) {
                    activeInput.focus();
                    activeInput.setSelectionRange(newCursorPos, newCursorPos);
                }
            }, 0);
        }

        function validateFormula(formula) {
            const set = getCurrentSet();
            const errors = [];
            const warnings = [];

            const openBraces = (formula.match(/\{/g) || []).length;
            const closeBraces = (formula.match(/\}/g) || []).length;
            if (openBraces !== closeBraces) {
                errors.push('Unmatched curly braces in formula');
            }

            const openParens = (formula.match(/\(/g) || []).length;
            const closeParens = (formula.match(/\)/g) || []).length;
            if (openParens !== closeParens) {
                errors.push('Unmatched parentheses in formula');
            }

            const fieldRefs = formula.match(/\{([^}]+)\}/g) || [];
            const lookup = {};
            set?.schema?.forEach(field => {
                if (field?.name) lookup[field.name.toLowerCase()] = true;
                if (field?.id) lookup[String(field.id).toLowerCase()] = true;
            });
            fieldRefs.forEach(ref => {
                const fieldName = ref.slice(1, -1);
                const exists = lookup[fieldName.toLowerCase()];
                if (!exists) {
                    errors.push(`Unknown field: ${fieldName}`);
                }
            });

            const functionCalls = formula.match(/\b([A-Z_]+)\s*\(/g) || [];
            functionCalls.forEach(call => {
                const functionName = call.match(/([A-Z_]+)/)[1];
                const exists = Object.values(getFormulaSpec().functions || {})
                    .flat()
                    .some(fn => fn.name === functionName);

                if (!exists) {
                    errors.push(`Unknown function: ${functionName}`);
                }
            });

            if (formula.includes('&')) {
                warnings.push('Using & for concatenation will convert values to text');
            }

            state.formulaEditor.validation = {
                isValid: errors.length === 0,
                errors,
                warnings
            };
        }

        function updateFormulaPreview(formula) {
            if (!formula.trim()) {
                state.formulaEditor.preview = { result: null, error: null };
                return;
            }

            try {
                const set = getCurrentSet();
                if (!set) {
                    state.formulaEditor.preview = { result: null, error: 'No set available for preview' };
                    return;
                }
                const sampleRecord = Array.from(set.records.values())[0] || {};

                const service = state.formulaFieldService;
                if (!service) {
                    state.formulaEditor.preview = { result: null, error: 'Formula engine unavailable' };
                    return;
                }

                const result = service.evaluateForRecord(formula, sampleRecord, set.schema);

                if (result.success) {
                    state.formulaEditor.preview = {
                        result: result.preview,
                        error: null
                    };
                } else {
                    state.formulaEditor.preview = {
                        result: null,
                        error: result.error.message
                    };
                }
            } catch (error) {
                state.formulaEditor.preview = {
                    result: null,
                    error: error.message
                };
            }
        }

        function renderVisualBuilder() {
            return `
                <div class="visual-formula-builder">
                    <div class="mb-4">
                        <h3 class="font-semibold mb-2">Build your formula visually</h3>
                        <p class="text-sm text-gray-600">Drag and drop blocks to create your formula</p>
                    </div>
                    <div class="formula-blocks" id="visualFormulaBlocks">
                        ${renderVisualBlocks()}
                    </div>
                    <button class="add-block-btn w-full" onclick="addFormulaBlock()">
                        <i class="ph ph-plus"></i>
                        Add Block
                    </button>
                    <div class="mt-6 p-4 bg-gray-50 border border-gray-200 rounded-lg">
                        <div class="text-xs font-semibold text-gray-500 uppercase mb-2">Generated Formula</div>
                        <div class="font-mono text-sm">${generateFormulaFromBlocks()}</div>
                    </div>
                </div>
            `;
        }

        function renderVisualBlocks() {
            if (!state.formulaEditor.visualBlocks || state.formulaEditor.visualBlocks.length === 0) {
                return '<p class="text-gray-500 text-center py-8">No blocks yet. Click "Add Block" to start building your formula.</p>';
            }

            return state.formulaEditor.visualBlocks.map((block, index) => `
                <div class="formula-block">
                    <div class="formula-block-type">${block.type}</div>
                    <div class="formula-block-content">
                        ${renderBlockContent(block, index)}
                    </div>
                    <div class="formula-block-actions">
                        <button class="formula-block-action" onclick="moveBlock(${index}, -1)" ${index === 0 ? 'disabled' : ''}>
                            <i class="ph ph-arrow-up"></i>
                        </button>
                        <button class="formula-block-action" onclick="moveBlock(${index}, 1)" ${index === state.formulaEditor.visualBlocks.length - 1 ? 'disabled' : ''}>
                            <i class="ph ph-arrow-down"></i>
                        </button>
                        <button class="formula-block-action delete" onclick="removeBlock(${index})">
                            <i class="ph ph-trash"></i>
                        </button>
                    </div>
                </div>
            `).join('');
        }

        function renderBlockContent(block, index) {
            const set = getCurrentSet();

            switch (block.type) {
                case 'field':
                    return `
                        <select onchange="updateBlock(${index}, 'field', this.value)">
                            <option value="">Select field...</option>
                            ${set.schema.map(f => `
                                <option value="${f.id}" ${block.field === f.id ? 'selected' : ''}>${f.name}</option>
                            `).join('')}
                        </select>
                    `;
                case 'function':
                    const functions = Object.values(getFormulaSpec().functions || {}).flat();
                    return `
                        <select onchange="updateBlock(${index}, 'function', this.value)">
                            <option value="">Select function...</option>
                            ${functions.map(fn => `
                                <option value="${fn.name}" ${block.function === fn.name ? 'selected' : ''}>${fn.name}</option>
                            `).join('')}
                        </select>
                        <input 
                            type="text" 
                            placeholder="Arguments" 
                            value="${block.args || ''}"
                            onchange="updateBlock(${index}, 'args', this.value)"
                        >
                    `;
                case 'operator':
                    return `
                        <select onchange="updateBlock(${index}, 'operator', this.value)">
                            <option value="">Select operator...</option>
                            <option value="+" ${block.operator === '+' ? 'selected' : ''}>+ (Add)</option>
                            <option value="-" ${block.operator === '-' ? 'selected' : ''}>- (Subtract)</option>
                            <option value="*" ${block.operator === '*' ? 'selected' : ''}>* (Multiply)</option>
                            <option value="/" ${block.operator === '/' ? 'selected' : ''}>/ (Divide)</option>
                            <option value="&" ${block.operator === '&' ? 'selected' : ''}>& (Concatenate)</option>
                            <option value=">" ${block.operator === '>' ? 'selected' : ''}>> (Greater than)</option>
                            <option value="<" ${block.operator === '<' ? 'selected' : ''}>< (Less than)</option>
                            <option value="=" ${block.operator === '=' ? 'selected' : ''}>= (Equal)</option>
                        </select>
                    `;
                case 'value':
                    return `
                        <input 
                            type="text" 
                            placeholder="Enter value" 
                            value="${block.value || ''}"
                            onchange="updateBlock(${index}, 'value', this.value)"
                        >
                    `;
                default:
                    return '';
            }
        }

        function addFormulaBlock() {
            if (!state.formulaEditor.visualBlocks) {
                state.formulaEditor.visualBlocks = [];
            }

            state.formulaEditor.visualBlocks.push({ type: 'field', field: '' });
            renderFormulaEditor();
        }

        function updateBlock(index, property, value) {
            if (!state.formulaEditor.visualBlocks[index]) return;
            state.formulaEditor.visualBlocks[index][property] = value;
            renderFormulaEditor();
        }

        function removeBlock(index) {
            state.formulaEditor.visualBlocks.splice(index, 1);
            renderFormulaEditor();
        }

        function moveBlock(index, direction) {
            const newIndex = index + direction;
            if (newIndex < 0 || newIndex >= state.formulaEditor.visualBlocks.length) return;

            const blocks = state.formulaEditor.visualBlocks;
            [blocks[index], blocks[newIndex]] = [blocks[newIndex], blocks[index]];
            renderFormulaEditor();
        }

        function generateFormulaFromBlocks() {
            if (!state.formulaEditor.visualBlocks || state.formulaEditor.visualBlocks.length === 0) {
                return 'No formula yet';
            }

            const currentSet = getCurrentSet();
            const parts = state.formulaEditor.visualBlocks.map(block => {
                switch (block.type) {
                    case 'field':
                        const field = currentSet?.schema?.find(f => f.id === block.field);
                        return field ? `{${field.name}}` : '[field]';
                    case 'function':
                        return `${block.function}(${block.args || ''})`;
                    case 'operator':
                        return block.operator || '[op]';
                    case 'value':
                        return typeof block.value === 'string' ? `"${block.value}"` : block.value;
                    default:
                        return '';
                }
            });

            return parts.join(' ');
        }

        function switchFormulaMode(mode) {
            if (mode === 'visual' && state.formulaEditor.mode === 'code') {
                state.formulaEditor.visualBlocks = [];
            } else if (mode === 'code' && state.formulaEditor.mode === 'visual') {
                state.formulaEditor.currentFormula = generateFormulaFromBlocks();
            }

            state.formulaEditor.mode = mode;
            renderFormulaEditor();
        }

        function saveFormula() {
            const formula = state.formulaEditor.mode === 'visual'
                ? generateFormulaFromBlocks()
                : state.formulaEditor.currentFormula;

            validateFormula(formula);

            if (!state.formulaEditor.validation.isValid) {
                showToast(' Please fix errors before saving');
                return;
            }

            if (typeof state.formulaEditor.onSave === 'function') {
                state.formulaEditor.onSave(formula, state.formulaEditor.visualBlocks);
                closeFormulaEditor();
                return;
            }

            const set = getCurrentSet();
            const fieldId = state.formulaEditor.fieldId;

            if (fieldId) {
                const field = set.schema.find(f => f.id === fieldId);
                if (field) {
                    field.config = field.config || {};
                    field.config.formula = formula;
                    field.config.visualBlocks = state.formulaEditor.visualBlocks;
                    recalculateFormulaField(fieldId);
                }
            }

            closeFormulaEditor();
            renderCurrentView();
            showToast(' Formula saved');
        }

        function recalculateFormulaField(fieldId) {
            const set = getCurrentSet();
            const field = set?.schema?.find(f => f.id === fieldId);

            if (!set || !field || field.type !== 'FORMULA') return;
            if (!state.formulaFieldService || !field.config?.formula) return;

            set.records.forEach(record => {
                const evaluation = state.formulaFieldService.evaluateForRecord(
                    field.config.formula,
                    record,
                    set.schema
                );

                record.__formulaMeta = record.__formulaMeta || {};
                record.__formulaMeta[field.id] = evaluation;
                record[field.id] = evaluation.success ? evaluation.result : '#ERROR';
            });
        }

        function closeFormulaEditor() {
            document.getElementById('formulaEditorModal')?.remove();
            state.formulaEditor.isOpen = false;
        }

        function showFormulaExamples() {
            showToast('Coming soon: curated formula examples');
        }

        function launchFormulaEditorFromConfig(targetId = 'formulaExpression') {
            const textarea = document.getElementById(targetId);
            const existingFormula = textarea?.value || '';

            openFormulaEditor(null, (formula, blocks = []) => {
                if (textarea) {
                    textarea.value = formula;
                    textarea.dataset.visualBlocks = JSON.stringify(blocks || []);
                }
            });

            state.formulaEditor.currentFormula = existingFormula;
        }

        const FIELD_TYPES = {
            TEXT: { id: 'TEXT', name: 'Single Line Text', description: 'Quick text field for titles and short labels', defaultValue: '', icon: 'ph-text-t' },
            LONG_TEXT: { id: 'LONG_TEXT', name: 'Long Text', description: 'Multi-line notes, descriptions, or comments', defaultValue: '', icon: 'ph-article' },
            NUMBER: { id: 'NUMBER', name: 'Number', description: 'Store numeric values with sorting and calculations', defaultValue: 0, icon: 'ph-hash' },
            CURRENCY: { id: 'CURRENCY', name: 'Currency', description: 'Track prices, budgets, and financial amounts', defaultValue: 0, icon: 'ph-currency-dollar' },
            DATE: { id: 'DATE', name: 'Date', description: 'Capture due dates, milestones, and schedules', defaultValue: '', icon: 'ph-calendar-blank' },
            EMAIL: { id: 'EMAIL', name: 'Email', description: 'Contact email addresses with validation', defaultValue: '', icon: 'ph-envelope-simple' },
            URL: { id: 'URL', name: 'URL', description: 'Links to webpages, docs, or media', defaultValue: '', icon: 'ph-link-simple' },
            PHONE: { id: 'PHONE', name: 'Phone', description: 'International phone numbers for contacts', defaultValue: '', icon: 'ph-phone' },
            LINK_RECORD: { id: 'LINK_RECORD', name: 'Link to Record', description: 'Connect records across sets with relationships', defaultValue: '', icon: 'ph-link-simple-horizontal', needsConfig: true },
            SINGLE_SELECT: { id: 'SINGLE_SELECT', name: 'Single Select', description: 'Choose one option from a defined list', defaultValue: '', icon: 'ph-list-bullets', needsConfig: true },
            CHECKBOX: { id: 'CHECKBOX', name: 'Checkbox', description: 'Quick yes/no or done/undone tracking', defaultValue: false, icon: 'ph-check-square' },
            FORMULA: { id: 'FORMULA', name: 'Formula', description: 'Calculated values using the repo\'s JavaScript formula rules', defaultValue: '', icon: 'ph-equals', needsConfig: true }
        };

        const VIEW_TYPE_ICONS = { grid: 'ph-table', card: 'ph-cards-three', kanban: 'ph-kanban', graph: 'ph-graph', KEY_DERIVED: 'ph-key' };

        const ICON_OPTIONS = [
            // Organization & Layout
            { token: 'ph-squares-four', label: 'Grid', keywords: ['dashboard', 'board', 'overview', 'layout'] },
            { token: 'ph-table', label: 'Table', keywords: ['grid', 'sheet', 'records', 'spreadsheet'] },
            { token: 'ph-cards-three', label: 'Cards', keywords: ['gallery', 'kanban', 'tiles', 'card'] },
            { token: 'ph-kanban', label: 'Kanban', keywords: ['workflow', 'board', 'columns', 'agile'] },
            { token: 'ph-list', label: 'List', keywords: ['items', 'menu', 'rows'] },
            { token: 'ph-list-bullets', label: 'List Bullets', keywords: ['todo', 'tasks', 'rows', 'items'] },
            { token: 'ph-list-checks', label: 'List Checks', keywords: ['todo', 'tasks', 'checklist', 'complete'] },
            { token: 'ph-list-dashes', label: 'List Dashes', keywords: ['items', 'menu', 'rows'] },
            { token: 'ph-list-numbers', label: 'List Numbers', keywords: ['ordered', 'sequence', 'steps'] },
            { token: 'ph-rows', label: 'Rows', keywords: ['layout', 'horizontal', 'lines'] },
            { token: 'ph-columns', label: 'Columns', keywords: ['layout', 'vertical', 'split'] },
            { token: 'ph-sidebar', label: 'Sidebar', keywords: ['navigation', 'menu', 'panel'] },
            { token: 'ph-sidebar-simple', label: 'Sidebar Simple', keywords: ['navigation', 'menu', 'panel'] },
            { token: 'ph-layout', label: 'Layout', keywords: ['design', 'structure', 'template'] },
            { token: 'ph-app-window', label: 'App Window', keywords: ['browser', 'application', 'screen'] },

            // Files & Folders
            { token: 'ph-folder', label: 'Folder', keywords: ['directory', 'files', 'organize'] },
            { token: 'ph-folders', label: 'Folders', keywords: ['files', 'library', 'taxonomy', 'organize'] },
            { token: 'ph-folder-open', label: 'Folder Open', keywords: ['directory', 'files', 'browse'] },
            { token: 'ph-folder-plus', label: 'Folder Plus', keywords: ['create', 'new', 'add'] },
            { token: 'ph-file', label: 'File', keywords: ['document', 'page', 'content'] },
            { token: 'ph-file-text', label: 'File Text', keywords: ['document', 'page', 'text'] },
            { token: 'ph-file-plus', label: 'File Plus', keywords: ['create', 'new', 'add'] },
            { token: 'ph-files', label: 'Files', keywords: ['documents', 'pages', 'multiple'] },
            { token: 'ph-note', label: 'Note', keywords: ['memo', 'text', 'write'] },
            { token: 'ph-note-blank', label: 'Note Blank', keywords: ['new', 'empty', 'create'] },
            { token: 'ph-notebook', label: 'Notebook', keywords: ['notes', 'doc', 'wiki', 'journal'] },
            { token: 'ph-notepad', label: 'Notepad', keywords: ['notes', 'memo', 'write'] },
            { token: 'ph-article', label: 'Article', keywords: ['blog', 'post', 'content'] },
            { token: 'ph-newspaper', label: 'Newspaper', keywords: ['news', 'article', 'media'] },
            { token: 'ph-book', label: 'Book', keywords: ['library', 'reading', 'documentation'] },
            { token: 'ph-book-open', label: 'Book Open', keywords: ['reading', 'documentation', 'learn'] },
            { token: 'ph-books', label: 'Books', keywords: ['library', 'reading', 'education'] },

            // Documents & Text
            { token: 'ph-clipboard', label: 'Clipboard', keywords: ['copy', 'paste', 'temp'] },
            { token: 'ph-clipboard-text', label: 'Clipboard Text', keywords: ['notes', 'summary', 'doc', 'copy'] },
            { token: 'ph-article-medium', label: 'Article Medium', keywords: ['blog', 'post', 'medium'] },
            { token: 'ph-textbox', label: 'Textbox', keywords: ['input', 'field', 'form'] },
            { token: 'ph-text-aa', label: 'Text AA', keywords: ['font', 'typography', 'letters'] },
            { token: 'ph-text-t', label: 'Text T', keywords: ['font', 'type', 'letter'] },
            { token: 'ph-quotes', label: 'Quotes', keywords: ['citation', 'text', 'speech'] },
            { token: 'ph-signature', label: 'Signature', keywords: ['sign', 'approve', 'autograph'] },

            // Communication
            { token: 'ph-chat', label: 'Chat', keywords: ['message', 'conversation', 'talk'] },
            { token: 'ph-chat-circle', label: 'Chat Circle', keywords: ['message', 'bubble', 'talk'] },
            { token: 'ph-chat-dots', label: 'Chat Dots', keywords: ['message', 'typing', 'conversation'] },
            { token: 'ph-chats', label: 'Chats', keywords: ['messages', 'conversations', 'multiple'] },
            { token: 'ph-envelope', label: 'Envelope', keywords: ['email', 'mail', 'message'] },
            { token: 'ph-envelope-open', label: 'Envelope Open', keywords: ['email', 'read', 'mail'] },
            { token: 'ph-envelope-simple', label: 'Envelope Simple', keywords: ['email', 'mail', 'send'] },
            { token: 'ph-paper-plane-tilt', label: 'Paper Plane', keywords: ['send', 'message', 'mail'] },
            { token: 'ph-phone', label: 'Phone', keywords: ['contact', 'call', 'support', 'telephone'] },
            { token: 'ph-phone-call', label: 'Phone Call', keywords: ['calling', 'telephone', 'contact'] },
            { token: 'ph-megaphone', label: 'Megaphone', keywords: ['announcement', 'broadcast', 'marketing'] },
            { token: 'ph-speaker-high', label: 'Speaker High', keywords: ['volume', 'sound', 'audio'] },
            { token: 'ph-bell', label: 'Bell', keywords: ['alerts', 'reminders', 'updates', 'notifications'] },
            { token: 'ph-bell-ringing', label: 'Bell Ringing', keywords: ['alert', 'notification', 'alarm'] },

            // Users & People
            { token: 'ph-user', label: 'User', keywords: ['person', 'profile', 'account'] },
            { token: 'ph-user-circle', label: 'User Circle', keywords: ['profile', 'account', 'avatar'] },
            { token: 'ph-user-plus', label: 'User Plus', keywords: ['add', 'invite', 'new'] },
            { token: 'ph-users', label: 'Users', keywords: ['people', 'group', 'team'] },
            { token: 'ph-users-three', label: 'Users Three', keywords: ['people', 'collaboration', 'group', 'team'] },
            { token: 'ph-user-gear', label: 'User Gear', keywords: ['settings', 'profile', 'account'] },
            { token: 'ph-identification-card', label: 'ID Card', keywords: ['profile', 'identity', 'badge'] },
            { token: 'ph-address-book', label: 'Address Book', keywords: ['contacts', 'people', 'directory'] },

            // Time & Calendar
            { token: 'ph-calendar', label: 'Calendar', keywords: ['dates', 'schedule', 'events', 'day'] },
            { token: 'ph-calendar-blank', label: 'Calendar Blank', keywords: ['dates', 'schedule', 'events', 'empty'] },
            { token: 'ph-calendar-check', label: 'Calendar Check', keywords: ['event', 'confirmed', 'scheduled'] },
            { token: 'ph-calendar-plus', label: 'Calendar Plus', keywords: ['add', 'event', 'new'] },
            { token: 'ph-calendar-x', label: 'Calendar X', keywords: ['cancel', 'delete', 'remove'] },
            { token: 'ph-clock', label: 'Clock', keywords: ['time', 'schedule', 'hour'] },
            { token: 'ph-clock-countdown', label: 'Clock Countdown', keywords: ['timer', 'countdown', 'deadline'] },
            { token: 'ph-timer', label: 'Timer', keywords: ['stopwatch', 'time', 'clock'] },
            { token: 'ph-hourglass', label: 'Hourglass', keywords: ['time', 'waiting', 'pending'] },
            { token: 'ph-alarm', label: 'Alarm', keywords: ['clock', 'reminder', 'alert'] },

            // Actions & Controls
            { token: 'ph-plus', label: 'Plus', keywords: ['add', 'create', 'new'] },
            { token: 'ph-plus-circle', label: 'Plus Circle', keywords: ['add', 'create', 'new'] },
            { token: 'ph-minus', label: 'Minus', keywords: ['remove', 'subtract', 'delete'] },
            { token: 'ph-minus-circle', label: 'Minus Circle', keywords: ['remove', 'delete', 'subtract'] },
            { token: 'ph-x', label: 'X', keywords: ['close', 'cancel', 'delete'] },
            { token: 'ph-x-circle', label: 'X Circle', keywords: ['close', 'cancel', 'remove'] },
            { token: 'ph-check', label: 'Check', keywords: ['done', 'complete', 'confirm'] },
            { token: 'ph-check-circle', label: 'Check Circle', keywords: ['done', 'complete', 'success'] },
            { token: 'ph-trash', label: 'Trash', keywords: ['delete', 'remove', 'bin'] },
            { token: 'ph-pencil', label: 'Pencil', keywords: ['edit', 'write', 'modify'] },
            { token: 'ph-pencil-simple', label: 'Pencil Simple', keywords: ['edit', 'write', 'modify'] },
            { token: 'ph-pen', label: 'Pen', keywords: ['write', 'edit', 'signature'] },
            { token: 'ph-eraser', label: 'Eraser', keywords: ['delete', 'remove', 'clear'] },
            { token: 'ph-copy', label: 'Copy', keywords: ['duplicate', 'clone', 'paste'] },
            { token: 'ph-scissors', label: 'Scissors', keywords: ['cut', 'trim', 'clip'] },
            { token: 'ph-floppy-disk', label: 'Floppy Disk', keywords: ['save', 'store', 'disk'] },
            { token: 'ph-download', label: 'Download', keywords: ['save', 'export', 'get'] },
            { token: 'ph-upload', label: 'Upload', keywords: ['import', 'add', 'send'] },
            { token: 'ph-export', label: 'Export', keywords: ['download', 'save', 'output'] },
            { token: 'ph-share', label: 'Share', keywords: ['send', 'distribute', 'forward'] },
            { token: 'ph-share-network', label: 'Share Network', keywords: ['social', 'distribute', 'connect'] },

            // Navigation
            { token: 'ph-arrow-left', label: 'Arrow Left', keywords: ['back', 'previous', 'return'] },
            { token: 'ph-arrow-right', label: 'Arrow Right', keywords: ['forward', 'next', 'continue'] },
            { token: 'ph-arrow-up', label: 'Arrow Up', keywords: ['top', 'scroll', 'increase'] },
            { token: 'ph-arrow-down', label: 'Arrow Down', keywords: ['bottom', 'scroll', 'decrease'] },
            { token: 'ph-caret-left', label: 'Caret Left', keywords: ['previous', 'back', 'nav'] },
            { token: 'ph-caret-right', label: 'Caret Right', keywords: ['next', 'forward', 'nav'] },
            { token: 'ph-caret-up', label: 'Caret Up', keywords: ['expand', 'show', 'nav'] },
            { token: 'ph-caret-down', label: 'Caret Down', keywords: ['dropdown', 'expand', 'nav'] },
            { token: 'ph-house', label: 'House', keywords: ['home', 'main', 'start'] },
            { token: 'ph-house-line', label: 'House Line', keywords: ['overview', 'landing', 'summary', 'home'] },
            { token: 'ph-compass', label: 'Compass', keywords: ['navigation', 'explore', 'direction'] },
            { token: 'ph-map-pin', label: 'Map Pin', keywords: ['location', 'marker', 'place'] },
            { token: 'ph-map-trifold', label: 'Map Trifold', keywords: ['location', 'routes', 'navigation', 'geography'] },
            { token: 'ph-navigation-arrow', label: 'Navigation Arrow', keywords: ['direction', 'gps', 'location'] },

            // Search & View
            { token: 'ph-magnifying-glass', label: 'Search', keywords: ['find', 'search', 'look'] },
            { token: 'ph-magnifying-glass-plus', label: 'Zoom In', keywords: ['enlarge', 'magnify', 'expand'] },
            { token: 'ph-magnifying-glass-minus', label: 'Zoom Out', keywords: ['reduce', 'shrink', 'minimize'] },
            { token: 'ph-eye', label: 'Eye', keywords: ['view', 'see', 'preview'] },
            { token: 'ph-eye-closed', label: 'Eye Closed', keywords: ['hide', 'hidden', 'invisible'] },
            { token: 'ph-eye-slash', label: 'Eye Slash', keywords: ['hide', 'hidden', 'invisible'] },
            { token: 'ph-binoculars', label: 'Binoculars', keywords: ['search', 'find', 'explore'] },
            { token: 'ph-funnel', label: 'Funnel', keywords: ['filter', 'sort', 'refine'] },
            { token: 'ph-funnel-simple', label: 'Funnel Simple', keywords: ['filter', 'sort', 'refine'] },
            { token: 'ph-sliders', label: 'Sliders', keywords: ['settings', 'adjust', 'control'] },
            { token: 'ph-sliders-horizontal', label: 'Sliders Horizontal', keywords: ['settings', 'adjust', 'filter'] },
            { token: 'ph-adjustments', label: 'Adjustments', keywords: ['settings', 'controls', 'tune'] },

            // Business & Work
            { token: 'ph-briefcase', label: 'Briefcase', keywords: ['portfolio', 'business', 'clients', 'work'] },
            { token: 'ph-suitcase', label: 'Suitcase', keywords: ['travel', 'business', 'luggage'] },
            { token: 'ph-bank', label: 'Bank', keywords: ['finance', 'money', 'institution'] },
            { token: 'ph-buildings', label: 'Buildings', keywords: ['city', 'office', 'company'] },
            { token: 'ph-storefront', label: 'Storefront', keywords: ['shop', 'store', 'retail'] },
            { token: 'ph-shopping-bag', label: 'Shopping Bag', keywords: ['purchase', 'buy', 'retail'] },
            { token: 'ph-shopping-cart', label: 'Shopping Cart', keywords: ['sales', 'store', 'orders', 'ecommerce'] },
            { token: 'ph-shopping-cart-simple', label: 'Cart Simple', keywords: ['purchase', 'buy', 'shop'] },
            { token: 'ph-currency-dollar', label: 'Dollar', keywords: ['money', 'price', 'payment'] },
            { token: 'ph-money', label: 'Money', keywords: ['cash', 'payment', 'finance'] },
            { token: 'ph-credit-card', label: 'Credit Card', keywords: ['payment', 'transaction', 'purchase'] },
            { token: 'ph-coin', label: 'Coin', keywords: ['money', 'currency', 'payment'] },
            { token: 'ph-receipt', label: 'Receipt', keywords: ['invoice', 'payment', 'transaction'] },
            { token: 'ph-invoice', label: 'Invoice', keywords: ['bill', 'payment', 'receipt'] },
            { token: 'ph-wallet', label: 'Wallet', keywords: ['money', 'payment', 'finance'] },

            // Analytics & Data
            { token: 'ph-chart-line', label: 'Chart Line', keywords: ['metrics', 'reporting', 'dash', 'analytics', 'graph'] },
            { token: 'ph-chart-bar', label: 'Chart Bar', keywords: ['graph', 'statistics', 'data'] },
            { token: 'ph-chart-bar-horizontal', label: 'Chart Bar Horizontal', keywords: ['graph', 'statistics', 'data'] },
            { token: 'ph-chart-pie', label: 'Chart Pie', keywords: ['graph', 'statistics', 'distribution'] },
            { token: 'ph-chart-pie-slice', label: 'Chart Pie Slice', keywords: ['graph', 'statistics', 'portion'] },
            { token: 'ph-chart-line-up', label: 'Chart Line Up', keywords: ['growth', 'increase', 'trending'] },
            { token: 'ph-chart-line-down', label: 'Chart Line Down', keywords: ['decrease', 'decline', 'trending'] },
            { token: 'ph-trend-up', label: 'Trend Up', keywords: ['growth', 'increase', 'positive'] },
            { token: 'ph-trend-down', label: 'Trend Down', keywords: ['decrease', 'decline', 'negative'] },
            { token: 'ph-presentation', label: 'Presentation', keywords: ['slides', 'meeting', 'report'] },
            { token: 'ph-presentation-chart', label: 'Presentation Chart', keywords: ['slides', 'analytics', 'report'] },

            // Tech & Development
            { token: 'ph-code', label: 'Code', keywords: ['development', 'programming', 'developer'] },
            { token: 'ph-terminal', label: 'Terminal', keywords: ['console', 'command', 'cli'] },
            { token: 'ph-terminal-window', label: 'Terminal Window', keywords: ['console', 'command', 'shell'] },
            { token: 'ph-brackets-curly', label: 'Brackets Curly', keywords: ['code', 'json', 'programming'] },
            { token: 'ph-bug', label: 'Bug', keywords: ['error', 'issue', 'debug'] },
            { token: 'ph-cpu', label: 'CPU', keywords: ['processor', 'hardware', 'computing'] },
            { token: 'ph-hard-drive', label: 'Hard Drive', keywords: ['storage', 'disk', 'data'] },
            { token: 'ph-database', label: 'Database', keywords: ['storage', 'records', 'warehouse', 'data'] },
            { token: 'ph-server', label: 'Server', keywords: ['database', 'hosting', 'backend'] },
            { token: 'ph-cloud', label: 'Cloud', keywords: ['sync', 'storage', 'backup', 'online'] },
            { token: 'ph-cloud-arrow-up', label: 'Cloud Upload', keywords: ['sync', 'upload', 'backup'] },
            { token: 'ph-cloud-arrow-down', label: 'Cloud Download', keywords: ['sync', 'download', 'retrieve'] },
            { token: 'ph-git-branch', label: 'Git Branch', keywords: ['version', 'control', 'code'] },
            { token: 'ph-git-commit', label: 'Git Commit', keywords: ['version', 'control', 'save'] },
            { token: 'ph-git-merge', label: 'Git Merge', keywords: ['version', 'control', 'combine'] },
            { token: 'ph-github-logo', label: 'GitHub', keywords: ['code', 'repository', 'git'] },

            // Security
            { token: 'ph-lock', label: 'Lock', keywords: ['security', 'private', 'secure'] },
            { token: 'ph-lock-key', label: 'Lock Key', keywords: ['permissions', 'security', 'access', 'roles'] },
            { token: 'ph-lock-open', label: 'Lock Open', keywords: ['unlock', 'access', 'open'] },
            { token: 'ph-key', label: 'Key', keywords: ['password', 'access', 'security'] },
            { token: 'ph-shield', label: 'Shield', keywords: ['security', 'protection', 'safety'] },
            { token: 'ph-shield-check', label: 'Shield Check', keywords: ['security', 'verified', 'protected'] },
            { token: 'ph-fingerprint', label: 'Fingerprint', keywords: ['biometric', 'security', 'identity'] },
            { token: 'ph-password', label: 'Password', keywords: ['security', 'login', 'access'] },

            // Media & Design
            { token: 'ph-image', label: 'Image', keywords: ['photo', 'picture', 'media'] },
            { token: 'ph-images', label: 'Images', keywords: ['photos', 'gallery', 'media'] },
            { token: 'ph-camera', label: 'Camera', keywords: ['photo', 'picture', 'capture'] },
            { token: 'ph-video-camera', label: 'Video Camera', keywords: ['recording', 'film', 'media'] },
            { token: 'ph-play', label: 'Play', keywords: ['video', 'start', 'media'] },
            { token: 'ph-pause', label: 'Pause', keywords: ['stop', 'media', 'video'] },
            { token: 'ph-film-strip', label: 'Film Strip', keywords: ['video', 'movie', 'cinema'] },
            { token: 'ph-music-notes', label: 'Music Notes', keywords: ['audio', 'sound', 'song'] },
            { token: 'ph-palette', label: 'Palette', keywords: ['color', 'design', 'art'] },
            { token: 'ph-paint-brush', label: 'Paint Brush', keywords: ['design', 'art', 'draw'] },
            { token: 'ph-paint-roller', label: 'Paint Roller', keywords: ['design', 'theme', 'style'] },
            { token: 'ph-eyedropper', label: 'Eyedropper', keywords: ['color', 'picker', 'design'] },

            // Symbols & Shapes
            { token: 'ph-star', label: 'Star', keywords: ['favorite', 'rating', 'important'] },
            { token: 'ph-heart', label: 'Heart', keywords: ['like', 'favorite', 'love'] },
            { token: 'ph-flag', label: 'Flag', keywords: ['marker', 'important', 'report'] },
            { token: 'ph-bookmark', label: 'Bookmark', keywords: ['save', 'favorite', 'mark'] },
            { token: 'ph-bookmark-simple', label: 'Bookmark Simple', keywords: ['save', 'favorite', 'mark'] },
            { token: 'ph-tag', label: 'Tag', keywords: ['labels', 'categories', 'taxonomy', 'label'] },
            { token: 'ph-hash', label: 'Hash', keywords: ['hashtag', 'number', 'tag'] },
            { token: 'ph-at', label: 'At', keywords: ['mention', 'email', 'address'] },
            { token: 'ph-info', label: 'Info', keywords: ['information', 'help', 'about'] },
            { token: 'ph-question', label: 'Question', keywords: ['help', 'faq', 'support'] },
            { token: 'ph-warning', label: 'Warning', keywords: ['alert', 'caution', 'danger'] },
            { token: 'ph-warning-circle', label: 'Warning Circle', keywords: ['alert', 'caution', 'error'] },
            { token: 'ph-prohibit', label: 'Prohibit', keywords: ['blocked', 'forbidden', 'no'] },
            { token: 'ph-circle', label: 'Circle', keywords: ['shape', 'dot', 'round'] },
            { token: 'ph-square', label: 'Square', keywords: ['shape', 'box', 'rectangle'] },
            { token: 'ph-triangle', label: 'Triangle', keywords: ['shape', 'arrow', 'pointer'] },
            { token: 'ph-diamond', label: 'Diamond', keywords: ['shape', 'gem', 'special'] },

            // Actions & Ideas
            { token: 'ph-rocket', label: 'Rocket', keywords: ['project', 'ship', 'release', 'launch'] },
            { token: 'ph-rocket-launch', label: 'Rocket Launch', keywords: ['start', 'deploy', 'begin'] },
            { token: 'ph-lightbulb', label: 'Lightbulb', keywords: ['brainstorm', 'concepts', 'innovation', 'ideas'] },
            { token: 'ph-target', label: 'Target', keywords: ['goal', 'objective', 'aim'] },
            { token: 'ph-trophy', label: 'Trophy', keywords: ['achievement', 'success', 'award'] },
            { token: 'ph-medal', label: 'Medal', keywords: ['award', 'achievement', 'winner'] },
            { token: 'ph-gift', label: 'Gift', keywords: ['present', 'reward', 'bonus'] },
            { token: 'ph-crown', label: 'Crown', keywords: ['premium', 'vip', 'royal'] },
            { token: 'ph-magic-wand', label: 'Magic Wand', keywords: ['auto', 'ai', 'magic'] },
            { token: 'ph-sparkle', label: 'Sparkle', keywords: ['new', 'special', 'shine'] },
            { token: 'ph-lightning', label: 'Lightning', keywords: ['fast', 'quick', 'speed'] },
            { token: 'ph-fire', label: 'Fire', keywords: ['hot', 'trending', 'popular'] },

            // Connectivity & Links
            { token: 'ph-link', label: 'Link', keywords: ['url', 'connection', 'attach'] },
            { token: 'ph-link-simple', label: 'Link Simple', keywords: ['connection', 'attach', 'url', 'hyperlink'] },
            { token: 'ph-link-break', label: 'Link Break', keywords: ['unlink', 'disconnect', 'remove'] },
            { token: 'ph-paperclip', label: 'Paperclip', keywords: ['attach', 'file', 'attachment'] },
            { token: 'ph-anchor', label: 'Anchor', keywords: ['link', 'fixed', 'permanent'] },
            { token: 'ph-wireless', label: 'Wireless', keywords: ['wifi', 'connection', 'network'] },
            { token: 'ph-wifi-high', label: 'WiFi High', keywords: ['wireless', 'connection', 'network'] },
            { token: 'ph-globe', label: 'Globe', keywords: ['world', 'internet', 'global'] },
            { token: 'ph-globe-hemisphere-west', label: 'Globe West', keywords: ['world', 'map', 'earth'] },

            // Settings & Configuration
            { token: 'ph-gear', label: 'Gear', keywords: ['settings', 'configuration', 'options'] },
            { token: 'ph-gear-six', label: 'Gear Six', keywords: ['settings', 'config', 'preferences'] },
            { token: 'ph-wrench', label: 'Wrench', keywords: ['tools', 'fix', 'maintenance'] },
            { token: 'ph-nut', label: 'Nut', keywords: ['settings', 'configuration', 'hardware'] },
            { token: 'ph-faders', label: 'Faders', keywords: ['settings', 'adjust', 'mixer'] },
            { token: 'ph-toggle-left', label: 'Toggle Left', keywords: ['switch', 'off', 'disable'] },
            { token: 'ph-toggle-right', label: 'Toggle Right', keywords: ['switch', 'on', 'enable'] },

            // Miscellaneous
            { token: 'ph-smiley', label: 'Smiley', keywords: ['emoji', 'happy', 'face'] },
            { token: 'ph-package', label: 'Package', keywords: ['box', 'delivery', 'product'] },
            { token: 'ph-cube', label: 'Cube', keywords: ['3d', 'box', 'object'] },
            { token: 'ph-puzzle-piece', label: 'Puzzle Piece', keywords: ['plugin', 'extension', 'addon'] },
            { token: 'ph-tree', label: 'Tree', keywords: ['nature', 'hierarchy', 'branch'] },
            { token: 'ph-plant', label: 'Plant', keywords: ['nature', 'growing', 'organic'] }
        ];

        const ICONS_PER_PAGE = 60;

        function renderIcon(icon) {
            if (!icon) return '';
            const trimmed = icon.toString().trim();
            if (trimmed.startsWith('<')) return trimmed;
            if (trimmed.startsWith('ph ')) return `<i class="${trimmed}"></i>`;
            if (trimmed.startsWith('ph-')) return `<i class="ph ${trimmed}"></i>`;
            return trimmed;
        }

        function cloneConfig(config) {
            if (typeof structuredClone === 'function') return structuredClone(config || null);
            return JSON.parse(JSON.stringify(config || null));
        }

        function extractIconToken(icon) {
            if (!icon) return '';
            const trimmed = icon.toString().trim();
            const match = trimmed.match(/ph-[\w-]+/);
            if (match) return match[0];
            return trimmed;
        }

        function buildIconSearchText(option) {
            const keywords = (option.keywords || []).join(' ');
            return `${option.label} ${option.token} ${keywords}`.toLowerCase();
        }

        function fuzzyScore(query, text) {
            const normalizedQuery = (query || '').trim().toLowerCase();
            if (!normalizedQuery) return 1;
            const normalizedText = text.toLowerCase();
            const parts = normalizedQuery.split(/\s+/).filter(Boolean);

            let score = 0;
            parts.forEach(part => {
                if (normalizedText.includes(part)) {
                    score += 2;
                    return;
                }

                let lastIndex = -1;
                let subsequenceScore = 0;
                for (const char of part) {
                    const idx = normalizedText.indexOf(char, lastIndex + 1);
                    if (idx === -1) { subsequenceScore = 0; break; }
                    const distance = lastIndex === -1 ? 0 : idx - lastIndex - 1;
                    subsequenceScore += Math.max(0.1, 1 - distance * 0.08);
                    lastIndex = idx;
                }
                if (subsequenceScore > 0) {
                    const proximityBoost = Math.min(0.5, part.length / 12);
                    score += (subsequenceScore / part.length) + proximityBoost;
                }
            });

            return score / parts.length;
        }

        function findIconMeta(token) {
            const clean = extractIconToken(token);
            return ICON_OPTIONS.find(opt => opt.token === clean);
        }

        const ICON_SELECTOR_TARGETS = {
            newSetIcon: { selectorId: 'newSetIconSelector', previewId: 'newSetIconPreview', tokenId: 'newSetIconToken' },
            newViewIcon: { selectorId: 'newViewIconSelector', previewId: 'newViewIconPreview', tokenId: 'newViewIconToken' }
        };

        function syncIconSelector(inputId) {
            const config = ICON_SELECTOR_TARGETS[inputId];
            const input = document.getElementById(inputId);
            if (!config || !input) return;
            const token = extractIconToken(input.value || '');
            const meta = findIconMeta(token);
            const preview = document.getElementById(config.previewId);
            if (preview) preview.innerHTML = renderIcon(token || 'ph-squares-four');
            const tokenLabel = document.getElementById(config.tokenId);
            if (tokenLabel) tokenLabel.textContent = meta ? `${meta.label}  ${meta.token}` : (token || 'Select an icon');
        }

        function bindIconSelector(inputId) {
            const config = ICON_SELECTOR_TARGETS[inputId];
            if (!config) return;
            const selector = document.getElementById(config.selectorId);
            if (selector) {
                const trigger = () => openIconPicker(inputId);
                selector.onclick = trigger;
                selector.onkeydown = (event) => {
                    if (event.key === 'Enter' || event.key === ' ' || event.key === 'Spacebar') {
                        event.preventDefault();
                        trigger();
                    }
                };
            }
            const input = document.getElementById(inputId);
            if (input) input.addEventListener('change', () => syncIconSelector(inputId));
            syncIconSelector(inputId);
        }

        function openIconPicker(targetInputId) {
            state.iconPickerTarget = targetInputId;
            state.iconPickerQuery = '';
            state.iconPickerPage = 1;
            const searchInput = document.getElementById('iconPickerSearch');
            if (searchInput) {
                searchInput.value = '';
                setTimeout(() => searchInput.focus(), 50);
            }
            renderIconPickerOptions();
            openModal('iconPickerModal');
        }

        function renderIconPickerOptions() {
            const container = document.getElementById('iconPickerOptions');
            const pagination = document.getElementById('iconPickerPagination');
            if (!container) return;
            const search = (state.iconPickerQuery || '').toLowerCase();
            const currentValue = state.iconPickerTarget ? extractIconToken(document.getElementById(state.iconPickerTarget)?.value || '') : '';

            container.innerHTML = '';
            if (pagination) pagination.innerHTML = '';

            const scored = ICON_OPTIONS
                .map(opt => ({ ...opt, score: fuzzyScore(search, buildIconSearchText(opt)) }))
                .filter(entry => entry.score > 0)
                .sort((a, b) => b.score - a.score);

            if (scored.length === 0) {
                container.innerHTML = '<p class="text-sm text-gray-500">No icons match your search. Try a related term like table or board.</p>';
                return;
            }

            const totalPages = Math.max(1, Math.ceil(scored.length / ICONS_PER_PAGE));
            state.iconPickerPage = Math.min(Math.max(state.iconPickerPage, 1), totalPages);
            const startIndex = (state.iconPickerPage - 1) * ICONS_PER_PAGE;
            const pagedIcons = scored.slice(startIndex, startIndex + ICONS_PER_PAGE);

            if (pagination) {
                pagination.innerHTML = `
                    <span class="icon-pagination-count">${scored.length} icons</span>
                    <div class="icon-pagination-buttons">
                        <button type="button" class="icon-page-btn" data-direction="prev" ${state.iconPickerPage === 1 ? 'disabled' : ''}>Prev</button>
                        <span class="text-sm text-gray-600">Page ${state.iconPickerPage} / ${totalPages}</span>
                        <button type="button" class="icon-page-btn" data-direction="next" ${state.iconPickerPage === totalPages ? 'disabled' : ''}>Next</button>
                    </div>
                `;

                pagination.querySelectorAll('.icon-page-btn').forEach(btn => {
                    btn.onclick = () => {
                        const direction = btn.getAttribute('data-direction');
                        if (direction === 'prev' && state.iconPickerPage > 1) {
                            state.iconPickerPage -= 1;
                        } else if (direction === 'next' && state.iconPickerPage < totalPages) {
                            state.iconPickerPage += 1;
                        }
                        renderIconPickerOptions();
                    };
                });
            }

            pagedIcons.forEach(opt => {
                const btn = document.createElement('button');
                btn.type = 'button';
                btn.className = `icon-option${opt.token === currentValue ? ' active' : ''}`;
                btn.setAttribute('aria-label', opt.label);
                btn.innerHTML = `
                    <span class="icon-chip">${renderIcon(opt.token)}</span>
                    <span class="sr-only">${opt.label}</span>
                `;
                btn.onclick = () => selectIconFromPicker(opt.token);
                container.appendChild(btn);
            });
        }

        function selectIconFromPicker(token) {
            if (state.iconPickerTarget) {
                const input = document.getElementById(state.iconPickerTarget);
                if (input) {
                    input.value = token;
                    input.dispatchEvent(new Event('change'));
                }
            }
            closeModal('iconPickerModal');
        }

        const EO_OPERATOR_SET = {
            INS: { id: 'INS', name: 'Instantiate', description: 'Create a new object that did not exist before.' },
            DES: { id: 'DES', name: 'Designate', description: 'Assign a name, ID, label, alias, or classification.' },
            SEG: { id: 'SEG', name: 'Segment', description: 'Change boundaries, structure, or partition membership.' },
            CON: { id: 'CON', name: 'Connect', description: 'Create or remove a connection between objects.' },
            ALT: { id: 'ALT', name: 'Alternate', description: 'Toggle or switch between mutually exclusive states.' },
            SYN: { id: 'SYN', name: 'Synthesize', description: 'Combine two or more objects into a new unified whole.' },
            SUP: { id: 'SUP', name: 'Superposition', description: 'Hold contradictory states as simultaneously true without resolving them.' },
            REC: { id: 'REC', name: 'Recurse', description: 'Introduce a new layer of logic, rules, or self-reference.' },
            NUL: { id: 'NUL', name: 'Nullify', description: 'Declare absence, deletion, or erasure.' }
        };

        function getModesForOperator(operator) {
            return state.connectionModes?.[operator] || [];
        }

        function normalizeParamList(params = []) {
            if (params === undefined || params === null) return [];
            if (!Array.isArray(params)) throw new Error('Parameter lists must be arrays');

            return Array.from(
                new Set(
                    params
                        .map(param => typeof param === 'string' ? param.trim() : String(param || '').trim())
                        .filter(Boolean)
                )
            );
        }

        function validateConnectionFormatPayload(format) {
            const modes = getModesForOperator(format?.operator);
            if (!modes.length) throw new Error('Invalid operator');
            if (!modes.includes(format?.mode)) throw new Error('Invalid mode for operator');

            const requiredParams = normalizeParamList(format.requiredParams || []);
            const optionalParams = normalizeParamList(format.optionalParams || []);
            const worldId = format.worldId || state.currentWorldId;

            return {
                ...format,
                id: format.id || `CF_${format.operator}_${Date.now()}_${Math.random().toString(36).slice(2, 6)}`,
                operator: format.operator,
                mode: format.mode,
                description: format.description || '',
                requiredParams,
                optionalParams,
                createdAt: format.createdAt || new Date().toISOString(),
                worldId
            };
        }

        function addConnectionFormat(format) {
            let payload;
            try {
                payload = validateConnectionFormatPayload(format);
            } catch (error) {
                showToast(` ${error.message || 'Unable to create connection format'}`);
                return null;
            }

            state.connectionFormats.set(payload.id, payload);
            return payload.id;
        }

        function updateConnectionFormat(formatId, updates = {}) {
            const existing = state.connectionFormats.get(formatId);
            if (!existing) throw new Error(`Connection format ${formatId} not found`);

            const merged = validateConnectionFormatPayload({ ...existing, ...updates, id: formatId });
            state.connectionFormats.set(formatId, { ...existing, ...merged, updatedAt: new Date().toISOString() });
            return formatId;
        }

        function deleteConnectionFormat(formatId) {
            if (!state.connectionFormats.has(formatId)) throw new Error(`Connection format ${formatId} not found`);
            const inUse = Array.from(state.connections.values()).some(conn => conn.formatId === formatId);
            if (inUse) throw new Error('Cannot delete a format that is used by existing connections');
            state.connectionFormats.delete(formatId);
            return formatId;
        }

        function getConnectionFormatView(filterFn) {
            const formats = Array.from(state.connectionFormats.values()).filter(fmt => !fmt.worldId || fmt.worldId === state.currentWorldId);
            return typeof filterFn === 'function' ? formats.filter(filterFn) : formats;
        }

        function findConnectionFormat(formatId) {
            return state.connectionFormats.get(formatId) || null;
        }

        function getDefaultConnectionFormatId(preferredOperator = null) {
            const formats = getConnectionFormatView(fmt => !preferredOperator || fmt.operator === preferredOperator);
            return formats.length ? formats[0].id : null;
        }

        function suggestFormatsForView(view) {
            const suggestions = [];

            if (view?.filters?.length) {
                suggestions.push('SEG');
            }

            if (view?.aggregationRules?.length) {
                suggestions.push('SYN');
            }

            if (view?.pivotField) {
                suggestions.push('SUP');
            }

            return suggestions;
        }

        // DEFINITIONS & CONNECTIONS
        function deriveWorldIdForEntity(entity) {
            if (!entity) return state.currentWorldId;
            if (entity.type === 'Record') {
                const ref = getRecordById(entity.id);
                if (ref?.set?.worldId) return ref.set.worldId;
            }
            if (entity.type === 'Set') {
                const set = state.sets.get(entity.id);
                if (set?.worldId) return set.worldId;
            }
            if (entity.type === 'Connection') {
                const existing = state.connections.get(entity.id);
                if (existing?.worldId) return existing.worldId;
            }
            return state.currentWorldId;
        }

        function findDefinitionByEntity(entity, worldId = state.currentWorldId) {
            if (!entity) return null;
            return Array.from(state.definitions.values()).find(def =>
                def.entity?.type === entity.type &&
                def.entity?.id === entity.id &&
                (!worldId || !def.worldId || def.worldId === worldId)
            ) || null;
        }

        function renderEntityLabel(entity) {
            if (!entity) return '';
            const def = findDefinitionByEntity(entity);
            if (def?.term) return def.term;

            if (entity.type === 'Record') {
                return getRecordDisplayName(entity.id);
            }
            if (entity.type === 'Set') {
                return state.sets.get(entity.id)?.name || entity.id;
            }
            if (entity.type === 'Connection') {
                const conn = state.connections.get(entity.id);
                if (conn) return `${renderEntityLabel(conn.subject)} ${conn.mode || ''} ${renderEntityLabel(conn.operand)}`;
            }
            return entity.id;
        }

        function addDefinition(def) {
            if (!def?.entity || !def?.entity?.type || !def?.entity?.id) {
                throw new Error('Definitions require an entity with type and id');
            }
            if (!def.term || !def.definition) {
                throw new Error('Definitions require both term and definition text');
            }

            const id = def.id || `def_${Date.now()}_${Math.random().toString(36).substr(2, 6)}`;
            const worldId = def.worldId || deriveWorldIdForEntity(def.entity);
            const payload = {
                ...def,
                id,
                worldId,
                tags: def.tags || [],
                createdAt: def.createdAt || new Date().toISOString()
            };

            state.definitions.set(id, payload);
            return payload;
        }

        function updateDefinition(id, updates = {}) {
            const existing = state.definitions.get(id);
            if (!existing) throw new Error(`Definition ${id} not found`);

            const next = {
                ...existing,
                ...updates,
                id,
                updatedAt: new Date().toISOString()
            };

            state.definitions.set(id, next);
            return next;
        }

        function deleteDefinition(id) {
            const existing = state.definitions.get(id);
            if (!existing) throw new Error(`Definition ${id} not found`);
            state.definitions.delete(id);
            return existing;
        }

        function getDefinitionView(filterFn) {
            const defs = Array.from(state.definitions.values()).filter(def => !def.worldId || def.worldId === state.currentWorldId);
            return typeof filterFn === 'function' ? defs.filter(filterFn) : defs;
        }

        function getConnectionView(filterFn) {
            const conns = Array.from(state.connections.values()).filter(conn => !conn.worldId || conn.worldId === state.currentWorldId);
            return typeof filterFn === 'function' ? conns.filter(filterFn) : conns;
        }

        function seedWorldDefaults(worldId = state.currentWorldId) {
            const locationsId = createSet('Locations', 'ph-map-pin', worldId);
            const locationsSet = state.sets.get(locationsId);
            locationsSet.schema = [
                { id: 'name', name: 'Location', type: 'TEXT', width: '220px' },
                { id: 'area', name: 'Area', type: 'TEXT', width: '180px' },
                { id: 'notes', name: 'Notes', type: 'LONG_TEXT', width: '260px' }
            ];

            const observationsId = createSet('Observations', 'ph-binoculars', worldId);
            const observationsSet = state.sets.get(observationsId);
            observationsSet.schema = [
                { id: 'date', name: 'Date', type: 'DATE', width: '140px' },
                { id: 'observer', name: 'Observer', type: 'TEXT', width: '180px' },
                { id: 'observation', name: 'Observation', type: 'LONG_TEXT', width: '260px' }
            ];

            createView(locationsId, 'Locations', { type: 'grid', sorts: [{ fieldId: 'name', direction: 'asc' }] });
            createView(observationsId, 'Observations', { type: 'grid', sorts: [{ fieldId: 'date', direction: 'desc' }] });

            return { locationsId, observationsId };
        }

        // INITIALIZATION
        async function initializeApp() {
            state.operatorSet = EO_OPERATOR_SET;

            // Initialize lean context system
            if (typeof EOLeanContext !== 'undefined') {
                state.leanContext = new EOLeanContext();
                console.log(' Lean Context System initialized');
            }

            initializeOperatorRules();
            await loadConnectionModes();
            createSampleData();
            applyRouteParams();
            initializeFormulaSupport();
            renderSidebar();
            if (state.currentSpecialView) {
                renderCurrentView();
            } else if (state.currentSetId) {
                switchSet(state.currentSetId, state.currentViewId);
            } else {
                renderCurrentView();
            }
            setupEventListeners();
            setupKeyboardShortcuts();
            applyResponsiveLayout();
            window.addEventListener('resize', applyResponsiveLayout);
            syncUrlState();
        }

        function normalizeOperatorModeDictionary(data) {
            if (!data || typeof data !== 'object' || Array.isArray(data)) return {};

            const normalized = {};
            Object.entries(data).forEach(([op, modes]) => {
                if (!Array.isArray(modes)) return;
                const cleaned = modes.map(mode => typeof mode === 'string' ? mode.trim() : '').filter(Boolean);
                if (cleaned.length) normalized[op] = cleaned;
            });

            return normalized;
        }

        async function loadConnectionModes() {
            try {
                const response = await fetch('data/connection_modes.json');
                if (!response.ok) throw new Error('Unable to load operator dictionary');

                const rawModes = await response.json();
                state.connectionModes = normalizeOperatorModeDictionary(rawModes);
            } catch (error) {
                console.warn('Unable to load connection modes', error);
                state.connectionModes = {};
            }
        }

        function readRouteParams() {
            const params = new URLSearchParams(window.location.search);
            return {
                worldId: params.get('world'),
                setId: params.get('set'),
                viewId: params.get('view'),
                special: params.get('special')
            };
        }

        function applyRouteParams() {
            const route = readRouteParams();
            if (route.worldId && state.worlds.has(route.worldId)) {
                state.currentWorldId = route.worldId;
            }

            if (route.special) {
                state.currentSpecialView = route.special;
                state.currentSetId = null;
                state.currentViewId = null;
                return;
            }

            if (route.setId && state.sets.has(route.setId)) {
                state.currentSetId = route.setId;
                const set = state.sets.get(route.setId);
                if (route.viewId && set.views.has(route.viewId)) {
                    state.currentViewId = route.viewId;
                } else if (set.views.size > 0) {
                    state.currentViewId = Array.from(set.views.keys())[0];
                }
            }
        }

        function syncUrlState() {
            const params = new URLSearchParams();
            if (state.currentWorldId) params.set('world', state.currentWorldId);

            if (state.currentSpecialView) {
                params.set('special', state.currentSpecialView);
            } else {
                if (state.currentSetId) params.set('set', state.currentSetId);
                if (state.currentViewId) params.set('view', state.currentViewId);
            }

            const query = params.toString();
            const nextUrl = query ? `${window.location.pathname}?${query}` : window.location.pathname;
            window.history.replaceState({}, '', nextUrl);
        }

        function applyResponsiveLayout() {
            const appContainer = document.getElementById('appContainer');
            const isMobile = window.matchMedia('(max-width: 1024px)').matches;
            const bottomBar = document.getElementById('mobileBottomBar');
            const fab = document.getElementById('mobileFab');
            const topbar = document.getElementById('mobileTopbar');

            if (isMobile) {
                appContainer.classList.add('mobile-layout');
                appContainer.classList.toggle('sidebar-open-mobile', state.sidebarOpenMobile);
                appContainer.classList.remove('sidebar-collapsed');
                bottomBar?.classList.remove('hidden');
                fab?.classList.remove('hidden');
                topbar?.classList.remove('hidden');
            } else {
                appContainer.classList.remove('mobile-layout');
                appContainer.classList.remove('sidebar-open-mobile');
                appContainer.classList.toggle('sidebar-collapsed', state.sidebarCollapsed);
                bottomBar?.classList.add('hidden');
                fab?.classList.add('hidden');
                topbar?.classList.add('hidden');
            }

            updateMobileChrome();
        }

        function updateMobileChrome() {
            const titleEl = document.getElementById('mobileTopbarTitle');
            const set = getCurrentSet();
            const view = getCurrentView();
            const special = state.currentSpecialView === 'definitions'
                ? 'Definitions'
                : state.currentSpecialView === 'connections'
                    ? 'Connections'
                    : state.currentSpecialView === 'entities'
                        ? 'Entities'
                        : null;

            if (titleEl) titleEl.textContent = special || set?.name || 'EO';

            document.querySelectorAll('.mobile-bottom-action').forEach(btn => {
                const type = btn.dataset.mobileNav;
                if (!type) return;
                btn.classList.toggle('active', !special && view?.type === type);
            });
        }

        let toolbarMenuCleanup = null;
        function setupToolbarMenu() {
            if (typeof toolbarMenuCleanup === 'function') {
                toolbarMenuCleanup();
                toolbarMenuCleanup = null;
            }

            const menu = document.querySelector('.toolbar-menu');
            const toggle = document.getElementById('toolbarMenuToggle');
            const panel = document.getElementById('toolbarMenuPanel');
            if (!menu || !toggle || !panel) return;

            const closeMenu = () => menu.classList.remove('open');

            const toggleHandler = (event) => {
                event.stopPropagation();
                menu.classList.toggle('open');
            };

            const panelHandler = (event) => {
                event.stopPropagation();
                if (event.target.closest('button')) closeMenu();
            };

            const clickHandler = (event) => {
                if (!menu.contains(event.target)) closeMenu();
            };

            const keydownHandler = (event) => {
                if (event.key === 'Escape') closeMenu();
            };

            toggle.addEventListener('click', toggleHandler);
            panel.addEventListener('click', panelHandler);
            document.addEventListener('click', clickHandler);
            document.addEventListener('keydown', keydownHandler);

            toolbarMenuCleanup = () => {
                toggle.removeEventListener('click', toggleHandler);
                panel.removeEventListener('click', panelHandler);
                document.removeEventListener('click', clickHandler);
                document.removeEventListener('keydown', keydownHandler);
            };
        }

        function handleAddRecord() {
            const set = getCurrentSet();
            if (!set) return;

            const record = { id: `rec_${Date.now()}` };
            set.schema.forEach(f => record[f.id] = FIELD_TYPES[f.type].defaultValue);
            set.records.set(record.id, record);
            renderCurrentView();
            showToast(' Record added');
        }

        function wireViewStageActions() {
            const addRecordBtn = document.getElementById('addRecordBtn');
            if (addRecordBtn) addRecordBtn.onclick = handleAddRecord;

            const addFieldBtn = document.getElementById('addFieldBtn');
            if (addFieldBtn) addFieldBtn.onclick = openAddFieldModal;

            const filterBtn = document.getElementById('filterBtn');
            if (filterBtn) filterBtn.onclick = openFilterModal;

            const sortBtn = document.getElementById('sortBtn');
            if (sortBtn) sortBtn.onclick = openSortModal;

            const deleteSelectedBtn = document.getElementById('deleteSelectedBtn');
            if (deleteSelectedBtn) deleteSelectedBtn.onclick = handleDeleteSelectedRecords;

            const reifyBtn = document.getElementById('reifyViewBtn');
            if (reifyBtn) reifyBtn.onclick = reifyCurrentView;

            const toolbarActions = [
                ['popupSettingsBtn', openPopupSettingsModal],
                ['importCsvBtn', openCsvImportModal],
                ['fuzzyPanelBtn', openFuzzyPanel]
            ];

            toolbarActions.forEach(([id, handler]) => {
                const el = document.getElementById(id);
                if (el) el.onclick = handler;
            });
        }

        function renderViewActions(extraControls = '') {
            return `
                <div class="view-stage-actions">
                    <div class="toolbar-row scrollable">
                        <div class="toolbar-group">
                            <div class="primary-actions">
                                <button id="addRecordBtn" class="btn btn-primary btn-sm">+ Add Record</button>
                                <button id="addFieldBtn" class="btn btn-secondary btn-sm">+ Add Field</button>
                            </div>
                            <div class="view-stage-inline-actions">
                                <button id="filterBtn" class="btn btn-secondary btn-sm">
                                    <i class="ph ph-funnel-simple"></i>
                                    Filter
                                </button>
                                <button id="sortBtn" class="btn btn-secondary btn-sm">
                                    <i class="ph ph-arrows-down-up"></i>
                                    Sort
                                </button>
                            </div>
                            ${extraControls ? `<div class="toolbar-group">${extraControls}</div>` : ''}
                        </div>
                    </div>
                    <div class="toolbar-row secondary">
                        <div class="selection-group">
                            <div id="selectionIndicator" class="selection-indicator hidden">
                                <i class="ph ph-check-square-offset"></i>
                                <span><span id="selectedCount">0</span> selected</span>
                            </div>
                            <button id="deleteSelectedBtn" class="btn btn-danger btn-sm" disabled>
                                <i class="ph ph-trash"></i>
                                Delete
                            </button>
                        </div>
                        <div class="toolbar-group">
                            <button id="reifyViewBtn" class="btn btn-secondary btn-sm">
                                <i class="ph ph-cube-focus"></i>
                                Reify View
                            </button>
                            <button class="btn btn-secondary btn-sm" onclick="openColumnRulesModal()">
                                <i class="ph ph-gear-six text-sm"></i>
                                <span class="ml-1">Fields</span>
                            </button>
                            <div class="toolbar-menu">
                                <button id="toolbarMenuToggle" class="btn btn-secondary btn-sm toolbar-menu-toggle">
                                    <i class="ph ph-dots-three-outline"></i>
                                    Actions
                                </button>
                                <div class="toolbar-menu-panel" id="toolbarMenuPanel">
                                    <button id="popupSettingsBtn" class="btn btn-secondary btn-sm toolbar-menu-item">
                                        <i class="ph ph-gear-six"></i>
                                        Details
                                    </button>
                                    <button id="importCsvBtn" class="btn btn-secondary btn-sm toolbar-menu-item">
                                        <i class="ph ph-upload-simple"></i>
                                        Import CSV
                                    </button>
                                    <div class="toolbar-menu-divider"></div>
                                    <button id="fuzzyPanelBtn" class="btn btn-secondary btn-sm toolbar-menu-item">
                                        <i class="ph ph-graph"></i>
                                        Fuzzy Matches
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        function finalizeViewStage() {
            wireViewStageActions();
            setupToolbarMenu();
        }

        function triggerPrimaryAction() {
            const addRecordBtn = document.getElementById('addRecordBtn');
            if (addRecordBtn) { addRecordBtn.click(); return; }

            document.getElementById('addFieldBtn')?.click();
        }

        function initializeOperatorRules() {
            const defaultRules = [
                {
                    rule_id: 'rule_ins_requires_object',
                    applies_to_op: 'INS',
                    description: 'Instantiation must target an identifiable object.',
                    effect: 'require_object_id'
                },
                {
                    rule_id: 'rule_events_require_actor',
                    description: 'All events must be attributable to an actor.',
                    effect: 'require_actor'
                },
                {
                    rule_id: 'rule_con_requires_object',
                    applies_to_op: 'CON',
                    description: 'Connections must reference a concrete edge object.',
                    effect: 'require_object_id'
                },
                {
                    rule_id: 'rule_con_requires_endpoints',
                    applies_to_op: 'CON',
                    description: 'Connections must include both source and target references.',
                    effect: 'require_connection_endpoints'
                },
                {
                    rule_id: 'rule_nullify_marks_deleted',
                    applies_to_op: 'NUL',
                    description: 'Nullify operations explicitly mark the object as deleted in the payload.',
                    effect: 'mark_deleted'
                }
            ];

            defaultRules.forEach(rule => registerInterpretationRule(rule, { skipEvent: true }));
        }

        function createSampleData() {
            const defaultWorldId = createWorld('Example World', 'world_example');
            state.currentWorldId = defaultWorldId;
            const worldDefaults = state.worlds.get(defaultWorldId)?.defaults || {};

            const locationsId = worldDefaults.locationsId || createSet('Locations', 'ph-map-pin', defaultWorldId);
            const observationsId = worldDefaults.observationsId || createSet('Observations', 'ph-binoculars', defaultWorldId);

            const locationsSet = state.sets.get(locationsId);
            locationsSet.schema = [
                { id: 'name', name: 'Location', type: 'TEXT', width: '220px' },
                { id: 'area', name: 'Area', type: 'TEXT', width: '180px' },
                { id: 'notes', name: 'Notes', type: 'LONG_TEXT', width: '260px' }
            ];

            locationsSet.records.clear();
            locationsSet.views.clear();
            const ridgeId = addRecord(locationsId, { name: 'Summit Ridge', area: 'Highlands', notes: 'Windy lookout with clean sight lines.' });
            const marshId = addRecord(locationsId, { name: 'Quiet Marsh', area: 'Wetlands', notes: 'Shallow water and dense reeds.' });
            const groveId = addRecord(locationsId, { name: 'North Grove', area: 'Forest Edge', notes: 'Shaded trail with frequent wildlife activity.' });

            createView(locationsId, 'Locations', { type: 'grid', sorts: [{ fieldId: 'name', direction: 'asc' }] });
            createView(locationsId, 'By Area', {
                type: 'KEY_DERIVED',
                key: { setId: locationsId, fieldId: 'area' },
                schema: [
                    { id: 'locationNames', name: 'Locations', type: 'TEXT', sourceFieldId: 'name' },
                    { id: 'notesSummary', name: 'Notes', type: 'LONG_TEXT', sourceFieldId: 'notes' }
                ],
                columnRules: {
                    locationNames: { rule: 'sup_all' },
                    notesSummary: { rule: 'sup_all' }
                }
            });

            const observationsSet = state.sets.get(observationsId);
            observationsSet.schema = [
                { id: 'date', name: 'Date', type: 'DATE', width: '140px' },
                { id: 'location', name: 'Location', type: 'TEXT', width: '200px' },
                { id: 'observer', name: 'Observer', type: 'TEXT', width: '180px' },
                { id: 'observation', name: 'Observation', type: 'LONG_TEXT', width: '260px' }
            ];

            observationsSet.records.clear();
            observationsSet.views.clear();
            const obs1Id = addRecord(observationsId, { date: '2024-04-12', location: 'Summit Ridge', observer: 'M. Ellis', observation: 'Found fresh tracks along the ridge path.' });
            const obs2Id = addRecord(observationsId, { date: '2024-04-13', location: 'Quiet Marsh', observer: 'S. Kaur', observation: 'Low mist over the marsh; water depth at 0.4m.' });
            const obs3Id = addRecord(observationsId, { date: '2024-04-14', location: 'North Grove', observer: 'J. Rivera', observation: 'Pair of hawks circling above the grove at noon.' });
            const obs4Id = addRecord(observationsId, { date: '2024-04-15', location: 'Summit Ridge', observer: 'M. Ellis', observation: 'Clear skies; ridge visibility extends 10km.' });

            createView(observationsId, 'Observations', {
                type: 'grid',
                sorts: [{ fieldId: 'date', direction: 'desc' }]
            });

            createView(observationsId, 'By Location', {
                type: 'KEY_DERIVED',
                key: { setId: observationsId, fieldId: 'location' },
                schema: [
                    { id: 'notes', name: 'Observations', type: 'LONG_TEXT', sourceFieldId: 'observation' },
                    { id: 'observers', name: 'Observers', type: 'TEXT', sourceFieldId: 'observer' },
                    { id: 'latestDate', name: 'Most Recent', type: 'DATE', sourceFieldId: 'date' }
                ],
                columnRules: {
                    notes: { rule: 'sup_all' },
                    observers: { rule: 'sup_all' },
                    latestDate: { rule: 'prefer_newest' }
                }
            });

            createView(observationsId, 'By Observer', {
                type: 'KEY_DERIVED',
                key: { setId: observationsId, fieldId: 'observer' },
                schema: [
                    { id: 'locations', name: 'Locations', type: 'TEXT', sourceFieldId: 'location' },
                    { id: 'notes', name: 'Observations', type: 'LONG_TEXT', sourceFieldId: 'observation' },
                    { id: 'latestDate', name: 'Most Recent', type: 'DATE', sourceFieldId: 'date' }
                ],
                columnRules: {
                    locations: { rule: 'sup_all' },
                    notes: { rule: 'sup_all' },
                    latestDate: { rule: 'prefer_newest' }
                }
            });

            Array.from(state.definitions.values())
                .filter(def => def.worldId === defaultWorldId)
                .forEach(def => state.definitions.delete(def.id));

            Array.from(state.connectionFormats.values())
                .filter(fmt => fmt.worldId === defaultWorldId)
                .forEach(fmt => state.connectionFormats.delete(fmt.id));

            const observationLinkFormatId = addConnectionFormat({
                id: `${defaultWorldId}_format_observation_link`,
                operator: 'CON',
                mode: 'is linked to',
                description: 'Links an observation to its location',
                requiredParams: ['context'],
                optionalParams: ['notes'],
                worldId: defaultWorldId
            });

            if (!observationLinkFormatId) return;

            addDefinition({
                id: `${defaultWorldId}_def_location`,
                entity: { type: 'Record', id: ridgeId },
                term: 'Field Location',
                definition: 'A place where observations are collected in the example world.',
                notes: 'Locations anchor the observation network.',
                tags: ['example', 'location'],
                worldId: defaultWorldId
            });
            addDefinition({
                id: `${defaultWorldId}_def_observation`,
                entity: { type: 'Record', id: obs1Id },
                term: 'Observation Entry',
                definition: 'A single sighting or measurement recorded by an observer.',
                notes: 'Use date and observer to track context.',
                tags: ['example', 'observation'],
                worldId: defaultWorldId
            });
            addDefinition({
                id: `${defaultWorldId}_def_link`,
                entity: { type: 'Connection', id: `${defaultWorldId}_example_conn_1` },
                term: 'Observed At',
                definition: 'Connects each observation to the location where it was made.',
                notes: 'Maintains spatial context for notes.',
                tags: ['example', 'connection'],
                worldId: defaultWorldId
            });

            Array.from(state.connections.values())
                .filter(conn => conn.worldId === defaultWorldId)
                .forEach(conn => state.connections.delete(conn.id));

            addConnection({
                id: `${defaultWorldId}_example_conn_1`,
                subject: { type: 'Record', id: obs1Id },
                formatId: observationLinkFormatId,
                operand: { type: 'Record', id: ridgeId },
                description: 'Tracks where the ridge observation was made.',
                params: { context: 'location' },
                worldId: defaultWorldId
            });

            addConnection({
                id: `${defaultWorldId}_example_conn_2`,
                subject: { type: 'Record', id: obs2Id },
                formatId: observationLinkFormatId,
                operand: { type: 'Record', id: marshId },
                description: 'Links marsh observation to its site.',
                params: { context: 'location' },
                worldId: defaultWorldId
            });

            addConnection({
                id: `${defaultWorldId}_example_conn_3`,
                subject: { type: 'Record', id: obs3Id },
                formatId: observationLinkFormatId,
                operand: { type: 'Record', id: groveId },
                description: 'Associates grove observation with location.',
                params: { context: 'location' },
                worldId: defaultWorldId
            });

            addConnection({
                id: `${defaultWorldId}_example_conn_4`,
                subject: { type: 'Record', id: obs4Id },
                formatId: observationLinkFormatId,
                operand: { type: 'Record', id: ridgeId },
                description: 'Links the second ridge observation to its site.',
                params: { context: 'location' },
                worldId: defaultWorldId
            });

            state.currentSetId = observationsId;
            state.currentViewId = Array.from(observationsSet.views.keys())[0];
            state.expandedSets.add(observationsId);
            state.expandedSets.add(locationsId);
        }

        // WORLD & SET MANAGEMENT
        function createWorld(name, worldId = null) {
            const resolvedWorldId = worldId || ('world_' + Date.now());
            const defaults = seedWorldDefaults(resolvedWorldId);

            state.worlds.set(resolvedWorldId, {
                id: resolvedWorldId,
                name,
                setIds: new Set([defaults.locationsId, defaults.observationsId].filter(Boolean)),
                createdAt: new Date().toISOString(),
                defaults
            });
            return resolvedWorldId;
        }

        function getWorld(worldId = state.currentWorldId) {
            return worldId ? state.worlds.get(worldId) : null;
        }

        function getSetsForWorld(worldId = state.currentWorldId) {
            return Array.from(state.sets.values()).filter(set => set.worldId === worldId);
        }

        function createSet(name, icon = 'ph-squares-four', worldId = state.currentWorldId) {
            const resolvedWorldId = worldId || state.currentWorldId;
            const setId = 'set_' + Date.now();
            state.sets.set(setId, {
                id: setId,
                name: name,
                icon: icon,
                worldId: resolvedWorldId,
                schema: [],
                records: new Map(),
                views: new Map(),
                profiles: new Map([['default', { id: 'default', name: 'All Fields', visibleFields: [] }]])
            });
            registerEntity({ id: setId, type: 'Set', name, worldId: resolvedWorldId });
            const world = getWorld(resolvedWorldId);
            world?.setIds?.add(setId);
            createEvent(
                'Create Set',
                'INS',
                { type: 'Set', id: setId },
                { name, worldId: resolvedWorldId },
                { summary: `Created set "${name}"`, scale: 'collection' }
            );
            return setId;
        }

        function createView(setId, name, config = {}) {
            const viewId = 'view_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            const set = state.sets.get(setId);
            const viewPayload = {
                id: viewId,
                setId,
                name: name,
                type: config.type || 'grid',
                icon: config.icon || VIEW_TYPE_ICONS[config.type || 'grid'] || '',
                filters: config.filters || [],
                sorts: config.sorts || [],
                hiddenFields: config.hiddenFields || [],
                popupVisibilityRules: config.popupVisibilityRules || [],
                popupLayout: config.popupLayout || { size: 'medium', columns: 4, rows: 4 },
                kanbanGroupField: config.kanbanGroupField || null,
                cardFields: config.cardFields || [],
                parentId: config.parentId || null,
                key: config.key || null,
                schema: config.schema || null,
                relationships: config.relationships || [],
                rollups: config.rollups || [],
                showRecordId: config.showRecordId || false,
                identifierField: config.identifierField || null,
                columnRules: config.columnRules || {},
                createdAt: Date.now(),
                createdBy: state.currentUser.id
            };
            set.views.set(viewId, viewPayload);

            if (config.type === 'KEY_DERIVED') {
                createEvent(
                    'Create Key View',
                    'SYN',
                    { type: 'View', id: viewId, setId },
                    { view: viewPayload, summary: `Generated view "${name}" from identity property` },
                    { scale: 'collection' }
                );
            }

            return viewId;
        }

        function reifyCurrentView() {
            const view = getCurrentView();
            if (!view) {
                showToast(' No active view to reify');
                return null;
            }
            const setId = state.currentSetId;
            return reifyView({ ...view, setId: view.setId || setId });
        }

        function reifyView(view) {
            if (!view) return null;

            const randomId = crypto.randomUUID ? crypto.randomUUID() : `${Date.now()}_${Math.random().toString(36).substr(2, 6)}`;
            const id = `entity_view_${randomId}`;
            const viewRef = {
                setId: view.setId || view.sourceSet || view.sourceSetId || null,
                viewId: view.id || view.key || view.name,
                viewName: view.name
            };
            const memberRefs = collectViewMembers(view);
            const viewWorldId = viewRef.setId ? state.sets.get(viewRef.setId)?.worldId : state.currentWorldId;
            const viewEntity = {
                id,
                type: 'ViewEntity',
                entityType: view.name || 'Reified View',
                viewRef,
                sourceSet: view.setId || view.sourceSet || null,
                memberRefs,
                origin: 'reified',
                worldId: viewWorldId,
                createdAt: Date.now()
            };

            registerEntity(viewEntity);

            addDefinition({
                id: `def_${id}`,
                entity: { type: 'ViewEntity', id },
                term: view.name || 'Reified View',
                definition: 'A view created from filters, groups, or aggregates.',
                notes: `Reified from view ${viewRef.viewName || viewRef.viewId || ''}`.trim(),
                tags: ['reified', 'view'],
                worldId: viewWorldId
            });

            const lineage = extractViewLineage(view, id);
            lineage.forEach(conn => addConnection(conn));

            showToast(` View reified as entity: ${id}`);
            return id;
        }

        function collectViewMembers(view) {
            if (!view) return [];
            const setId = view.setId || view.sourceSet || view.sourceSetId || null;
            const set = setId ? state.sets.get(setId) : null;
            if (!set) return [];

            let records = Array.from(set.records.values());
            if (Array.isArray(view.filters) && view.filters.length > 0) records = applyFilterGroups(records, view.filters, set.schema);
            if (Array.isArray(view.sorts) && view.sorts.length > 0) records = applySorts(records, view.sorts, set.schema);

            return records.map(record => ({ type: 'Record', id: record.id, setId: set.id }));
        }

        function extractViewLineage(view, newEntityId) {
            const list = [];
            const sourceSetId = view.setId || view.sourceSet || view.sourceSetId || null;
            const idFactory = () => `conn_${crypto.randomUUID ? crypto.randomUUID() : `${Date.now()}_${Math.random().toString(36).substr(2, 6)}`}`;

            if (Array.isArray(view.filters)) {
                view.filters.forEach(filter => {
                    if (!filter?.fieldId) return;
                    list.push({
                        id: idFactory(),
                        subject: { type: 'Field', id: filter.fieldId },
                        operator: 'SEG',
                        mode: 'filters by',
                        operand: { type: 'ViewEntity', id: newEntityId },
                        description: 'View generated by filtering',
                        params: filter
                    });
                });
            }

            if (Array.isArray(view.groupBy)) {
                view.groupBy.forEach(group => {
                    if (!group?.fieldId) return;
                    list.push({
                        id: idFactory(),
                        subject: { type: 'Field', id: group.fieldId },
                        operator: 'SEG',
                        mode: 'groups by',
                        operand: { type: 'ViewEntity', id: newEntityId },
                        description: 'View grouped by field',
                        params: group
                    });
                });
            }

            if (Array.isArray(view.aggregationRules)) {
                view.aggregationRules.forEach(rule => {
                    list.push({
                        id: idFactory(),
                        subject: { type: 'Set', id: sourceSetId },
                        operator: 'SYN',
                        mode: 'aggregates into',
                        operand: { type: 'ViewEntity', id: newEntityId },
                        description: 'Aggregated fields/materialized view',
                        params: rule
                    });
                });
            }

            if (view.pivotField) {
                list.push({
                    id: idFactory(),
                    subject: { type: 'Field', id: view.pivotField },
                    operator: 'SUP',
                    mode: 'superposes over',
                    operand: { type: 'ViewEntity', id: newEntityId },
                    description: 'View pivoted on field',
                    params: {}
                });
            }

            return list;
        }

        function scoreKeyCandidate(set, fieldId, fieldName, fieldType = 'TEXT') {
            let score = 0;
            if (fieldType === 'LINK_RECORD') score += 0.35;

            const values = Array.from(set.records.values()).map(r => r[fieldId]).filter(v => v !== undefined && v !== null);
            if (values.length > 0) {
                const unique = new Set(values.map(v => JSON.stringify(v))).size;
                const reuseRatio = 1 - unique / values.length;
                score += reuseRatio * 0.4;
            }

            for (const [otherSetId, otherSet] of state.sets.entries()) {
                if (otherSetId === set.id) continue;
                const overlap = otherSet.schema.some(f => f.id === fieldId || f.name === fieldName || f.name === fieldId);
                const dataOverlap = Array.from(otherSet.records.values()).some(r => r[fieldId] !== undefined);
                if (overlap || dataOverlap) score += 0.15;
            }

            score = Math.min(1, score);
            return { score };
        }

        function scoreFieldAsKey(set, field) {
            return scoreKeyCandidate(set, field.id, field.name, field.type);
        }

        function findLooseKeyCandidates(set) {
            const schemaFieldIds = new Set(set.schema.map(f => f.id));
            const counts = new Map();

            set.records.forEach(record => {
                Object.keys(record || {}).forEach(fieldId => {
                    if (fieldId === 'id' || schemaFieldIds.has(fieldId)) return;
                    counts.set(fieldId, (counts.get(fieldId) || 0) + 1);
                });
            });

            const totalRecords = Math.max(set.records.size, 1);
            return [...counts.entries()]
                .map(([fieldId, count]) => ({
                    fieldId,
                    fieldName: fieldId,
                    score: Math.min(1, count / totalRecords)
                }))
                .filter(candidate => candidate.score > 0.6);
        }

        function findKeyCandidates() {
            const candidates = new Map();

            const isValueField = (field) => (field.id?.toLowerCase() === 'value' || field.name?.toLowerCase() === 'value');

            const addCandidate = (setId, fieldId, fieldName, score) => {
                if (!fieldId) return;
                const key = `${setId}:${fieldId}`;
                const existing = candidates.get(key);
                if (!existing || score > existing.score) {
                    candidates.set(key, { setId, fieldId, fieldName, score });
                }
            };

            getSetsForWorld().forEach(set => {
                const setId = set.id;
                set.schema.forEach(field => {
                    const usage = scoreFieldAsKey(set, field);
                    if (usage.score > 0.6) {
                        addCandidate(setId, field.id, field.name, usage.score);
                    }
                });

                const valueField = set.schema.find(isValueField);
                if (valueField) {
                    const values = Array.from(set.records.values())
                        .map(r => r[valueField.id])
                        .filter(v => v !== undefined && v !== null && v !== '');
                    if (values.length > 0) {
                        const unique = new Set(values.map(v => JSON.stringify(v))).size;
                        const reuseRatio = 1 - unique / values.length;
                        const score = Math.min(1, Math.max(0.65, reuseRatio * 0.8 + 0.2));
                        addCandidate(setId, valueField.id, valueField.name || valueField.id, score);
                    }
                }

                set.views.forEach(view => {
                    if (!Array.isArray(view.schema)) return;
                    view.schema.forEach(field => {
                        const sourceFieldId = field.sourceFieldId || field.id;
                        const usage = scoreKeyCandidate(set, sourceFieldId, field.name || sourceFieldId, field.type);
                        if (usage.score > 0.6) {
                            addCandidate(setId, sourceFieldId, field.name || sourceFieldId, usage.score);
                        }
                    });
                });

                findLooseKeyCandidates(set).forEach(candidate => {
                    addCandidate(setId, candidate.fieldId, candidate.fieldName, candidate.score);
                });
            });

            return [...candidates.values()].sort((a, b) => b.score - a.score);
        }

        function findFieldAcrossSets(fieldId) {
            for (const set of getSetsForWorld()) {
                const setId = set.id;
                const schemaField = set.schema.find(f => f.id === fieldId);
                if (schemaField) return { setId, field: schemaField };

                for (const view of set.views.values()) {
                    if (!Array.isArray(view.schema)) continue;
                    const viewField = view.schema.find(f => f.id === fieldId || f.sourceFieldId === fieldId);
                    if (viewField) return { setId, field: viewField };
                }
            }
            return null;
        }

        function findAllItemsForKey(setId, fieldId) {
            const results = [];

            const worldId = state.sets.get(setId)?.worldId || state.currentWorldId;
            getSetsForWorld(worldId).forEach(set => {
                set.records.forEach((record, id) => {
                    if (record[fieldId] !== null && record[fieldId] !== undefined) {
                        results.push({ setId: set.id, recordId: id, record });
                    }
                });
            });

            return results;
        }

        function buildPropertyInventory(items, keyFieldId) {
            const propertyCount = new Map();

            items.forEach(({ record }) => {
                Object.keys(record).forEach(fieldId => {
                    if (fieldId === keyFieldId) return;
                    propertyCount.set(fieldId, (propertyCount.get(fieldId) || 0) + 1);
                });
            });

            return [...propertyCount.entries()]
                .filter(([_, count]) => count / Math.max(items.length, 1) > 0.2)
                .map(([f]) => f);
        }

        function detectRelationships(propertyIds) {
            return propertyIds
                .map(fieldId => {
                    const hit = findFieldAcrossSets(fieldId);
                    if (!hit) return null;
                    if (hit.field.type === 'LINK_RECORD') {
                        return { fieldId, setId: hit.setId, type: 'link' };
                    }
                    if (Array.isArray(hit.field.defaultValue)) {
                        return { fieldId, setId: hit.setId, type: 'array' };
                    }
                    return null;
                })
                .filter(Boolean);
        }

        function detectRollups(keyRef) {
            const rollups = [];
            const worldId = state.sets.get(keyRef.setId)?.worldId || state.currentWorldId;
            getSetsForWorld(worldId).forEach(set => {
                const setId = set.id;
                const hasReference = set.schema.some(f => f.id === keyRef.fieldId || f.name === keyRef.fieldId || f.config?.linkedSetId === keyRef.setId);
                if (hasReference) {
                    rollups.push({
                        type: 'count',
                        fromSetId: setId,
                        fieldId: keyRef.fieldId,
                        label: `Count of ${set.name} where ${keyRef.fieldId} matches`
                    });
                }
            });
            return rollups;
        }

        function autoDetectSchemaFromKey(keyRef) {
            const allItems = findAllItemsForKey(keyRef.setId, keyRef.fieldId);
            const propertyIds = buildPropertyInventory(allItems, keyRef.fieldId);
            const relationships = detectRelationships(propertyIds);
            const rollups = detectRollups(keyRef);

            const schema = propertyIds.map(propId => {
                const match = findFieldAcrossSets(propId);
                return {
                    id: `derived_${propId}`,
                    sourceFieldId: propId,
                    sourceSetId: match?.setId || null,
                    name: match?.field?.name || propId,
                    type: match?.field?.type || 'TEXT'
                };
            });

            return { schema, relationships, rollups };
        }

        function groupByKeyValue(items, keyFieldId) {
            const grouped = new Map();
            items.forEach(item => {
                const key = item.record[keyFieldId];
                if (key === undefined || key === null) return;
                if (!grouped.has(key)) grouped.set(key, []);
                grouped.get(key).push(item);
            });
            return grouped;
        }

        function applyColumnRule(values, ruleConfig = {}) {
            if (!values || values.length === 0) return null;
            const uniqueValues = values.filter(v => v !== undefined && v !== null);
            if (uniqueValues.length === 0) return null;
            const rule = ruleConfig.rule || 'sup_all';

            switch (rule) {
                case 'prefer_newest':
                    return uniqueValues[uniqueValues.length - 1];
                case 'prefer_oldest':
                    return uniqueValues[0];
                case 'prefer_set':
                    if (ruleConfig.setId) {
                        const found = uniqueValues.find(v => v && v.__sourceSetId === ruleConfig.setId);
                        if (found !== undefined) return found;
                    }
                    return uniqueValues[0];
                case 'average_numeric':
                    const nums = uniqueValues.map(Number).filter(n => !Number.isNaN(n));
                    return nums.length ? nums.reduce((a, b) => a + b, 0) / nums.length : null;
                case 'median_numeric':
                    const sorted = uniqueValues.map(Number).filter(n => !Number.isNaN(n)).sort((a, b) => a - b);
                    if (!sorted.length) return null;
                    const mid = Math.floor(sorted.length / 2);
                    return sorted.length % 2 ? sorted[mid] : (sorted[mid - 1] + sorted[mid]) / 2;
                case 'concat_text':
                    return uniqueValues.join(', ');
                case 'first_non_null':
                    return uniqueValues.find(v => v !== null && v !== undefined);
                case 'sup_all':
                default:
                    return { value: uniqueValues.map(val => ({ val })), _sup: true };
            }
        }

        function buildRowsFromGroups(grouped, view) {
            const rows = [];
            grouped.forEach((items, keyValue) => {
                const row = { id: `key_${keyValue}`, keyValue, __sourceItems: items };
                (view.schema || []).forEach(field => {
                    const values = items.map(item => {
                        const raw = item.record[field.sourceFieldId || field.id];
                        if (raw && typeof raw === 'object' && !raw.__sourceSetId) {
                            return { ...raw, __sourceSetId: item.setId };
                        }
                        if (raw !== undefined && raw !== null) {
                            return typeof raw === 'object' ? { ...raw, __sourceSetId: item.setId } : raw;
                        }
                        return undefined;
                    }).filter(v => v !== undefined);
                    row[field.id] = applyColumnRule(values, view.columnRules?.[field.id]);
                });
                rows.push(row);
            });
            return rows;
        }

        function addRecord(setId, data) {
            const set = state.sets.get(setId);
            const recordId = 'rec_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            const record = { id: recordId, ...data };
            set.records.set(recordId, record);
            registerEntity({ id: recordId, type: 'Record', setId, data, createdAt: new Date().toISOString() });
            createEvent(
                'Create Record',
                'INS',
                { type: 'Record', id: recordId, setId },
                { setId, recordId, data, summary: 'Created record' }
            );
            recomputeFormulasForSet(set);
            return recordId;
        }

        function getRecordById(recordId) {
            for (const [setId, set] of state.sets.entries()) {
                if (set.records.has(recordId)) {
                    return { setId, set, record: set.records.get(recordId) };
                }
            }
            return null;
        }

        function getLinkedSet(field) {
            const linkedSetId = field?.config?.linkedSetId;
            if (!linkedSetId) return null;
            return state.sets.get(linkedSetId) || null;
        }

        function getLinkedRecordOptions(field) {
            const linkedSet = getLinkedSet(field);
            return linkedSet ? Array.from(linkedSet.records.values()) : [];
        }

        function createLinkedRecordOptionList(field) {
            const options = getLinkedRecordOptions(field);
            return options.map(opt => ({
                id: opt.id,
                label: opt.name || getRecordDisplayName(opt.id) || opt.id
            }));
        }

        // CSV IMPORT & FUZZY MATCHING
        const CREATE_FIELD_PREFIX = '__create__';
        const CSV_FIELD_MATCH_THRESHOLD = 0.75;

        function slugifyFieldId(name) {
            return (name || '').toLowerCase()
                .replace(/[^a-z0-9]/g, '_')
                .replace(/_+/g, '_')
                .replace(/^_+|_+$/g, '') || 'field';
        }

        function isCreateFieldValue(value) {
            return typeof value === 'string' && value.startsWith(CREATE_FIELD_PREFIX);
        }

        function buildCreateFieldValue(header) {
            return `${CREATE_FIELD_PREFIX}${slugifyFieldId(header)}`;
        }

        function findBestFieldMatch(header, schema) {
            const target = (header || '').trim();
            let best = null;
            schema.forEach(field => {
                const score = Math.max(
                    similarityScore(target, field.name),
                    similarityScore(target, field.id)
                );
                if (!best || score > best.score) {
                    best = { field, score };
                }
            });
            return best;
        }

        function resetCsvImportState() {
            const defaultSetId = state.currentSetId || Array.from(state.sets.keys())[0] || null;
            state.csvImportState = {
                headers: [],
                rows: [],
                mappings: {},
                previewRows: [],
                matches: [],
                targetMode: defaultSetId ? 'existing' : 'new',
                targetSetId: defaultSetId,
                newSetName: ''
            };
            const badge = document.getElementById('csvRowCountBadge');
            if (badge) badge.textContent = '0 rows';
            const mappingEl = document.getElementById('csvMappingContainer');
            if (mappingEl) mappingEl.innerHTML = '<p class="text-sm text-gray-500">Load a CSV file or paste CSV text to start mapping.</p>';
            const previewEl = document.getElementById('csvPreviewContainer');
            if (previewEl) previewEl.innerHTML = '<p class="text-sm text-gray-500">Preview will appear after parsing.</p>';
            const matchesEl = document.getElementById('csvMatchSuggestions');
            if (matchesEl) matchesEl.innerHTML = '<p class="text-sm text-gray-500">No suggestions yet.</p>';
            const textInput = document.getElementById('csvTextInput');
            if (textInput) textInput.value = '';
            const fileInput = document.getElementById('csvFileInput');
            if (fileInput) fileInput.value = '';
            populateCsvTargetSetOptions();
            syncCsvImportTargetUi();
        }

        function populateCsvTargetSetOptions() {
            const select = document.getElementById('csvTargetSetSelect');
            if (!select) return;
            const options = getSetsForWorld().map(set => `<option value="${set.id}">${set.name}</option>`);
            if (!options.length) {
                select.innerHTML = '<option value="" disabled>No sets available</option>';
                select.value = '';
                state.csvImportState.targetSetId = null;
                return;
            }
            select.innerHTML = options.join('');
            const desired = state.csvImportState.targetSetId || state.currentSetId || select.options[0]?.value || '';
            select.value = desired;
            state.csvImportState.targetSetId = select.value || null;
        }

        function syncCsvImportTargetUi() {
            const mode = state.csvImportState.targetMode;
            document.querySelectorAll('input[name="csvImportTargetMode"]').forEach(input => {
                input.checked = input.value === mode;
            });
            document.getElementById('csvExistingSetPicker')?.classList.toggle('hidden', mode !== 'existing');
            document.getElementById('csvNewSetFields')?.classList.toggle('hidden', mode !== 'new');
            const select = document.getElementById('csvTargetSetSelect');
            if (select && mode === 'existing') select.value = state.csvImportState.targetSetId || '';
            const nameInput = document.getElementById('csvNewSetName');
            if (nameInput && mode === 'new') nameInput.value = state.csvImportState.newSetName || '';
        }

        function getCsvTargetSet() {
            if (state.csvImportState.targetMode === 'existing') {
                const setId = state.csvImportState.targetSetId || state.currentSetId;
                return setId ? state.sets.get(setId) : null;
            }
            return {
                id: null,
                name: state.csvImportState.newSetName?.trim() || 'New Set',
                schema: [],
                records: new Map()
            };
        }

        function handleCsvTargetChange() {
            populateCsvTargetSetOptions();
            syncCsvImportTargetUi();
            if (state.csvImportState.headers.length) {
                const set = getCsvTargetSet();
                state.csvImportState.mappings = autoMapColumns(state.csvImportState.headers, set);
                renderCsvMapping();
                renderCsvPreview();
                renderCsvMatches();
            }
        }

        function openCsvImportModal(targetSetId = null) {
            resetCsvImportState();
            if (targetSetId) {
                state.csvImportState.targetMode = 'existing';
                state.csvImportState.targetSetId = targetSetId;
                populateCsvTargetSetOptions();
                syncCsvImportTargetUi();
            }
            openModal('csvImportModal');
        }

        function handleCsvFileSelected(event) {
            const file = event.target.files?.[0];
            if (!file) return;
            const targetSet = getCsvTargetSet();
            if (!targetSet) {
                showToast(' Choose a destination set first');
                event.target.value = '';
                return;
            }
            const reader = new FileReader();
            reader.onload = (e) => {
                const { headers, rows } = parseCsvContent(e.target.result || '');
                handleCsvData(headers, rows);
            };
            reader.readAsText(file);
        }

        function previewCsvFromText() {
            const text = document.getElementById('csvTextInput')?.value || '';
            const targetSet = getCsvTargetSet();
            if (!targetSet) {
                showToast(' Choose a destination set first');
                return;
            }
            const { headers, rows } = parseCsvContent(text);
            handleCsvData(headers, rows);
        }

        function parseCsvContent(text) {
            if (!text || !text.trim()) return { headers: [], rows: [] };
            const rows = [];
            let current = '';
            let inQuotes = false;
            const result = [];
            for (let i = 0; i < text.length; i++) {
                const char = text[i];
                const nextChar = text[i + 1];
                if (char === '"') {
                    if (inQuotes && nextChar === '"') {
                        current += '"';
                        i++;
                    } else {
                        inQuotes = !inQuotes;
                    }
                } else if (char === ',' && !inQuotes) {
                    rowPush(current);
                } else if ((char === '\n' || char === '\r') && !inQuotes) {
                    rowPush(current);
                    if (result.length) rows.push(result.splice(0));
                } else {
                    current += char;
                }
            }
            rowPush(current);
            if (result.length) rows.push(result);

            function rowPush(value) {
                result.push(value.trim());
                current = '';
            }

            const headers = rows.shift() || [];
            const normalizedRows = rows.filter(r => r.length && r.some(cell => cell !== '')).map(r => {
                const obj = {};
                headers.forEach((h, idx) => obj[h] = r[idx] || '');
                return obj;
            });
            return { headers, rows: normalizedRows };
        }

        function autoMapColumns(headers, set) {
            const mappings = {};
            const schema = set?.schema || [];
            headers.forEach(h => {
                const match = findBestFieldMatch(h, schema);
                if (match && match.score >= CSV_FIELD_MATCH_THRESHOLD) {
                    mappings[h] = match.field.id;
                } else {
                    mappings[h] = buildCreateFieldValue(h);
                }
            });
            return mappings;
        }

        function handleCsvData(headers, rows) {
            const set = getCsvTargetSet();
            if (state.csvImportState.targetMode === 'existing' && !set) {
                showToast(' Choose a destination set first');
                return;
            }
            state.csvImportState.headers = headers;
            state.csvImportState.rows = rows;
            state.csvImportState.mappings = autoMapColumns(headers, set);
            const badge = document.getElementById('csvRowCountBadge');
            if (badge) badge.textContent = `${rows.length} rows`;
            renderCsvMapping();
            renderCsvPreview();
            renderCsvMatches();
        }

        function renderCsvMapping() {
            const container = document.getElementById('csvMappingContainer');
            const set = getCsvTargetSet();
            if (!container || !set) return;
            if (!state.csvImportState.headers.length) {
                container.innerHTML = '<p class="text-sm text-gray-500">No headers detected yet.</p>';
                return;
            }

            container.innerHTML = state.csvImportState.headers.map(header => {
                const mappedField = state.csvImportState.mappings[header] || '';
                const createValue = buildCreateFieldValue(header);
                const options = ['<option value="">Skip</option>']
                    .concat(`<option value="${createValue}" ${mappedField === createValue ? 'selected' : ''}> Create new field: "${header}"</option>`)
                    .concat(set.schema.map(f => `<option value="${f.id}" ${mappedField === f.id ? 'selected' : ''}>${f.name}</option>`))
                    .join('');
                return `
                    <div class="flex items-center gap-3">
                        <div class="w-1/3 font-medium">${header}</div>
                        <div class="flex-1">
                            <select data-csv-header="${header}" class="flex-1">${options}</select>
                            ${isCreateFieldValue(mappedField) ? `<p class="text-xs text-amber-600 mt-1">Will create a new text field named "${header}"</p>` : ''}
                        </div>
                    </div>
                `;
            }).join('');

            container.querySelectorAll('select').forEach(select => {
                select.onchange = (event) => {
                    const header = event.target.dataset.csvHeader;
                    state.csvImportState.mappings[header] = event.target.value;
                    renderCsvPreview();
                    renderCsvMatches();
                };
            });
        }

        function buildCsvPreviewRows(limit = 5) {
            const set = getCsvTargetSet();
            if (!set) return [];
            const mappedHeaders = state.csvImportState.headers
                .map(header => [header, state.csvImportState.mappings[header]])
                .filter(([, fieldId]) => fieldId);
            return state.csvImportState.rows.slice(0, limit).map(row => {
                const preview = { __original: row };
                mappedHeaders.forEach(([header, fieldId]) => {
                    const field = set.schema.find(f => f.id === fieldId);
                    let value = row[header] || '';
                    if (['NUMBER', 'CURRENCY'].includes(field?.type)) {
                        const numeric = parseFloat(value);
                        value = isNaN(numeric) ? '' : numeric;
                    }
                    preview[fieldId] = value;
                });
                return preview;
            });
        }

        function renderCsvPreview() {
            const container = document.getElementById('csvPreviewContainer');
            const set = getCsvTargetSet();
            if (!container || !set) return;
            const mappedEntries = state.csvImportState.headers
                .map(header => [header, state.csvImportState.mappings[header]])
                .filter(([, fieldId]) => fieldId);
            if (!mappedEntries.length || !state.csvImportState.rows.length) {
                container.innerHTML = '<p class="text-sm text-gray-500">Map at least one column to preview records.</p>';
                return;
            }

            const previewRows = buildCsvPreviewRows();
            state.csvImportState.previewRows = previewRows;
            const headerCells = mappedEntries.map(([header, fieldId]) => {
                const field = set.schema.find(f => f.id === fieldId);
                const label = field?.name || header;
                const badge = field ? '' : '<span class="ml-2 text-xs font-semibold text-amber-600">(creates field)</span>';
                return `<th>${label}${badge}</th>`;
            }).join('');

            const bodyRows = previewRows.map(row => {
                const cells = mappedEntries.map(([, fieldId]) => `<td>${row[fieldId] ?? ''}</td>`).join('');
                return `<tr>${cells}</tr>`;
            }).join('');

            container.innerHTML = `
                <table class="csv-preview-table">
                    <thead><tr>${headerCells}</tr></thead>
                    <tbody>${bodyRows}</tbody>
                </table>
            `;
        }

        function similarityScore(a, b) {
            const s1 = (a || '').toString().trim().toLowerCase();
            const s2 = (b || '').toString().trim().toLowerCase();
            if (!s1 || !s2) return 0;
            const distance = levenshteinDistance(s1, s2);
            return 1 - (distance / Math.max(s1.length, s2.length));
        }

        function levenshteinDistance(a, b) {
            const matrix = Array.from({ length: b.length + 1 }, () => []);
            for (let i = 0; i <= b.length; i++) matrix[i][0] = i;
            for (let j = 0; j <= a.length; j++) matrix[0][j] = j;
            for (let i = 1; i <= b.length; i++) {
                for (let j = 1; j <= a.length; j++) {
                    if (b.charAt(i - 1) === a.charAt(j - 1)) {
                        matrix[i][j] = matrix[i - 1][j - 1];
                    } else {
                        matrix[i][j] = Math.min(
                            matrix[i - 1][j - 1] + 1,
                            matrix[i][j - 1] + 1,
                            matrix[i - 1][j] + 1
                        );
                    }
                }
            }
            return matrix[b.length][a.length];
        }

        function resolvePrimaryFieldFromMappings(set) {
            const nameField = Object.entries(state.csvImportState.mappings).find(([, fieldId]) => fieldId === 'name');
            if (nameField) return nameField[1];
            const textFields = set.schema.filter(f => ['TEXT', 'LONG_TEXT'].includes(f.type));
            const mappedTextField = Object.entries(state.csvImportState.mappings)
                .map(([, fieldId]) => set.schema.find(f => f.id === fieldId))
                .find(f => f && ['TEXT', 'LONG_TEXT'].includes(f.type));
            return mappedTextField?.id || textFields[0]?.id || set.schema[0]?.id;
        }

        function renderCsvMatches() {
            const container = document.getElementById('csvMatchSuggestions');
            const set = getCsvTargetSet();
            if (!container || !set) return;
            if (!state.csvImportState.rows.length) {
                container.innerHTML = '<p class="text-sm text-gray-500">Load rows to see suggestions.</p>';
                return;
            }

            const keyFieldId = resolvePrimaryFieldFromMappings(set);
            if (!keyFieldId) {
                container.innerHTML = '<p class="text-sm text-gray-500">Map at least one text column to find duplicates.</p>';
                return;
            }

            const existing = Array.from(set.records.values());
            const matches = [];
            state.csvImportState.rows.forEach(row => {
                const mappedValue = Object.entries(state.csvImportState.mappings).find(([, fieldId]) => fieldId === keyFieldId);
                const candidateValue = mappedValue ? row[mappedValue[0]] : '';
                let bestMatch = null;
                existing.forEach(rec => {
                    const score = similarityScore(candidateValue, rec[keyFieldId]);
                    if (score >= 0.6 && (!bestMatch || score > bestMatch.score)) {
                        bestMatch = { csvValue: candidateValue, record: rec, score };
                    }
                });
                if (bestMatch) matches.push(bestMatch);
            });

            state.csvImportState.matches = matches;
            if (!matches.length) {
                container.innerHTML = '<p class="text-sm text-gray-500">No close matches detected.</p>';
                return;
            }

            container.innerHTML = matches.slice(0, 10).map(match => `
                <div class="fuzzy-match-row">
                    <div class="flex-1">
                        <div class="text-sm text-gray-500">CSV Value</div>
                        <strong>${match.csvValue || '(blank)'}</strong>
                    </div>
                    <div class="flex-1">
                        <div class="text-sm text-gray-500">Existing Record</div>
                        <strong>${match.record.name || match.record.id}</strong>
                        <div class="text-xs text-gray-500">Score: <span class="fuzzy-score">${match.score.toFixed(2)}</span></div>
                    </div>
                </div>
            `).join('');
        }

        function importCsvRecords() {
            let set = null;
            if (state.csvImportState.targetMode === 'existing') {
                const setId = state.csvImportState.targetSetId || state.currentSetId;
                if (!setId) {
                    showToast(' Choose a destination set first');
                    return;
                }
                set = state.sets.get(setId);
            } else {
                const name = (state.csvImportState.newSetName || '').trim();
                if (!name) {
                    showToast(' Name your new set before importing');
                    return;
                }
                const setId = createSet(name, 'ph-squares-four', state.currentWorldId);
                createView(setId, 'All ' + name, { type: 'grid' });
                state.expandedSets.add(setId);
                renderSidebar();
                switchSet(setId, null);
                set = state.sets.get(setId);
                state.csvImportState.targetMode = 'existing';
                state.csvImportState.targetSetId = setId;
            }
            if (!set) return;
            const mappedHeaders = Object.entries(state.csvImportState.mappings).filter(([, fieldId]) => fieldId);
            if (!mappedHeaders.length) {
                showToast(' Map at least one column');
                return;
            }
            if (!state.csvImportState.rows.length) {
                showToast(' No rows to import');
                return;
            }

            const existingFieldIds = new Set(set.schema.map(f => f.id));
            mappedHeaders
                .filter(([, fieldId]) => isCreateFieldValue(fieldId))
                .forEach(([header, fieldId]) => {
                    const suggestedId = fieldId.replace(CREATE_FIELD_PREFIX, '') || slugifyFieldId(header);
                    const fieldName = header?.trim() || 'New Field';
                    let uniqueId = suggestedId;
                    let counter = 1;
                    while (existingFieldIds.has(uniqueId)) {
                        uniqueId = `${suggestedId}_${counter++}`;
                    }

                    const newField = { id: uniqueId, name: fieldName, type: 'TEXT', width: '150px', config: {} };
                    set.schema.push(newField);
                    set.records.forEach(r => r[uniqueId] = FIELD_TYPES.TEXT.defaultValue);
                    existingFieldIds.add(uniqueId);
                    state.csvImportState.mappings[header] = uniqueId;
                });

            const finalizedMappings = Object.entries(state.csvImportState.mappings).filter(([, fieldId]) => fieldId);

            // Create ONE context template for the entire import (lean approach)
            let importTemplateId = null;
            if (state.leanContext) {
                const importFilename = state.csvImportState.filename || 'import.csv';
                importTemplateId = state.leanContext.registerContextTemplate({
                    method: 'declared',
                    source: 'csv_import',
                    agent: state.currentUser.id,
                    timeframe: {
                        start: new Date().toISOString().split('T')[0]
                    }
                });
            }

            state.csvImportState.rows.forEach(row => {
                const recordData = {};
                finalizedMappings.forEach(([header, fieldId]) => {
                    const field = set.schema.find(f => f.id === fieldId);
                    let value = row[header];
                    if (['NUMBER', 'CURRENCY'].includes(field?.type)) {
                        const numeric = parseFloat(value);
                        value = isNaN(numeric) ? 0 : numeric;
                    }
                    recordData[fieldId] = value;
                });

                // Use lean record creation if available
                if (state.leanContext && importTemplateId) {
                    const leanRecord = state.leanContext.createLeanRecord(set.id, recordData, importTemplateId);
                    set.records.set(leanRecord.id, leanRecord);
                    createEvent(
                        'Create Record',
                        'INS',
                        { type: 'Record', id: leanRecord.id, setId: set.id },
                        { setId: set.id, recordId: leanRecord.id, data: recordData, summary: 'Created record via import' }
                    );
                } else {
                    addRecord(set.id, recordData);
                }
            });

            // Create batch import event (compact)
            if (state.leanContext && importTemplateId) {
                createEvent(
                    'Batch Import',
                    'INS',
                    { type: 'Set', id: set.id },
                    {
                        count: state.csvImportState.rows.length,
                        templateId: importTemplateId,
                        summary: `Imported ${state.csvImportState.rows.length} records`
                    }
                );
            }

            switchSet(set.id, null);
            showToast(` Imported ${state.csvImportState.rows.length} records`);
            closeModal('csvImportModal');
        }

        function computeFuzzyMatchesForSet(set, threshold = state.fuzzyPanelState.threshold) {
            if (!set) return [];
            const candidates = Array.from(set.records.values());
            const textFields = set.schema.filter(f => ['TEXT', 'LONG_TEXT'].includes(f.type));
            const fieldId = textFields[0]?.id || set.schema[0]?.id;
            const matches = [];
            for (let i = 0; i < candidates.length; i++) {
                for (let j = i + 1; j < candidates.length; j++) {
                    const a = candidates[i];
                    const b = candidates[j];
                    const score = similarityScore(a[fieldId], b[fieldId]);
                    if (score >= threshold) {
                        matches.push({ a, b, score, fieldId });
                    }
                }
            }
            return matches.sort((x, y) => y.score - x.score).slice(0, 50);
        }

        function renderFuzzyPanel() {
            const container = document.getElementById('fuzzyMatchList');
            const thresholdInput = document.getElementById('fuzzyThresholdInput');
            if (!container || !thresholdInput) return;
            const set = getCurrentSet();
            if (!set) return;
            const threshold = parseFloat(thresholdInput.value) || state.fuzzyPanelState.threshold;
            state.fuzzyPanelState.threshold = threshold;
            const matches = computeFuzzyMatchesForSet(set, threshold);
            state.fuzzyPanelState.matches = matches;

            if (!matches.length) {
                container.innerHTML = '<p class="text-sm text-gray-500">No matches at this threshold.</p>';
                return;
            }

            container.innerHTML = matches.map(match => `
                <div class="fuzzy-match-row">
                    <div class="flex-1">
                        <div class="text-sm text-gray-500">Record A</div>
                        <strong>${match.a.name || match.a.id}</strong>
                    </div>
                    <div class="flex-1">
                        <div class="text-sm text-gray-500">Record B</div>
                        <strong>${match.b.name || match.b.id}</strong>
                        <div class="text-xs text-gray-500">Score: <span class="fuzzy-score">${match.score.toFixed(2)}</span></div>
                    </div>
                    <div class="flex items-center gap-2">
                        <button class="btn btn-secondary btn-sm" data-link="${match.a.id}|${match.b.id}" data-score="${match.score}">Link</button>
                        <button class="btn btn-secondary btn-sm" data-dismiss="${match.a.id}|${match.b.id}">Dismiss</button>
                    </div>
                </div>
            `).join('');

            container.querySelectorAll('[data-link]').forEach(btn => {
                btn.onclick = () => {
                    const [sourceId, targetId] = btn.dataset.link.split('|');
                    const score = parseFloat(btn.dataset.score || '0');
                    createConnection(sourceId, targetId, { reason: 'fuzzy-match', score });
                    showToast(' Linked records');
                };
            });

            container.querySelectorAll('[data-dismiss]').forEach(btn => {
                btn.onclick = () => {
                    btn.closest('.fuzzy-match-row').remove();
                };
            });
        }

        function openFuzzyPanel() {
            renderFuzzyPanel();
            document.getElementById('fuzzyMatchPanel').classList.add('open');
        }

        function closeFuzzyPanel() {
            document.getElementById('fuzzyMatchPanel').classList.remove('open');
        }

        function validateConnectionPayload(connection) {
            if (!connection?.formatId) {
                throw new Error('Connections must reference a connection format');
            }

            const format = findConnectionFormat(connection.formatId);
            if (!format) {
                throw new Error('Referenced connection format not found');
            }

            if (!connection?.subject || !connection?.operand) {
                throw new Error('Connections require both subject and operand');
            }
            const { subject, operand } = connection;
            if (!subject.type || !subject.id || !operand.type || !operand.id) {
                throw new Error('Connections require typed entity references');
            }

            const subjectWorld = deriveWorldIdForEntity(subject);
            const operandWorld = deriveWorldIdForEntity(operand);
            const worldMismatch = subjectWorld && operandWorld && subjectWorld !== operandWorld;
            if (worldMismatch) {
                throw new Error('Connections must stay within the same world');
            }

            const params = connection.params || {};
            if (params === null || typeof params !== 'object' || Array.isArray(params)) {
                throw new Error('Connection params must be an object');
            }

            format.requiredParams.forEach(param => {
                if (!(param in params)) {
                    throw new Error(`Missing required param: ${param}`);
                }
            });

            const worldId = connection.worldId || subjectWorld || operandWorld || state.currentWorldId;
            if (format.worldId && worldId && format.worldId !== worldId) {
                throw new Error('Connection must use a format from the same world');
            }

            return {
                ...connection,
                params,
                worldId,
                formatId: format.id,
                operator: format.operator,
                mode: format.mode
            };
        }

        function addConnection(conn) {
            let normalized;
            try {
                normalized = validateConnectionPayload(conn);
            } catch (error) {
                console.error(error);
                showToast(` ${error.message || 'Unable to create connection'}`);
                return null;
            }

            const connectionId = conn.id || `conn_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            const payload = {
                ...normalized,
                id: connectionId,
                createdAt: normalized.createdAt || new Date().toISOString()
            };

            state.connections.set(connectionId, payload);
            registerEntity({ id: connectionId, type: 'Connection', worldId: payload.worldId, subject: payload.subject, operand: payload.operand });

            const summary = `Connected ${renderEntityLabel(payload.subject)} ${payload.mode || ''} ${renderEntityLabel(payload.operand)}`.trim();
            createEvent(
                'Create Connection',
                'CON',
                { type: 'Connection', id: connectionId },
                {
                    edge: payload,
                    summary
                },
                { frame: 'graph', scale: 'relationship' }
            );

            return connectionId;
        }

        function updateConnection(connectionId, updates = {}) {
            const existing = state.connections.get(connectionId);
            if (!existing) throw new Error(`Connection ${connectionId} not found`);

            const merged = validateConnectionPayload({
                ...existing,
                ...updates,
                id: connectionId
            });

            const updated = {
                ...existing,
                ...merged,
                updatedAt: new Date().toISOString()
            };

            state.connections.set(connectionId, updated);

            const summary = `Updated connection ${connectionId} (${renderEntityLabel(updated.subject)} ${updated.mode || ''} ${renderEntityLabel(updated.operand)})`;
            createEvent(
                'Update Connection',
                'CON',
                { type: 'Connection', id: connectionId },
                {
                    edge: updated,
                    summary
                },
                { frame: 'graph', scale: 'relationship' }
            );

            return updated;
        }

        function deleteConnection(connectionId) {
            const existing = state.connections.get(connectionId);
            if (!existing) throw new Error(`Connection ${connectionId} not found`);

            state.connections.delete(connectionId);

            const summary = `Removed connection ${renderEntityLabel(existing.subject)} ${existing.mode || ''} ${renderEntityLabel(existing.operand)}`;
            createEvent(
                'Delete Connection',
                'CON',
                { type: 'Connection', id: connectionId },
                {
                    edge: existing,
                    summary,
                    deleted: true
                },
                { frame: 'graph', scale: 'relationship' }
            );

            return existing;
        }

        function createConnection(sourceId, targetId, formatId = null, params = {}) {
            const resolvedFormatId = formatId || getDefaultConnectionFormatId('CON') || getDefaultConnectionFormatId();
            if (!resolvedFormatId) {
                showToast(' Add a connection format before creating connections');
                return null;
            }

            return addConnection({
                subject: { type: 'Record', id: sourceId },
                operand: { type: 'Record', id: targetId },
                formatId: resolvedFormatId,
                params
            });
        }

        // SIDEBAR
        function toggleSidebar() {
            const isMobile = window.matchMedia('(max-width: 1024px)').matches;
            if (isMobile) {
                state.sidebarOpenMobile = !state.sidebarOpenMobile;
            } else {
                state.sidebarCollapsed = !state.sidebarCollapsed;
            }
            applyResponsiveLayout();
        }

        function closeMobileSidebar() {
            if (!state.sidebarOpenMobile) return;
            state.sidebarOpenMobile = false;
            applyResponsiveLayout();
        }

        function toggleSetExpansion(setId) {
            if (state.expandedSets.has(setId)) {
                state.expandedSets.delete(setId);
            } else {
                state.expandedSets.add(setId);
            }
            renderSidebar();
        }

        function renderWorldSelector() {
            const select = document.getElementById('worldSelect');
            const label = document.getElementById('currentWorldLabel');
            const headerLabel = document.getElementById('currentWorldHeaderLabel');
            if (!select) return;

            select.innerHTML = '';
            state.worlds.forEach((world, id) => {
                const opt = document.createElement('option');
                opt.value = id;
                opt.textContent = world.name;
                select.appendChild(opt);
            });

            if (!state.currentWorldId && select.options.length > 0) {
                state.currentWorldId = select.options[0].value;
            }

            if (state.currentWorldId) {
                select.value = state.currentWorldId;
            }

            if (label) {
                const world = getWorld();
                label.textContent = world?.name || 'No world selected';
            }

            if (headerLabel) {
                const world = getWorld();
                headerLabel.textContent = world?.name || 'No world selected';
            }
        }

        function pruneTabsForWorld(worldId) {
            if (!worldId) return;

            state.openTabs = state.openTabs.filter(tab => {
                const set = state.sets.get(tab.setId);
                return set?.worldId === worldId;
            });
        }

        function switchWorld(worldId) {
            if (!worldId || !state.worlds.has(worldId)) return;
            state.currentWorldId = worldId;
            pruneTabsForWorld(worldId);
            const sets = getSetsForWorld(worldId);
            if (!sets.some(set => set.id === state.currentSetId)) {
                state.currentSetId = sets[0]?.id || null;
                state.currentViewId = null;
            }
            renderWorldSelector();
            renderSidebar();
            renderViewTabs();
            if (state.currentSetId) {
                switchSet(state.currentSetId, state.currentViewId);
            }
            syncUrlState();
        }

        function openAddWorldModal() {
            const input = document.getElementById('newWorldName');
            if (input) input.value = '';
            openModal('addWorldModal');
        }

        function openEntitiesPage() {
            state.currentSpecialView = 'entities';
            state.currentSetId = null;
            state.currentViewId = null;
            closeMobileSidebar();
            renderSidebar();
            renderCurrentView();
            updateMobileChrome();
            syncUrlState();
        }

        function saveWorldFromModal() {
            const input = document.getElementById('newWorldName');
            const name = input?.value.trim();
            if (!name) { showConfirm('Please enter a world name', () => {}); return; }
            const worldId = createWorld(name);
            switchWorld(worldId);
            closeModal('addWorldModal');
            showToast(' World created');
        }

        function openDefinitionsPage() {
            state.currentSpecialView = 'definitions';
            state.currentSetId = null;
            state.currentViewId = null;
            closeMobileSidebar();
            renderSidebar();
            renderCurrentView();
            updateMobileChrome();
            syncUrlState();
        }

        function openConnectionsPage() {
            state.currentSpecialView = 'connections';
            state.currentSetId = null;
            state.currentViewId = null;
            closeMobileSidebar();
            renderSidebar();
            renderCurrentView();
            updateMobileChrome();
            syncUrlState();
        }

        function renderSidebar() {
            const container = document.getElementById('setsList');
            container.innerHTML = '';

            renderWorldSelector();

            const definitionsBtn = document.getElementById('definitionsNavBtn');
            const connectionsBtn = document.getElementById('connectionsNavBtn');
            const entitiesBtn = document.getElementById('entitiesNavBtn');
            if (entitiesBtn) entitiesBtn.classList.toggle('active', state.currentSpecialView === 'entities');
            if (definitionsBtn) definitionsBtn.classList.toggle('active', state.currentSpecialView === 'definitions');
            if (connectionsBtn) connectionsBtn.classList.toggle('active', state.currentSpecialView === 'connections');

            const setsForWorld = getSetsForWorld();
            if (setsForWorld.length === 0) {
                container.innerHTML = '<p class="text-sm text-gray-400">No sets in this world yet.</p>';
                return;
            }

            setsForWorld.forEach(set => {
                const setId = set.id;
                const isExpanded = state.expandedSets.has(setId);
                const isActive = setId === state.currentSetId;

                const setItem = document.createElement('div');
                setItem.className = `set-item ${isExpanded ? 'expanded' : ''}`;

                const setHeader = document.createElement('div');
                setHeader.className = `set-header ${isActive && !state.currentViewId ? 'active' : ''}`;
                setHeader.innerHTML = `
                    <span class="set-icon">${renderIcon(set.icon)}</span>
                    <span class="set-name">${set.name}</span>
                    <span class="set-expand-icon"></span>
                `;
                setHeader.onclick = (e) => { if (e.detail === 1) toggleSetExpansion(setId); };
                setHeader.ondblclick = (e) => { e.stopPropagation(); openAddSetModal(setId); };
                setHeader.oncontextmenu = (e) => { e.preventDefault(); e.stopPropagation(); openAddSetModal(setId); };
                setItem.appendChild(setHeader);

                if (isExpanded) {
                    const viewsList = document.createElement('div');
                    viewsList.className = 'views-list';

                    const orderedViews = Array.from(set.views.entries());
                    renderViewTree(orderedViews, setId, viewsList);

                    const addViewBtn = document.createElement('div');
                    addViewBtn.className = 'add-view-btn';
                    addViewBtn.textContent = '+ Add View';
                    addViewBtn.onclick = (e) => {
                        e.stopPropagation();
                        state.currentSetId = setId;
                        openAddViewModal(setId);
                    };
                    viewsList.appendChild(addViewBtn);

                    setItem.appendChild(viewsList);
                }

                container.appendChild(setItem);
            });

            renderViewTabs();
        }

        function renderViewTree(orderedViews, setId, container, parentId = null, depth = 0) {
            const normalizedParent = parentId || null;
            const childViews = orderedViews.filter(([_, view]) => (view.parentId || null) === normalizedParent);

            childViews.forEach(([viewId, view]) => {
                const viewItem = document.createElement('div');
                viewItem.className = `view-item ${viewId === state.currentViewId ? 'active' : ''}`;
                viewItem.style.paddingLeft = `${12 + depth * 16}px`;
                viewItem.innerHTML = `
                    <span class="view-item-icon">${renderIcon(view.icon || VIEW_TYPE_ICONS[view.type])}</span>
                    <span>${view.name}</span>
                `;
                viewItem.onclick = (e) => {
                    e.stopPropagation();
                    switchSet(setId, viewId);
                };
                viewItem.ondblclick = (e) => { e.stopPropagation(); openAddViewModal(setId, viewId); };
                viewItem.oncontextmenu = (e) => { e.preventDefault(); e.stopPropagation(); openAddViewModal(setId, viewId); };

                container.appendChild(viewItem);
                renderViewTree(orderedViews, setId, container, viewId, depth + 1);
            });
        }

        function isViewDescendant(set, startId, potentialAncestorId) {
            let currentParent = set.views.get(startId)?.parentId || null;
            while (currentParent) {
                if (currentParent === potentialAncestorId) return true;
                currentParent = set.views.get(currentParent)?.parentId || null;
            }
            return false;
        }

        function populateViewParentOptions(setId, excludeViewId = null, selectedParentId = null) {
            const select = document.getElementById('newViewParent');
            if (!select) return;

            select.innerHTML = '';
            const defaultOption = document.createElement('option');
            defaultOption.value = '';
            defaultOption.textContent = 'No parent';
            select.appendChild(defaultOption);

            const set = state.sets.get(setId);
            if (!set) return;

            const orderedViews = Array.from(set.views.entries());
            const renderOptions = (parentId = null, depth = 0) => {
                const children = orderedViews.filter(([id, view]) => (view.parentId || null) === (parentId || null));
                children.forEach(([id, view]) => {
                    if (excludeViewId && id === excludeViewId) return;
                    const option = document.createElement('option');
                    option.value = id;
                    option.innerHTML = `${' '.repeat(depth)}${renderIcon(view.icon || VIEW_TYPE_ICONS[view.type])} ${view.name}`;
                    select.appendChild(option);
                    renderOptions(id, depth + 1);
                });
            };

            renderOptions();
            select.value = selectedParentId || '';
        }

        function openAddViewModal(setId, viewId = null) {
            const set = state.sets.get(setId);
            if (!set) return;

            const titleEl = document.getElementById('addViewModalTitle');
            const saveBtn = document.getElementById('saveAddViewBtn');
            const nameInput = document.getElementById('newViewName');
            const iconInput = document.getElementById('newViewIcon');
            const keySelect = document.getElementById('keyCandidateSelect');
            const radioBlank = document.querySelector('input[name="viewCreationMode"][value="blank"]');
            const radioKey = document.querySelector('input[name="viewCreationMode"][value="key"]');

            state.currentSetId = setId;
            if (viewId) {
                const view = set.views.get(viewId);
                state.viewEditorContext = { setId, viewId };
                if (titleEl) titleEl.textContent = 'Edit View';
                if (saveBtn) saveBtn.textContent = 'Save';
                if (nameInput) nameInput.value = view?.name || '';
                if (iconInput) iconInput.value = extractIconToken(view?.icon || VIEW_TYPE_ICONS[view?.type]);
                populateViewParentOptions(setId, viewId, view?.parentId || null);
                if (radioBlank && radioKey) {
                    radioBlank.checked = view?.type !== 'KEY_DERIVED';
                    radioKey.checked = view?.type === 'KEY_DERIVED';
                }
                if (keySelect && view?.type === 'KEY_DERIVED' && view.key) {
                    const optionValue = `${view.key.setId}:${view.key.fieldId}`;
                    keySelect.innerHTML = `<option value="${optionValue}">${view.key.fieldId}</option>`;
                    keySelect.disabled = true;
                }
            } else {
                state.viewEditorContext = { setId, viewId: null };
                if (titleEl) titleEl.textContent = 'Create View';
                if (saveBtn) saveBtn.textContent = 'Create';
                if (nameInput) nameInput.value = '';
                if (iconInput) iconInput.value = 'ph-table';
                populateViewParentOptions(setId);
                const candidates = findKeyCandidates();
                if (keySelect) {
                    keySelect.disabled = candidates.length === 0;
                    keySelect.innerHTML = candidates.length === 0
                        ? '<option value="">No stable identity properties detected yet</option>'
                        : candidates.map(c => `<option value="${c.setId}:${c.fieldId}">${c.fieldName} (${state.sets.get(c.setId)?.name || 'Set'})</option>`).join('');
                }
                if (radioBlank && radioKey) {
                    radioBlank.checked = true;
                    radioKey.checked = false;
                }
            }

            syncIconSelector('newViewIcon');
            openModal('addViewModal');
        }

        function getTabKey(setId, viewId) {
            return `${setId || ''}::${viewId || ''}`;
        }

        function ensureOpenTab(setId, viewId) {
            const set = state.sets.get(setId);
            const view = set?.views.get(viewId);
            if (!set || !view) return;
            const key = getTabKey(setId, viewId);
            const exists = state.openTabs.some(tab => getTabKey(tab.setId, tab.viewId) === key);
            if (!exists) {
                state.openTabs.push({ setId, viewId });
            }
            renderViewTabs();
        }

        function closeViewTab(setId, viewId) {
            const key = getTabKey(setId, viewId);
            const index = state.openTabs.findIndex(tab => getTabKey(tab.setId, tab.viewId) === key);
            if (index === -1) return;
            const closingActive = state.currentSetId === setId && state.currentViewId === viewId;
            const fallback = closingActive ? (state.openTabs[index + 1] || state.openTabs[index - 1]) : null;
            state.openTabs.splice(index, 1);
            renderViewTabs();

            if (closingActive) {
                if (fallback) {
                    switchSet(fallback.setId, fallback.viewId);
                } else {
                    state.currentSetId = null;
                    state.currentViewId = null;
                    renderSidebar();
                    renderCurrentView();
                    updateMobileChrome();
                }
            }
        }

        function reorderOpenTabs(dragKey, targetKey, position) {
            const fromIndex = state.openTabs.findIndex(tab => getTabKey(tab.setId, tab.viewId) === dragKey);
            const targetIndex = state.openTabs.findIndex(tab => getTabKey(tab.setId, tab.viewId) === targetKey);
            if (fromIndex === -1 || targetIndex === -1 || dragKey === targetKey) return;

            const [dragged] = state.openTabs.splice(fromIndex, 1);
            const adjustedTarget = fromIndex < targetIndex ? targetIndex - 1 : targetIndex;
            const insertIndex = position === 'before' ? adjustedTarget : adjustedTarget + 1;
            state.openTabs.splice(insertIndex, 0, dragged);
            renderViewTabs();
        }

        function clearTabDropIndicators() {
            document.querySelectorAll('.view-tab').forEach(tab => {
                tab.classList.remove('tab-drop-before', 'tab-drop-after', 'tab-being-dragged');
            });
        }

        function handleTabDragStart(event, tab) {
            const key = getTabKey(tab.setId, tab.viewId);
            tabDragState.draggingKey = key;
            tabDragState.dropKey = null;
            tabDragState.dropPosition = null;
            event.dataTransfer.effectAllowed = 'move';
            event.dataTransfer.setData('text/plain', key);
            event.currentTarget.classList.add('tab-being-dragged');
        }

        function handleTabDragOver(event, targetTab) {
            if (!tabDragState.draggingKey) return;
            event.preventDefault();

            const targetKey = getTabKey(targetTab.setId, targetTab.viewId);
            if (targetKey === tabDragState.draggingKey) return;

            const rect = event.currentTarget.getBoundingClientRect();
            const position = event.clientX < rect.left + rect.width / 2 ? 'before' : 'after';
            clearTabDropIndicators();
            event.currentTarget.classList.add(position === 'before' ? 'tab-drop-before' : 'tab-drop-after');
            tabDragState.dropKey = targetKey;
            tabDragState.dropPosition = position;
        }

        function finalizeTabDrag() {
            clearTabDropIndicators();
            tabDragState.draggingKey = null;
            tabDragState.dropKey = null;
            tabDragState.dropPosition = null;
        }

        function handleTabDrop(event, targetTab) {
            if (!tabDragState.draggingKey) return;
            event.preventDefault();
            const targetKey = getTabKey(targetTab.setId, targetTab.viewId);
            const position = tabDragState.dropPosition || 'after';
            reorderOpenTabs(tabDragState.draggingKey, targetKey, position);
            finalizeTabDrag();
        }

        function renderViewTabs() {
            const container = document.getElementById('viewTabs');
            const surface = document.getElementById('viewSurface');
            if (!container) return;

            const validatedTabs = [];
            state.openTabs.forEach(tab => {
                const set = state.sets.get(tab.setId);
                const view = set?.views.get(tab.viewId);
                if (set && view) validatedTabs.push(tab);
            });
            state.openTabs = validatedTabs;

            if (state.openTabs.length === 0) {
                container.innerHTML = '';
                container.classList.add('hidden');
                if (state.currentSpecialView) {
                    surface?.classList.remove('hidden');
                } else {
                    surface?.classList.add('hidden');
                }
                return;
            }

            container.classList.remove('hidden');
            surface?.classList.remove('hidden');
            container.innerHTML = '';

            state.openTabs.forEach((tab, index) => {
                const set = state.sets.get(tab.setId);
                const view = set?.views.get(tab.viewId);
                if (!set || !view) return;
                const isActive = state.currentSetId === tab.setId && state.currentViewId === tab.viewId;
                const tabKey = getTabKey(tab.setId, tab.viewId);

                const tabEl = document.createElement('div');
                tabEl.className = `view-tab ${isActive ? 'active' : ''}`;
                tabEl.dataset.tabKey = tabKey;
                tabEl.draggable = true;
                tabEl.onclick = () => switchSet(tab.setId, tab.viewId);
                tabEl.ondragstart = (e) => handleTabDragStart(e, tab);
                tabEl.ondragover = (e) => handleTabDragOver(e, tab);
                tabEl.ondragleave = () => clearTabDropIndicators();
                tabEl.ondrop = (e) => handleTabDrop(e, tab);
                tabEl.ondragend = finalizeTabDrag;

                const iconSpan = document.createElement('span');
                iconSpan.className = 'view-tab-icon';
                iconSpan.innerHTML = renderIcon(view.icon || VIEW_TYPE_ICONS[view.type]);

                const textWrap = document.createElement('div');
                textWrap.className = 'view-tab-text';
                textWrap.innerHTML = `
                    <span class="view-tab-name">${view.name}</span>
                    <span class="view-tab-meta">${set.name}</span>
                `;

                const actions = document.createElement('div');
                actions.className = 'view-tab-actions';

                const closeBtn = document.createElement('button');
                closeBtn.className = 'view-tab-btn';
                closeBtn.innerHTML = '<i class="ph ph-x"></i>';
                closeBtn.onclick = (e) => { e.stopPropagation(); closeViewTab(tab.setId, tab.viewId); };

                actions.appendChild(closeBtn);

                tabEl.appendChild(iconSpan);
                tabEl.appendChild(textWrap);
                tabEl.appendChild(actions);

                container.appendChild(tabEl);
            });
        }

        function switchSet(setId, viewId) {
            const set = state.sets.get(setId);
            if (!set) return;
            if (set.worldId && state.currentWorldId !== set.worldId) {
                state.currentWorldId = set.worldId;
                renderWorldSelector();
            }
            state.currentSpecialView = null;
            state.currentSetId = setId;
            state.currentViewId = viewId;
            if (!viewId && set.views.size > 0) {
                state.currentViewId = Array.from(set.views.keys())[0];
            }
            if (state.currentViewId) ensureOpenTab(state.currentSetId, state.currentViewId);
            closeMobileSidebar();
            renderSidebar();
            renderViewTabs();
            renderCurrentView();
            updateMobileChrome();
            syncUrlState();
        }

        function getCurrentSet() { return state.sets.get(state.currentSetId); }
        function getCurrentView() { const set = getCurrentSet(); return set?.views.get(state.currentViewId); }
        function getCurrentProfile() { const set = getCurrentSet(); return set?.profiles.get(state.currentProfileId); }

        // VIEW SWITCHING
        function switchViewType(type) {
            const view = getCurrentView();
            if (!view) return;
            view.type = type;

            renderCurrentView();
            updateMobileChrome();
        }

        function renderCurrentView() {
            const container = document.getElementById('viewContainer');
            if (state.currentSpecialView === 'entities') {
                renderEntitiesPage();
                updateMobileChrome();
                return;
            }
            if (state.currentSpecialView === 'definitions') {
                renderDefinitionsPage();
                updateMobileChrome();
                return;
            }

            if (state.currentSpecialView === 'connections') {
                renderConnectionsPage();
                updateMobileChrome();
                return;
            }

            const view = getCurrentView();
            if (!view) {
                if (container) container.innerHTML = '<div class="p-6 text-sm text-gray-500">Select a view to get started.</div>';
                return;
            }

            ensureViewDefaults(view);

            updateMobileChrome();

            switch(view.type) {
                case 'grid':
                    renderGridView();
                    break;
                case 'card':
                    renderCardView();
                    break;
                case 'kanban':
                    renderKanbanView();
                    break;
                case 'graph':
                    renderGraphView();
                    break;
                case 'KEY_DERIVED':
                    renderKeyDerivedView();
                    break;
            }
        }

        function ensureViewDefaults(view) {
            if (!view.icon) view.icon = VIEW_TYPE_ICONS[view.type] || 'ph-note';
            if (!view.sorts) view.sorts = [];
            if (!view.columnRules) view.columnRules = {};
            if (typeof view.showRecordId === 'undefined') view.showRecordId = false;
        }

        function syncSelectionState(visibleRecords = []) {
            const set = getCurrentSet();
            if (!set) return;

            const visibleIds = visibleRecords.map(r => r.id);
            const validIds = new Set(visibleIds.length ? visibleIds : Array.from(set.records.keys()));
            state.selectedRecordIds = new Set(
                [...(state.selectedRecordIds || new Set())].filter(id => validIds.has(id))
            );

            if (state.selectedRecordIds.size === 0) state.lastSelectedRecordId = null;
        }

        function handleRecordSelection(recordId, isRange, orderedRecords = []) {
            const visibleIds = orderedRecords.map(r => r.id);
            if (!state.selectedRecordIds) state.selectedRecordIds = new Set();

            if (isRange && state.lastSelectedRecordId && visibleIds.includes(state.lastSelectedRecordId)) {
                const startIndex = visibleIds.indexOf(state.lastSelectedRecordId);
                const endIndex = visibleIds.indexOf(recordId);
                if (startIndex >= 0 && endIndex >= 0) {
                    const [from, to] = startIndex < endIndex ? [startIndex, endIndex] : [endIndex, startIndex];
                    for (let i = from; i <= to; i++) {
                        state.selectedRecordIds.add(visibleIds[i]);
                    }
                }
            } else {
                if (state.selectedRecordIds.has(recordId)) state.selectedRecordIds.delete(recordId);
                else state.selectedRecordIds.add(recordId);
                state.lastSelectedRecordId = recordId;
            }

            updateSelectionUI(orderedRecords);
        }

        function updateSelectionUI(visibleRecords = []) {
            const rows = document.querySelectorAll('#tableBody tr');
            rows.forEach(row => {
                const id = row.dataset.recordId;
                const isSelected = state.selectedRecordIds?.has(id);
                row.classList.toggle('row-selected', !!isSelected);
                const checkbox = row.querySelector('input[data-row-select]');
                if (checkbox) checkbox.checked = !!isSelected;
            });

            const visibleIds = visibleRecords.map(r => r.id);
            const selectedVisibleCount = visibleIds.filter(id => state.selectedRecordIds?.has(id)).length;
            const selectAllCheckbox = document.getElementById('selectAllRows');
            if (selectAllCheckbox) {
                const allSelected = visibleIds.length > 0 && selectedVisibleCount === visibleIds.length;
                selectAllCheckbox.checked = allSelected;
                selectAllCheckbox.indeterminate = selectedVisibleCount > 0 && !allSelected;
            }

            const indicator = document.getElementById('selectionIndicator');
            const countEl = document.getElementById('selectedCount');
            if (indicator && countEl) {
                const count = state.selectedRecordIds?.size || 0;
                indicator.classList.toggle('hidden', count === 0);
                countEl.textContent = count;
            }

            const deleteBtn = document.getElementById('deleteSelectedBtn');
            if (deleteBtn) deleteBtn.disabled = !state.selectedRecordIds || state.selectedRecordIds.size === 0;
        }

        function handleDeleteSelectedRecords() {
            const set = getCurrentSet();
            if (!set || !state.selectedRecordIds || state.selectedRecordIds.size === 0) return;

            const ids = [...state.selectedRecordIds].filter(id => set.records.has(id));
            if (ids.length === 0) return;

            const message = `Are you sure you want to delete ${ids.length} selected record${ids.length === 1 ? '' : 's'}? ` +
                'All changes are reversible while within your retention window (future thresholds may limit recovery).';

            showConfirm(message, () => {
                ids.forEach(recordId => {
                    set.records.delete(recordId);
                    createEvent(
                        'Delete Record',
                        'NUL',
                        { type: 'Record', id: recordId, setId: set.id },
                        { setId: set.id, recordId, summary: 'Record deleted' }
                    );
                });

                state.selectedRecordIds.clear();
                state.lastSelectedRecordId = null;
                renderCurrentView();
                showToast(' Selected records deleted (reversible while within retention)');
            });
        }

        function getRecordIdFieldDefinition() {
            return { id: '__recordId', name: 'Record ID', type: 'RECORD_ID', width: '200' };
        }

        function applyColumnWidth(fieldId, width) {
            const normalizedWidth = clampColumnWidth(width);
            const widthPx = `${normalizedWidth}px`;
            const set = getCurrentSet();
            const field = set?.schema.find(f => f.id === fieldId);
            if (field) field.width = widthPx;

            document.querySelectorAll(`[data-field-id="${fieldId}"]`).forEach(el => {
                el.style.width = widthPx;
            });

            const table = document.getElementById('dataTable');
            if (table && set) {
                const totalWidth = set.schema.reduce((sum, f) => sum + getFieldWidth(f), 0);
                table.style.minWidth = `${Math.max(totalWidth, 600)}px`;
            }
        }

        function addColumnResizer(element, field) {
            const existingResizer = element.querySelector('.column-resizer');
            if (existingResizer) return;

            const resizer = document.createElement('div');
            resizer.className = 'column-resizer';
            element.appendChild(resizer);

            let startX = 0;
            let startWidth = getFieldWidth(field);

            const onMouseMove = (event) => {
                const delta = event.clientX - startX;
                applyColumnWidth(field.id, startWidth + delta);
            };

            const onMouseUp = () => {
                document.body.classList.remove('resizing');
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
            };

            resizer.addEventListener('mousedown', (event) => {
                event.stopPropagation();
                event.preventDefault();
                startX = event.clientX;
                startWidth = getFieldWidth(field);
                document.body.classList.add('resizing');
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            });
        }

        function getPointerPosition(event) {
            if (!event) return { clientX: 0, clientY: 0 };
            if (event.touches && event.touches.length > 0) {
                return { clientX: event.touches[0].clientX, clientY: event.touches[0].clientY };
            }
            if (event.changedTouches && event.changedTouches.length > 0) {
                return { clientX: event.changedTouches[0].clientX, clientY: event.changedTouches[0].clientY };
            }
            return { clientX: event.clientX, clientY: event.clientY };
        }

        function createColumnGhost(element, position) {
            const ghost = document.createElement('div');
            ghost.className = 'column-drag-ghost';
            ghost.style.width = `${element.offsetWidth}px`;
            ghost.innerHTML = element.innerHTML;
            ghost.style.left = `${position.clientX - columnDragState.offsetX}px`;
            ghost.style.top = `${position.clientY - columnDragState.offsetY}px`;
            document.body.appendChild(ghost);
            return ghost;
        }

        function clearColumnDropIndicators() {
            document.querySelectorAll('#tableHeader .column-header').forEach(header => {
                header.classList.remove('column-drop-before', 'column-drop-after');
            });
        }

        function updateColumnDropTarget(clientX) {
            const headers = Array.from(document.querySelectorAll('#tableHeader .column-header'));
            clearColumnDropIndicators();

            const target = headers.find(h => {
                const rect = h.getBoundingClientRect();
                return clientX >= rect.left && clientX <= rect.right;
            });

            if (!target || target.dataset.fieldId === columnDragState.draggedFieldId) {
                columnDragState.dropFieldId = null;
                columnDragState.dropPosition = null;
                return;
            }

            const rect = target.getBoundingClientRect();
            const position = clientX < rect.left + rect.width / 2 ? 'before' : 'after';
            target.classList.add(position === 'before' ? 'column-drop-before' : 'column-drop-after');
            columnDragState.dropFieldId = target.dataset.fieldId;
            columnDragState.dropPosition = position;
        }

        function reorderSchemaField(draggedFieldId, targetFieldId, position) {
            const set = getCurrentSet();
            if (!set) return;

            const fromIndex = set.schema.findIndex(f => f.id === draggedFieldId);
            let targetIndex = set.schema.findIndex(f => f.id === targetFieldId);
            if (fromIndex === -1 || targetIndex === -1) return;

            const [field] = set.schema.splice(fromIndex, 1);
            if (fromIndex < targetIndex) targetIndex -= 1;
            const insertIndex = position === 'after' ? targetIndex + 1 : targetIndex;
            set.schema.splice(insertIndex, 0, field);
        }

        function endColumnDrag() {
            resetColumnGrabState(columnDragState.sourceElement);
            document.body.classList.remove('column-dragging');
            document.removeEventListener('mousemove', handleColumnDragMove);
            document.removeEventListener('touchmove', handleColumnDragMove);
            document.removeEventListener('mouseup', endColumnDrag);
            document.removeEventListener('touchend', endColumnDrag);
            document.removeEventListener('touchcancel', endColumnDrag);

            if (columnDragState.ghost) columnDragState.ghost.remove();
            if (columnDragState.sourceElement) columnDragState.sourceElement.classList.remove('column-being-dragged');
            clearColumnDropIndicators();

            if (columnDragState.draggedFieldId && columnDragState.dropFieldId) {
                reorderSchemaField(columnDragState.draggedFieldId, columnDragState.dropFieldId, columnDragState.dropPosition);
                renderCurrentView();
            }

            columnDragState.draggedFieldId = null;
            columnDragState.dropFieldId = null;
            columnDragState.dropPosition = null;
            columnDragState.ghost = null;
            columnDragState.sourceElement = null;

            setTimeout(() => { columnDragState.preventClick = false; }, 30);
        }

        function handleColumnDragMove(event) {
            if (!columnDragState.draggedFieldId || !columnDragState.ghost) return;
            if (event.cancelable) event.preventDefault();
            const position = getPointerPosition(event);
            columnDragState.ghost.style.left = `${position.clientX - columnDragState.offsetX}px`;
            columnDragState.ghost.style.top = `${position.clientY - columnDragState.offsetY}px`;
            updateColumnDropTarget(position.clientX);
        }

        function startColumnDrag(startPosition, element, field) {
            columnDragState.timer = null;
            columnDragState.holdReady = false;
            columnDragState.draggedFieldId = field.id;
            columnDragState.sourceElement = element;
            columnDragState.preventClick = true;

            const rect = element.getBoundingClientRect();
            columnDragState.offsetX = startPosition.clientX - rect.left;
            columnDragState.offsetY = startPosition.clientY - rect.top;

            columnDragState.ghost = createColumnGhost(element, startPosition);
            element.classList.add('column-being-dragged');
            document.body.classList.add('column-dragging');

            document.addEventListener('mousemove', handleColumnDragMove);
            document.addEventListener('touchmove', handleColumnDragMove, { passive: false });
            document.addEventListener('mouseup', endColumnDrag);
            document.addEventListener('touchend', endColumnDrag);
            document.addEventListener('touchcancel', endColumnDrag);
        }

        function resetColumnGrabState(element) {
            if (columnDragState.holdTimer) {
                clearTimeout(columnDragState.holdTimer);
                columnDragState.holdTimer = null;
            }
            columnDragState.holdReady = false;
            if (element) element.classList.remove('column-grab-ready');
            document.body.classList.remove('column-grab-ready');
        }

        function setupColumnDragInteractions(element, field) {
            let pointerActive = false;
            let dragStarted = false;
            let startPosition = null;

            const handlePointerDown = (event) => {
                if (event.button !== undefined && event.button !== 0) return;
                if (event.target.closest('.column-resizer')) return;
                pointerActive = true;
                dragStarted = false;
                startPosition = getPointerPosition(event);
                resetColumnGrabState(element);
                columnDragState.holdTimer = setTimeout(() => {
                    if (!pointerActive || dragStarted) return;
                    columnDragState.holdReady = true;
                    element.classList.add('column-grab-ready');
                    document.body.classList.add('column-grab-ready');
                }, 180);
            };

            const handlePointerMove = (event) => {
                if (!pointerActive || dragStarted) return;
                const position = getPointerPosition(event);
                const deltaX = Math.abs(position.clientX - startPosition.clientX);
                const deltaY = Math.abs(position.clientY - startPosition.clientY);
                if (!columnDragState.holdReady) {
                    if (deltaX > 6 || deltaY > 6) resetColumnGrabState(element);
                    return;
                }
                if (deltaX > 6 || deltaY > 6) {
                    dragStarted = true;
                    resetColumnGrabState(element);
                    startColumnDrag(position, element, field);
                }
            };

            const resetPointerState = () => {
                pointerActive = false;
                dragStarted = false;
                resetColumnGrabState(element);
                startPosition = null;
            };

            element.addEventListener('mousedown', handlePointerDown);
            element.addEventListener('touchstart', handlePointerDown);
            element.addEventListener('mousemove', handlePointerMove);
            element.addEventListener('touchmove', handlePointerMove, { passive: false });
            element.addEventListener('mouseup', resetPointerState);
            element.addEventListener('mouseleave', resetPointerState);
            element.addEventListener('touchend', resetPointerState);
            element.addEventListener('touchcancel', resetPointerState);
        }

        // GRID VIEW
        function renderGridView() {
            const set = getCurrentSet();
            if (!set) return;

            const previousSelection = state.selectedCell
                ? { recordId: state.selectedCell.recordId, fieldId: state.selectedCell.fieldId }
                : state.lastSelectedCell;
            state.selectedCell = null;
            state.editingCell = null;

            const view = getCurrentView();
            const profile = getCurrentProfile();
            const schema = set.schema.filter(f =>
                !profile || profile.visibleFields.length === 0 || profile.visibleFields.includes(f.id)
            );

            const recordIdField = view.showRecordId ? getRecordIdFieldDefinition() : null;
            const tableSchema = recordIdField ? [recordIdField, ...schema] : schema;

            let records = Array.from(set.records.values());
            if (view && view.filters.length > 0) records = applyFilterGroups(records, view.filters, schema);
            if (view?.sorts?.length) records = applySorts(records, view.sorts, tableSchema);

            const recordCount = records.length;
            const recordLabel = recordCount === 1 ? 'record' : 'records';

            syncSelectionState(records);

            const container = document.getElementById('viewContainer');
            container.innerHTML = `
                <div class="view-stage-header">
                    <div class="view-stage-title">
                        <span class="view-stage-pill">${set.name}</span>
                        <div class="min-w-0">
                            <div class="view-stage-name">${view.name}</div>
                            <div class="view-stage-sub">Grid view  ${recordCount} ${recordLabel}</div>
                        </div>
                    </div>
                    ${renderViewActions()}
                </div>
                <div class="view-stage-body">
                    <div class="view-table-shell">
                        <div class="table-scroll">
                            <table id="dataTable" class="border-collapse">
                                <thead><tr id="tableHeader"></tr></thead>
                                <tbody id="tableBody"></tbody>
                            </table>
                        </div>
                        <div class="table-footer">
                            <span class="record-counter" id="recordCounter">${recordCount} ${recordLabel}</span>
                        </div>
                    </div>
                </div>
            `;

            const headerRow = document.getElementById('tableHeader');
            const selectAllHeader = document.createElement('th');
            selectAllHeader.className = 'column-header selection-header';
            selectAllHeader.innerHTML = `<input type="checkbox" id="selectAllRows" aria-label="Select all rows">`;
            headerRow.appendChild(selectAllHeader);

            tableSchema.forEach(field => {
                const th = document.createElement('th');
                th.className = 'column-header';
                th.dataset.type = field.type;
                th.dataset.fieldId = field.id;
                const width = `${getFieldWidth(field)}px`;
                th.style.width = width;
                const sortIndex = view?.sorts?.findIndex(s => s.fieldId === field.id) ?? -1;
                const sortConfig = sortIndex >= 0 ? view.sorts[sortIndex] : null;
                const directionIcon = sortConfig ? (sortConfig.direction === 'desc' ? '' : '') : '';
                const indicatorClass = sortConfig ? 'sort-indicator' : 'sort-indicator muted';
                const orderBadge = sortConfig ? `<span class="order-badge">${sortIndex + 1}</span>` : '';
                th.innerHTML = `<span>${field.name}</span><span class="${indicatorClass}"><span class="direction-icon">${directionIcon}</span>${orderBadge}</span>`;
                th.onclick = () => {
                    if (columnDragState.preventClick) return;
                    toggleColumnSort(field.id);
                };
                addColumnResizer(th, field);
                setupColumnDragInteractions(th, field);
                th.oncontextmenu = (e) => { e.preventDefault(); showColumnMenu(e, field); };
                headerRow.appendChild(th);
            });

            const table = document.getElementById('dataTable');
            const minimumTableWidth = tableSchema.reduce((sum, field) => sum + getFieldWidth(field), 0);
            table.style.minWidth = `${Math.max(minimumTableWidth, 600)}px`;

            const tbody = document.getElementById('tableBody');
            records.forEach((record, index) => {
                const tr = document.createElement('tr');
                tr.dataset.recordId = record.id;
                tr.ondblclick = () => openExpandedRecord(record.id);

                tr.onclick = (event) => {
                    if (event.defaultPrevented) return;

                    const interactiveTarget = event.target.closest(
                        'button, a, input, select, textarea, label, [contenteditable="true"], .cell-editing'
                    );
                    if (interactiveTarget) return;

                    handleRecordSelection(record.id, event.shiftKey, records);
                };

                const selectTd = document.createElement('td');
                selectTd.className = 'row-select-cell';
                const checkboxId = `select-${record.id}`;
                selectTd.innerHTML = `<input type="checkbox" data-row-select id="${checkboxId}" aria-label="Select record ${record.id}">`;
                const rowCheckbox = selectTd.querySelector('input');
                rowCheckbox.checked = state.selectedRecordIds?.has(record.id);
                rowCheckbox.onchange = (event) => {
                    event.stopPropagation();
                    handleRecordSelection(record.id, event.shiftKey, records);
                };
                tr.appendChild(selectTd);

                tableSchema.forEach(field => {
                    const td = document.createElement('td');
                    const isRecordIdColumn = field.id === '__recordId';
                    td.className = isRecordIdColumn ? 'cell-static' : 'cell-editable';
                    td.dataset.recordId = record.id;
                    td.dataset.fieldId = field.id;
                    td.style.width = `${getFieldWidth(field)}px`;
                    const value = record[field.id];
                    td.innerHTML = renderCellValue(value, field, record);
                    addColumnResizer(td, field);
                    if (isRecordIdColumn) {
                        td.onclick = (e) => { e.stopPropagation(); openExpandedRecord(record.id); };
                        td.ondblclick = (e) => { e.stopPropagation(); openExpandedRecord(record.id); };
                    } else if (field.type === 'CHECKBOX') {
                        td.onclick = (e) => {
                            e.stopPropagation();
                            const now = Date.now();
                            if (td._lastToggleTime && now - td._lastToggleTime < 250) return;
                            td._lastToggleTime = now;
                            toggleCheckbox(record.id, field.id);
                        };
                        td.ondblclick = (e) => {
                            e.stopPropagation();
                            openExpandedRecord(record.id);
                        };
                    } else {
                        td.onclick = (e) => {
                            e.stopPropagation();
                            handleCellClick(td, record.id, field);
                        };
                        td.ondblclick = (e) => {
                            e.stopPropagation();
                            openExpandedRecord(record.id);
                        };
                    }
                    if (!isRecordIdColumn) {
                        td.oncontextmenu = (e) => { e.preventDefault(); showCellMenu(e, record.id, field); };
                    }
                    tr.appendChild(td);
                });

                tbody.appendChild(tr);
            });

            if (previousSelection) {
                const match = tbody.querySelector(`[data-record-id="${previousSelection.recordId}"][data-field-id="${previousSelection.fieldId}"]`);
                if (match) {
                    selectCell(match, previousSelection.recordId, previousSelection.fieldId);
                }
            }

            wireViewStageActions();
            setupToolbarMenu();
        }

        function renderKeyDerivedView() {
            const view = getCurrentView();
            if (!view?.key) return renderGridView();

            const keyRef = view.key;
            const allItems = findAllItemsForKey(keyRef.setId, keyRef.fieldId);
            const grouped = groupByKeyValue(allItems, keyRef.fieldId);
            const rows = buildRowsFromGroups(grouped, view);

            const container = document.getElementById('viewContainer');
            container.innerHTML = `
                <div class="view-stage-header">
                    <div class="view-stage-title">
                        <span class="view-stage-pill">${state.sets.get(keyRef.setId)?.name || 'Key set'}</span>
                        <div class="min-w-0">
                            <div class="view-stage-name">${view.name}</div>
                            <div class="view-stage-sub">Generated key view  ${rows.length} collections</div>
                        </div>
                    </div>
                    ${renderViewActions()}
                </div>
                <div class="view-stage-body">
                    <div class="view-table-shell">
                        <div class="table-scroll">
                            <table id="dataTable" class="border-collapse">
                                <thead><tr id="tableHeader"></tr></thead>
                                <tbody id="tableBody"></tbody>
                            </table>
                        </div>
                        <div class="table-footer">
                            <span class="record-counter" id="recordCounter">${rows.length} collections</span>
                        </div>
                    </div>
                </div>
            `;

            const headerRow = document.getElementById('tableHeader');
            headerRow.innerHTML = '';
            const keyHeader = document.createElement('th');
            keyHeader.className = 'column-header';
            keyHeader.textContent = 'Identity Property';
            headerRow.appendChild(keyHeader);

            (view.schema || []).forEach(field => {
                const th = document.createElement('th');
                th.className = 'column-header';
                th.dataset.fieldId = field.id;
                th.textContent = field.name;
                headerRow.appendChild(th);
            });

            const tbody = document.getElementById('tableBody');
            rows.forEach(row => {
                const tr = document.createElement('tr');
                const identityCell = document.createElement('td');
                identityCell.textContent = row.keyValue;
                tr.appendChild(identityCell);

                (view.schema || []).forEach(field => {
                    const td = document.createElement('td');
                    td.className = 'cell-editable';
                    const value = row[field.id];
                    td.innerHTML = renderCellValue(value, field, row);
                    td.onclick = () => openObservationModal({ keyValue: row.keyValue, field, items: row.__sourceItems });
                    tr.appendChild(td);
                });

                tbody.appendChild(tr);
            });

            finalizeViewStage();
            updateSelectionUI(rows);
        }

        function renderCellValue(value, field, record) {
            if (value && typeof value === 'object' && value._sup) {
                return renderSuperpositionCell(value.value || []);
            }
            switch(field.type) {
                case 'TEXT': case 'LONG_TEXT': case 'EMAIL': case 'URL': case 'PHONE':
                    return value || '';
                case 'NUMBER':
                    return value ? Number(value).toLocaleString() : '';
                case 'CURRENCY':
                    return value ? new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD' }).format(value) : '';
                case 'DATE':
                    return value ? new Date(value).toLocaleDateString() : '';
                case 'CHECKBOX':
                    return value ? '' : '';
                case 'LINK_RECORD':
                    if (!value) return '';
                    const linkedName = getRecordDisplayName(value);
                    return `<button class="text-blue-600 hover:underline" onclick="event.stopPropagation(); openLinkedRecord('${value}')">${linkedName}</button>`;
                case 'SINGLE_SELECT':
                    if (!value) return '';
                    const color = field.config?.colors?.[value] || 'gray';
                    return `<span class="badge badge-${color}">${value}</span>`;
                case 'FORMULA':
                    if (record?.__formulaMeta?.[field.id]?.success) {
                        const meta = record.__formulaMeta[field.id];
                        return meta.preview || meta.result || '';
                    }
                    if (record?.__formulaMeta?.[field.id]?.error) {
                        const message = record.__formulaMeta[field.id].error.message;
                        return `<span class="text-red-600" title="${message}">${message}</span>`;
                    }
                    return value || '';
                case 'RECORD_ID':
                    return `<span class="font-mono text-xs text-gray-700">${record?.id || ''}</span>`;
                default:
                    return value || '';
            }
        }

        function openColumnRulesModal() {
            const modal = document.getElementById('columnRulesModal');
            const view = getCurrentView();
            if (!modal || !view) return;

            const fields = view.type === 'KEY_DERIVED' ? (view.schema || []) : getCurrentSet()?.schema || [];
            const fieldSelect = document.getElementById('columnRulesFieldSelect');
            fieldSelect.innerHTML = '';
            fields.forEach(f => {
                const opt = document.createElement('option');
                opt.value = f.id;
                opt.textContent = f.name;
                fieldSelect.appendChild(opt);
            });

            const ruleSelect = document.getElementById('columnRulesRuleSelect');
            const setPicker = document.getElementById('columnRulesSetPicker');
            const preferredSet = document.getElementById('columnRulesPreferredSet');
            preferredSet.innerHTML = '';
            state.sets.forEach(set => {
                const opt = document.createElement('option');
                opt.value = set.id;
                opt.textContent = set.name;
                preferredSet.appendChild(opt);
            });

            const currentRule = view.columnRules?.[fieldSelect.value] || { rule: 'sup_all' };
            ruleSelect.value = currentRule.rule || 'sup_all';
            preferredSet.value = currentRule.setId || '';
            setPicker.classList.toggle('hidden', ruleSelect.value !== 'prefer_set');

            const recordIdToggle = document.getElementById('recordIdVisibilityToggle');
            if (recordIdToggle) recordIdToggle.checked = !!view.showRecordId;

            updateColumnRulesSummary();
            openModal('columnRulesModal');
        }

        function updateColumnRulesSummary() {
            const view = getCurrentView();
            if (!view) return;
            const summary = document.getElementById('columnRulesSummary');
            const fieldSelect = document.getElementById('columnRulesFieldSelect');
            const ruleSelect = document.getElementById('columnRulesRuleSelect');
            const preferredSet = document.getElementById('columnRulesPreferredSet');
            const field = (view.schema || getCurrentSet()?.schema || []).find(f => f.id === fieldSelect.value);
            const ruleText = ruleSelect.options[ruleSelect.selectedIndex]?.textContent;
            const setName = preferredSet.value ? state.sets.get(preferredSet.value)?.name : null;
            summary.textContent = `${field?.name || 'Field'}  ${ruleText}${setName ? ` (${setName})` : ''}`;
        }

        function toggleRecordIdVisibility(isVisible) {
            const view = getCurrentView();
            if (!view) return;

            view.showRecordId = isVisible;
            createEvent(
                'View Schema Update',
                'SEG',
                { type: 'View', id: view.id, setId: view.key?.setId || state.currentSetId },
                { viewId: view.id, changes: { showRecordId: isVisible }, summary: isVisible ? 'Enabled Record ID column' : 'Hid Record ID column' },
                { scale: 'collection' }
            );

            renderCurrentView();
        }

        function saveColumnRule() {
            const view = getCurrentView();
            if (!view) return;
            const fieldId = document.getElementById('columnRulesFieldSelect').value;
            const rule = document.getElementById('columnRulesRuleSelect').value;
            const setId = document.getElementById('columnRulesPreferredSet').value || null;

            view.columnRules = view.columnRules || {};
            view.columnRules[fieldId] = { rule, ...(rule === 'prefer_set' ? { setId } : {}) };

            createEvent(
                'View Schema Update',
                'SEG',
                { type: 'View', id: view.id, setId: view.key?.setId || state.currentSetId },
                { viewId: view.id, changes: { columnRules: view.columnRules }, summary: 'Updated column rules' },
                { scale: 'collection' }
            );

            closeModal('columnRulesModal');
            renderCurrentView();
        }

        function deleteColumnRule() {
            const view = getCurrentView();
            if (!view) return;
            const fieldId = document.getElementById('columnRulesFieldSelect').value;
            if (view.columnRules?.[fieldId]) {
                delete view.columnRules[fieldId];
                createEvent(
                    'View Schema Update',
                    'SEG',
                    { type: 'View', id: view.id, setId: view.key?.setId || state.currentSetId },
                    { viewId: view.id, changes: { columnRules: view.columnRules }, summary: 'Cleared column rule' },
                    { scale: 'collection' }
                );
            }
            closeModal('columnRulesModal');
            renderCurrentView();
        }

        function renderSuperpositionCell(entries) {
            if (!Array.isArray(entries) || entries.length === 0) return '';
            const compact = entries.map(e => e?.val ?? '').filter(Boolean).join(' | ');
            const tooltip = entries.map(e => `${e?.val ?? ''}  ${e?.context?.source || 'observation'}`).join('\n');
            return `<span class="sup-chip" title="${tooltip}">${compact}</span>`;
        }

        // LEAN CONTEXT COMPARISON (Phase 2)
        function showQuickDiff(recordId, fieldId, event) {
            event?.stopPropagation();

            const set = getCurrentSet();
            if (!set || !state.leanContext) return;

            const record = set.records.get(recordId);
            const value = record?.[fieldId];

            if (!value?._sup || !value.value || value.value.length < 2) return;

            // Get contexts for comparison
            const contexts = value.value.slice(0, 2).map(() => state.leanContext.getFieldContext(record, fieldId));
            const diff = state.leanContext.explainContextDifference(contexts[0], contexts[1]);

            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black bg-opacity-20 flex items-center justify-center z-50';
            modal.onclick = (e) => e.target === modal && modal.remove();

            modal.innerHTML = `
                <div class="bg-white rounded-lg shadow-xl max-w-md p-4" onclick="event.stopPropagation()">
                    <div class="flex justify-between items-start mb-3">
                        <h4 class="font-semibold">Why Different?</h4>
                        <button onclick="this.closest('.fixed').remove()" class="text-gray-400 hover:text-gray-600"></button>
                    </div>
                    ${diff.diffs.length === 0 ? '<p class="text-gray-600">No significant differences found.</p>' : ''}
                    ${diff.diffs.map(d => `
                        <div class="text-sm mb-2">
                            <span class="font-medium">${d.label}:</span>
                            <div class="ml-4">
                                <div class="text-red-600">${d.a || '(not set)'}</div>
                                <div class="text-green-600">${d.b || '(not set)'}</div>
                            </div>
                        </div>
                    `).join('')}
                    <div class="mt-3 text-xs text-gray-600 border-t pt-2">
                        ${diff.compatible ? ' Can compare with caution' : ' Should not compare'}
                    </div>
                </div>
            `;

            document.body.appendChild(modal);
        }

        function getStabilityColor(tag) {
            const colors = {
                'emerging': 'yellow',
                'forming': 'gray',
                'stable': 'green'
            };
            return colors[tag] || 'gray';
        }

        // CARD VIEW
        function renderCardView() {
            const set = getCurrentSet();
            if (!set) return;

            const view = getCurrentView();
            let records = Array.from(set.records.values());
            if (view && view.filters.length > 0) records = applyFilterGroups(records, view.filters, set.schema);
            if (view?.sorts?.length) records = applySorts(records, view.sorts, set.schema);

            const stabilityToggle = state.leanContext ? `
                <label class="flex items-center gap-2 text-sm text-gray-700 bg-gray-50 border border-gray-200 px-3 py-2 rounded-lg">
                    <input type="checkbox" id="showStabilityToggle" ${view?.showStability ? 'checked' : ''}
                           onchange="toggleStabilityDisplay()">
                    <span>Show stability</span>
                </label>
            ` : '';

            const container = document.getElementById('viewContainer');
            container.innerHTML = `
                <div class="view-stage-header">
                    <div class="view-stage-title">
                        <span class="view-stage-pill">${set.name}</span>
                        <div class="min-w-0">
                            <div class="view-stage-name">${view.name}</div>
                            <div class="view-stage-sub">Card view  ${records.length} ${records.length === 1 ? 'record' : 'records'}</div>
                        </div>
                    </div>
                    ${renderViewActions(stabilityToggle)}
                </div>
                <div class="view-stage-body">
                    <div class="cards-grid" id="cardsGrid"></div>
                </div>`;

            const grid = document.getElementById('cardsGrid');
            records.forEach(record => {
                const card = document.createElement('div');
                card.className = 'card';
                card.onclick = () => openExpandedRecord(record.id);

                const primaryField = set.schema[0];
                const displayFields = set.schema.slice(1, 6);

                card.innerHTML = `
                    <div class="flex items-start justify-between mb-2">
                        <div class="card-title">${record[primaryField.id] || 'Untitled'}</div>
                        ${view?.showStability && state.leanContext ? `
                            <span class="badge badge-${getStabilityColor(state.leanContext.getRecordStability(record.id))} text-xs">
                                ${state.leanContext.getRecordStability(record.id)}
                            </span>
                        ` : ''}
                    </div>
                    ${displayFields.map(field => {
                        const value = record[field.id];
                        if (!value && value !== 0 && value !== false) return '';
                        return `
                            <div class="card-field">
                                <div class="card-field-label">${field.name}</div>
                                <div class="card-field-value">${renderCellValue(value, field, record)}</div>
                            </div>
                        `;
                    }).join('')}
                `;

                grid.appendChild(card);
            });

            finalizeViewStage();
        }

        function toggleStabilityDisplay() {
            const view = getCurrentView();
            if (!view) return;
            view.showStability = document.getElementById('showStabilityToggle')?.checked || false;
            renderCurrentView();
        }

        // KANBAN VIEW
        function renderKanbanView() {
            const set = getCurrentSet();
            const view = getCurrentView();
            if (!set || !view) return;

            const pickGroupingAction = `<button onclick="openKanbanConfig()" class="btn btn-secondary btn-sm">Pick grouping</button>`;
            const changeGroupingAction = `<button onclick="openKanbanConfig()" class="btn btn-secondary btn-sm">Change grouping</button>`;

            if (!view.kanbanGroupField) {
                const container = document.getElementById('viewContainer');
                container.innerHTML = `
                    <div class="view-stage-header">
                        <div class="view-stage-title">
                            <span class="view-stage-pill">${set.name}</span>
                            <div class="min-w-0">
                                <div class="view-stage-name">${view.name}</div>
                                <div class="view-stage-sub">Kanban view  Choose a grouping</div>
                            </div>
                        </div>
                        ${renderViewActions(pickGroupingAction)}
                    </div>
                    <div class="view-stage-body">
                        <div class="kanban-empty-state">
                            <div class="text-4xl mb-4"></div>
                            <p class="text-lg font-semibold mb-2">Configure Kanban Board</p>
                            <p class="mb-4">Select a single-select field to group your records</p>
                            <button onclick="openKanbanConfig()" class="btn btn-primary">Configure Kanban</button>
                        </div>
                    </div>
                `;
                finalizeViewStage();
                return;
            }
            
            const groupField = set.schema.find(f => f.id === view.kanbanGroupField);
            if (!groupField || groupField.type !== 'SINGLE_SELECT') {
                showToast(' Invalid kanban configuration');
                return;
            }
            
            let records = Array.from(set.records.values());
            if (view.filters.length > 0) records = applyFilterGroups(records, view.filters, set.schema);
            if (view?.sorts?.length) records = applySorts(records, view.sorts, set.schema);

            const recordCount = records.length;
            const recordLabel = recordCount === 1 ? 'record' : 'records';

            const container = document.getElementById('viewContainer');
            container.innerHTML = `
                <div class="view-stage-header">
                    <div class="view-stage-title">
                        <span class="view-stage-pill">${set.name}</span>
                        <div class="min-w-0">
                            <div class="view-stage-name">${view.name}</div>
                            <div class="view-stage-sub">Kanban view  ${groupField.name}  ${recordCount} ${recordLabel}</div>
                        </div>
                    </div>
                    ${renderViewActions(changeGroupingAction)}
                </div>
                <div class="view-stage-body">
                    <div class="kanban-board" id="kanbanBoard"></div>
                </div>
            `;

            const board = document.getElementById('kanbanBoard');
            const options = groupField.config.options || [];
            
            options.forEach(option => {
                const columnRecords = records.filter(r => r[groupField.id] === option);
                const column = createKanbanColumn(option, columnRecords, groupField);
                board.appendChild(column);
            });
            
            // Uncategorized column
            const uncategorized = records.filter(r => !r[groupField.id]);
            if (uncategorized.length > 0) {
                const column = createKanbanColumn('Uncategorized', uncategorized, groupField);
                board.appendChild(column);
            }

            finalizeViewStage();
        }

        function createKanbanColumn(title, records, groupField) {
            const column = document.createElement('div');
            column.className = 'kanban-column';
            column.dataset.value = title;
            
            const color = groupField.config?.colors?.[title] || 'gray';
            
            column.innerHTML = `
                <div class="kanban-column-header">
                    <div class="kanban-column-title">
                        <span class="badge badge-${color}">${title}</span>
                    </div>
                    <span class="kanban-column-count">${records.length}</span>
                </div>
                <div class="kanban-cards" data-column="${title}"></div>
            `;
            
            const cardsContainer = column.querySelector('.kanban-cards');
            
            // Enable drop
            cardsContainer.addEventListener('dragover', (e) => {
                e.preventDefault();
                column.classList.add('drag-over');
            });
            
            cardsContainer.addEventListener('dragleave', () => {
                column.classList.remove('drag-over');
            });
            
            cardsContainer.addEventListener('drop', (e) => {
                e.preventDefault();
                column.classList.remove('drag-over');
                
                if (state.draggedRecord) {
                    const newValue = title === 'Uncategorized' ? '' : title;
                    updateRecord(state.draggedRecord.id, groupField.id, newValue, state.draggedRecord[groupField.id]);
                    state.draggedRecord = null;
                    renderKanbanView();
                }
            });
            
            records.forEach(record => {
                const card = createKanbanCard(record);
                cardsContainer.appendChild(card);
            });
            
            return column;
        }

        function createKanbanCard(record) {
            const set = getCurrentSet();
            const card = document.createElement('div');
            card.className = 'kanban-card';
            card.draggable = true;
            card.dataset.recordId = record.id;
            
            const primaryField = set.schema[0];
            const displayFields = set.schema.slice(1, 4);
            
            card.innerHTML = `
                <div class="font-semibold mb-2">${record[primaryField.id] || 'Untitled'}</div>
                ${displayFields.map(field => {
                    const value = record[field.id];
                    if (!value && value !== 0 && value !== false) return '';
                    return `<div class="text-sm text-gray-600 mb-1">${renderCellValue(value, field, record)}</div>`;
                }).join('')}
            `;
            
            card.addEventListener('dragstart', (e) => {
                state.draggedRecord = record;
                card.classList.add('dragging');
            });
            
            card.addEventListener('dragend', () => {
                card.classList.remove('dragging');
            });
            
            card.onclick = (e) => {
                if (!card.classList.contains('dragging')) {
                    openExpandedRecord(record.id);
                }
            };
            
            return card;
        }

        function openKanbanConfig() {
            const set = getCurrentSet();
            const select = document.getElementById('kanbanGroupField');
            select.innerHTML = '<option value="">Select a field...</option>';
            
            set.schema.forEach(field => {
                if (field.type === 'SINGLE_SELECT') {
                    select.innerHTML += `<option value="${field.id}">${field.name}</option>`;
                }
            });
            
            const view = getCurrentView();
            if (view.kanbanGroupField) {
                select.value = view.kanbanGroupField;
            }
            
            openModal('kanbanConfigModal');
        }

        function saveKanbanConfig() {
            const fieldId = document.getElementById('kanbanGroupField').value;
            if (!fieldId) {
                showConfirm('Please select a field to group by', () => {});
                return;
            }

            const view = getCurrentView();
            view.kanbanGroupField = fieldId;

            closeModal('kanbanConfigModal');
            renderKanbanView();
            showToast(' Kanban configured');
        }

        // ENTITIES
        function groupEntitiesByType(entities = []) {
            const groups = new Map();
            entities.forEach(entity => {
                const key = entity.entityType || entity.type || 'Unknown';
                if (!groups.has(key)) groups.set(key, []);
                groups.get(key).push(entity);
            });
            return groups;
        }

        function renderEntityMembership(entity) {
            if (!entity?.memberRefs?.length) return '';
            const preview = entity.memberRefs.slice(0, 3)
                .map(ref => renderEntityLabel(ref))
                .join(', ');
            const remaining = entity.memberRefs.length > 3 ? ` +${entity.memberRefs.length - 3} more` : '';
            return `
                <div class="mt-2 text-xs text-gray-600 bg-gray-50 border border-gray-200 rounded-md px-3 py-2">
                    <div class="font-semibold text-gray-800 flex items-center gap-1">
                        <i class="ph ph-tree-structure"></i>
                        Entity table  ${entity.memberRefs.length} items
                    </div>
                    <div class="mt-1 text-gray-500">${preview}${remaining}</div>
                </div>
            `;
        }

        function renderEntityGroups(groupMap) {
            if (!groupMap?.size) return '<p class="text-sm text-gray-500">No entities yet. Reify a view or add one manually.</p>';

            return Array.from(groupMap.entries()).map(([groupKey, entities]) => {
                const reifiedCount = entities.filter(e => e.origin === 'reified').length;
                const manualCount = entities.filter(e => e.origin === 'manual').length;
                return `
                    <div class="border border-gray-200 rounded-lg p-4 bg-white shadow-sm">
                        <div class="flex items-start justify-between gap-3">
                            <div>
                                <div class="text-xs font-semibold uppercase tracking-wide text-gray-500">${groupKey}</div>
                                <div class="text-lg font-semibold text-gray-900">${entities.length} entr${entities.length === 1 ? 'y' : 'ies'}</div>
                                <div class="text-sm text-gray-500">${reifiedCount} reified  ${manualCount} direct</div>
                            </div>
                            <div class="text-right text-xs text-gray-500 leading-tight">
                                <div>Tracked in ${getWorld()?.name || 'world'}</div>
                                <div>Last updated ${new Date(Math.max(...entities.map(e => e.updatedAt || e.createdAt || Date.now()))).toLocaleString()}</div>
                            </div>
                        </div>
                        <div class="mt-3 space-y-2">
                            ${entities.map(entity => `
                                <div class="border border-gray-100 rounded-md p-3 bg-gray-50">
                                    <div class="flex items-center justify-between gap-2">
                                        <div class="min-w-0">
                                            <div class="text-sm font-semibold text-gray-800 truncate">${renderEntityLabel(entity)}</div>
                                            <div class="text-xs text-gray-500 flex flex-wrap items-center gap-2">
                                                <span class="inline-flex items-center gap-1"><i class="ph ph-tag"></i>${entity.type}</span>
                                                ${entity.origin ? `<span class="inline-flex items-center gap-1"><i class="ph ph-compass"></i>${entity.origin}</span>` : ''}
                                                ${entity.viewRef ? `<span class="inline-flex items-center gap-1 text-blue-600"><i class="ph ph-eye"></i>View: ${entity.viewRef.viewName || entity.viewRef.viewId}</span>` : ''}
                                            </div>
                                        </div>
                                        <div class="flex items-center gap-2 text-xs">
                                            ${entity.origin === 'manual' ? `<button class="text-red-500" data-entity-delete="${entity.id}">Delete</button>` : `<span class="text-gray-400" title="Reified entities are protected">Protected</span>`}
                                        </div>
                                    </div>
                                    ${renderEntityMembership(entity)}
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
            }).join('');
        }

        function resetEntityForm() {
            const form = document.getElementById('entityForm');
            if (!form) return;
            form.reset();
            state.entityFormState.editingId = null;
        }

        function handleEntityFormSubmit() {
            const form = document.getElementById('entityForm');
            if (!form) return;

            const id = form.querySelector('#entityId')?.value.trim();
            const type = form.querySelector('#entityKind')?.value.trim();
            const entityType = form.querySelector('#entityType')?.value.trim();
            const label = form.querySelector('#entityLabel')?.value.trim();
            const notes = form.querySelector('#entityNotes')?.value.trim();

            if (!id || !type) {
                showToast('Please provide both an entity id and type');
                return;
            }

            registerEntity({
                id,
                type,
                entityType: entityType || type,
                name: label || undefined,
                notes,
                origin: 'manual',
                createdAt: new Date().toISOString(),
                updatedAt: new Date().toISOString(),
                worldId: state.currentWorldId
            });

            showToast(' Entity captured');
            resetEntityForm();
            renderEntitiesPage(state.entityFormState.activeFilter || 'all');
        }

        function renderEntitiesPage(filterKey = 'all') {
            state.entityFormState.activeFilter = filterKey;

            const filters = {
                all: () => true,
                reified: entity => entity.origin === 'reified',
                manual: entity => entity.origin === 'manual',
                views: entity => entity.type === 'ViewEntity',
                records: entity => entity.type === 'Record'
            };

            const entities = getEntityView(filters[filterKey]);
            const grouped = groupEntitiesByType(entities);
            const container = document.getElementById('viewContainer');
            const reifiedCount = entities.filter(e => e.origin === 'reified').length;
            const manualCount = entities.filter(e => e.origin === 'manual').length;

            container.innerHTML = `
                <div class="view-stage-header">
                    <div class="view-stage-title">
                        <span class="view-stage-pill">${getWorld()?.name || 'Entities'}</span>
                        <div class="min-w-0">
                            <div class="view-stage-name">Entities</div>
                            <div class="view-stage-sub">${entities.length} tracked  ${grouped.size} types</div>
                        </div>
                    </div>
                </div>
                <div class="view-stage-body space-y-6">
                    <div class="flex flex-wrap items-center justify-between gap-3">
                        <div class="space-y-1">
                            <div class="font-semibold text-gray-900">Entity tools</div>
                            <p class="text-sm text-gray-500">Filter, review, and capture entities connected to your world.</p>
                        </div>
                        <div class="flex gap-2">
                            <button class="btn btn-primary btn-sm" id="openEntityFormBtn">${state.entityFormState.editingId ? 'Update Entity' : 'Add Entity'}</button>
                        </div>
                    </div>
                    <div class="flex flex-wrap gap-2">
                        ${['all','reified','manual','views','records'].map(key => `<button class="btn btn-secondary btn-sm ${filterKey === key ? 'btn-primary' : ''}" data-entity-filter="${key}">${key.charAt(0).toUpperCase() + key.slice(1)}</button>`).join('')}
                    </div>
                    <div class="grid grid-cols-1 md:grid-cols-3 gap-3">
                        <div class="p-4 rounded-lg border border-gray-200 bg-white shadow-sm">
                            <div class="text-xs font-semibold uppercase tracking-wide text-gray-500">Reified</div>
                            <div class="text-2xl font-bold text-gray-900">${reifiedCount}</div>
                            <div class="text-xs text-gray-500">Made persistent from views</div>
                        </div>
                        <div class="p-4 rounded-lg border border-gray-200 bg-white shadow-sm">
                            <div class="text-xs font-semibold uppercase tracking-wide text-gray-500">Direct</div>
                            <div class="text-2xl font-bold text-gray-900">${manualCount}</div>
                            <div class="text-xs text-gray-500">Added manually</div>
                        </div>
                        <div class="p-4 rounded-lg border border-gray-200 bg-white shadow-sm">
                            <div class="text-xs font-semibold uppercase tracking-wide text-gray-500">Types</div>
                            <div class="text-2xl font-bold text-gray-900">${grouped.size}</div>
                            <div class="text-xs text-gray-500">Entity families</div>
                        </div>
                    </div>
                    <div class="space-y-3">
                        ${renderEntityGroups(grouped)}
                    </div>
                    <div class="p-4 rounded-lg border border-gray-200 bg-white shadow-sm" id="entityFormCard">
                        <div class="flex items-center justify-between mb-3">
                            <div>
                                <div class="text-xs font-semibold uppercase tracking-wide text-gray-500">Add Entity</div>
                                <div class="text-sm text-gray-500">Capture a new entity type without duplicating data.</div>
                            </div>
                            ${state.entityFormState.editingId ? '<button class="btn btn-secondary btn-sm" id="resetEntityForm">Clear</button>' : ''}
                        </div>
                        <form id="entityForm" class="grid grid-cols-1 md:grid-cols-2 gap-3">
                            <div>
                                <label class="form-label">Entity Kind *</label>
                                <input id="entityKind" type="text" class="border rounded px-3 py-2 w-full" placeholder="Record, Observation, etc." />
                            </div>
                            <div>
                                <label class="form-label">Entity ID *</label>
                                <input id="entityId" type="text" class="border rounded px-3 py-2 w-full" placeholder="Unique identifier" />
                            </div>
                            <div>
                                <label class="form-label">Entity Type / Family</label>
                                <input id="entityType" type="text" class="border rounded px-3 py-2 w-full" placeholder="Grouping e.g. Questionable Observations" />
                            </div>
                            <div>
                                <label class="form-label">Display Label</label>
                                <input id="entityLabel" type="text" class="border rounded px-3 py-2 w-full" placeholder="Human readable name" />
                            </div>
                            <div class="md:col-span-2">
                                <label class="form-label">Notes</label>
                                <textarea id="entityNotes" class="border rounded px-3 py-2 w-full" rows="2" placeholder="Optional context or provenance"></textarea>
                            </div>
                            <div class="md:col-span-2 flex justify-end">
                                <button type="submit" id="entitySubmit" class="btn btn-primary">Capture Entity</button>
                            </div>
                        </form>
                    </div>
                </div>
            `;

            document.querySelectorAll('[data-entity-filter]').forEach(btn => {
                btn.onclick = () => renderEntitiesPage(btn.dataset.entityFilter);
            });

            document.querySelectorAll('[data-entity-delete]').forEach(btn => {
                btn.onclick = () => {
                    deleteEntity(btn.dataset.entityDelete);
                    renderEntitiesPage(filterKey);
                    showToast(' Entity removed');
                };
            });

            const form = document.getElementById('entityForm');
            if (form) form.onsubmit = (event) => { event.preventDefault(); handleEntityFormSubmit(); };
            const resetBtn = document.getElementById('resetEntityForm');
            if (resetBtn) resetBtn.onclick = resetEntityForm;
            const openFormBtn = document.getElementById('openEntityFormBtn');
            if (openFormBtn) {
                openFormBtn.onclick = () => {
                    const formCard = document.getElementById('entityFormCard');
                    formCard?.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    const firstInput = document.getElementById('entityKind');
                    if (firstInput) firstInput.focus();
                };
            }
        }

        // GRAPH VIEW
        function renderGraphView() {
            const set = getCurrentSet();
            const view = getCurrentView();
            const definitions = getDefinitionView();
            const connections = getConnectionView();
            const entities = state.entities ? Array.from(state.entities.values()) : [];

            const container = document.getElementById('viewContainer');
            const nodeLabel = definitions.length === 1 ? 'node' : 'nodes';
            const edgeLabel = connections.length === 1 ? 'edge' : 'edges';

            container.innerHTML = `
                <div class="view-stage-header">
                    <div class="view-stage-title">
                        <span class="view-stage-pill">${getWorld()?.name || 'Graph'}</span>
                        <div class="min-w-0">
                            <div class="view-stage-name">${view?.name || 'Graph View'}</div>
                            <div class="view-stage-sub">${definitions.length} ${nodeLabel}  ${connections.length} ${edgeLabel}</div>
                        </div>
                    </div>
                    ${set ? renderViewActions() : ''}
                </div>
                <div class="view-stage-body">
                    <div class="graph-container" id="graphContainer">
                        <svg id="graphSvg" width="100%" height="100%"></svg>
                    </div>
                </div>
            `;

            renderGraph(definitions, connections, entities);

            finalizeViewStage();
        }

        function renderGraph(definitions, connections, entities = []) {
            const container = document.getElementById('graphContainer');
            const svg = document.getElementById('graphSvg');
            const width = container?.clientWidth || 800;
            const height = container?.clientHeight || 600;

            svg.setAttribute('width', width);
            svg.setAttribute('height', height);
            svg.innerHTML = '';

            const typeColors = {
                Record: '#3b82f6',
                Field: '#10b981',
                Set: '#f59e0b',
                Connection: '#8b5cf6',
                ViewEntity: '#0ea5e9'
            };

            const nodes = [];
            const nodeMap = new Map();
            const definitionsByKey = new Map();
            definitions.forEach(def => {
                const key = `${def.entity?.type}:${def.entity?.id}`;
                if (key) definitionsByKey.set(key, def);
            });

            const addNode = (entity) => {
                const key = `${entity.type}:${entity.id}`;
                if (nodeMap.has(key)) return nodeMap.get(key);
                const definition = definitionsByKey.get(key);
                const node = {
                    id: key,
                    entity,
                    label: definition?.term || renderEntityLabel(entity),
                    detail: definition?.definition || definition?.notes || '',
                    color: typeColors[entity.type] || '#0ea5e9',
                    x: Math.random() * (width - 100) + 50,
                    y: Math.random() * (height - 100) + 50,
                    vx: 0,
                    vy: 0
                };
                nodeMap.set(key, node);
                nodes.push(node);
                return node;
            };

            (entities || []).forEach(entity => addNode(entity));
            definitions.forEach(def => addNode(def.entity));

            const links = [];
            connections.forEach(conn => {
                const source = addNode(conn.subject);
                const target = addNode(conn.operand);
                links.push({
                    source,
                    target,
                    label: `${conn.operator || ''} ${conn.mode || ''}`.trim() || 'linked'
                });
            });

            if (nodes.length === 0 && links.length === 0) {
                svg.innerHTML = `<text x="${width/2}" y="${height/2}" text-anchor="middle" fill="#9ca3af" font-size="14">No graph data available</text>`;
                return;
            }

            const iterations = 60;
            const centerX = width / 2;
            const centerY = height / 2;

            for (let i = 0; i < iterations; i++) {
                nodes.forEach(node => {
                    const dx = centerX - node.x;
                    const dy = centerY - node.y;
                    node.vx += dx * 0.01;
                    node.vy += dy * 0.01;

                    nodes.forEach(other => {
                        if (node === other) return;
                        const dx = node.x - other.x;
                        const dy = node.y - other.y;
                        const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                        const force = 900 / (dist * dist);
                        node.vx += (dx / dist) * force;
                        node.vy += (dy / dist) * force;
                    });
                });

                links.forEach(link => {
                    const dx = link.target.x - link.source.x;
                    const dy = link.target.y - link.source.y;
                    const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                    const force = dist * 0.015;
                    link.source.vx += (dx / dist) * force;
                    link.source.vy += (dy / dist) * force;
                    link.target.vx -= (dx / dist) * force;
                    link.target.vy -= (dy / dist) * force;
                });

                nodes.forEach(node => {
                    node.x += node.vx;
                    node.y += node.vy;
                    node.vx *= 0.8;
                    node.vy *= 0.8;
                    node.x = Math.max(50, Math.min(width - 50, node.x));
                    node.y = Math.max(50, Math.min(height - 50, node.y));
                });
            }

            const linkGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            linkGroup.setAttribute('class', 'links');
            links.forEach(link => {
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', link.source.x);
                line.setAttribute('y1', link.source.y);
                line.setAttribute('x2', link.target.x);
                line.setAttribute('y2', link.target.y);
                line.setAttribute('stroke', '#cbd5e1');
                line.setAttribute('stroke-width', '2');
                linkGroup.appendChild(line);

                const midX = (link.source.x + link.target.x) / 2;
                const midY = (link.source.y + link.target.y) / 2;
                const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                label.setAttribute('x', midX);
                label.setAttribute('y', midY - 6);
                label.setAttribute('text-anchor', 'middle');
                label.setAttribute('fill', '#6b7280');
                label.setAttribute('font-size', '10');
                label.textContent = link.label;
                linkGroup.appendChild(label);
            });
            svg.appendChild(linkGroup);

            const nodeGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            nodeGroup.setAttribute('class', 'nodes');
            nodes.forEach(node => {
                const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                g.setAttribute('class', 'graph-node');
                g.setAttribute('transform', `translate(${node.x},${node.y})`);
                g.style.cursor = 'pointer';

                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('r', '32');
                circle.setAttribute('fill', node.color);
                circle.setAttribute('stroke', '#111827');
                circle.setAttribute('stroke-width', '2');

                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('text-anchor', 'middle');
                text.setAttribute('dy', '0.35em');
                text.setAttribute('fill', 'white');
                text.setAttribute('font-size', '11');
                text.setAttribute('font-weight', '700');
                text.textContent = node.label?.substring(0, 18) || node.id;

                const title = document.createElementNS('http://www.w3.org/2000/svg', 'title');
                title.textContent = node.detail || node.label;

                g.appendChild(circle);
                g.appendChild(text);
                g.appendChild(title);

                nodeGroup.appendChild(g);
            });
            svg.appendChild(nodeGroup);
        }

        function serializeTagsInput(value) {
            return (value || '')
                .split(',')
                .map(tag => tag.trim())
                .filter(Boolean);
        }

        function parseDefinitionGridRows(text) {
            const lines = (text || '').split('\n').map(line => line.trim()).filter(Boolean);
            if (!lines.length) return [];

            const delimiter = lines.some(line => line.includes('\t')) ? '\t' : ',';
            const splitLine = (line) => line.split(delimiter).map(cell => cell.trim());
            const headerCells = splitLine(lines[0]).map(cell => cell.toLowerCase());
            const headerKeywords = ['entity type', 'entity id', 'term', 'definition'];
            const hasHeader = headerKeywords.some(keyword => headerCells.some(cell => cell.includes(keyword.replace(' ', '_')) || cell.includes(keyword)));
            const startIndex = hasHeader ? 1 : 0;

            const rows = [];
            for (let i = startIndex; i < lines.length; i++) {
                const cells = splitLine(lines[i]);
                if (!cells.length || cells.every(cell => !cell)) continue;
                const [entityType, entityId, term, definitionText, notes = '', tags = ''] = cells;
                rows.push({
                    entityType: entityType || '',
                    entityId: entityId || '',
                    term: term || '',
                    definition: definitionText || '',
                    notes: notes || '',
                    tags: serializeTagsInput(tags)
                });
            }

            return rows;
        }

        function handleDefinitionImportSubmit() {
            const textarea = document.getElementById('definitionImportText');
            if (!textarea) return;

            const rows = parseDefinitionGridRows(textarea.value);
            if (!rows.length) {
                showToast('Please paste at least one row');
                return;
            }

            let added = 0;
            let updated = 0;
            let skipped = 0;

            rows.forEach(row => {
                const entityType = row.entityType?.trim();
                const entityId = row.entityId?.trim();
                const term = row.term?.trim();
                const definitionText = row.definition?.trim();

                if (!entityType || !entityId || !term || !definitionText) {
                    skipped += 1;
                    return;
                }

                const payload = {
                    entity: { type: entityType, id: entityId },
                    term,
                    definition: definitionText,
                    notes: row.notes?.trim() || '',
                    tags: row.tags || []
                };

                const existing = findDefinitionByEntity(payload.entity);
                if (existing) {
                    updateDefinition(existing.id, payload);
                    updated += 1;
                } else {
                    addDefinition(payload);
                    added += 1;
                }
            });

            renderDefinitionsPage(state.definitionFormState.activeFilter || 'all');
            showToast(` Imported ${added + updated} definitions${updated ? ` (${updated} updated)` : ''}${skipped ? `  ${skipped} skipped` : ''}`);
        }

        function openDefinitionModal(definitionId = null) {
            resetDefinitionForm();
            if (definitionId) populateDefinitionForm(definitionId);
            openModal('definitionModal');
            const entityTypeSelect = document.getElementById('definitionEntityType');
            if (entityTypeSelect) entityTypeSelect.focus();
        }

        function closeDefinitionModal() {
            closeModal('definitionModal');
        }

        function resetDefinitionForm() {
            state.definitionFormState.editingId = null;
            const form = document.getElementById('definitionForm');
            if (!form) return;
            form.reset();
            const submit = document.getElementById('definitionSubmit');
            if (submit) submit.textContent = 'Add Definition';
            const title = document.getElementById('definitionModalTitle');
            if (title) title.textContent = 'Add Definition';
        }

        function populateDefinitionForm(definitionId) {
            const def = state.definitions.get(definitionId);
            if (!def) return;
            const form = document.getElementById('definitionForm');
            if (!form) return;
            form.querySelector('#definitionEntityType').value = def.entity?.type || '';
            form.querySelector('#definitionEntityId').value = def.entity?.id || '';
            form.querySelector('#definitionTerm').value = def.term || '';
            form.querySelector('#definitionDefinition').value = def.definition || '';
            form.querySelector('#definitionNotes').value = def.notes || '';
            form.querySelector('#definitionTags').value = (def.tags || []).join(', ');
            const submit = document.getElementById('definitionSubmit');
            if (submit) submit.textContent = 'Save Definition';
            const title = document.getElementById('definitionModalTitle');
            if (title) title.textContent = 'Edit Definition';
            state.definitionFormState.editingId = def.id;
            openModal('definitionModal');
        }

        function handleDefinitionFormSubmit() {
            const form = document.getElementById('definitionForm');
            if (!form) return;
            const entityType = form.querySelector('#definitionEntityType').value;
            const entityId = form.querySelector('#definitionEntityId').value.trim();
            const term = form.querySelector('#definitionTerm').value.trim();
            const definitionText = form.querySelector('#definitionDefinition').value.trim();
            const notes = form.querySelector('#definitionNotes').value.trim();
            const tags = serializeTagsInput(form.querySelector('#definitionTags').value);

            if (!entityType || !entityId || !term || !definitionText) {
                showToast('Please complete entity, term, and definition');
                return;
            }

            const payload = {
                id: state.definitionFormState.editingId,
                entity: { type: entityType, id: entityId },
                term,
                definition: definitionText,
                notes,
                tags
            };

            if (state.definitionFormState.editingId) {
                updateDefinition(payload.id, payload);
                showToast(' Definition updated');
            } else {
                addDefinition(payload);
                showToast(' Definition added');
            }

            resetDefinitionForm();
            closeDefinitionModal();
            renderDefinitionsPage(state.definitionFormState.activeFilter || 'all');
        }

        function attachDefinitionInlineEditing() {
            document.querySelectorAll('[data-def-inline]').forEach(cell => {
                const [field, defId] = (cell.dataset.defInline || '').split(':');
                if (!field || !defId) return;

                const original = cell.textContent.trim();
                cell.contentEditable = 'true';
                cell.onfocus = () => cell.dataset.originalValue = cell.textContent.trim();
                cell.onkeydown = (event) => {
                    if (event.key === 'Enter') {
                        event.preventDefault();
                        cell.blur();
                    }
                };
                cell.onblur = () => {
                    const current = (cell.textContent || '').trim();
                    const baseline = cell.dataset.originalValue !== undefined ? cell.dataset.originalValue : original;
                    if (current === baseline) return;

                    const def = state.definitions.get(defId);
                    if (!def) return;
                    const updates = { ...def };
                    if (field === 'tags') {
                        updates.tags = current ? current.split(',').map(t => t.trim()).filter(Boolean) : [];
                    } else {
                        updates[field] = current;
                    }

                    updateDefinition(defId, updates);
                    showToast(' Definition updated');
                    renderDefinitionsPage(state.definitionFormState.activeFilter || 'all');
                };
            });
        }

        function renderDefinitionsTable(definitions) {
            if (!definitions.length) return '<p class="text-sm text-gray-500">No definitions yet.</p>';
            return `
                <div class="overflow-auto border border-gray-200 rounded-lg bg-white">
                    <table class="min-w-full text-sm">
                        <thead class="bg-gray-50">
                            <tr>
                                <th class="px-4 py-3 text-left text-xs font-semibold text-gray-500">Entity</th>
                                <th class="px-4 py-3 text-left text-xs font-semibold text-gray-500">Term</th>
                                <th class="px-4 py-3 text-left text-xs font-semibold text-gray-500">Definition</th>
                                <th class="px-4 py-3 text-left text-xs font-semibold text-gray-500">Notes</th>
                                <th class="px-4 py-3 text-left text-xs font-semibold text-gray-500">Tags</th>
                                <th class="px-4 py-3 text-left text-xs font-semibold text-gray-500">Actions</th>
                            </tr>
                        </thead>
                        <tbody class="divide-y divide-gray-200">
                            ${definitions.map(def => `
                                <tr>
                                    <td class="px-4 py-3 whitespace-nowrap text-gray-800">${def.entity.type}: ${renderEntityLabel(def.entity)}</td>
                                    <td class="px-4 py-3 font-semibold text-gray-900" data-def-inline="term:${def.id}">${def.term}</td>
                                    <td class="px-4 py-3 text-gray-700" data-def-inline="definition:${def.id}">${def.definition}</td>
                                    <td class="px-4 py-3 text-gray-500" data-def-inline="notes:${def.id}">${def.notes || ''}</td>
                                    <td class="px-4 py-3 text-gray-500" data-def-inline="tags:${def.id}">${(def.tags || []).join(', ')}</td>
                                    <td class="px-4 py-3 whitespace-nowrap space-x-3">
                                        <button class="text-blue-600" data-def-edit="${def.id}">Edit</button>
                                        <button class="text-red-500" data-def-delete="${def.id}">Delete</button>
                                    </td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                </div>
            `;
        }

        function renderDefinitionsPage(filterKey = 'all') {
            state.definitionFormState.activeFilter = filterKey;
            const filters = {
                all: () => true,
                records: def => def.entity?.type === 'Record',
                fields: def => def.entity?.type === 'Field',
                connections: def => def.entity?.type === 'Connection',
                viewEntities: def => def.entity?.type === 'ViewEntity',
                core: def => (def.tags || []).includes('core'),
                demo: def => (def.tags || []).includes('demo')
            };

            const definitions = getDefinitionView(filters[filterKey]);
            const container = document.getElementById('viewContainer');
            container.innerHTML = `
                <div class="view-stage-header">
                    <div class="view-stage-title">
                        <span class="view-stage-pill">${getWorld()?.name || 'World'}</span>
                        <div class="min-w-0">
                            <div class="view-stage-name">Definitions</div>
                            <div class="view-stage-sub">${definitions.length} entries</div>
                        </div>
                    </div>
                </div>
                <div class="view-stage-body space-y-4">
                    <div class="flex flex-wrap items-center justify-between gap-3">
                        <div class="flex flex-wrap gap-2">
                            ${Object.keys(filters).map(key => `<button class="btn btn-secondary btn-sm ${filterKey === key ? 'btn-primary' : ''}" data-def-filter="${key}">${key === 'all' ? 'All' : key.charAt(0).toUpperCase() + key.slice(1)}</button>`).join('')}
                        </div>
                        <div class="flex gap-2">
                            <button class="btn btn-secondary btn-sm" id="toggleDefinitionImport">${state.definitionFormState.showImportPanel ? 'Hide Import' : 'Import Definitions'}</button>
                            <button class="btn btn-primary btn-sm" id="openDefinitionModalBtn">Add Definition</button>
                        </div>
                    </div>
                    ${state.definitionFormState.showImportPanel ? `
                    <div class="border border-gray-200 rounded-lg bg-white p-4 space-y-3">
                        <div class="flex items-center justify-between">
                            <div>
                                <div class="font-semibold">Import definitions</div>
                                <p class="text-sm text-gray-500">Paste tab or comma separated rows: Entity Type, Entity ID, Term, Definition, Notes, Tags.</p>
                            </div>
                            <button class="btn btn-secondary btn-sm" id="closeDefinitionImport">Close</button>
                        </div>
                        <textarea id="definitionImportText" class="w-full border rounded px-3 py-2 text-sm font-mono" rows="5" placeholder="Record\tobs_123\tSnow depth\tDepth of snow in cm\tMetric reference\twinter, core"></textarea>
                        <div class="text-xs text-gray-500">Existing rows update matching entities; missing fields are skipped.</div>
                        <div class="flex justify-end">
                            <button class="btn btn-primary btn-sm" id="runDefinitionImport">Import pasted rows</button>
                        </div>
                    </div>
                    ` : ''}
                    ${renderDefinitionsTable(definitions)}
                </div>
            `;

            document.querySelectorAll('[data-def-filter]').forEach(btn => {
                btn.onclick = () => renderDefinitionsPage(btn.dataset.defFilter);
            });

            document.querySelectorAll('[data-def-edit]').forEach(btn => {
                btn.onclick = () => openDefinitionModal(btn.dataset.defEdit);
            });

            document.querySelectorAll('[data-def-delete]').forEach(btn => {
                btn.onclick = () => {
                    deleteDefinition(btn.dataset.defDelete);
                    renderDefinitionsPage(filterKey);
                    showToast(' Definition removed');
                };
            });

            const importToggleBtn = document.getElementById('toggleDefinitionImport');
            if (importToggleBtn) {
                importToggleBtn.onclick = () => {
                    state.definitionFormState.showImportPanel = !state.definitionFormState.showImportPanel;
                    renderDefinitionsPage(filterKey);
                };
            }

            const importCloseBtn = document.getElementById('closeDefinitionImport');
            if (importCloseBtn) {
                importCloseBtn.onclick = () => {
                    state.definitionFormState.showImportPanel = false;
                    renderDefinitionsPage(filterKey);
                };
            }

            const importRunBtn = document.getElementById('runDefinitionImport');
            if (importRunBtn) importRunBtn.onclick = handleDefinitionImportSubmit;

            const openModalBtn = document.getElementById('openDefinitionModalBtn');
            if (openModalBtn) openModalBtn.onclick = () => openDefinitionModal();

            const form = document.getElementById('definitionForm');
            if (form) form.onsubmit = (event) => { event.preventDefault(); handleDefinitionFormSubmit(); };

            attachDefinitionInlineEditing();
        }

        function renderModeOptions(operator, selectedMode = '') {
            const modes = getModesForOperator(operator);
            return modes.map(mode => `<option value="${mode}" ${mode === selectedMode ? 'selected' : ''}>${mode}</option>`).join('');
        }

        function populateConnectionFormatOptions(selectedOperator = '') {
            const operatorSelect = document.getElementById('connectionFormatOperator');
            if (!operatorSelect) return;
            const operatorOptions = Object.keys(state.connectionModes || {});
            operatorSelect.innerHTML = ['<option value="">Select operator</option>', ...operatorOptions.map(op => `<option value="${op}">${op}</option>`)].join('');
            operatorSelect.value = selectedOperator || operatorOptions[0] || '';

            const modeSelect = document.getElementById('connectionFormatMode');
            if (modeSelect) {
                modeSelect.innerHTML = renderModeOptions(operatorSelect.value || selectedOperator, '');
            }
        }

        function populateConnectionFormatForm(formatId) {
            const format = state.connectionFormats.get(formatId);
            if (!format) return;
            const form = document.getElementById('connectionFormatForm');
            if (!form) return;

            populateConnectionFormatOptions(format.operator);

            form.querySelector('#connectionFormatOperator').value = format.operator;
            const modeSelect = form.querySelector('#connectionFormatMode');
            if (modeSelect) {
                modeSelect.innerHTML = renderModeOptions(format.operator, format.mode);
            }

            form.querySelector('#connectionFormatDescription').value = format.description || '';
            form.querySelector('#connectionFormatRequired').value = (format.requiredParams || []).join(', ');
            form.querySelector('#connectionFormatOptional').value = (format.optionalParams || []).join(', ');
            state.connectionFormatFormState.editingId = format.id;

            const submit = document.getElementById('connectionFormatSubmit');
            if (submit) submit.textContent = 'Save Format';
            const title = document.getElementById('connectionFormatModalTitle');
            if (title) title.textContent = 'Edit Connection Format';
            openModal('connectionFormatModal');
        }

        function resetConnectionFormatForm() {
            state.connectionFormatFormState.editingId = null;
            const form = document.getElementById('connectionFormatForm');
            if (!form) return;
            form.reset();
            populateConnectionFormatOptions();
            const submit = document.getElementById('connectionFormatSubmit');
            if (submit) submit.textContent = 'Add Format';
            const title = document.getElementById('connectionFormatModalTitle');
            if (title) title.textContent = 'Add Connection Format';
        }

        function openConnectionFormatModal(formatId = null) {
            resetConnectionFormatForm();
            if (formatId) populateConnectionFormatForm(formatId);
            openModal('connectionFormatModal');
        }

        function handleConnectionFormatSubmit() {
            const form = document.getElementById('connectionFormatForm');
            if (!form) return;

            const operator = form.querySelector('#connectionFormatOperator')?.value;
            const mode = form.querySelector('#connectionFormatMode')?.value;
            const requiredParams = (form.querySelector('#connectionFormatRequired')?.value || '').split(',').map(p => p.trim()).filter(Boolean);
            const optionalParams = (form.querySelector('#connectionFormatOptional')?.value || '').split(',').map(p => p.trim()).filter(Boolean);
            const description = form.querySelector('#connectionFormatDescription')?.value || '';

            const payload = {
                id: state.connectionFormatFormState.editingId,
                operator,
                mode,
                description,
                requiredParams,
                optionalParams,
                worldId: state.currentWorldId
            };

            const isEdit = Boolean(state.connectionFormatFormState.editingId);
            try {
                if (isEdit) {
                    updateConnectionFormat(payload.id, payload);
                    showToast(' Format updated');
                } else {
                    addConnectionFormat(payload);
                    showToast(' Format added');
                }
            } catch (error) {
                showToast(error.message);
                return;
            }

            resetConnectionFormatForm();
            closeModal('connectionFormatModal');
            renderConnectionsPage(state.connectionFormState.activeFilter || 'all');
        }

        function renderConnectionParamFields(containerId, formatId, params = {}) {
            const container = document.getElementById(containerId);
            if (!container) return;
            const format = findConnectionFormat(formatId);
            if (!format) {
                container.innerHTML = '<p class="text-sm text-gray-500">Select a format to enter parameters.</p>';
                return;
            }

            const allParams = [...format.requiredParams, ...format.optionalParams];
            if (!allParams.length) {
                container.innerHTML = '<p class="text-sm text-gray-500">No parameters required for this format.</p>';
                return;
            }

            container.innerHTML = allParams.map(name => {
                const required = format.requiredParams.includes(name);
                const value = params[name] !== undefined ? params[name] : '';
                const safeValue = typeof value === 'object' ? JSON.stringify(value) : String(value || '');
                const escapedValue = safeValue
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/"/g, '&quot;');
                return `
                    <div>
                        <label class="form-label">${name}${required ? ' *' : ''}</label>
                        <input
                            type="text"
                            class="border rounded px-3 py-2 w-full"
                            data-param-name="${name}"
                            data-param-required="${required ? 'true' : 'false'}"
                            value="${escapedValue}"
                        />
                    </div>
                `;
            }).join('');
        }

        function populateConnectionForm(connId) {
            const conn = state.connections.get(connId);
            if (!conn) return;
            const form = document.getElementById('connectionForm');
            if (!form) return;
            populateConnectionSelectOptions(conn.formatId, conn.params || {});
            form.querySelector('#connectionSubjectType').value = conn.subject?.type || '';
            form.querySelector('#connectionSubjectId').value = conn.subject?.id || '';
            form.querySelector('#connectionOperandType').value = conn.operand?.type || '';
            form.querySelector('#connectionOperandId').value = conn.operand?.id || '';
            form.querySelector('#connectionDescription').value = conn.description || '';
            state.connectionFormState.editingId = conn.id;

            const submit = document.getElementById('connectionSubmit');
            if (submit) submit.textContent = 'Save Connection';
            const title = document.getElementById('connectionModalTitle');
            if (title) title.textContent = 'Edit Connection';
        }

        function resetConnectionForm() {
            state.connectionFormState.editingId = null;
            const form = document.getElementById('connectionForm');
            if (!form) return;
            form.reset();
            const defaultFormat = getDefaultConnectionFormatId();
            populateConnectionSelectOptions(defaultFormat, {});
            const submit = document.getElementById('connectionSubmit');
            if (submit) submit.textContent = 'Add Connection';
            const title = document.getElementById('connectionModalTitle');
            if (title) title.textContent = 'Add Connection';
        }

        function populateConnectionSelectOptions(selectedFormatId, params = {}) {
            const select = document.getElementById('connectionFormatSelect');
            if (!select) return;
            const formats = getConnectionFormatView();
            select.innerHTML = ['<option value="">Select a format</option>', ...formats.map(fmt => `<option value="${fmt.id}">${fmt.id} (${fmt.operator} / ${fmt.mode})</option>`)].join('');
            const resolved = selectedFormatId || getDefaultConnectionFormatId();
            state.connectionFormState.selectedFormatId = resolved;
            if (resolved) select.value = resolved;
            renderConnectionParamFields('connectionParamFields', resolved, params);
            updateConnectionFormatSummary(resolved);
        }

        function updateConnectionFormatSummary(formatId) {
            const summary = document.getElementById('connectionFormatSummary');
            const format = formatId ? findConnectionFormat(formatId) : null;
            if (!summary) return;
            summary.textContent = format ? `${format.operator}  ${format.mode}` : 'No format selected';
        }

        function openConnectionModal(connId = null) {
            resetConnectionForm();
            if (connId) populateConnectionForm(connId);
            openModal('connectionModal');
            const typeSelect = document.getElementById('connectionSubjectType');
            if (typeSelect) typeSelect.focus();
        }

        function collectParamsFromInputs(containerId, format) {
            const container = document.getElementById(containerId);
            const params = {};
            if (!container || !format) return params;

            const inputs = container.querySelectorAll('[data-param-name]');
            for (const input of inputs) {
                const name = input.dataset.paramName;
                const required = input.dataset.paramRequired === 'true';
                const rawValue = (input.value || '').trim();
                if (!rawValue) {
                    if (required) throw new Error(`Missing required param: ${name}`);
                    continue;
                }

                try {
                    params[name] = JSON.parse(rawValue);
                } catch (err) {
                    params[name] = rawValue;
                }
            }

            return params;
        }

        function handleConnectionFormSubmit() {
            const form = document.getElementById('connectionForm');
            if (!form) return;

            const formatId = form.querySelector('#connectionFormatSelect')?.value;
            if (!formatId) {
                showToast('Select a connection format');
                return;
            }

            const format = findConnectionFormat(formatId);
            if (!format) {
                showToast('Selected connection format not found');
                return;
            }

            let params = {};
            try {
                params = collectParamsFromInputs('connectionParamFields', format);
            } catch (error) {
                showToast(error.message);
                return;
            }

            const payload = {
                id: state.connectionFormState.editingId,
                formatId,
                subject: { type: form.querySelector('#connectionSubjectType').value, id: form.querySelector('#connectionSubjectId').value.trim() },
                operand: { type: form.querySelector('#connectionOperandType').value, id: form.querySelector('#connectionOperandId').value.trim() },
                description: form.querySelector('#connectionDescription').value.trim(),
                params
            };

            if (!payload.subject.type || !payload.subject.id || !payload.operand.type || !payload.operand.id) {
                showToast('Please provide subject and operand details');
                return;
            }

            if (state.connectionFormState.editingId) {
                updateConnection(payload.id, payload);
                showToast(' Connection updated');
            } else {
                addConnection(payload);
                showToast(' Connection added');
            }

            resetConnectionForm();
            closeModal('connectionModal');
            renderConnectionsPage(state.connectionFormState.activeFilter || 'all');
        }

        function renderConnectionFormatsTable(formats) {
            if (!formats.length) return '<p class="text-sm text-gray-500">No connection formats yet.</p>';
            return `
                <div class="overflow-auto border border-gray-200 rounded-lg bg-white">
                    <table class="min-w-full text-sm">
                        <thead class="bg-gray-50">
                            <tr>
                                <th class="px-4 py-3 text-left text-xs font-semibold text-gray-500">ID</th>
                                <th class="px-4 py-3 text-left text-xs font-semibold text-gray-500">Operator</th>
                                <th class="px-4 py-3 text-left text-xs font-semibold text-gray-500">Mode</th>
                                <th class="px-4 py-3 text-left text-xs font-semibold text-gray-500">Required Params</th>
                                <th class="px-4 py-3 text-left text-xs font-semibold text-gray-500">Optional Params</th>
                                <th class="px-4 py-3 text-left text-xs font-semibold text-gray-500">Description</th>
                                <th class="px-4 py-3 text-left text-xs font-semibold text-gray-500">Actions</th>
                            </tr>
                        </thead>
                        <tbody class="divide-y divide-gray-200">
                            ${formats.map(fmt => `
                                <tr>
                                    <td class="px-4 py-3 text-gray-800 whitespace-nowrap">${fmt.id}</td>
                                    <td class="px-4 py-3 text-gray-800">${fmt.operator}</td>
                                    <td class="px-4 py-3 text-gray-800">${fmt.mode}</td>
                                    <td class="px-4 py-3 text-gray-600" data-format-inline="requiredParams:${fmt.id}">${(fmt.requiredParams || []).join(', ') || ''}</td>
                                    <td class="px-4 py-3 text-gray-600" data-format-inline="optionalParams:${fmt.id}">${(fmt.optionalParams || []).join(', ') || ''}</td>
                                    <td class="px-4 py-3 text-gray-500" data-format-inline="description:${fmt.id}">${fmt.description || ''}</td>
                                    <td class="px-4 py-3 whitespace-nowrap space-x-3">
                                        <button class="text-blue-600" data-format-edit="${fmt.id}">Edit</button>
                                        <button class="text-red-500" data-format-delete="${fmt.id}">Delete</button>
                                    </td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                </div>
            `;
        }

        function renderConnectionsTable(connections) {
            if (!connections.length) return '<p class="text-sm text-gray-500">No connections yet.</p>';
            return `
                <div class="overflow-auto border border-gray-200 rounded-lg bg-white">
                    <table class="min-w-full text-sm">
                        <thead class="bg-gray-50">
                            <tr>
                                <th class="px-4 py-3 text-left text-xs font-semibold text-gray-500">Subject</th>
                                <th class="px-4 py-3 text-left text-xs font-semibold text-gray-500">Format</th>
                                <th class="px-4 py-3 text-left text-xs font-semibold text-gray-500">Operator</th>
                                <th class="px-4 py-3 text-left text-xs font-semibold text-gray-500">Mode</th>
                                <th class="px-4 py-3 text-left text-xs font-semibold text-gray-500">Operand</th>
                                <th class="px-4 py-3 text-left text-xs font-semibold text-gray-500">Description</th>
                                <th class="px-4 py-3 text-left text-xs font-semibold text-gray-500">Params</th>
                                <th class="px-4 py-3 text-left text-xs font-semibold text-gray-500">Actions</th>
                            </tr>
                        </thead>
                        <tbody class="divide-y divide-gray-200">
                            ${connections.map(conn => {
                                const format = findConnectionFormat(conn.formatId);
                                return `
                                    <tr>
                                        <td class="px-4 py-3 whitespace-nowrap text-gray-800">${conn.subject?.type}: ${renderEntityLabel(conn.subject)}</td>
                                        <td class="px-4 py-3 text-gray-800">${format?.id || conn.formatId || ''}</td>
                                        <td class="px-4 py-3 text-gray-700">${format?.operator || conn.operator || ''}</td>
                                        <td class="px-4 py-3 text-gray-700">${format?.mode || conn.mode || ''}</td>
                                        <td class="px-4 py-3 whitespace-nowrap text-gray-800">${conn.operand?.type}: ${renderEntityLabel(conn.operand)}</td>
                                        <td class="px-4 py-3 text-gray-500" data-conn-inline="description:${conn.id}">${conn.description || ''}</td>
                                        <td class="px-4 py-3 text-gray-500" data-conn-inline="params:${conn.id}">${JSON.stringify(conn.params || {})}</td>
                                        <td class="px-4 py-3 whitespace-nowrap space-x-3">
                                            <button class="text-blue-600" data-conn-edit="${conn.id}">Edit</button>
                                            <button class="text-red-500" data-conn-delete="${conn.id}">Delete</button>
                                        </td>
                                    </tr>
                                `;
                            }).join('')}
                        </tbody>
                    </table>
                </div>
            `;
        }

        function renderConnectionsPage(filterKey = 'all') {
            state.connectionFormState.activeFilter = filterKey;
            const filters = {
                all: () => true,
                con: conn => conn.operator === 'CON',
                seg: conn => conn.operator === 'SEG',
                withDefinitions: conn => findDefinitionByEntity(conn.subject) || findDefinitionByEntity(conn.operand),
                compound: conn => conn.subject?.type === 'Connection' || conn.operand?.type === 'Connection'
            };

            const formats = getConnectionFormatView();
            const connections = getConnectionView(filters[filterKey]);
            const container = document.getElementById('viewContainer');

            container.innerHTML = `
                <div class="view-stage-header">
                    <div class="view-stage-title">
                        <span class="view-stage-pill">${getWorld()?.name || 'World'}</span>
                        <div class="min-w-0">
                            <div class="view-stage-name">Connections</div>
                            <div class="view-stage-sub">${connections.length} edges  ${formats.length} formats</div>
                        </div>
                    </div>
                </div>
                <div class="view-stage-body space-y-6">
                    <div class="flex flex-wrap items-center justify-between gap-3">
                        <div class="space-y-1">
                            <div class="font-semibold text-gray-900">Connection tools</div>
                            <p class="text-sm text-gray-500">Work with formats and edges using modals and inline edits.</p>
                        </div>
                        <div class="flex gap-2">
                            <button class="btn btn-secondary btn-sm" id="openConnectionFormatModalBtn">Add Format</button>
                            <button class="btn btn-primary btn-sm" id="openConnectionModalBtn">Add Connection</button>
                        </div>
                    </div>
                    <div class="border border-gray-200 rounded-lg bg-white p-4 space-y-3">
                        <div class="flex items-center justify-between">
                            <div>
                                <div class="font-semibold">Connection Formats</div>
                                <p class="text-sm text-gray-500">Define operator + mode templates using the EO dictionary.</p>
                            </div>
                        </div>
                        ${renderConnectionFormatsTable(formats)}
                    </div>

                    <div class="flex flex-wrap gap-2">
                        ${Object.keys(filters).map(key => `<button class="btn btn-secondary btn-sm ${filterKey === key ? 'btn-primary' : ''}" data-conn-filter="${key}">${key === 'all' ? 'All' : key}</button>`).join('')}
                    </div>
                    ${renderConnectionsTable(connections)}
                </div>
            `;

            document.querySelectorAll('[data-conn-filter]').forEach(btn => {
                btn.onclick = () => renderConnectionsPage(btn.dataset.connFilter);
            });

            document.querySelectorAll('[data-conn-edit]').forEach(btn => {
                btn.onclick = () => openConnectionModal(btn.dataset.connEdit);
            });

            document.querySelectorAll('[data-conn-delete]').forEach(btn => {
                btn.onclick = () => {
                    deleteConnection(btn.dataset.connDelete);
                    renderConnectionsPage(filterKey);
                    showToast(' Connection removed');
                };
            });

            document.querySelectorAll('[data-format-edit]').forEach(btn => {
                btn.onclick = () => openConnectionFormatModal(btn.dataset.formatEdit);
            });

            document.querySelectorAll('[data-format-delete]').forEach(btn => {
                btn.onclick = () => {
                    try {
                        deleteConnectionFormat(btn.dataset.formatDelete);
                        renderConnectionsPage(filterKey);
                        showToast(' Format removed');
                    } catch (error) {
                        showToast(error.message);
                    }
                };
            });

            const openConnectionBtn = document.getElementById('openConnectionModalBtn');
            if (openConnectionBtn) openConnectionBtn.onclick = () => openConnectionModal();

            const openFormatBtn = document.getElementById('openConnectionFormatModalBtn');
            if (openFormatBtn) openFormatBtn.onclick = () => openConnectionFormatModal();

            const formatOperatorSelect = document.getElementById('connectionFormatOperator');
            if (formatOperatorSelect) {
                formatOperatorSelect.onchange = (event) => {
                    const nextModes = renderModeOptions(event.target.value);
                    const modeSelect = document.getElementById('connectionFormatMode');
                    if (modeSelect) modeSelect.innerHTML = nextModes;
                };
            }

            const connFormatSelect = document.getElementById('connectionFormatSelect');
            if (connFormatSelect) {
                connFormatSelect.onchange = (event) => {
                    state.connectionFormState.selectedFormatId = event.target.value;
                    renderConnectionParamFields('connectionParamFields', event.target.value, {});
                    updateConnectionFormatSummary(event.target.value);
                };
            }

            const connForm = document.getElementById('connectionForm');
            if (connForm) connForm.onsubmit = (event) => { event.preventDefault(); handleConnectionFormSubmit(); };

            const formatForm = document.getElementById('connectionFormatForm');
            if (formatForm) formatForm.onsubmit = (event) => { event.preventDefault(); handleConnectionFormatSubmit(); };

            attachConnectionFormatInlineEditing();
            attachConnectionInlineEditing();
        }

        function attachConnectionFormatInlineEditing() {
            document.querySelectorAll('[data-format-inline]').forEach(cell => {
                const [field, formatId] = (cell.dataset.formatInline || '').split(':');
                if (!field || !formatId) return;
                const original = cell.textContent.trim();
                cell.contentEditable = 'true';
                cell.onfocus = () => cell.dataset.originalValue = cell.textContent.trim();
                cell.onkeydown = (event) => {
                    if (event.key === 'Enter') {
                        event.preventDefault();
                        cell.blur();
                    }
                };
                cell.onblur = () => {
                    const current = (cell.textContent || '').trim();
                    const baseline = cell.dataset.originalValue !== undefined ? cell.dataset.originalValue : original;
                    if (current === baseline) return;
                    const updates = {};
                    if (field === 'requiredParams' || field === 'optionalParams') {
                        updates[field] = current ? current.split(',').map(p => p.trim()).filter(Boolean) : [];
                    } else {
                        updates[field] = current;
                    }

                    updateConnectionFormat(formatId, updates);
                    showToast(' Connection format updated');
                    renderConnectionsPage(state.connectionFormState.activeFilter || 'all');
                };
            });
        }

        function attachConnectionInlineEditing() {
            document.querySelectorAll('[data-conn-inline]').forEach(cell => {
                const [field, connId] = (cell.dataset.connInline || '').split(':');
                if (!field || !connId) return;
                const original = cell.textContent.trim();
                cell.contentEditable = 'true';
                cell.onfocus = () => cell.dataset.originalValue = cell.textContent.trim();
                cell.onkeydown = (event) => {
                    if (event.key === 'Enter') {
                        event.preventDefault();
                        cell.blur();
                    }
                };
                cell.onblur = () => {
                    const current = (cell.textContent || '').trim();
                    const baseline = cell.dataset.originalValue !== undefined ? cell.dataset.originalValue : original;
                    if (current === baseline) return;

                    try {
                        if (field === 'params') {
                            const parsed = current ? JSON.parse(current) : {};
                            updateConnection(connId, { params: parsed });
                        } else {
                            updateConnection(connId, { [field]: current });
                        }
                        showToast(' Connection updated');
                        renderConnectionsPage(state.connectionFormState.activeFilter || 'all');
                    } catch (error) {
                        showToast('Params must be valid JSON');
                        renderConnectionsPage(state.connectionFormState.activeFilter || 'all');
                    }
                };
            });
        }

        // CELL EDITING
        function handleCellClick(td, recordId, field) {
            if (state.editingCell && state.editingCell.td !== td) {
                exitEditMode();
            }

            if (state.selectedCell?.td === td && state.selectedCell?.recordId === recordId) {
                enterEditMode(td, recordId, field);
                return;
            }

            selectCell(td, recordId, field.id);
        }

        function selectCell(td, recordId, fieldId) {
            if (state.editingCell) exitEditMode();

            if (state.selectedCell?.td) {
                state.selectedCell.td.classList.remove('cell-selected');
                state.selectedCell.td.tabIndex = -1;
            }

            td.classList.add('cell-selected');
            td.tabIndex = 0;
            td.focus();

            state.selectedCell = { td, recordId, fieldId };
            state.lastSelectedCell = { recordId, fieldId };

            const set = getCurrentSet();
            const record = set?.records.get(recordId);
            const value = record ? record[fieldId] : null;
            if (value && value._sup) {
                openObservationModal({ recordId, fieldId, setId: set?.id });
            }
        }

        function enterEditMode(td, recordId, field) {
            exitEditMode(false);

            if (field.type === 'FORMULA') {
                td.classList.add('cell-selected');
                state.editingCell = null;
                showToast('Formula fields are calculated automatically');
                return;
            }

            td.classList.remove('cell-selected');
            td.classList.add('cell-editing');
            state.editingCell = { td, recordId, fieldId: field.id };

            if (field.type === 'DATE') {
                showDatePicker(td, recordId, field);
            } else if (field.type === 'SINGLE_SELECT') {
                showSelectDropdown(td, recordId, field);
            } else if (field.type === 'LINK_RECORD') {
                showLinkedRecordDropdown(td, recordId, field);
            } else {
                makeContentEditable(td, recordId, field);
            }
        }

        function exitEditMode(save = true) {
            if (!state.editingCell) return;

            const { td, recordId, fieldId } = state.editingCell;

            if (td.contentEditable === 'true') {
                td.contentEditable = false;
                if (save) {
                    finalizeContentEdit(td, recordId, fieldId);
                }
            }

            td.classList.remove('cell-editing');
            td.classList.add('cell-selected');
            td.tabIndex = 0;

            state.editingCell = null;
            state.selectedCell = { td, recordId, fieldId };
            state.lastSelectedCell = { recordId, fieldId };
        }

        function makeContentEditable(td, recordId, field) {
            const set = getCurrentSet();
            const record = set.records.get(recordId);
            const currentValue = record[field.id];

            td.contentEditable = true;
            td.textContent = currentValue || '';
            td.focus();

            const range = document.createRange();
            range.selectNodeContents(td);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
        }

        function finalizeContentEdit(td, recordId, fieldId) {
            const set = getCurrentSet();
            const record = set.records.get(recordId);
            const field = set.schema.find(f => f.id === fieldId);
            const currentValue = record[fieldId];

            let newValue = td.textContent.trim();
            if (field.type === 'NUMBER' || field.type === 'CURRENCY') {
                newValue = parseFloat(newValue) || 0;
            }

            if (String(newValue) !== String(currentValue)) {
                updateRecord(recordId, fieldId, newValue, currentValue);
            } else {
                renderCurrentView();
            }
        }

        function toggleCheckbox(recordId, fieldId) {
            const set = getCurrentSet();
            const record = set.records.get(recordId);
            const currentValue = record[fieldId];
            updateRecord(recordId, fieldId, !currentValue, currentValue);
        }

        function showDatePicker(cell, recordId, field) {
            const set = getCurrentSet();
            const record = set.records.get(recordId);
            const currentValue = record[field.id];

            const input = document.createElement('input');
            input.type = 'date';
            input.value = currentValue || '';
            input.className = 'w-full px-2 py-1';
            cell.innerHTML = '';
            cell.appendChild(input);
            input.focus();
            input.onblur = () => {
                exitEditMode(false);
                const newValue = input.value;
                if (newValue !== currentValue) updateRecord(recordId, field.id, newValue, currentValue);
                else renderCurrentView();
            };
        }

        function showSelectDropdown(td, recordId, field) {
            const options = field.config.options.map(opt => ({
                value: opt,
                label: opt,
                color: field.config.colors?.[opt] || '#f3f4f6',
                icon: ''
            }));

            showEnhancedSelectDropdown(td, recordId, field, options);
        }

        function showEnhancedSelectDropdown(td, recordId, field, options) {
            const set = getCurrentSet();
            const record = set.records.get(recordId);
            const currentValue = record[field.id];

            document.querySelectorAll('.custom-select-dropdown').forEach(d => d.remove());

            const dropdown = document.createElement('div');
            dropdown.className = 'custom-select-dropdown';

            const rect = td.getBoundingClientRect();
            const spaceBelow = window.innerHeight - rect.bottom;
            const spaceAbove = rect.top;
            const dropdownHeight = Math.min(400, options.length * 40 + 100);

            if (spaceBelow >= dropdownHeight || spaceBelow > spaceAbove) {
                dropdown.style.top = `${rect.bottom + 4}px`;
            } else {
                dropdown.style.bottom = `${window.innerHeight - rect.top + 4}px`;
            }
            dropdown.style.left = `${rect.left}px`;
            dropdown.style.minWidth = `${rect.width}px`;

            dropdown.innerHTML = `
                <input 
                    type="text" 
                    class="custom-select-search" 
                    placeholder="Search or type to filter..."
                    autocomplete="off"
                    spellcheck="false"
                >
                <div class="custom-select-options"></div>
                <div class="custom-select-footer">
                    <button class="clear-btn">Clear</button>
                </div>
            `;

            document.body.appendChild(dropdown);

            const searchInput = dropdown.querySelector('.custom-select-search');
            const optionsContainer = dropdown.querySelector('.custom-select-options');
            const clearBtn = dropdown.querySelector('.clear-btn');

            let highlightedIndex = -1;
            let filteredOptions = [...options];

            function updateHighlight() {
                optionsContainer.querySelectorAll('.custom-select-option').forEach((el, i) => {
                    el.classList.toggle('highlighted', i === highlightedIndex);
                });
            }

            function scrollToHighlighted() {
                const highlighted = optionsContainer.querySelector('.highlighted');
                if (highlighted) {
                    highlighted.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
                }
            }

            function selectOption(value) {
                if (value !== currentValue) {
                    updateRecord(recordId, field.id, value, currentValue);
                }
                dropdown.remove();
                exitEditMode();
            }

            function renderOptions(query = '') {
                filteredOptions = query.trim() === ''
                    ? [...options]
                    : options.filter(opt => opt.label.toLowerCase().includes(query.toLowerCase()));

                if (filteredOptions.length === 0) {
                    optionsContainer.innerHTML = `
                        <div class="custom-select-empty">
                            <div class="custom-select-empty-icon"></div>
                            <div>No matches found</div>
                            <div style="font-size: 12px; margin-top: 4px;">Try a different search term</div>
                        </div>
                    `;
                    return;
                }

                optionsContainer.innerHTML = filteredOptions.map((opt, index) => {
                    const isSelected = opt.value === currentValue;
                    const isHighlighted = index === highlightedIndex;

                    let displayLabel = opt.label;
                    if (query.trim() !== '') {
                        const regex = new RegExp(`(${query})`, 'gi');
                        displayLabel = opt.label.replace(regex, '<span class="search-match">$1</span>');
                    }

                    return `
                        <div 
                            class="custom-select-option ${isSelected ? 'selected' : ''} ${isHighlighted ? 'highlighted' : ''}"
                            data-value="${opt.value}"
                            data-index="${index}"
                        >
                            <div class="custom-select-option-icon" style="background: ${opt.color || '#f3f4f6'}">
                                ${opt.icon || ''}
                            </div>
                            <div class="custom-select-option-text">${displayLabel}</div>
                            ${isSelected ? '<span class="custom-select-option-badge">Current</span>' : ''}
                        </div>
                    `;
                }).join('');

                optionsContainer.querySelectorAll('.custom-select-option').forEach(el => {
                    el.onclick = () => selectOption(el.dataset.value);
                    el.onmouseenter = () => {
                        highlightedIndex = parseInt(el.dataset.index);
                        updateHighlight();
                    };
                });
            }

            searchInput.oninput = (e) => {
                highlightedIndex = 0;
                renderOptions(e.target.value);
            };

            searchInput.onkeydown = (e) => {
                if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    highlightedIndex = Math.min(highlightedIndex + 1, filteredOptions.length - 1);
                    updateHighlight();
                    scrollToHighlighted();
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    highlightedIndex = Math.max(highlightedIndex - 1, 0);
                    updateHighlight();
                    scrollToHighlighted();
                } else if (e.key === 'Enter') {
                    e.preventDefault();
                    if (highlightedIndex >= 0 && highlightedIndex < filteredOptions.length) {
                        selectOption(filteredOptions[highlightedIndex].value);
                    }
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    dropdown.remove();
                    exitEditMode(false);
                }
            };

            clearBtn.onclick = () => {
                selectOption('');
            };

            setTimeout(() => {
                document.addEventListener('click', function closeDropdown(e) {
                    if (!dropdown.contains(e.target) && e.target !== td) {
                        dropdown.remove();
                        exitEditMode(false);
                        document.removeEventListener('click', closeDropdown);
                    }
                });
            }, 0);

            renderOptions();
            searchInput.focus();
        }

        function showLinkedRecordDropdown(td, recordId, field) {
            const linkedSet = getLinkedSet(field);
            if (!linkedSet) {
                showToast(' Configure linked set first');
                exitEditMode(false);
                return;
            }

            const options = Array.from(linkedSet.records.values()).map(rec => ({
                value: rec.id,
                label: rec.name || rec.id,
                icon: '',
                color: '#e0f2fe'
            }));

            if (options.length === 0) {
                showToast(' No records in linked set');
                exitEditMode(false);
                return;
            }

            showEnhancedSelectDropdown(td, recordId, field, options);
        }

        function filterLinkedRecordSelect(selectId, query) {
            const select = document.getElementById(selectId);
            if (!select) return;

            const optionsData = select.dataset.options
                ? JSON.parse(decodeURIComponent(select.dataset.options))
                : [];
            const normalizedQuery = query.trim().toLowerCase();
            const filtered = optionsData.filter(opt => opt.label.toLowerCase().includes(normalizedQuery));
            const previousValue = select.value;

            select.innerHTML = '<option value="">Select a record</option>';

            if (filtered.length === 0) {
                const placeholder = document.createElement('option');
                placeholder.disabled = true;
                placeholder.textContent = 'No matches';
                select.appendChild(placeholder);
                select.value = '';
                select.disabled = true;
                return;
            }

            filtered.forEach(opt => {
                const option = document.createElement('option');
                option.value = opt.id;
                option.textContent = opt.label;
                select.appendChild(option);
            });

            const stillExists = filtered.some(opt => opt.id === previousValue);
            select.value = stillExists ? previousValue : '';
            select.disabled = false;
        }

      function updateRecord(recordId, fieldId, newValue, oldValue) {
          const set = getCurrentSet();
          const record = set.records.get(recordId);
          const field = set.schema.find(f => f.id === fieldId);
          record[fieldId] = newValue;
            createEvent(
                'Update Cell',
                'SEG',
                { type: 'Record', id: recordId, setId: set.id },
                {
                    fieldId: fieldId,
                    fieldName: field.name,
                    oldValue: oldValue,
                    newValue: newValue,
                    setId: set.id,
                    recordId: recordId,
                    summary: `Updated ${field.name}`
                }
            );
            recomputeFormulasForSet(set);
            renderCurrentView();
          showToast(` Updated ${field.name}`);
      }

        function buildDefaultConfigForType(type) {
            switch(type) {
                case 'SINGLE_SELECT':
                    return { options: [{ value: 'Option 1', color: 'blue' }] };
                case 'LINK_RECORD':
                    return { linkedSetId: state.currentSetId };
                case 'FORMULA':
                    return { formula: '', visualBlocks: [] };
                default:
                    return null;
            }
        }

        function snapshotFieldValues(set, fieldId) {
            const values = new Map();
            set.records.forEach((record, recordId) => {
                values.set(recordId, record[fieldId]);
            });
            return values;
        }

        function restoreFieldValues(set, fieldId, values) {
            values.forEach((value, recordId) => {
                const record = set.records.get(recordId);
                if (record) record[fieldId] = value;
            });
        }

        function convertValueForType(value, fromType, toType, targetConfig = {}) {
            const defaults = FIELD_TYPES[toType]?.defaultValue;
            if (value === undefined || value === null) return defaults;

            switch(toType) {
                case 'TEXT':
                case 'LONG_TEXT':
                    return value === '' ? '' : String(value);
                case 'NUMBER':
                case 'CURRENCY': {
                    if (value === '') return 0;
                    if (value instanceof Date) return value.getTime();
                    if (typeof value === 'boolean') return value ? 1 : 0;
                    const cleaned = String(value).replace(/[$,]/g, '');
                    const parsed = Number(cleaned);
                    return Number.isNaN(parsed) ? 0 : parsed;
                }
                case 'DATE': {
                    if (value instanceof Date) return value;
                    if (typeof value === 'number') {
                        const date = new Date(value);
                        return Number.isNaN(date.getTime()) ? '' : date;
                    }
                    const parsed = new Date(value);
                    return Number.isNaN(parsed.getTime()) ? '' : parsed;
                }
                case 'EMAIL':
                case 'URL':
                case 'PHONE':
                    return String(value ?? '').trim();
                case 'CHECKBOX':
                    if (typeof value === 'string') {
                        return ['true', '1', 'yes', 'y', 'checked', 'on'].includes(value.trim().toLowerCase());
                    }
                    return Boolean(value);
                case 'SINGLE_SELECT': {
                    const str = String(value ?? '').trim();
                    if (!str) return '';
                    const options = targetConfig.options || [];
                    if (!options.some(opt => opt.value === str)) {
                        options.push({ value: str, color: 'gray' });
                        targetConfig.options = options;
                    }
                    return str;
                }
                case 'LINK_RECORD':
                    return typeof value === 'string' ? value : '';
                case 'FORMULA':
                    return defaults;
                default:
                    return value;
            }
        }

      // FIELD MANAGEMENT
      function resetFieldNameValidation() {
          const nameInput = document.getElementById('newFieldName');
          const nameError = document.getElementById('fieldNameError');
          if (nameInput) {
              nameInput.classList.remove('input-error');
              nameInput.removeAttribute('aria-invalid');
          }
          if (nameError) {
              nameError.classList.add('hidden');
              nameError.textContent = '';
          }
      }

      function openAddFieldModal() {
          state.selectOptions = [{ value: 'Option 1', color: 'blue' }];
          const nameInput = document.getElementById('newFieldName');
          if (nameInput) nameInput.value = '';
          resetFieldNameValidation();
          document.getElementById('newFieldType').value = 'TEXT';
          const formulaInput = document.getElementById('formulaExpression');
          if (formulaInput) {
              formulaInput.value = '';
              delete formulaInput.dataset.visualBlocks;
          }
          renderFieldTypeGrid('TEXT');
            closeFieldTypeDropdown();
            updateFieldConfig('TEXT');

            const linkSelect = document.getElementById('linkToSet');
            linkSelect.innerHTML = '';
            getSetsForWorld(state.currentWorldId).forEach(set => {
                const label = set.id === state.currentSetId ? `${set.name} (this set)` : set.name;
                linkSelect.innerHTML += `<option value="${set.id}">${label}</option>`;
            });
            if (linkSelect.options.length === 0) {
                linkSelect.innerHTML = '<option value="">No sets available</option>';
                linkSelect.disabled = true;
            } else {
                linkSelect.disabled = false;
                const defaultValue = state.sets.has(state.currentSetId) ? state.currentSetId : linkSelect.options[0].value;
                linkSelect.value = defaultValue;
            }

            openModal('addFieldModal');
        }

        function renderFieldTypeGrid(selectedType) {
            const trigger = document.getElementById('fieldTypeTrigger');
            const dropdown = document.getElementById('fieldTypeDropdown');
            const selectedName = document.getElementById('selectedFieldTypeName');
            const selectedDescription = document.getElementById('selectedFieldTypeDescription');

            if (!trigger || !dropdown) return;

            const fieldType = FIELD_TYPES[selectedType] || Object.values(FIELD_TYPES)[0];
            const iconTarget = trigger.querySelector('.field-type-trigger-icon');
            if (iconTarget) iconTarget.innerHTML = renderIcon(fieldType.icon);
            if (selectedName) selectedName.textContent = fieldType.name;
            if (selectedDescription) selectedDescription.textContent = fieldType.description || fieldType.id.replace(/_/g, ' ');

            dropdown.innerHTML = '';
            Object.values(FIELD_TYPES).forEach(optionType => {
                const option = document.createElement('div');
                option.className = `field-type-option ${optionType.id === selectedType ? 'selected' : ''}`;
                option.dataset.typeId = optionType.id;
                option.innerHTML = `
                    <div class="field-type-icon">${renderIcon(optionType.icon)}</div>
                    <div class="field-type-info">
                        <div class="field-type-name">${optionType.name}</div>
                        <div class="field-type-description">${optionType.description || optionType.id.replace(/_/g, ' ')}</div>
                    </div>
                    <span class="field-type-check">${optionType.id === selectedType ? '' : ''}</span>
                `;
                option.onclick = () => selectFieldType(optionType.id);
                dropdown.appendChild(option);
            });
        }

        function selectFieldType(typeId) {
            document.getElementById('newFieldType').value = typeId;
            renderFieldTypeGrid(typeId);
            updateFieldConfig(typeId);
            closeFieldTypeDropdown();
        }

        function renderChangeFieldTypeGrid(selectedType) {
            const trigger = document.getElementById('changeFieldTypeTrigger');
            const dropdown = document.getElementById('changeFieldTypeDropdown');
            const selectedName = document.getElementById('changeSelectedFieldTypeName');
            const selectedDescription = document.getElementById('changeSelectedFieldTypeDescription');

            if (!trigger || !dropdown) return;

            const fieldType = FIELD_TYPES[selectedType] || Object.values(FIELD_TYPES)[0];
            const iconTarget = trigger.querySelector('.field-type-trigger-icon');
            if (iconTarget) iconTarget.innerHTML = renderIcon(fieldType.icon);
            if (selectedName) selectedName.textContent = fieldType.name;
            if (selectedDescription) selectedDescription.textContent = fieldType.description || fieldType.id.replace(/_/g, ' ');

            dropdown.innerHTML = '';
            Object.values(FIELD_TYPES).forEach(optionType => {
                const option = document.createElement('div');
                option.className = `field-type-option ${optionType.id === selectedType ? 'selected' : ''}`;
                option.dataset.typeId = optionType.id;
                option.innerHTML = `
                    <div class="field-type-icon">${renderIcon(optionType.icon)}</div>
                    <div class="field-type-info">
                        <div class="field-type-name">${optionType.name}</div>
                        <div class="field-type-description">${optionType.description || optionType.id.replace(/_/g, ' ')}</div>
                    </div>
                    <span class="field-type-check">${optionType.id === selectedType ? '' : ''}</span>
                `;
                option.onclick = () => selectChangeFieldType(optionType.id);
                dropdown.appendChild(option);
            });
        }

        function describeFieldType(typeId) {
            return FIELD_TYPES[typeId]?.name || typeId || '';
        }

        function updateChangeFieldTypeSummary(selectedType) {
            const summary = document.getElementById('changeFieldTypeSummary');
            if (!summary) return;

            const originalType = state.changeFieldOriginalType;
            const currentLabel = describeFieldType(selectedType);

            if (!originalType) {
                summary.textContent = currentLabel ? `Type: ${currentLabel}` : '';
                return;
            }

            const originalLabel = describeFieldType(originalType);
            if (selectedType === originalType) {
                summary.textContent = `Type: ${originalLabel}`;
            } else {
                summary.textContent = `Type: ${originalLabel}  ${currentLabel}`;
            }
        }

        function selectChangeFieldType(typeId) {
            const input = document.getElementById('changeFieldTypeInput');
            if (input) input.value = typeId;
            renderChangeFieldTypeGrid(typeId);
            resetChangeFieldConfig(typeId);
            renderChangeFieldConfig(typeId);
            if (typeId === 'LINK_RECORD') {
                renderChangeLinkSelect();
            }
            updateChangeFieldTypeSummary(typeId);
            closeChangeFieldTypeDropdown();
        }

        function toggleFieldTypeDropdown() {
            if (state.fieldTypeDropdownOpen) {
                closeFieldTypeDropdown();
            } else {
                openFieldTypeDropdown();
            }
        }

        function toggleChangeFieldTypeDropdown() {
            if (state.changeFieldTypeDropdownOpen) {
                closeChangeFieldTypeDropdown();
            } else {
                openChangeFieldTypeDropdown();
            }
        }

        function openFieldTypeDropdown() {
            const dropdown = document.getElementById('fieldTypeDropdown');
            const trigger = document.getElementById('fieldTypeTrigger');
            if (!dropdown || !trigger) return;
            dropdown.classList.remove('hidden');
            trigger.classList.add('active');
            state.fieldTypeDropdownOpen = true;
        }

        function openChangeFieldTypeDropdown() {
            const dropdown = document.getElementById('changeFieldTypeDropdown');
            const trigger = document.getElementById('changeFieldTypeTrigger');
            if (!dropdown || !trigger) return;
            dropdown.classList.remove('hidden');
            trigger.classList.add('active');
            state.changeFieldTypeDropdownOpen = true;
        }

        function closeFieldTypeDropdown() {
            const dropdown = document.getElementById('fieldTypeDropdown');
            const trigger = document.getElementById('fieldTypeTrigger');
            if (!dropdown || !trigger) return;
            dropdown.classList.add('hidden');
            trigger.classList.remove('active');
            state.fieldTypeDropdownOpen = false;
        }

        function closeChangeFieldTypeDropdown() {
            const dropdown = document.getElementById('changeFieldTypeDropdown');
            const trigger = document.getElementById('changeFieldTypeTrigger');
            if (!dropdown || !trigger) return;
            dropdown.classList.add('hidden');
            trigger.classList.remove('active');
            state.changeFieldTypeDropdownOpen = false;
        }

        function hasFieldHistory(setId, fieldId) {
            const key = `${setId}:${fieldId}`;
            const stack = state.fieldTypeHistory.get(key);
            return Array.isArray(stack) && stack.length > 0;
        }

        function buildChangeFieldConfig(typeId) {
            if (typeId === 'SINGLE_SELECT') {
                return {
                    options: state.changeSelectOptions.map(o => o.value),
                    colors: Object.fromEntries(state.changeSelectOptions.map(o => [o.value, o.color]))
                };
            }
            if (typeId === 'LINK_RECORD') {
                return { linkedSetId: state.changeLinkedSetId || state.currentSetId };
            }
            if (typeId === 'FORMULA') {
                const textarea = document.getElementById('changeFormulaExpression');
                let visualBlocks = [];
                if (textarea?.dataset?.visualBlocks) {
                    try { visualBlocks = JSON.parse(textarea.dataset.visualBlocks); } catch (error) { visualBlocks = []; }
                }
                return { formula: textarea?.value?.trim() || '', visualBlocks };
            }
            return null;
        }

        function changeFieldType(fieldId, newType, newConfig = null) {
            const set = getCurrentSet();
            const field = set.schema.find(f => f.id === fieldId);
            if (!field || !FIELD_TYPES[newType]) return;

            const previousType = field.type;
            const previousConfig = cloneConfig(field.config);
            const targetConfig = cloneConfig(newConfig ?? buildDefaultConfigForType(newType));
            const typeChanged = previousType !== newType;
            const configChanged = JSON.stringify(previousConfig || null) !== JSON.stringify(targetConfig || null);

            if (!typeChanged && !configChanged) return;

            const historyKey = `${set.id}:${fieldId}`;
            const historyStack = state.fieldTypeHistory.get(historyKey) || [];
            const historyEntry = {
                type: previousType,
                config: cloneConfig(field.config)
            };
            if (typeChanged) {
                historyEntry.values = snapshotFieldValues(set, fieldId);
            }
            historyStack.push(historyEntry);
            state.fieldTypeHistory.set(historyKey, historyStack);

            if (typeChanged) {
                set.records.forEach((record, recordId) => {
                    const oldValue = record[fieldId];
                    record[fieldId] = convertValueForType(oldValue, previousType, newType, targetConfig || {});
                });
            }

            field.type = newType;
            field.config = targetConfig;

            createEvent(
                'Change Field Type',
                'SEG',
                { type: 'Field', id: fieldId, setId: set.id },
                { previousType, newType, fieldId, fieldName: field.name, setId: set.id, summary: typeChanged ? `Changed ${field.name} to ${FIELD_TYPES[newType].name}` : `Updated ${field.name}` }
            );

            recomputeFormulasForSet(set);
            renderCurrentView();
            showToast(typeChanged ? ` ${field.name} is now ${FIELD_TYPES[newType].name}` : ` ${field.name} updated`);
        }

        function saveChangeFieldType() {
            const context = state.changeFieldContext;
            const input = document.getElementById('changeFieldTypeInput');
            const newType = input?.value;
            if (!context || !newType) return;
            const newConfig = buildChangeFieldConfig(newType);
            changeFieldType(context.id, newType, newConfig);
            closeChangeFieldTypeModal();
        }

        function closeChangeFieldTypeModal() {
            state.changeFieldContext = null;
            state.changeFieldOriginalType = null;
            closeModal('changeFieldTypeModal');
        }

        function revertFieldType(fieldId) {
            const set = getCurrentSet();
            const field = set.schema.find(f => f.id === fieldId);
            if (!field) return;

            const historyKey = `${set.id}:${fieldId}`;
            const historyStack = state.fieldTypeHistory.get(historyKey) || [];
            const last = historyStack.pop();

            if (!last) {
                showToast('No previous type to restore');
                return;
            }

            field.type = last.type;
            field.config = cloneConfig(last.config);
            if (last.values) {
                restoreFieldValues(set, fieldId, last.values);
            }
            if (historyStack.length === 0) {
                state.fieldTypeHistory.delete(historyKey);
            } else {
                state.fieldTypeHistory.set(historyKey, historyStack);
            }

            createEvent(
                'Revert Field Type',
                'SEG',
                { type: 'Field', id: fieldId, setId: set.id },
                { restoredType: last.type, fieldId, fieldName: field.name, setId: set.id, summary: `Reverted ${field.name} to ${FIELD_TYPES[last.type].name}` }
            );

            recomputeFormulasForSet(set);
            renderCurrentView();
            showToast(` ${field.name} restored to ${FIELD_TYPES[last.type].name}`);
        }

        function updateFieldConfig(typeId) {
            document.getElementById('singleSelectConfig').classList.remove('visible');
            document.getElementById('linkToRecordConfig').classList.remove('visible');
            document.getElementById('formulaFieldConfig').classList.remove('visible');
            if (typeId === 'SINGLE_SELECT') {
                document.getElementById('singleSelectConfig').classList.add('visible');
                renderSelectOptions();
            } else if (typeId === 'LINK_RECORD') {
                document.getElementById('linkToRecordConfig').classList.add('visible');
            } else if (typeId === 'FORMULA') {
                document.getElementById('formulaFieldConfig').classList.add('visible');
            }
        }

        function renderChangeFieldConfig(typeId) {
            document.getElementById('changeSingleSelectConfig').classList.remove('visible');
            document.getElementById('changeLinkToRecordConfig').classList.remove('visible');
            document.getElementById('changeFormulaFieldConfig').classList.remove('visible');

            if (typeId === 'SINGLE_SELECT') {
                document.getElementById('changeSingleSelectConfig').classList.add('visible');
                renderChangeSelectOptions();
            } else if (typeId === 'LINK_RECORD') {
                document.getElementById('changeLinkToRecordConfig').classList.add('visible');
            } else if (typeId === 'FORMULA') {
                document.getElementById('changeFormulaFieldConfig').classList.add('visible');
            }
        }

        function renderChangeSelectOptions() {
            const container = document.getElementById('changeSelectOptionsList');
            container.innerHTML = state.changeSelectOptions.map((opt, i) => `
                <div class="option-row">
                    <input type="text" value="${opt.value}" onchange="changeUpdateSelectOption(${i}, this.value, '${opt.color}')" placeholder="Option ${i + 1}">
                    <div class="color-picker">
                        ${['blue', 'green', 'yellow', 'red', 'purple', 'gray'].map(c => `
                            <div class="color-option badge-${c} ${opt.color === c ? 'selected' : ''}"
                                 onclick="changeUpdateSelectOption(${i}, '${opt.value}', '${c}')"></div>
                        `).join('')}
                    </div>
                    ${state.changeSelectOptions.length > 1 ? `<button onclick="changeRemoveSelectOption(${i})" class="btn btn-secondary btn-sm"></button>` : ''}
                </div>
            `).join('');
        }

        function changeAddSelectOption() {
            state.changeSelectOptions.push({ value: `Option ${state.changeSelectOptions.length + 1}`, color: 'blue' });
            renderChangeSelectOptions();
        }

        function changeUpdateSelectOption(index, value, color) {
            state.changeSelectOptions[index] = { value, color };
            renderChangeSelectOptions();
        }

        function changeRemoveSelectOption(index) {
            state.changeSelectOptions.splice(index, 1);
            renderChangeSelectOptions();
        }

        function resetChangeFieldConfig(typeId, field = null) {
            if (typeId === 'SINGLE_SELECT') {
                if (field?.config?.options) {
                    state.changeSelectOptions = field.config.options.map(opt => ({
                        value: typeof opt === 'string' ? opt : opt.value,
                        color: field.config.colors?.[typeof opt === 'string' ? opt : opt.value] || opt.color || 'blue'
                    }));
                } else {
                    state.changeSelectOptions = [{ value: 'Option 1', color: 'blue' }];
                }
            } else if (typeId === 'LINK_RECORD') {
                state.changeLinkedSetId = field?.config?.linkedSetId || state.currentSetId;
            } else if (typeId === 'FORMULA') {
                const textarea = document.getElementById('changeFormulaExpression');
                const formula = field?.config?.formula || '';
                if (textarea) {
                    textarea.value = formula;
                    if (field?.config?.visualBlocks) {
                        textarea.dataset.visualBlocks = JSON.stringify(field.config.visualBlocks);
                        state.changeFormulaBlocks = field.config.visualBlocks;
                    } else {
                        delete textarea.dataset.visualBlocks;
                        state.changeFormulaBlocks = [];
                    }
                }
            } else {
                const textarea = document.getElementById('changeFormulaExpression');
                if (textarea) { textarea.value = ''; delete textarea.dataset.visualBlocks; }
                state.changeFormulaBlocks = [];
            }
        }

        function renderChangeLinkSelect() {
            const linkSelect = document.getElementById('changeLinkToSet');
            if (!linkSelect) return;

            linkSelect.innerHTML = '';
            getSetsForWorld(state.currentWorldId).forEach(set => {
                const label = set.id === state.currentSetId ? `${set.name} (this set)` : set.name;
                linkSelect.innerHTML += `<option value="${set.id}">${label}</option>`;
            });

            if (linkSelect.options.length === 0) {
                linkSelect.innerHTML = '<option value="">No sets available</option>';
                linkSelect.disabled = true;
                state.changeLinkedSetId = '';
            } else {
                linkSelect.disabled = false;
                const defaultValue = state.changeLinkedSetId || (state.sets.has(state.currentSetId) ? state.currentSetId : linkSelect.options[0].value);
                linkSelect.value = defaultValue;
                state.changeLinkedSetId = defaultValue;
            }
        }

        function renderSelectOptions() {
            const container = document.getElementById('selectOptionsList');
            container.innerHTML = state.selectOptions.map((opt, i) => `
                <div class="option-row">
                    <input type="text" value="${opt.value}" onchange="updateSelectOption(${i}, this.value, '${opt.color}')" placeholder="Option ${i + 1}">
                    <div class="color-picker">
                        ${['blue', 'green', 'yellow', 'red', 'purple', 'gray'].map(c => `
                            <div class="color-option badge-${c} ${opt.color === c ? 'selected' : ''}" 
                                 onclick="updateSelectOption(${i}, '${opt.value}', '${c}')"></div>
                        `).join('')}
                    </div>
                    ${state.selectOptions.length > 1 ? `<button onclick="removeSelectOption(${i})" class="btn btn-secondary btn-sm"></button>` : ''}
                </div>
            `).join('');
        }

        function addSelectOption() {
            state.selectOptions.push({ value: `Option ${state.selectOptions.length + 1}`, color: 'blue' });
            renderSelectOptions();
        }

        function updateSelectOption(index, value, color) {
            state.selectOptions[index] = { value, color };
            renderSelectOptions();
        }

        function removeSelectOption(index) {
            state.selectOptions.splice(index, 1);
            renderSelectOptions();
        }

      function saveField() {
          const nameInput = document.getElementById('newFieldName');
          const nameError = document.getElementById('fieldNameError');
          const name = nameInput.value.trim();
          const type = document.getElementById('newFieldType').value;

          if (!name) {
              if (nameError) {
                  nameError.textContent = 'Please add a field name to continue.';
                  nameError.classList.remove('hidden');
              }
              nameInput.classList.add('input-error');
              nameInput.setAttribute('aria-invalid', 'true');
              nameInput.focus();
              return;
          }

          resetFieldNameValidation();

          const set = getCurrentSet();
          const fieldId = name.toLowerCase().replace(/[^a-z0-9]/g, '_');
            
            if (set.schema.find(f => f.id === fieldId)) {
                showConfirm('A field with this name already exists', () => {});
                return;
            }
            
            const newField = { id: fieldId, name: name, type: type, width: '150px', config: {} };

            if (type === 'SINGLE_SELECT') {
                newField.config = {
                    options: state.selectOptions.map(o => o.value),
                    colors: Object.fromEntries(state.selectOptions.map(o => [o.value, o.color]))
                };
            } else if (type === 'LINK_RECORD') {
                const linkedSetId = document.getElementById('linkToSet').value;
                if (!linkedSetId) { showConfirm('Select a set to link to', () => {}); return; }
                newField.config = { linkedSetId };
            } else if (type === 'FORMULA') {
                const formulaValue = document.getElementById('formulaExpression').value.trim();
                if (!formulaValue) { showConfirm('Enter a formula expression for this field', () => {}); return; }
                let visualBlocks = [];
                const visualBlocksRaw = document.getElementById('formulaExpression')?.dataset?.visualBlocks;
                if (visualBlocksRaw) {
                    try { visualBlocks = JSON.parse(visualBlocksRaw); } catch (error) { visualBlocks = []; }
                }
                newField.config = { formula: formulaValue, visualBlocks };
            }

            set.schema.push(newField);
            set.records.forEach(r => r[fieldId] = FIELD_TYPES[type].defaultValue);
            recomputeFormulasForSet(set);

            closeModal('addFieldModal');
            renderCurrentView();
            
            // Scroll to new field
            setTimeout(() => {
                const header = document.querySelector(`[data-field-id="${fieldId}"]`);
                if (header) {
                    header.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'end' });
                    header.style.animation = 'flash-yellow 0.5s ease-out';
                }
            }, 100);
            
            showToast(' Field added');
        }

        // FILTERING (simplified for space)
        function openFilterModal() {
            renderFilterBuilder();
            openModal('filterModal');
        }

        function renderFilterBuilder() {
            const view = getCurrentView();
            const container = document.getElementById('filterGroupsContainer');
            if (!view.filters || view.filters.length === 0) view.filters = [[{ field: '', operator: 'equals', value: '' }]];
            container.innerHTML = view.filters.map((group, groupIndex) => `
                <div class="filter-group">
                    <div class="filter-group-header">
                        <div class="filter-operator-toggle">
                            <button class="${group.operator !== 'OR' ? 'active' : ''}" onclick="setGroupOperator(${groupIndex}, 'AND')">AND</button>
                            <button class="${group.operator === 'OR' ? 'active' : ''}" onclick="setGroupOperator(${groupIndex}, 'OR')">OR</button>
                        </div>
                        <button onclick="removeFilterGroup(${groupIndex})" class="text-red-600 text-sm">Remove Group</button>
                    </div>
                    ${group.map((rule, ruleIndex) => renderFilterRule(groupIndex, ruleIndex, rule)).join('')}
                    <button onclick="addFilterRule(${groupIndex})" class="btn btn-secondary btn-sm mt-2">+ Add Rule</button>
                </div>
            `).join('');
        }

        function renderFilterRule(groupIndex, ruleIndex, rule) {
            const schema = getCurrentSet().schema;
            return `
                <div class="filter-rule">
                    <select onchange="updateFilterField(${groupIndex}, ${ruleIndex}, this.value)">
                        <option value="">Select field...</option>
                        ${schema.map(f => `<option value="${f.id}" ${f.id === rule.field ? 'selected' : ''}>${f.name}</option>`).join('')}
                    </select>
                    <select><option>equals</option></select>
                    <input type="text" value="${rule.value || ''}" onchange="updateFilterValue(${groupIndex}, ${ruleIndex}, this.value)">
                    <button onclick="removeFilterRule(${groupIndex}, ${ruleIndex})" class="text-red-600"></button>
                </div>
            `;
        }

        function applyFilterGroups(records, filterGroups, schema) {
            return records.filter(record => {
                return filterGroups.some(group => {
                    const operator = group.operator || 'AND';
                    const rules = group.filter(r => r.field);
                    if (operator === 'AND') return rules.every(rule => record[rule.field] === rule.value);
                    else return rules.some(rule => record[rule.field] === rule.value);
                });
            });
        }

        function getSortableValue(value, field) {
            if (value === undefined || value === null) return '';
            switch(field?.type) {
                case 'NUMBER':
                case 'CURRENCY':
                    return Number(value) || 0;
                case 'DATE':
                    return new Date(value).getTime() || 0;
                case 'CHECKBOX':
                    return value ? 1 : 0;
                default:
                    return String(value).toLowerCase();
            }
        }

        function applySorts(records, sorts, schema) {
            if (!sorts || sorts.length === 0) return records;
            const schemaMap = new Map(schema.map(f => [f.id, f]));
            const activeSorts = sorts.filter(sort => schemaMap.has(sort.fieldId));
            if (activeSorts.length === 0) return records;

            return [...records].sort((a, b) => {
                for (const sort of activeSorts) {
                    const field = schemaMap.get(sort.fieldId);
                    const aVal = getSortableValue(a[sort.fieldId], field);
                    const bVal = getSortableValue(b[sort.fieldId], field);

                    if (aVal < bVal) return sort.direction === 'desc' ? 1 : -1;
                    if (aVal > bVal) return sort.direction === 'desc' ? -1 : 1;
                }
                return 0;
            });
        }

        function toggleColumnSort(fieldId) {
            const view = getCurrentView();
            if (!view) return;

            ensureViewDefaults(view);
            const existingIndex = view.sorts.findIndex(s => s.fieldId === fieldId);
            if (existingIndex === -1) {
                view.sorts.unshift({ fieldId, direction: 'asc' });
            } else if (view.sorts[existingIndex].direction === 'asc') {
                view.sorts[existingIndex].direction = 'desc';
            } else {
                view.sorts.splice(existingIndex, 1);
            }

            renderCurrentView();
        }

        function openSortModal() {
            const view = getCurrentView();
            if (!view) return;

            ensureViewDefaults(view);
            renderSortBuilder();
            openModal('sortModal');
        }

        function renderSortBuilder() {
            const set = getCurrentSet();
            const view = getCurrentView();
            if (!set || !view) return;

            const container = document.getElementById('sortRulesContainer');
            const schema = set.schema;

            if (!view.sorts || view.sorts.length === 0) {
                container.innerHTML = '<p class="text-sm text-gray-500">No sorts configured. Add a field to start sorting.</p>';
                return;
            }

            container.innerHTML = view.sorts.map((sort, index) => `
                <div class="flex items-center gap-3 p-3 rounded-lg border border-gray-200 bg-gray-50">
                    <div class="text-xs font-semibold text-gray-500">#${index + 1}</div>
                    <select class="flex-1" onchange="updateSortField(${index}, this.value)">
                        <option value="">Select field...</option>
                        ${schema.map(f => `<option value="${f.id}" ${f.id === sort.fieldId ? 'selected' : ''}>${f.name}</option>`).join('')}
                    </select>
                    <select onchange="updateSortDirection(${index}, this.value)">
                        <option value="asc" ${sort.direction === 'asc' ? 'selected' : ''}>Ascending</option>
                        <option value="desc" ${sort.direction === 'desc' ? 'selected' : ''}>Descending</option>
                    </select>
                    <div class="flex items-center gap-1">
                        <button class="btn btn-secondary btn-sm" onclick="moveSort(${index}, -1)" ${index === 0 ? 'disabled' : ''}></button>
                        <button class="btn btn-secondary btn-sm" onclick="moveSort(${index}, 1)" ${index === view.sorts.length - 1 ? 'disabled' : ''}></button>
                        <button class="btn btn-danger btn-sm" onclick="removeSortRule(${index})"></button>
                    </div>
                </div>
            `).join('');
        }

        function addSortRule() {
            const set = getCurrentSet();
            const view = getCurrentView();
            if (!set || !view) return;

            const defaultField = set.schema[0]?.id || '';
            view.sorts.push({ fieldId: defaultField, direction: 'asc' });
            renderSortBuilder();
        }

        function updateSortField(index, fieldId) {
            const view = getCurrentView();
            if (!view) return;
            view.sorts[index].fieldId = fieldId;
            renderSortBuilder();
        }

        function updateSortDirection(index, direction) {
            const view = getCurrentView();
            if (!view) return;
            view.sorts[index].direction = direction;
            renderSortBuilder();
        }

        function moveSort(index, delta) {
            const view = getCurrentView();
            if (!view) return;
            const newIndex = index + delta;
            if (newIndex < 0 || newIndex >= view.sorts.length) return;
            const [item] = view.sorts.splice(index, 1);
            view.sorts.splice(newIndex, 0, item);
            renderSortBuilder();
        }

        function removeSortRule(index) {
            const view = getCurrentView();
            if (!view) return;
            view.sorts.splice(index, 1);
            renderSortBuilder();
        }

        function clearSorts() {
            const view = getCurrentView();
            if (!view) return;
            view.sorts = [];
            renderSortBuilder();
            renderCurrentView();
        }

        function applySortsFromModal() {
            closeModal('sortModal');
            renderCurrentView();
        }

        function setGroupOperator(groupIndex, operator) {
            const view = getCurrentView();
            view.filters[groupIndex].operator = operator;
            renderFilterBuilder();
        }

        function addFilterRule(groupIndex) {
            const view = getCurrentView();
            view.filters[groupIndex].push({ field: '', operator: 'equals', value: '' });
            renderFilterBuilder();
        }

        function removeFilterRule(groupIndex, ruleIndex) {
            const view = getCurrentView();
            view.filters[groupIndex].splice(ruleIndex, 1);
            if (view.filters[groupIndex].length === 0) view.filters.splice(groupIndex, 1);
            renderFilterBuilder();
        }

        function addFilterGroup() {
            const view = getCurrentView();
            view.filters.push([{ field: '', operator: 'equals', value: '' }]);
            renderFilterBuilder();
        }

        function removeFilterGroup(groupIndex) {
            const view = getCurrentView();
            view.filters.splice(groupIndex, 1);
            renderFilterBuilder();
        }

        function updateFilterField(groupIndex, ruleIndex, fieldId) {
            const view = getCurrentView();
            view.filters[groupIndex][ruleIndex].field = fieldId;
            renderFilterBuilder();
        }

        function updateFilterValue(groupIndex, ruleIndex, value) {
            const view = getCurrentView();
            view.filters[groupIndex][ruleIndex].value = value;
        }

        function applyFilters() {
            closeModal('filterModal');
            renderCurrentView();
            showToast(' Filters applied');
        }

        function clearFilters() {
            const view = getCurrentView();
            view.filters = [[{ field: '', operator: 'equals', value: '' }]];
            renderFilterBuilder();
        }

        // EXPANDED RECORD
        function openExpandedRecord(recordId) {
            const set = getCurrentSet();
            const record = set.records.get(recordId);
            state.currentRecordTab = 'history';
            state.recordHistoryVisible = true;
            document.getElementById('expandedRecordTitle').textContent = record.name || record.id;
            renderExpandedRecordMain(recordId);
            renderRecordSidebar(recordId);
            updateRecordHistoryVisibility();
            openModal('expandedRecordModal');
        }

        function openCellHistory(recordId, fieldId) {
            openObservationModal({ recordId, fieldId, setId: getCurrentSet()?.id });
        }

        function openObservationModal({ recordId = null, fieldId = null, setId = null, keyValue = null, field = null, items = [] }) {
            const modal = document.getElementById('cellHistoryModal');
            const targetSet = setId ? state.sets.get(setId) : getCurrentSet();
            const record = recordId ? targetSet?.records.get(recordId) : null;
            const schemaField = field || targetSet?.schema?.find(f => f.id === fieldId) || { id: fieldId, name: fieldId, type: 'TEXT' };

            const entries = state.eventStream
                .filter(e => e.op === 'SEG' && e.data?.fieldId === schemaField.id && (!recordId || e.data?.recordId === recordId))
                .sort((a, b) => new Date(a.published) - new Date(b.published));

            const supValues = [];
            const latestValue = record ? record[schemaField.id] : null;
            if (latestValue && latestValue._sup && Array.isArray(latestValue.value)) supValues.push(...latestValue.value);
            if (items.length > 0 && schemaField) {
                items.forEach(item => {
                    const candidate = item.record[schemaField.sourceFieldId || schemaField.id];
                    if (candidate && candidate._sup && Array.isArray(candidate.value)) supValues.push(...candidate.value);
                });
            }

            state.cellHistoryContext = {
                recordId,
                fieldId: schemaField.id,
                fieldName: schemaField.name || schemaField.id,
                recordName: record?.name || keyValue || recordId || 'Item',
                entries,
                index: entries.length > 0 ? entries.length - 1 : 0,
                selectedValueSource: 'new',
                supValues,
                latestValue,
                fieldType: schemaField.type,
                sourceSetName: targetSet?.name
            };

            renderCellHistoryModal();
            if (modal?.classList.contains('hidden')) openModal('cellHistoryModal');
        }

        function renderCellHistoryModal() {
            const container = document.getElementById('cellHistoryContent');
            const title = document.getElementById('cellHistoryTitle');
            const subtitle = document.getElementById('cellHistorySubtitle');
            const ctx = state.cellHistoryContext;

            if (!ctx) return;
            ctx.activePanel = ctx.activePanel || 'latest';

            title.textContent = `${ctx.fieldName} observations`;
            subtitle.textContent = ctx.recordName ? `Item: ${ctx.recordName}` : 'Multiple items';

            const supList = (ctx.supValues || []).map(entry => `<div class="flex items-center justify-between border rounded-lg p-2"><span class="font-medium">${entry.val ?? ''}</span><span class="text-xs text-gray-500">${entry.context?.source || 'observation'}</span></div>`).join('');
            const timeline = ctx.entries.map((entry, i) => `
                <div class="border rounded-lg p-3 ${i === ctx.index ? 'border-blue-500 bg-blue-50' : 'border-gray-200 bg-white'}" onclick="selectCellHistoryEntry(${i})">
                    <div class="flex items-center justify-between">
                        <div class="font-medium">${entry.data?.fieldName || ctx.fieldName}</div>
                        <div class="text-xs text-gray-500">${new Date(entry.published).toLocaleString()}</div>
                    </div>
                    <div class="text-sm text-gray-600 mt-1">${entry.data?.summary || 'Updated value'}</div>
                    <div class="text-sm mt-2 flex items-center gap-2">
                        <span class="text-red-600">${entry.data?.oldValue ?? ''}</span>
                        <span></span>
                        <span class="text-green-600">${entry.data?.newValue ?? ''}</span>
                    </div>
                </div>
            `).join('');

            const activeEntry = ctx.entries[ctx.index] || {};
            const selectedValue = ctx.selectedValueSource === 'old'
                ? activeEntry.data?.oldValue
                : activeEntry.data?.newValue;
            const latestValue = ctx.latestValue ?? selectedValue;

            container.innerHTML = `
                <div class="flex items-center gap-2 mb-4">
                    ${['latest','observations','timeline','connections'].map(tab => `<button class="btn btn-secondary btn-sm ${ctx.activePanel === tab ? 'bg-gray-200' : ''}" onclick="setObservationPanel('${tab}')">${tab === 'latest' ? ' Latest Value' : tab === 'observations' ? ' Observations' : tab === 'timeline' ? ' Timeline' : ' Connections'}</button>`).join('')}
                </div>
                <div class="space-y-4">
                    ${ctx.activePanel === 'latest' ? `<div class="text-lg font-semibold">${renderCellValue(latestValue, { type: ctx.fieldType || 'TEXT' }, {}) || ''}</div>` : ''}
                    ${ctx.activePanel === 'observations' ? (supList || '<p class="text-gray-500">No multiple observations yet.</p>') : ''}
                    ${ctx.activePanel === 'timeline' ? `<div class="flex items-center justify-between mb-2"><div class="text-sm text-gray-600">${ctx.entries.length} change${ctx.entries.length === 1 ? '' : 's'} found</div><div class="flex items-center gap-2"><button class="btn btn-secondary btn-sm" ${ctx.index === 0 ? 'disabled' : ''} onclick="stepCellHistory(-1)"> Prev</button><button class="btn btn-secondary btn-sm" ${ctx.index >= ctx.entries.length - 1 ? 'disabled' : ''} onclick="stepCellHistory(1)">Next </button></div></div><div class="space-y-3">${timeline}</div>` : ''}
                    ${ctx.activePanel === 'connections' ? `<div class="text-sm text-gray-600">Source Set: ${ctx.sourceSetName || 'Unknown'}</div>` : ''}
                </div>
            `;
        }

        function setObservationPanel(panel) {
            if (!state.cellHistoryContext) return;
            state.cellHistoryContext.activePanel = panel;
            renderCellHistoryModal();
        }

        function selectCellHistoryEntry(index) {
            if (!state.cellHistoryContext) return;
            state.cellHistoryContext.index = index;
            renderCellHistoryModal();
        }

        function stepCellHistory(direction) {
            if (!state.cellHistoryContext || state.cellHistoryContext.entries.length === 0) return;
            const newIndex = Math.min(Math.max(state.cellHistoryContext.index + direction, 0), state.cellHistoryContext.entries.length - 1);
            state.cellHistoryContext.index = newIndex;
            renderCellHistoryModal();
        }

        function chooseHistoryValue(source) {
            if (!state.cellHistoryContext) return;
            state.cellHistoryContext.selectedValueSource = source;
            renderCellHistoryModal();
        }

        function applySelectedHistoricalValue() {
            const ctx = state.cellHistoryContext;
            if (!ctx || ctx.entries.length === 0) return;

            const entry = ctx.entries[ctx.index];
            const selectedValue = ctx.selectedValueSource === 'old'
                ? entry.data?.oldValue
                : entry.data?.newValue;

            const set = getCurrentSet();
            const record = set.records.get(ctx.recordId);
            const currentValue = record ? record[ctx.fieldId] : undefined;

            updateRecord(ctx.recordId, ctx.fieldId, selectedValue, currentValue);

            if (!document.getElementById('expandedRecordModal').classList.contains('hidden')) {
                renderExpandedRecordMain(ctx.recordId);
                renderRecordSidebar(ctx.recordId);
            }

            openCellHistory(ctx.recordId, ctx.fieldId);
        }

        function ensurePopupRule(fieldId) {
            const view = getCurrentView();
            if (!view) return null;
            view.popupVisibilityRules = view.popupVisibilityRules || [];
            let rule = view.popupVisibilityRules.find(r => r.fieldId === fieldId);
            if (!rule) {
                rule = { fieldId, visibility: 'show', criteria: { type: 'always', value: '' } };
                view.popupVisibilityRules.push(rule);
            }
            return rule;
        }

        function evaluatePopupCriteria(criteria, value) {
            if (!criteria || criteria.type === 'always') return true;

            switch (criteria.type) {
                case 'equals':
                    return String(value ?? '').toLowerCase() === String(criteria.value ?? '').toLowerCase();
                case 'notEquals':
                    return String(value ?? '').toLowerCase() !== String(criteria.value ?? '').toLowerCase();
                case 'contains':
                    return String(value ?? '').toLowerCase().includes(String(criteria.value ?? '').toLowerCase());
                case 'empty':
                    return value === undefined || value === null || value === '';
                case 'notEmpty':
                    return !(value === undefined || value === null || value === '');
                default:
                    return true;
            }
        }

        function refreshOpenRecordModal() {
            const container = document.getElementById('expandedRecordMain');
            const recordId = container?.dataset?.recordId;
            if (recordId && !document.getElementById('expandedRecordModal').classList.contains('hidden')) {
                renderExpandedRecordMain(recordId);
            }
        }

        function shouldDisplayFieldInPopup(field, record) {
            const view = getCurrentView();
            if (!view) return true;
            view.popupVisibilityRules = view.popupVisibilityRules || [];
            const rule = view.popupVisibilityRules.find(r => r.fieldId === field.id);
            if (!rule) return true;

            const criteriaMet = evaluatePopupCriteria(rule.criteria, record[field.id]);
            if (!rule.criteria || criteriaMet) {
                return rule.visibility !== 'hide';
            }

            return true;
        }

        function renderExpandedRecordMain(recordId) {
            const set = getCurrentSet();
            const view = getCurrentView();
            const record = set.records.get(recordId);
            const container = document.getElementById('expandedRecordMain');
            container.dataset.recordId = recordId;

            const orderedFields = view ? getPopupOrderedFields(set, view) : set.schema;
            const visibleFields = orderedFields.filter(field => shouldDisplayFieldInPopup(field, record));

            container.innerHTML = visibleFields.length === 0
                ? '<p class="text-gray-500">No fields are visible in this modal based on the current view settings.</p>'
                : `
                <div class="space-y-4">
                    ${visibleFields.map(field => `
                        <div class="field-editor">
                            <label class="form-label">${field.name}</label>
                            ${renderFieldEditor(recordId, field, record[field.id])}
                        </div>
                    `).join('')}
                </div>
            `;
        }

        function renderFieldEditor(recordId, field, value) {
            switch(field.type) {
                case 'TEXT': case 'EMAIL': case 'URL': case 'PHONE':
                    return `<input type="text" value="${value || ''}" onchange="updateRecordField('${recordId}', '${field.id}', this.value)">`;
                case 'LONG_TEXT':
                    return `<textarea rows="4" onchange="updateRecordField('${recordId}', '${field.id}', this.value)">${value || ''}</textarea>`;
                case 'NUMBER': case 'CURRENCY':
                    return `<input type="number" value="${value || 0}" onchange="updateRecordField('${recordId}', '${field.id}', parseFloat(this.value))">`;
                case 'DATE':
                    return `<input type="date" value="${value || ''}" onchange="updateRecordField('${recordId}', '${field.id}', this.value)">`;
                case 'CHECKBOX':
                    return `<input type="checkbox" ${value ? 'checked' : ''} onchange="updateRecordField('${recordId}', '${field.id}', this.checked)">`;
                case 'LINK_RECORD': {
                    const linkedSet = getLinkedSet(field);
                    const options = createLinkedRecordOptionList(field);
                    const disableSelect = !linkedSet || options.length === 0;
                    const selectId = `linked-record-select-${recordId}-${field.id}`;
                    const optionsDataAttr = encodeURIComponent(JSON.stringify(options));
                    const hint = !linkedSet
                        ? '<p class="text-xs text-gray-500 mt-1">Configure a linked set to enable selection.</p>'
                        : options.length === 0
                            ? '<p class="text-xs text-gray-500 mt-1">Add records to the linked set to select one.</p>'
                            : '';

                    return `
                        <div class="space-y-1">
                            <input type="text" class="border rounded px-3 py-2 text-sm w-full" placeholder="Search linked records..." ${!linkedSet ? 'disabled' : ''} oninput="filterLinkedRecordSelect('${selectId}', this.value)">
                            <select id="${selectId}" class="border rounded px-3 py-2 text-sm w-full" data-options="${optionsDataAttr}" ${disableSelect ? 'disabled' : ''} onchange="updateRecordField('${recordId}', '${field.id}', this.value)">
                                <option value="">Select a record</option>
                                ${options.map(opt => `<option value="${opt.id}" ${opt.id === value ? 'selected' : ''}>${opt.label}</option>`).join('')}
                            </select>
                            ${hint}
                        </div>
                    `;
                }
                case 'SINGLE_SELECT':
                    return `<select onchange="updateRecordField('${recordId}', '${field.id}', this.value)">
                        <option value="">Select...</option>
                        ${field.config.options.map(opt => `<option value="${opt}" ${opt === value ? 'selected' : ''}>${opt}</option>`).join('')}
                    </select>`;
                default:
                    return `<input type="text" value="${value || ''}" onchange="updateRecordField('${recordId}', '${field.id}', this.value)">`;
            }
        }

        function updateRecordField(recordId, fieldId, value) {
            const set = getCurrentSet();
            const record = set.records.get(recordId);
            const oldValue = record[fieldId];
            updateRecord(recordId, fieldId, value, oldValue);
            renderExpandedRecordMain(recordId);
        }

        function switchRecordTab(tab) {
            state.currentRecordTab = tab;
            const recordId = document.getElementById('expandedRecordMain').dataset.recordId;
            renderExpandedRecordMain(recordId);
            renderRecordSidebar(recordId);
            updateRecordHistoryVisibility();
        }

        function renderRecordSidebar(recordId) {
            const container = document.getElementById('expandedRecordSidebar');
            document.querySelectorAll('.record-tab').forEach(t => {
                t.classList.toggle('active', t.dataset.tab === state.currentRecordTab);
            });

            if (!container) return;

            switch (state.currentRecordTab) {
                case 'connections':
                    renderConnectionsSidebar(container, recordId);
                    break;
                case 'history':
                default:
                    renderHistorySidebar(container, recordId);
                    break;
            }
        }

        function renderHistorySidebar(container, recordId) {
            const history = state.eventStream.filter(e => e.object?.id === recordId && e.op === 'SEG');
            container.innerHTML = `
                <h3 class="font-semibold mb-4">Change History</h3>
                ${history.length === 0 ? '<p class="text-gray-500">No changes yet</p>' : ''}
                ${history.map(e => `
                    <div class="history-entry">
                        <div class="font-medium">${e.data?.fieldName || 'Field change'}</div>
                        <div class="text-sm text-gray-500">${getTimeAgo(e.published)}</div>
                        <div class="text-sm mt-1">
                            <span class="text-red-600">${e.data?.oldValue}</span> 
                            <span class="text-green-600">${e.data?.newValue}</span>
                        </div>
                    </div>
                `).join('')}
            `;
        }

        function getConnectionBuilder() {
            if (!state.connectionBuilder) {
                state.connectionBuilder = { targetSetId: null, targetRecordId: '', searchQuery: '', formatId: null, params: {} };
            }
            return state.connectionBuilder;
        }

        function renderConnectionsSidebar(container, recordId) {
            const builder = getConnectionBuilder();
            const setEntries = getSetsForWorld().map(set => [set.id, set]);
            const selectedSetId = builder.targetSetId && state.sets.has(builder.targetSetId)
                ? builder.targetSetId
                : (setEntries[0]?.[0] || null);
            if (builder.targetSetId !== selectedSetId) builder.targetSetId = selectedSetId;

            const formatOptions = getConnectionFormatView();
            const sidebarFormatId = builder.formatId && state.connectionFormats.has(builder.formatId)
                ? builder.formatId
                : (formatOptions[0]?.id || null);
            if (builder.formatId !== sidebarFormatId) builder.formatId = sidebarFormatId;
            const selectedFormat = findConnectionFormat(sidebarFormatId);

            const selectedSet = selectedSetId ? state.sets.get(selectedSetId) : null;
            const allAvailableRecords = selectedSet ? Array.from(selectedSet.records.values()).filter(r => r.id !== recordId) : [];
            const search = builder.searchQuery?.trim().toLowerCase() || '';
            const availableRecords = search
                ? allAvailableRecords.filter(rec => (rec.name || rec.id || '').toLowerCase().includes(search) || rec.id.toLowerCase().includes(search))
                : allAvailableRecords;
            const selectedRecordId = availableRecords.some(rec => rec.id === builder.targetRecordId) ? builder.targetRecordId : '';
            if (builder.targetRecordId !== selectedRecordId) builder.targetRecordId = selectedRecordId;

            const connections = getConnectionView(edge =>
                (edge.subject?.type === 'Record' && edge.subject?.id === recordId) ||
                (edge.operand?.type === 'Record' && edge.operand?.id === recordId)
            );

            container.innerHTML = `
                <div class="space-y-4">
                    <div>
                        <h3 class="font-semibold">Connections</h3>
                        <p class="text-sm text-gray-600">Link this record to other records.</p>
                    </div>
                    <div class="border border-gray-200 bg-white rounded-lg p-4 space-y-3">
                        <label class="form-label">Select set</label>
                        <select id="newConnectionSet" class="border rounded px-3 py-2 text-sm w-full" onchange="handleConnectionSetChange('${recordId}', this.value)">
                            ${setEntries.length === 0 ? '<option value="">No sets available</option>' : ''}
                            ${setEntries.map(([id, set]) => `<option value="${id}" ${id === selectedSetId ? 'selected' : ''}>${set.name || id}</option>`).join('')}
                        </select>
                        <label class="form-label">Search records</label>
                        <input
                            type="text"
                            class="border rounded px-3 py-2 text-sm w-full"
                            placeholder="Search by name or ID"
                            value="${builder.searchQuery || ''}"
                            oninput="handleConnectionSearchChange('${recordId}', this.value)"
                            ${!selectedSetId ? 'disabled' : ''}
                        />
                        <label class="form-label">Connect to</label>
                        <select id="newConnectionTarget" class="border rounded px-3 py-2 text-sm w-full" onchange="handleConnectionRecordChange('${recordId}', this.value)" ${!selectedSetId ? 'disabled' : ''}>
                            <option value="">${selectedSetId ? 'Select a record' : 'Select a set first'}</option>
                            ${availableRecords.length === 0 && selectedSetId ? `<option value="" disabled>${allAvailableRecords.length === 0 ? 'No records available' : 'No matches found'}</option>` : ''}
                            ${availableRecords.map(rec => `<option value="${rec.id}" ${rec.id === selectedRecordId ? 'selected' : ''}>${rec.name || rec.id}</option>`).join('')}
                        </select>
                        <label class="form-label">Format</label>
                        <select id="sidebarConnectionFormat" class="border rounded px-3 py-2 text-sm w-full" ${formatOptions.length === 0 ? 'disabled' : ''}>
                            <option value="">${formatOptions.length === 0 ? 'Add a connection format first' : 'Select a format'}</option>
                            ${formatOptions.map(fmt => `<option value="${fmt.id}" ${fmt.id === sidebarFormatId ? 'selected' : ''}>${fmt.operator}  ${fmt.mode}</option>`).join('')}
                        </select>
                        <div class="text-xs text-gray-600">${selectedFormat ? `${selectedFormat.operator} / ${selectedFormat.mode}` : 'No format selected'}</div>
                        <div id="sidebarConnectionParams" class="grid grid-cols-1 gap-2"></div>
                        <button class="btn btn-primary btn-sm" onclick="createConnectionFromSidebar('${recordId}')" ${(availableRecords.length === 0 || !selectedRecordId || !sidebarFormatId) ? 'disabled' : ''}>Add Connection</button>
                        ${availableRecords.length === 0
                            ? `<p class="text-xs text-gray-500">${allAvailableRecords.length === 0 ? 'Add records to the selected set to create connections.' : 'No records match your search.'}</p>`
                            : ''}
                    </div>
                    <div class="space-y-3">
                        ${connections.length === 0 ? '<p class="text-gray-500">No connections yet.</p>' : connections.map(edge => renderConnectionCard(edge, recordId)).join('')}
                    </div>
                </div>
            `;

            renderConnectionParamFields('sidebarConnectionParams', sidebarFormatId, builder.params || {});
            const sidebarFormatSelect = document.getElementById('sidebarConnectionFormat');
            if (sidebarFormatSelect) {
                sidebarFormatSelect.onchange = (event) => {
                    builder.formatId = event.target.value || null;
                    builder.params = {};
                    renderConnectionsSidebar(container, recordId);
                };
            }

            const paramInputs = document.getElementById('sidebarConnectionParams')?.querySelectorAll('[data-param-name]') || [];
            paramInputs.forEach(input => {
                input.oninput = () => {
                    const name = input.dataset.paramName;
                    const raw = (input.value || '').trim();
                    if (!raw) {
                        delete builder.params[name];
                        return;
                    }
                    try {
                        builder.params[name] = JSON.parse(raw);
                    } catch (err) {
                        builder.params[name] = raw;
                    }
                };
            });
        }

        function handleConnectionSetChange(recordId, setId) {
            const builder = getConnectionBuilder();
            builder.targetSetId = setId || null;
            builder.targetRecordId = '';
            builder.searchQuery = '';
            renderRecordSidebar(recordId);
        }

        function handleConnectionRecordChange(recordId, targetId) {
            const builder = getConnectionBuilder();
            builder.targetRecordId = targetId || '';
            renderRecordSidebar(recordId);
        }

        function handleConnectionSearchChange(recordId, query) {
            const builder = getConnectionBuilder();
            builder.searchQuery = query;
            builder.targetRecordId = '';
            renderRecordSidebar(recordId);
        }

        function renderConnectionCard(edge, recordId) {
            const isSubject = edge.subject?.type === 'Record' && edge.subject?.id === recordId;
            const isOperand = edge.operand?.type === 'Record' && edge.operand?.id === recordId;
            const otherRef = isSubject ? edge.operand : edge.subject;
            const direction = isSubject ? '' : (isOperand ? '' : '');
            const timestamp = edge.updatedAt || edge.createdAt;

            return `
                <div class="border border-gray-200 rounded-lg p-3 bg-white">
                    <div class="flex items-center justify-between gap-3">
                        <div>
                            <div class="font-semibold">${direction} ${renderEntityLabel(otherRef)}</div>
                            <div class="text-xs text-gray-500">${edge.operator || 'CON'}  ${edge.mode || 'related to'}  ${timestamp ? getTimeAgo(timestamp) : ''}</div>
                        </div>
                        <div class="flex items-center gap-3">
                            <button class="text-sm text-blue-600" onclick="editConnectionParameters('${edge.id}', '${recordId}')">Edit parameters</button>
                            <button class="text-sm text-red-500" onclick="deleteConnectionFromSidebar('${edge.id}', '${recordId}')">Remove</button>
                        </div>
                    </div>
                    <div class="mt-2">
                        <div class="text-xs font-semibold text-gray-600 mb-1">Parameters</div>
                        ${renderConnectionParams(edge.params)}
                    </div>
                </div>
            `;
        }

        function renderConnectionParams(params) {
            if (!params || !Object.keys(params).length) {
                return '<p class="text-xs text-gray-500">No parameters</p>';
            }

            return `<dl class="text-xs text-gray-700 space-y-1">
                ${Object.entries(params).map(([key, value]) => `
                    <div class="flex justify-between gap-2">
                        <dt class="font-medium text-gray-600">${key}</dt>
                        <dd class="text-right break-all text-gray-800">${typeof value === 'object' ? JSON.stringify(value) : value}</dd>
                    </div>
                `).join('')}
            </dl>`;
        }

        function parseConnectionParams(raw) {
            if (!raw || !raw.trim()) return {};

            let parsed;
            try {
                parsed = JSON.parse(raw);
            } catch (err) {
                throw new Error('Connection parameters must be valid JSON');
            }

            if (parsed === null || typeof parsed !== 'object' || Array.isArray(parsed)) {
                throw new Error('Connection parameters must be a JSON object');
            }

            return parsed;
        }

        function editConnectionParameters(connectionId, recordId) {
            const existing = state.connections.get(connectionId);
            if (!existing) {
                showToast('Connection not found');
                return;
            }

            const currentJson = JSON.stringify(existing.params || {}, null, 2);
            const input = prompt('Edit connection parameters (JSON object)', currentJson);
            if (input === null) return;

            let parsed;
            try {
                parsed = parseConnectionParams(input);
            } catch (err) {
                showToast(err.message);
                return;
            }

            try {
                updateConnection(connectionId, { params: parsed });
                renderRecordSidebar(recordId);
                showToast(' Parameters updated');
            } catch (error) {
                showToast(error.message);
            }
        }

        function getRecordDisplayName(recordId) {
            const ref = getRecordById(recordId);
            if (!ref) return recordId;

            const identifierFieldId = getIdentifierFieldForSet(ref.set, ref.setId === state.currentSetId ? state.currentViewId : null);
            const identifierValue = identifierFieldId ? ref.record?.[identifierFieldId] : null;

            return identifierValue || ref.record?.name || recordId;
        }

        function getIdentifierFieldForSet(set, preferredViewId = null) {
            if (!set) return null;

            if (preferredViewId && set.views.has(preferredViewId)) {
                const preferredView = set.views.get(preferredViewId);
                if (preferredView?.identifierField) return preferredView.identifierField;
            }

            for (const view of set.views.values()) {
                if (view?.identifierField) return view.identifierField;
            }

            return null;
        }

        function openLinkedRecord(recordId) {
            if (!recordId) return;
            const ref = getRecordById(recordId);
            if (!ref) {
                showToast('Linked record not found');
                return;
            }

            const firstViewId = ref.set.views.size ? Array.from(ref.set.views.keys())[0] : null;
            if (ref.setId !== state.currentSetId) {
                switchSet(ref.setId, firstViewId);
            }
            openExpandedRecord(recordId);
        }

        function createConnectionFromSidebar(recordId) {
            const builder = getConnectionBuilder();
            const target = builder.targetRecordId || document.getElementById('newConnectionTarget')?.value;
            if (!target) {
                showToast('Select a record to connect');
                return;
            }

            const formatId = builder.formatId || document.getElementById('sidebarConnectionFormat')?.value;
            if (!formatId) {
                showToast('Select a connection format');
                return;
            }

            const format = findConnectionFormat(formatId);
            if (!format) {
                showToast('Selected connection format not found');
                return;
            }

            let params = {};
            try {
                params = collectParamsFromInputs('sidebarConnectionParams', format);
            } catch (error) {
                showToast(error.message);
                return;
            }

            builder.targetRecordId = '';
            builder.params = {};
            addConnection({
                subject: { type: 'Record', id: recordId },
                operand: { type: 'Record', id: target },
                formatId,
                params
            });
            renderRecordSidebar(recordId);
            showToast(' Connection created');
        }

        function deleteConnectionFromSidebar(connectionId, recordId) {
            deleteConnection(connectionId);
            renderRecordSidebar(recordId);
            showToast(' Connection removed');
        }

        function updateRecordHistoryVisibility() {
            const historyColumn = document.getElementById('expandedRecordHistoryColumn');
            const mainWrapper = document.getElementById('expandedRecordMainWrapper');
            const toggleBtn = document.getElementById('toggleHistorySidebarBtn');
            const isVisible = state.recordHistoryVisible;

            if (historyColumn) historyColumn.classList.toggle('hidden', !isVisible);
            if (mainWrapper) {
                mainWrapper.classList.toggle('md:col-span-3', !isVisible);
                mainWrapper.classList.toggle('md:col-span-2', isVisible);
                mainWrapper.classList.toggle('border-r', isVisible);
            }
            if (toggleBtn) {
                toggleBtn.disabled = false;
                toggleBtn.textContent = state.recordHistoryVisible ? 'Hide History' : 'Show History';
            }
        }

        function toggleRecordHistoryVisibility() {
            state.recordHistoryVisible = !state.recordHistoryVisible;
            updateRecordHistoryVisibility();
        }

        function getPopupLayout(view) {
            const defaults = { size: 'medium', columns: 4, rows: 4 };
            view.popupLayout = { ...defaults, ...(view.popupLayout || {}) };
            return view.popupLayout;
        }

        function getPopupOrderedFields(set, view) {
            const defaultOrder = set.schema.map(f => f.id);
            view.popupFieldOrder = Array.isArray(view.popupFieldOrder) && view.popupFieldOrder.length
                ? view.popupFieldOrder
                : defaultOrder;
            const orderMap = new Map(view.popupFieldOrder.map((id, idx) => [id, idx]));
            return [...set.schema].sort((a, b) => {
                const aIndex = orderMap.has(a.id) ? orderMap.get(a.id) : Number.MAX_SAFE_INTEGER;
                const bIndex = orderMap.has(b.id) ? orderMap.get(b.id) : Number.MAX_SAFE_INTEGER;
                return aIndex - bIndex;
            });
        }

        function renderPopupSettings(targetIds = ['popupSettingsFields', 'popupSettingsSidebar']) {
            const popupModal = document.getElementById('popupSettingsModal');
            const modalOpen = popupModal && !popupModal.classList.contains('hidden');
            if (modalOpen) {
                renderPopupConfigurator();
            }
            renderInlinePopupSettings(targetIds);
        }

        function renderInlinePopupSettings(targetIds = ['popupSettingsFields']) {
            const set = getCurrentSet();
            const view = getCurrentView();
            if (!set || !view) return;

            view.popupVisibilityRules = view.popupVisibilityRules || [];
            const fields = getPopupOrderedFields(set, view);
            const popupSettingsHtml = fields.map(field => {
                const rule = view.popupVisibilityRules.find(r => r.fieldId === field.id) || { visibility: 'show', criteria: { type: 'always', value: '' } };
                const criteriaType = rule.criteria?.type || 'always';
                const criteriaValue = rule.criteria?.value || '';
                const needsValue = ['equals', 'notEquals', 'contains'].includes(criteriaType);

                return `
                    <div class="border border-gray-200 rounded-lg p-4">
                        <div class="flex items-center justify-between gap-4 flex-wrap">
                            <div>
                                <div class="font-semibold text-gray-900">${field.name}</div>
                                <div class="text-sm text-gray-500">${field.type}</div>
                            </div>
                            <div class="flex items-center gap-3 flex-wrap">
                                <label class="text-sm text-gray-600 flex items-center gap-2">
                                    Visibility
                                    <select class="border rounded px-2 py-1" onchange="updatePopupVisibilityRule('${field.id}', this.value)">
                                        <option value="show" ${rule.visibility !== 'hide' ? 'selected' : ''}>Show</option>
                                        <option value="hide" ${rule.visibility === 'hide' ? 'selected' : ''}>Hide</option>
                                    </select>
                                </label>
                                <label class="text-sm text-gray-600 flex items-center gap-2">
                                    Criteria
                                    <select class="border rounded px-2 py-1" onchange="updatePopupCriteriaType('${field.id}', this.value)">
                                        <option value="always" ${criteriaType === 'always' ? 'selected' : ''}>Always</option>
                                        <option value="equals" ${criteriaType === 'equals' ? 'selected' : ''}>Value equals</option>
                                        <option value="notEquals" ${criteriaType === 'notEquals' ? 'selected' : ''}>Value not equal</option>
                                        <option value="contains" ${criteriaType === 'contains' ? 'selected' : ''}>Value contains</option>
                                        <option value="empty" ${criteriaType === 'empty' ? 'selected' : ''}>When empty</option>
                                        <option value="notEmpty" ${criteriaType === 'notEmpty' ? 'selected' : ''}>When not empty</option>
                                    </select>
                                </label>
                                <input
                                    type="text"
                                    class="border rounded px-3 py-1 text-sm ${needsValue ? '' : 'opacity-50'}"
                                    placeholder="Criteria value"
                                    value="${criteriaValue}"
                                    ${needsValue ? '' : 'disabled'}
                                    oninput="updatePopupCriteriaValue('${field.id}', this.value)">
                            </div>
                        </div>
                    </div>
                `;
            }).join('');

            const targets = Array.isArray(targetIds) ? targetIds : [targetIds];
            targets.forEach(id => {
                const container = document.getElementById(id);
                if (container) container.innerHTML = popupSettingsHtml;
            });
        }

        function openPopupSettingsModal() {
            state.popupUi = state.popupUi || { filter: 'all', activeTab: 'popupFields' };
            state.popupUi.filter = state.popupUi.filter || 'all';
            state.popupUi.activeTab = 'popupFields';
            renderPopupConfigurator();
            openModal('popupSettingsModal');
        }

        function updatePopupVisibilityRule(fieldId, visibility) {
            const rule = ensurePopupRule(fieldId);
            if (!rule) return;
            rule.visibility = visibility;
            logPopupEvent('visibility', { fieldId, visibility });
            renderPopupSettings();
            refreshOpenRecordModal();
        }

        function updatePopupCriteriaType(fieldId, type) {
            const rule = ensurePopupRule(fieldId);
            if (!rule) return;
            rule.criteria = rule.criteria || { type: 'always', value: '' };
            rule.criteria.type = type;
            if (!['equals', 'notEquals', 'contains'].includes(type)) {
                rule.criteria.value = '';
            }
            renderPopupSettings();
            logPopupEvent('criteriaType', { fieldId, type });
            refreshOpenRecordModal();
        }

        function updatePopupCriteriaValue(fieldId, value) {
            const rule = ensurePopupRule(fieldId);
            if (!rule) return;
            rule.criteria = rule.criteria || { type: 'always', value: '' };
            rule.criteria.value = value;
            logPopupEvent('criteriaValue', { fieldId, value });
            renderPopupSettings();
            refreshOpenRecordModal();
        }

        function setPopupTab(tab) {
            state.popupUi.activeTab = tab;
            document.querySelectorAll('.popup-config-tab').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.tab === tab);
            });
            document.querySelectorAll('.popup-tab-panel').forEach(panel => {
                panel.classList.toggle('active', panel.id === tab);
            });
            renderPopupConfigurator();
        }

        function setPopupFilter(filter) {
            state.popupUi.filter = filter;
            renderPopupConfigurator();
        }

        function renderPopupFilters() {
            const filters = [
                { id: 'all', label: 'All Fields' },
                { id: 'visible', label: ' Visible' },
                { id: 'hidden', label: ' Hidden' },
                { id: 'conditional', label: ' Conditional' }
            ];
            const container = document.getElementById('popupFilters');
            if (!container) return;
            container.innerHTML = filters.map(f => `
                <button class="popup-filter ${state.popupUi.filter === f.id ? 'active' : ''}" onclick="setPopupFilter('${f.id}')">${f.label}</button>
            `).join('');
        }

        function togglePopupFieldVisibility(fieldId) {
            const rule = ensurePopupRule(fieldId);
            if (!rule) return;
            const newVisibility = rule.visibility === 'hide' ? 'show' : 'hide';
            updatePopupVisibilityRule(fieldId, newVisibility);
        }

        function renderPopupFieldList() {
            const set = getCurrentSet();
            const view = getCurrentView();
            if (!set || !view) return;
            view.popupVisibilityRules = view.popupVisibilityRules || [];

            const fields = getPopupOrderedFields(set, view).filter(field => {
                const rule = view.popupVisibilityRules.find(r => r.fieldId === field.id);
                const isVisible = !rule || rule.visibility !== 'hide';
                const hasCondition = rule?.criteria?.type && rule.criteria.type !== 'always';
                if (state.popupUi.filter === 'visible') return isVisible;
                if (state.popupUi.filter === 'hidden') return !isVisible;
                if (state.popupUi.filter === 'conditional') return hasCondition;
                return true;
            });

            const container = document.getElementById('popupFieldList');
            if (!container) return;

            container.innerHTML = fields.map(field => {
                const rule = view.popupVisibilityRules.find(r => r.fieldId === field.id);
                const isVisible = !rule || rule.visibility !== 'hide';
                const hasCondition = rule?.criteria?.type && rule.criteria.type !== 'always';
                const typeMeta = FIELD_TYPES[field.type] || {};
                const typeLabel = typeMeta.name || field.type;
                return `
                    <div class="popup-field-card" draggable="true" data-field-id="${field.id}">
                        <div class="drag-handle"></div>
                        <div class="popup-field-icon">${renderIcon(typeMeta.icon || 'ph-app-window')}</div>
                        <div class="popup-field-meta">
                            <div class="popup-field-name">
                                ${field.name}
                                ${hasCondition ? '<span class="popup-badge warn">Conditional</span>' : ''}
                                ${!isVisible ? '<span class="popup-badge warn">Hidden</span>' : ''}
                            </div>
                            <div class="popup-field-type field-type">${typeLabel}</div>
                        </div>
                        <div class="flex items-center gap-2">
                            <div class="popup-toggle ${isVisible ? 'active' : ''}" onclick="togglePopupFieldVisibility('${field.id}')"></div>
                            <button class="btn btn-secondary btn-sm" onclick="focusPopupCondition('${field.id}')"><i class="ph ph-sliders-horizontal"></i></button>
                        </div>
                    </div>
                `;
            }).join('');

            const popupFieldCountBadge = document.getElementById('popupFieldCountBadge');
            if (popupFieldCountBadge) popupFieldCountBadge.textContent = fields.length;
            attachPopupFieldDragHandlers();
        }

        function attachPopupFieldDragHandlers() {
            document.querySelectorAll('.popup-field-card').forEach(card => {
                card.addEventListener('dragstart', handlePopupFieldDragStart);
                card.addEventListener('dragover', handlePopupFieldDragOver);
                card.addEventListener('drop', handlePopupFieldDrop);
                card.addEventListener('dragend', handlePopupFieldDragEnd);
            });
        }

        function handlePopupFieldDragStart(e) {
            state.popupDraggedField = e.currentTarget.dataset.fieldId;
            e.currentTarget.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
        }

        function handlePopupFieldDragOver(e) {
            e.preventDefault();
            const target = e.currentTarget;
            if (state.popupDraggedField && target.dataset.fieldId !== state.popupDraggedField) {
                target.classList.add('drag-over');
            }
        }

        function handlePopupFieldDrop(e) {
            e.preventDefault();
            const targetId = e.currentTarget.dataset.fieldId;
            if (state.popupDraggedField && targetId && targetId !== state.popupDraggedField) {
                updatePopupFieldOrder(state.popupDraggedField, targetId);
                logPopupEvent('reorder', { from: state.popupDraggedField, to: targetId });
            }
            document.querySelectorAll('.popup-field-card').forEach(el => el.classList.remove('drag-over'));
            state.popupDraggedField = null;
        }

        function handlePopupFieldDragEnd(e) {
            e.currentTarget.classList.remove('dragging');
            document.querySelectorAll('.popup-field-card').forEach(el => el.classList.remove('drag-over'));
            state.popupDraggedField = null;
        }

        function updatePopupFieldOrder(draggedId, targetId) {
            const set = getCurrentSet();
            const view = getCurrentView();
            if (!set || !view) return;

            const order = getPopupOrderedFields(set, view).map(f => f.id);
            const fromIndex = order.indexOf(draggedId);
            const toIndex = order.indexOf(targetId);
            if (fromIndex === -1 || toIndex === -1) return;

            order.splice(fromIndex, 1);
            order.splice(toIndex, 0, draggedId);
            view.popupFieldOrder = order;
            renderPopupConfigurator();
        }

        function renderPopupStats() {
            const set = getCurrentSet();
            const view = getCurrentView();
            if (!set || !view) return;
            view.popupVisibilityRules = view.popupVisibilityRules || [];
            const fields = getPopupOrderedFields(set, view);
            const visibleCount = fields.reduce((count, field) => {
                const rule = view.popupVisibilityRules.find(r => r.fieldId === field.id);
                return count + ((rule && rule.visibility === 'hide') ? 0 : 1);
            }, 0);
            const conditionalCount = view.popupVisibilityRules.filter(r => r.criteria?.type && r.criteria.type !== 'always').length;
            const popupVisibleCount = document.getElementById('popupVisibleCount');
            const popupConditionalCount = document.getElementById('popupConditionalCount');
            if (popupVisibleCount) popupVisibleCount.textContent = visibleCount;
            if (popupConditionalCount) popupConditionalCount.textContent = conditionalCount;
        }

        function renderPopupPreview() {
            const set = getCurrentSet();
            const view = getCurrentView();
            if (!set || !view) return;
            const layout = getPopupLayout(view);
            const preview = document.getElementById('popupPreview');
            if (!preview) return;

            const record = Array.from(set.records.values())[0] || {};
            const fields = getPopupOrderedFields(set, view)
                .filter(field => shouldDisplayFieldInPopup(field, record))
                .slice(0, (layout.rows || 1) * (layout.columns || 1));

            preview.innerHTML = `
                <div class="popup-preview-header">
                    <span>Record Preview</span>
                    <span class="popup-pill">${layout.size}  ${layout.columns} cols  ${layout.rows} rows</span>
                </div>
                <div class="popup-preview-fields cols-${layout.columns}">
                    ${fields.map(field => `
                        <div class="popup-preview-field">
                            <div class="label">${field.name}</div>
                            <div class="value">${record[field.id] ?? ''}</div>
                        </div>
                    `).join('')}
                </div>
            `;
        }

        function renderPopupLayoutOptions() {
            const view = getCurrentView();
            if (!view) return;
            const layout = getPopupLayout(view);

            const sizeOptions = [
                { id: 'small', label: 'Small', desc: 'Compact width' },
                { id: 'medium', label: 'Medium', desc: 'Balanced width' },
                { id: 'large', label: 'Large', desc: 'Full dialog' }
            ];
            const sizeContainer = document.getElementById('popupSizeOptions');
            if (sizeContainer) {
                sizeContainer.innerHTML = sizeOptions.map(opt => `
                    <div class="popup-layout-option ${layout.size === opt.id ? 'active' : ''}" onclick="updatePopupSize('${opt.id}')">
                        <div class="font-semibold">${opt.label}</div>
                        <div class="text-sm text-gray-600">${opt.desc}</div>
                    </div>
                `).join('');
            }

            const columnContainer = document.getElementById('popupColumnOptions');
            if (columnContainer) {
                columnContainer.innerHTML = [1, 2, 3, 4].map(cols => `
                    <div class="popup-layout-option ${layout.columns === cols ? 'active' : ''}" onclick="updatePopupColumns(${cols})">
                        <div class="font-semibold">${cols} Column${cols > 1 ? 's' : ''}</div>
                        <div class="text-sm text-gray-600">${cols === 1 ? 'Single stack' : cols === 2 ? 'Split view' : cols === 3 ? 'Dense grid' : 'Quartered grid'}</div>
                    </div>
                `).join('');
            }
        }

        function updatePopupSize(size) {
            const view = getCurrentView();
            if (!view) return;
            const layout = getPopupLayout(view);
            layout.size = size;
            logPopupEvent('size', { size });
            renderPopupConfigurator();
        }

        function updatePopupColumns(columns) {
            const view = getCurrentView();
            if (!view) return;
            const layout = getPopupLayout(view);
            layout.columns = columns;
            logPopupEvent('columns', { columns });
            renderPopupConfigurator();
        }

        function renderPopupConditions() {
            const set = getCurrentSet();
            const view = getCurrentView();
            if (!set || !view) return;
            view.popupVisibilityRules = view.popupVisibilityRules || [];
            const container = document.getElementById('popupConditionsList');
            if (!container) return;

            const fields = getPopupOrderedFields(set, view);
            container.innerHTML = fields.map(field => {
                const rule = view.popupVisibilityRules.find(r => r.fieldId === field.id) || { visibility: 'show', criteria: { type: 'always', value: '' } };
                const criteriaType = rule.criteria?.type || 'always';
                const needsValue = ['equals', 'notEquals', 'contains'].includes(criteriaType);
                return `
                    <div class="popup-condition-card" data-condition-field="${field.id}">
                        <div class="popup-condition-title">${field.name} <span class="popup-pill">${rule.visibility === 'hide' ? 'Hidden' : 'Shown'}</span></div>
                        <div class="popup-condition-row">
                            <label class="text-sm text-gray-600 flex items-center gap-2">Visibility
                                <select class="border rounded px-2 py-2 text-sm" onchange="updatePopupVisibilityRule('${field.id}', this.value)">
                                    <option value="show" ${rule.visibility !== 'hide' ? 'selected' : ''}>Show</option>
                                    <option value="hide" ${rule.visibility === 'hide' ? 'selected' : ''}>Hide</option>
                                </select>
                            </label>
                            <label class="text-sm text-gray-600 flex items-center gap-2">Criteria
                                <select class="border rounded px-2 py-2 text-sm" onchange="updatePopupCriteriaType('${field.id}', this.value)">
                                    <option value="always" ${criteriaType === 'always' ? 'selected' : ''}>Always</option>
                                    <option value="equals" ${criteriaType === 'equals' ? 'selected' : ''}>Value equals</option>
                                    <option value="notEquals" ${criteriaType === 'notEquals' ? 'selected' : ''}>Value not equal</option>
                                    <option value="contains" ${criteriaType === 'contains' ? 'selected' : ''}>Value contains</option>
                                    <option value="empty" ${criteriaType === 'empty' ? 'selected' : ''}>When empty</option>
                                    <option value="notEmpty" ${criteriaType === 'notEmpty' ? 'selected' : ''}>When not empty</option>
                                </select>
                            </label>
                            <input class="border rounded px-3 py-2 text-sm ${needsValue ? '' : 'opacity-50'}" placeholder="Criteria value" value="${rule.criteria?.value || ''}" ${needsValue ? '' : 'disabled'} oninput="updatePopupCriteriaValue('${field.id}', this.value)">
                        </div>
                    </div>
                `;
            }).join('');
        }

        function renderPopupEvents() {
            const container = document.getElementById('popupEventStream');
            if (!container) return;
            if (state.popupEventStream.length === 0) {
                container.innerHTML = '<p class="text-sm text-gray-600">No recent configuration changes yet.</p>';
                return;
            }
            container.innerHTML = state.popupEventStream.map(evt => `
                <div class="popup-event">
                    <div class="popup-event-header">
                        <span>${evt.type}</span>
                        <span class="popup-event-time">${new Date(evt.timestamp).toLocaleTimeString()}</span>
                    </div>
                    <div class="text-sm text-gray-600">${describePopupEvent(evt)}</div>
                </div>
            `).join('');
        }

        function describePopupEvent(event) {
            const name = event.data?.fieldId ? getFieldNameById(event.data.fieldId) : '';
            switch (event.action) {
                case 'visibility':
                    return `${name || 'Field'} set to ${event.data.visibility}`;
                case 'criteriaType':
                    return `${name || 'Field'} criteria: ${event.data.type}`;
                case 'criteriaValue':
                    return `${name || 'Field'} criteria value updated`;
                case 'reorder':
                    return `Reordered fields (${event.data.from}  ${event.data.to})`;
                case 'size':
                    return `Modal size changed to ${event.data.size}`;
                case 'columns':
                    return `Layout updated to ${event.data.columns} columns`;
                case 'template':
                    return `Applied ${event.data.template} template`;
                default:
                    return event.type;
            }
        }

        function renderPopupRecentChanges() {
            const container = document.getElementById('popupRecentChanges');
            if (!container) return;
            const items = state.popupEventStream.slice(0, 4);
            container.innerHTML = items.length === 0
                ? '<p class="text-sm text-gray-500">No changes yet.</p>'
                : items.map(evt => `<div> ${describePopupEvent(evt)}</div>`).join('');
        }

        function logPopupEvent(action, data = {}) {
            const entry = { id: Date.now(), action, data, type: action, timestamp: new Date().toISOString() };
            state.popupEventStream.unshift(entry);
            state.popupEventStream = state.popupEventStream.slice(0, 25);
            renderPopupEvents();
            renderPopupRecentChanges();
        }

        function resetPopupLayout() {
            const set = getCurrentSet();
            const view = getCurrentView();
            if (!set || !view) return;
            view.popupLayout = { size: 'medium', columns: 4, rows: 4 };
            view.popupFieldOrder = set.schema.map(f => f.id);
            view.popupVisibilityRules = [];
            logPopupEvent('reset', {});
            renderPopupConfigurator();
            refreshOpenRecordModal();
        }

        function applyPopupTemplate(template) {
            const set = getCurrentSet();
            const view = getCurrentView();
            if (!set || !view) return;
            const ordered = getPopupOrderedFields(set, view);
            const layout = getPopupLayout(view);

            if (template === 'minimal') {
                layout.size = 'small';
                layout.columns = 1;
                view.popupVisibilityRules = ordered.map((field, idx) => ({ fieldId: field.id, visibility: idx < 4 ? 'show' : 'hide', criteria: { type: 'always', value: '' } }));
            } else if (template === 'detailed') {
                layout.size = 'large';
                layout.columns = 3;
                view.popupVisibilityRules = ordered.map(field => ({ fieldId: field.id, visibility: 'show', criteria: { type: 'always', value: '' } }));
            } else if (template === 'compact') {
                layout.size = 'medium';
                layout.columns = 2;
                view.popupVisibilityRules = ordered.map((field, idx) => ({ fieldId: field.id, visibility: idx < 6 ? 'show' : 'hide', criteria: { type: 'always', value: '' } }));
            }
            logPopupEvent('template', { template });
            renderPopupConfigurator();
            refreshOpenRecordModal();
        }

        function focusPopupCondition(fieldId) {
            setPopupTab('popupConditions');
            requestAnimationFrame(() => {
                const el = document.querySelector(`[data-condition-field="${fieldId}"]`);
                if (el) el.scrollIntoView({ behavior: 'smooth', block: 'center' });
            });
        }

        function getFieldNameById(fieldId) {
            const set = getCurrentSet();
            return set?.schema.find(f => f.id === fieldId)?.name || fieldId;
        }

        function renderPopupConfigurator() {
            const activeTab = state.popupUi?.activeTab || 'popupFields';
            document.querySelectorAll('.popup-config-tab').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.tab === activeTab);
            });
            document.querySelectorAll('.popup-tab-panel').forEach(panel => {
                panel.classList.toggle('active', panel.id === activeTab);
            });
            renderPopupFilters();
            renderPopupFieldList();
            renderPopupStats();
            renderPopupLayoutOptions();
            renderPopupPreview();
            renderPopupConditions();
            renderPopupEvents();
            renderPopupRecentChanges();
        }

        // CONTEXT MENUS
        function showColumnMenu(e, field) {
            const currentView = getCurrentView();
            const isIdentifier = currentView?.identifierField === field.id;

            showContextMenu(e, [
                { label: 'Create View from Column', action: () => createViewFromColumn(field) },
                { label: isIdentifier ? 'Clear Identifier' : 'Use as Identifier', action: () => setIdentifierField(isIdentifier ? null : field.id) },
                { label: 'Change Field Type', action: () => openChangeFieldTypeModal(field) },
                hasFieldHistory(getCurrentSet()?.id, field.id) ? { label: 'Revert Last Type Change', action: () => revertFieldType(field.id) } : null,
                { label: 'Hide Field', action: () => hideField(field.id) },
                { label: 'Delete Field', action: () => confirmDelete('field', field.id), danger: true }
            ].filter(Boolean));
        }

        function setIdentifierField(fieldId) {
            const set = getCurrentSet();
            const view = getCurrentView();
            if (!set || !view) return;

            view.identifierField = fieldId || null;

            createEvent(
                'View Identifier Update',
                'UPD',
                { type: 'View', id: view.id, setId: set.id },
                { identifierField: view.identifierField, summary: fieldId ? `Set ${fieldId} as identifier for ${view.name}` : `Cleared identifier for ${view.name}` },
                { scale: 'collection' }
            );

            renderCurrentView();
            showToast(fieldId ? ' Identifier updated' : 'Identifier cleared');
        }

        function openChangeFieldTypeModal(field) {
            state.changeFieldContext = field;
            state.changeFieldOriginalType = field?.type || null;
            const nameTarget = document.getElementById('changeFieldName');
            const input = document.getElementById('changeFieldTypeInput');
            if (nameTarget) nameTarget.textContent = field.name;
            if (input) input.value = field.type;
            renderChangeFieldTypeGrid(field.type);
            resetChangeFieldConfig(field.type, field);
            renderChangeFieldConfig(field.type);
            renderChangeLinkSelect();
            updateChangeFieldTypeSummary(field.type);
            closeChangeFieldTypeDropdown();
            openModal('changeFieldTypeModal');
        }

        function showCellMenu(e, recordId, field) {
            showContextMenu(e, [
                { label: 'Create View from This Value', action: () => createViewFromValue(recordId, field) },
                { label: 'Open Cell History', action: () => openCellHistory(recordId, field.id) }
            ]);
        }

        function showContextMenu(e, items) {
            const menu = document.createElement('div');
            menu.className = 'context-menu';
            menu.style.top = `${e.clientY}px`;
            menu.style.left = `${e.clientX}px`;
            menu.innerHTML = items.map(item => `<div class="context-menu-item ${item.danger ? 'danger' : ''}">${item.label}</div>`).join('');
            menu.querySelectorAll('.context-menu-item').forEach((el, i) => {
                el.onclick = () => { items[i].action(); menu.remove(); };
            });
            document.body.appendChild(menu);
            setTimeout(() => {
                document.addEventListener('click', function close() { menu.remove(); document.removeEventListener('click', close); });
            }, 0);
        }

        function confirmDelete(type, id) {
            const messages = {
                field: 'Delete this field? This will remove data from all records.',
                record: 'Delete this record? This cannot be undone.'
            };
            showConfirm(messages[type], () => {
                if (type === 'field') deleteField(id);
                if (type === 'record') deleteRecord(id);
            });
        }

        function showConfirm(message, callback) {
            document.getElementById('confirmMessage').textContent = message;
            state.confirmCallback = callback;
            openModal('confirmModal');
        }

        function createViewFromColumn(field) {
            const set = getCurrentSet();
            if (!set) return;

            const keyRef = { setId: set.id, fieldId: field.id };
            const detection = autoDetectSchemaFromKey(keyRef);
            const viewName = `${field.name} Pivot`;
            const viewId = createView(set.id, viewName, {
                type: 'KEY_DERIVED',
                icon: 'ph-chart-pie',
                key: keyRef,
                schema: detection.schema,
                relationships: detection.relationships,
                rollups: detection.rollups
            });
            renderSidebar();
            switchSet(set.id, viewId);
            showToast(' View created from column');
        }

        function createViewFromValue(recordId, field) {
            const set = getCurrentSet();
            const record = set?.records.get(recordId);
            if (!set || !record) return;

            const value = record[field.id];
            const filters = [[{ field: field.id, operator: 'equals', value }]];
            const displayValue = typeof value === 'object' ? JSON.stringify(value) : (value ?? 'Empty');
            const viewName = `${field.name}: ${String(displayValue).slice(0, 42)}`;
            const viewId = createView(set.id, viewName, {
                type: 'grid',
                icon: 'ph-funnel-simple',
                filters
            });
            renderSidebar();
            switchSet(set.id, viewId);
            showToast(' View created from value');
        }

        function registerInterpretationRule(rule, options = {}) {
            const normalizedRule = {
                rule_id: rule.rule_id || `rule_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`,
                applies_to_op: rule.applies_to_op || null,
                description: rule.description || '',
                effect: rule.effect || 'none',
                frame: rule.frame || 'system',
                scale: rule.scale || 'system'
            };

            state.interpretationRules.push(normalizedRule);

            if (!options.skipEvent) {
                createEvent(
                    'Define Rule',
                    'REC',
                    { type: 'InterpretationRule', id: normalizedRule.rule_id },
                    { rule: normalizedRule, summary: normalizedRule.description },
                    { frame: normalizedRule.frame, scale: normalizedRule.scale }
                );
            }

            return normalizedRule;
        }

        function hideField(fieldId) {
            const view = getCurrentView();
            if (!view.hiddenFields.includes(fieldId)) view.hiddenFields.push(fieldId);
            renderCurrentView();
            showToast(' Field hidden');
        }

        function deleteField(fieldId) {
            const set = getCurrentSet();
            const fieldIndex = set.schema.findIndex(f => f.id === fieldId);
            if (fieldIndex === -1) return;
            const [field] = set.schema.splice(fieldIndex, 1);
            set.records.forEach(record => delete record[fieldId]);
            createEvent(
                'Delete Field',
                'NUL',
                { type: 'Field', id: fieldId, setId: set.id },
                { setId: set.id, fieldId, fieldName: field?.name, summary: `Deleted field ${field?.name || fieldId}` },
                { frame: 'schema', scale: 'collection' }
            );
            renderCurrentView();
            showToast(' Field deleted');
        }

        function deleteRecord(recordId) {
            const set = getCurrentSet();
            set.records.delete(recordId);
            if (state.selectedRecordIds) state.selectedRecordIds.delete(recordId);
            if (!state.selectedRecordIds || state.selectedRecordIds.size === 0) state.lastSelectedRecordId = null;
            createEvent(
                'Delete Record',
                'NUL',
                { type: 'Record', id: recordId, setId: set.id },
                { setId: set.id, recordId, summary: 'Record deleted' }
            );
            renderCurrentView();
            showToast(' Record deleted');
        }

        // UTILITIES
        function applyInterpretationRules(event) {
            const appliedRules = [];

            state.interpretationRules.forEach(rule => {
                if (rule.applies_to_op && rule.applies_to_op !== event.op) return;

                switch (rule.effect) {
                    case 'require_actor':
                        if (!event.actor || !event.actor.id) throw new Error('Events require an actor');
                        appliedRules.push(rule.rule_id);
                        break;
                    case 'require_object_id':
                        if (!event.object || !event.object.id) throw new Error('Operations require an object reference with an id');
                        appliedRules.push(rule.rule_id);
                        break;
                    case 'require_connection_endpoints':
                        if (!event.data?.edge?.subject || !event.data?.edge?.operand) throw new Error('Connections require both subject and operand');
                        appliedRules.push(rule.rule_id);
                        break;
                    case 'mark_deleted':
                        event.data = { ...event.data, deleted: true };
                        appliedRules.push(rule.rule_id);
                        break;
                    default:
                        break;
                }
            });

            return { ...event, appliedRules };
        }

        function createEvent(verb, op, object, data = {}, options = {}) {
            if (!state.operatorSet[op]) {
                throw new Error(`Invalid operator ${op}. Expected one of ${Object.keys(state.operatorSet).join(', ')}`);
            }

            const eventData = { ...data };

            if (options.summary && !eventData.summary) {
                eventData.summary = options.summary;
            }

            // Use lean context for compact event creation if available
            if (state.leanContext && options.useLeanContext !== false) {
                const compactEvent = state.leanContext.createCompactEvent(verb, op, object, eventData, options);
                // Add standard fields for backward compatibility
                compactEvent.frame = options.frame || 'ui';
                compactEvent.scale = options.scale || 'object';
                compactEvent.published = new Date(compactEvent.t).toISOString();
                compactEvent.actor = { type: state.currentUser.type, id: state.currentUser.id };
                compactEvent.verb = verb; // Keep full verb for compatibility
                compactEvent.data = eventData; // Keep full data for compatibility

                const interpretedEvent = applyInterpretationRules(compactEvent);
                state.eventStream.unshift(interpretedEvent);

                // Limit event history to prevent unbounded growth
                if (state.eventStream.length > 10000) {
                    state.eventStream = state.eventStream.slice(0, 5000);
                }

                return interpretedEvent;
            }

            // Fallback to standard event creation
            const event = {
                id: `event-${state.eventIdCounter++}`,
                verb: verb,
                op: op,
                frame: options.frame || 'ui',
                scale: options.scale || 'object',
                published: new Date().toISOString(),
                actor: { type: state.currentUser.type, id: state.currentUser.id },
                object: object,
                data: eventData
            };

            const interpretedEvent = applyInterpretationRules(event);
            state.eventStream.unshift(interpretedEvent);
            return interpretedEvent;
        }

        function getTimeAgo(timestamp) {
            const seconds = Math.floor((new Date() - new Date(timestamp)) / 1000);
            if (seconds < 60) return 'just now';
            if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
            if (seconds < 86400) return `${Math.floor(seconds / 3600)}h ago`;
            return `${Math.floor(seconds / 86400)}d ago`;
        }

        function showToast(message) {
            const toast = document.createElement('div');
            toast.className = 'toast';
            toast.innerHTML = `
                <div class="flex items-center gap-3">
                    <svg class="w-5 h-5 text-green-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>
                    </svg>
                    <span class="font-medium">${message}</span>
                </div>
            `;
            document.body.appendChild(toast);
            setTimeout(() => toast.remove(), 3000);
        }

        function closeAllContextMenus() {
            document.querySelectorAll('.context-menu').forEach(menu => menu.remove());
        }

        function closeAllModals(exceptId = null) {
            const remaining = [];
            state.modalStack.forEach(id => {
                if (id === exceptId) {
                    remaining.push(id);
                    return;
                }

                const modalEl = document.getElementById(id);
                if (modalEl) modalEl.classList.add('hidden');
            });
            state.modalStack = remaining;
        }

        function openModal(modalId) {
            closeAllContextMenus();
            closeAllModals(modalId);

            const modal = document.getElementById(modalId);
            if (!modal) return;

            modal.classList.remove('hidden');
            if (!state.modalStack.includes(modalId)) {
                state.modalStack.push(modalId);
            }
        }

        function closeModal(modalId) {
            closeAllContextMenus();
            const modal = document.getElementById(modalId);
            if (modal) modal.classList.add('hidden');
            state.modalStack = state.modalStack.filter(id => id !== modalId);
        }

        function exportJSON() {
            const world = getWorld();
            const worldSets = getSetsForWorld(world?.id);
            const connections = getConnectionView();
            const definitions = getDefinitionView();
            const data = {
                world: world ? { ...world, setIds: Array.from(world.setIds || []) } : null,
                sets: worldSets.map(s => ({
                    ...s,
                    setIds: undefined,
                    records: Array.from(s.records.values()),
                    views: Array.from(s.views.values()),
                    profiles: Array.from(s.profiles.values())
                })),
                definitions,
                connectionFormats: getConnectionFormatView(),
                connections,
                eventStream: state.eventStream
            };
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            const nameToken = world?.name ? world.name.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/(^-|-$)/g, '') : 'workbase';
            a.download = `${nameToken || 'workbase'}-export.json`;
            a.click();
            URL.revokeObjectURL(url);
            showToast(' Exported data');
        }

        function importWorldFromJson(payload) {
            if (!payload) return;

            try {
                const data = typeof payload === 'string' ? JSON.parse(payload) : payload;
                const world = data.world || null;
                if (!world) throw new Error('No world data found in file');

                state.worlds = new Map();
                state.sets = new Map();
                state.definitions = new Map();
                state.connectionFormats = new Map();
                state.connections = new Map();
                state.expandedSets = new Set();
                state.openTabs = [];
                state.currentSpecialView = null;
                state.selectedRecordIds.clear();
                state.lastSelectedRecordId = null;
                state.selectedCell = null;
                state.lastSelectedCell = null;
                state.editingCell = null;
                state.csvImportState = { headers: [], rows: [], mappings: {}, previewRows: [], matches: [], targetMode: 'existing', targetSetId: null, newSetName: '' };
                state.fuzzyPanelState = { threshold: 0.65, matches: [] };

                const worldId = world.id || `world_${Date.now()}`;
                const normalizedWorld = { ...world, id: worldId, setIds: new Set(world.setIds || []) };
                state.worlds.set(worldId, normalizedWorld);

                (data.sets || []).forEach(rawSet => {
                    const setId = rawSet.id || `set_${Date.now()}_${Math.random().toString(36).slice(2, 6)}`;
                    const records = new Map();
                    (rawSet.records || []).forEach(rec => {
                        const recId = rec.id || `rec_${Date.now()}_${Math.random().toString(36).slice(2, 6)}`;
                        records.set(recId, { ...rec, id: recId });
                    });

                    const views = new Map();
                    (rawSet.views || []).forEach(view => {
                        const viewId = view.id || `view_${Date.now()}_${Math.random().toString(36).slice(2, 6)}`;
                        views.set(viewId, { ...view, id: viewId });
                    });

                    const profiles = new Map();
                    (rawSet.profiles || []).forEach(profile => {
                        const profileId = profile.id || 'default';
                        profiles.set(profileId, { ...profile, id: profileId });
                    });

                    const normalizedSet = {
                        ...rawSet,
                        id: setId,
                        worldId: rawSet.worldId || worldId,
                        records,
                        views,
                        profiles
                    };

                    state.sets.set(setId, normalizedSet);
                    normalizedWorld.setIds.add(setId);
                    state.expandedSets.add(setId);
                });

                (data.definitions || []).forEach(def => {
                    const id = def.id || `def_${Date.now()}_${Math.random().toString(36).slice(2, 6)}`;
                    state.definitions.set(id, { ...def, id });
                });

                (data.connectionFormats || []).forEach(fmt => {
                    const id = fmt.id || `CF_${Date.now()}_${Math.random().toString(36).slice(2, 6)}`;
                    try {
                        const normalized = validateConnectionFormatPayload({ ...fmt, id });
                        state.connectionFormats.set(id, normalized);
                    } catch (error) {
                        console.warn('Skipping invalid connection format during import', error);
                    }
                });

                (data.connections || []).forEach(conn => {
                    const id = conn.id || `conn_${Date.now()}_${Math.random().toString(36).slice(2, 6)}`;
                    try {
                        const normalized = validateConnectionPayload({ ...conn, id });
                        state.connections.set(id, normalized);
                    } catch (error) {
                        console.warn('Skipping invalid connection during import', error);
                    }
                });

                state.eventStream = Array.isArray(data.eventStream) ? data.eventStream : [];
                const numericIds = state.eventStream
                    .map(e => typeof e.id === 'string' && e.id.startsWith('event-') ? parseInt(e.id.replace('event-', '')) : null)
                    .filter(n => Number.isFinite(n));
                const maxId = numericIds.length ? Math.max(...numericIds) : state.eventStream.length;
                state.eventIdCounter = (maxId || 0) + 1;

                state.currentWorldId = worldId;
                state.currentSetId = Array.from(normalizedWorld.setIds)[0] || null;
                state.currentViewId = state.currentSetId ? Array.from(state.sets.get(state.currentSetId).views.keys())[0] || null : null;

                renderWorldSelector();
                renderSidebar();
                if (state.currentSetId) switchSet(state.currentSetId, state.currentViewId);
                renderHistory();
                showToast(' World imported');
            } catch (error) {
                console.error('Failed to import world JSON', error);
                showToast(' Could not import world JSON');
            }
        }

        function triggerWorldImport() {
            const input = document.getElementById('worldJsonInput');
            if (input) {
                input.value = '';
                input.click();
            }
        }

        function handleWorldFileSelected(event) {
            const file = event.target.files?.[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => importWorldFromJson(e.target?.result || '');
            reader.readAsText(file);
        }

        function convertSetToCsv(set) {
            const headers = ['id', ...set.schema.map(f => f.id)];
            const escapeValue = (value) => {
                if (value === null || value === undefined) return '';
                const str = typeof value === 'object' ? JSON.stringify(value) : String(value);
                if (str.includes(',') || str.includes('"') || str.includes('\n')) {
                    return '"' + str.replace(/"/g, '""') + '"';
                }
                return str;
            };
            const rows = Array.from(set.records.values()).map(record => headers.map(h => escapeValue(record[h])).join(','));
            return [headers.join(','), ...rows].join('\n');
        }

        function exportWorldCSVs() {
            const world = getWorld();
            const sets = getSetsForWorld();
            if (!sets.length) {
                showToast(' No sets to export in this world');
                return;
            }
            sets.forEach(set => {
                const csv = convertSetToCsv(set);
                const blob = new Blob([csv], { type: 'text/csv' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                const prefix = world?.name ? world.name.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/(^-|-$)/g, '') : 'world';
                const setToken = set.name ? set.name.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/(^-|-$)/g, '') : set.id;
                a.href = url;
                a.download = `${prefix || 'world'}-${setToken || set.id}.csv`;
                a.click();
                URL.revokeObjectURL(url);
            });
            showToast(' Exported CSV files for this world');
        }

        function renderHistory() {
            const container = document.getElementById('historyContent');
            container.innerHTML = state.eventStream.map(e => `
                <div class="history-entry">
                    <div class="font-medium">${e.verb} <span class="text-xs text-gray-500">(${e.op})</span></div>
                    <div class="text-sm text-gray-500">${getTimeAgo(e.published)}  Frame: ${e.frame}  Scale: ${e.scale}</div>
                    <div class="text-sm">${e.data?.summary || e.verb}</div>
                    ${e.appliedRules?.length ? `<div class="text-xs text-gray-400">Rules: ${e.appliedRules.join(', ')}</div>` : ''}
                </div>
            `).join('');
        }

        // EVENT LISTENERS
        function setupEventListeners() {
            setupToolbarMenu();

            const fieldTypeTrigger = document.getElementById('fieldTypeTrigger');
            if (fieldTypeTrigger) fieldTypeTrigger.onclick = (event) => { event.preventDefault(); toggleFieldTypeDropdown(); };

            const changeFieldTypeTrigger = document.getElementById('changeFieldTypeTrigger');
            if (changeFieldTypeTrigger) changeFieldTypeTrigger.onclick = (event) => { event.preventDefault(); toggleChangeFieldTypeDropdown(); };

            document.getElementById('saveChangeFieldTypeBtn').onclick = saveChangeFieldType;
            document.getElementById('cancelChangeFieldTypeBtn').onclick = closeChangeFieldTypeModal;
            document.getElementById('closeChangeFieldTypeBtn').onclick = closeChangeFieldTypeModal;
            const changeLinkToSet = document.getElementById('changeLinkToSet');
            if (changeLinkToSet) changeLinkToSet.onchange = (event) => { state.changeLinkedSetId = event.target.value; };

            const filterBtn = document.getElementById('filterBtn');
            if (filterBtn) filterBtn.onclick = openFilterModal;
            const sortBtn = document.getElementById('sortBtn');
            if (sortBtn) sortBtn.onclick = openSortModal;
            document.getElementById('parseCsvTextBtn').onclick = previewCsvFromText;
            document.getElementById('csvFileInput').onchange = handleCsvFileSelected;
            document.getElementById('refreshCsvPreviewBtn').onclick = renderCsvPreview;
            document.getElementById('runCsvImportBtn').onclick = importCsvRecords;
            document.getElementById('cancelCsvImportBtn').onclick = () => closeModal('csvImportModal');
            document.getElementById('closeCsvImportBtn').onclick = () => closeModal('csvImportModal');
            document.querySelectorAll('input[name="csvImportTargetMode"]').forEach(input => {
                input.onchange = (event) => {
                    state.csvImportState.targetMode = event.target.value;
                    handleCsvTargetChange();
                };
            });
            document.getElementById('csvTargetSetSelect').onchange = (event) => {
                state.csvImportState.targetSetId = event.target.value || null;
                handleCsvTargetChange();
            };
            document.getElementById('csvNewSetName').oninput = (event) => {
                state.csvImportState.newSetName = event.target.value;
            };
            document.getElementById('closeFuzzyPanelBtn').onclick = closeFuzzyPanel;
            document.getElementById('refreshFuzzyMatchesBtn').onclick = renderFuzzyPanel;
            document.getElementById('fuzzyThresholdInput').oninput = renderFuzzyPanel;
            document.getElementById('closeHistoryBtn').onclick = () => document.getElementById('historyPanel').classList.remove('open');
            document.getElementById('toggleHistorySidebarBtn').onclick = toggleRecordHistoryVisibility;
            document.getElementById('closeExpandedRecordBtn').onclick = () => closeModal('expandedRecordModal');
            bindIconSelector('newSetIcon');
            bindIconSelector('newViewIcon');
            document.getElementById('closeIconPickerBtn').onclick = () => closeModal('iconPickerModal');
            document.getElementById('iconPickerSearch').oninput = (event) => {
                state.iconPickerQuery = event.target.value;
                state.iconPickerPage = 1;
                renderIconPickerOptions();
            };
            document.getElementById('closeFilterBtn').onclick = () => closeModal('filterModal');
            document.getElementById('closePopupSettingsBtn').onclick = () => closeModal('popupSettingsModal');
            document.getElementById('applyFiltersBtn').onclick = applyFilters;
            document.getElementById('clearFiltersBtn').onclick = clearFilters;
            document.getElementById('addFilterGroupBtn').onclick = addFilterGroup;
            document.getElementById('confirmCancelBtn').onclick = () => {
                state.confirmCallback = null;
                closeModal('confirmModal');
            };
            document.getElementById('confirmOkBtn').onclick = () => {
                if (state.confirmCallback) state.confirmCallback();
                state.confirmCallback = null;
                closeModal('confirmModal');
            };
            wireViewStageActions();
            document.getElementById('addSortRuleBtn').onclick = addSortRule;
            document.getElementById('clearSortsBtn').onclick = clearSorts;
            document.getElementById('applySortsBtn').onclick = applySortsFromModal;
            document.getElementById('closeSortBtn').onclick = () => closeModal('sortModal');
            const fieldNameInput = document.getElementById('newFieldName');
            if (fieldNameInput) fieldNameInput.addEventListener('input', resetFieldNameValidation);
          document.getElementById('saveAddFieldBtn').onclick = saveField;
          document.getElementById('cancelAddFieldBtn').onclick = () => closeModal('addFieldModal');
          document.getElementById('closeAddFieldBtn').onclick = () => closeModal('addFieldModal');
          document.getElementById('closeColumnRulesBtn').onclick = () => closeModal('columnRulesModal');
          document.getElementById('columnRulesRuleSelect').onchange = (e) => {
                document.getElementById('columnRulesSetPicker').classList.toggle('hidden', e.target.value !== 'prefer_set');
                updateColumnRulesSummary();
            };
            document.getElementById('columnRulesFieldSelect').onchange = updateColumnRulesSummary;
            document.getElementById('columnRulesPreferredSet').onchange = updateColumnRulesSummary;
          const recordIdVisibilityToggle = document.getElementById('recordIdVisibilityToggle');
          if (recordIdVisibilityToggle) recordIdVisibilityToggle.onchange = (e) => toggleRecordIdVisibility(e.target.checked);
          document.getElementById('saveColumnRuleBtn').onclick = saveColumnRule;
          document.getElementById('deleteColumnRuleBtn').onclick = deleteColumnRule;
          document.getElementById('addWorldBtn').onclick = openAddWorldModal;
          document.getElementById('saveAddWorldBtn').onclick = saveWorldFromModal;
          document.getElementById('cancelAddWorldBtn').onclick = () => closeModal('addWorldModal');
          document.getElementById('worldSelect').onchange = (e) => switchWorld(e.target.value);
          document.getElementById('exportWorldBtn').onclick = exportJSON;
          document.getElementById('viewWorldJsonBtn').onclick = openJsonViewer;
          document.getElementById('importWorldBtn').onclick = triggerWorldImport;
          document.getElementById('worldJsonInput').onchange = handleWorldFileSelected;
          document.getElementById('globalHistoryBtn').onclick = () => {
                document.getElementById('historyPanel').classList.add('open');
                renderHistory();
          };
          document.getElementById('saveAddSetBtn').onclick = () => {
                const nameInput = document.getElementById('newSetName');
                const name = nameInput.value.trim();
                const icon = extractIconToken(document.getElementById('newSetIcon').value.trim() || 'ph-squares-four');
                const worldId = document.getElementById('newSetWorld').value || state.currentWorldId;
                if (!name) { showToast(' Please enter a set name'); nameInput?.focus(); return; }
                if (state.setEditorContext?.setId) {
                    const set = state.sets.get(state.setEditorContext.setId);
                    const previousWorldId = set.worldId;
                    set.name = name;
                    set.icon = icon;
                    set.worldId = worldId;
                    if (previousWorldId && previousWorldId !== worldId) {
                        getWorld(previousWorldId)?.setIds?.delete(set.id);
                    }
                    getWorld(worldId)?.setIds?.add(set.id);
                    closeModal('addSetModal');
                    state.setEditorContext = null;
                    state.currentWorldId = worldId;
                    renderSidebar();
                    renderCurrentView();
                    showToast(' Set updated');
                } else {
                    const setId = createSet(name, icon, worldId);
                    closeModal('addSetModal');
                    document.getElementById('newSetName').value = '';
                    document.getElementById('newSetIcon').value = 'ph-squares-four';
                    syncIconSelector('newSetIcon');
                    createView(setId, 'All ' + name, { type: 'grid' });
                    state.expandedSets.add(setId);
                    state.currentWorldId = worldId;
                    renderSidebar();
                    switchSet(setId, null);
                    showToast(' Set created');
                    showConfirm('Import CSV into this set now?', () => {
                        openCsvImportModal(setId);
                    });
                }
            };
            document.getElementById('cancelAddSetBtn').onclick = () => { state.setEditorContext = null; closeModal('addSetModal'); };
            document.getElementById('saveAddViewBtn').onclick = () => {
                const name = document.getElementById('newViewName').value.trim();
                const icon = extractIconToken(document.getElementById('newViewIcon').value.trim() || 'ph-table');
                const parentId = document.getElementById('newViewParent').value || null;
                const creationMode = document.querySelector('input[name="viewCreationMode"]:checked')?.value || 'blank';
                const viewType = document.querySelector('input[name="newViewType"]:checked')?.value || 'grid';
                const keyCandidate = document.getElementById('keyCandidateSelect')?.value || '';
                if (!name) { showConfirm('Please enter a view name', () => {}); return; }
                const set = state.sets.get(state.viewEditorContext?.setId || state.currentSetId);
                const setId = set?.id;
                if (!setId) return;
                if (state.viewEditorContext?.viewId && parentId && isViewDescendant(set, parentId, state.viewEditorContext.viewId)) {
                    showConfirm('You cannot nest a view under its own descendant.', () => {});
                    return;
                }

                if (state.viewEditorContext?.viewId) {
                    const view = set.views.get(state.viewEditorContext.viewId);
                    if (view) {
                        view.name = name;
                        view.icon = icon;
                        view.parentId = parentId;
                    }
                    closeModal('addViewModal');
                    state.viewEditorContext = null;
                    renderSidebar();
                    switchSet(setId, view?.id || state.currentViewId);
                    showToast(' View updated');
                } else {
                    if (creationMode === 'key' && keyCandidate.includes(':')) {
                        const [keySetId, fieldId] = keyCandidate.split(':');
                        const keyRef = { setId: keySetId, fieldId };
                        const detection = autoDetectSchemaFromKey(keyRef);
                        const viewId = createView(keySetId, name, {
                            type: 'KEY_DERIVED',
                            icon: 'ph-key',
                            parentId,
                            key: keyRef,
                            schema: detection.schema,
                            relationships: detection.relationships,
                            rollups: detection.rollups,
                            filters: [{ field: fieldId, operator: 'notEmpty' }]
                        });
                        createEvent(
                            'View Schema Update',
                            'SEG',
                            { type: 'View', id: viewId, setId: keySetId },
                            { viewId, changes: { schema: detection.schema, relationships: detection.relationships, rollups: detection.rollups }, summary: 'Auto-generated schema from key' },
                            { scale: 'collection' }
                        );
                        closeModal('addViewModal');
                        document.getElementById('newViewName').value = '';
                        document.getElementById('newViewIcon').value = 'ph-table';
                        syncIconSelector('newViewIcon');
                        state.viewEditorContext = null;
                        renderSidebar();
                        switchSet(keySetId, viewId);
                        showToast(' Generated view from key');
                    } else {
                        const viewId = createView(setId, name, { type: viewType, icon, parentId });
                        closeModal('addViewModal');
                        document.getElementById('newViewName').value = '';
                        document.getElementById('newViewIcon').value = 'ph-table';
                        syncIconSelector('newViewIcon');
                        state.viewEditorContext = null;
                        renderSidebar();
                        switchSet(setId, viewId);
                        showToast(' View created');
                    }
                }
            };
            document.getElementById('cancelAddViewBtn').onclick = () => { state.viewEditorContext = null; closeModal('addViewModal'); };
            const viewCreationModes = document.querySelectorAll('input[name="viewCreationMode"]');
            viewCreationModes.forEach(radio => {
                radio.onchange = (e) => {
                    const select = document.getElementById('keyCandidateSelect');
                    const enableKey = e.target.value === 'key';
                    if (select) select.disabled = !enableKey || select.options.length === 0;
                };
            });
            document.getElementById('saveKanbanConfigBtn').onclick = saveKanbanConfig;
            document.getElementById('cancelKanbanConfigBtn').onclick = () => closeModal('kanbanConfigModal');
            document.getElementById('closeJsonViewerBtn').onclick = () => closeModal('jsonViewerModal');
            document.getElementById('copyJsonBtn').onclick = copyJsonToClipboard;
        }

        document.addEventListener('click', (event) => {
            const selector = document.querySelector('.field-type-select');
            if (!selector) return;
            if (!selector.contains(event.target)) closeFieldTypeDropdown();
        });

        // JSON VIEWER
        let currentJsonTab = 'all';
        
        function openJsonViewer() {
            currentJsonTab = 'all';
            renderJsonContent();
            openModal('jsonViewerModal');
        }
        
        function switchJsonTab(tab) {
            currentJsonTab = tab;
            document.querySelectorAll('.json-tab').forEach(t => t.classList.remove('active'));
            document.querySelector(`.json-tab[data-tab="${tab}"]`).classList.add('active');
            renderJsonContent();
        }
        
        function renderJsonContent() {
            let data;

            switch(currentJsonTab) {
                case 'all': {
                    const world = getWorld();
                    const worldSets = getSetsForWorld();
                    const definitions = getDefinitionView();
                    const connections = getConnectionView();
                    data = {
                        world: world ? { ...world, setIds: Array.from(world.setIds || []) } : null,
                        worlds: Array.from(state.worlds.values()).map(w => ({ ...w, setIds: Array.from(w.setIds || []) })),
                        sets: worldSets.map(s => ({
                            ...s,
                            records: Array.from(s.records.values()),
                            views: Array.from(s.views.values()),
                            profiles: Array.from(s.profiles.values())
                        })),
                        definitions,
                        connections,
                        eventStream: state.eventStream,
                        operatorSet: state.operatorSet,
                        interpretationRules: state.interpretationRules,
                        currentSetId: state.currentSetId,
                        currentViewId: state.currentViewId
                    };
                    break;
                }
                case 'sets': {
                    data = getSetsForWorld().map(s => ({
                        id: s.id,
                        name: s.name,
                        icon: s.icon,
                        schema: s.schema,
                        recordCount: s.records.size,
                        viewCount: s.views.size,
                        records: Array.from(s.records.values()),
                        views: Array.from(s.views.values())
                    }));
                    break;
                }
                case 'current': {
                    const set = getCurrentSet();
                    const setRecordIds = set ? new Set(Array.from(set.records.keys())) : new Set();
                    data = set ? {
                        id: set.id,
                        name: set.name,
                        icon: set.icon,
                        schema: set.schema,
                        records: Array.from(set.records.values()),
                        views: Array.from(set.views.values()),
                        profiles: Array.from(set.profiles.values()),
                        definitions: getDefinitionView(def =>
                            (def.entity?.type === 'Record' && setRecordIds.has(def.entity?.id)) ||
                            (def.entity?.type === 'Field' && set.schema.some(f => f.id === def.entity?.id))
                        ),
                        connections: getConnectionView(conn => (
                            conn.subject?.type === 'Record' && setRecordIds.has(conn.subject?.id)
                        ) || (
                            conn.operand?.type === 'Record' && setRecordIds.has(conn.operand?.id)
                        ))
                    } : null;
                    break;
                }
                case 'events':
                    data = state.eventStream;
                    break;
            }
            
            const jsonString = JSON.stringify(data, null, 2);
            const highlighted = syntaxHighlight(jsonString);
            document.getElementById('jsonContent').innerHTML = highlighted;
        }
        
        function syntaxHighlight(json) {
            json = json.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
            return json.replace(/("(\\u[a-zA-Z0-9]{4}|\\[^u]|[^\\"])*"(\s*:)?|\b(true|false|null)\b|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?)/g, function (match) {
                let cls = 'json-number';
                if (/^"/.test(match)) {
                    if (/:$/.test(match)) {
                        cls = 'json-key';
                    } else {
                        cls = 'json-string';
                    }
                } else if (/true|false/.test(match)) {
                    cls = 'json-boolean';
                } else if (/null/.test(match)) {
                    cls = 'json-null';
                }
                return '<span class="' + cls + '">' + match + '</span>';
            });
        }
        
        function copyJsonToClipboard() {
            const content = document.getElementById('jsonContent').textContent;
            navigator.clipboard.writeText(content).then(() => {
                const btn = document.getElementById('copyJsonBtn');
                const originalText = btn.textContent;
                btn.textContent = ' Copied!';
                btn.classList.add('btn-primary');
                btn.classList.remove('btn-secondary');
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.classList.remove('btn-primary');
                    btn.classList.add('btn-secondary');
                }, 2000);
            }).catch(err => {
                showToast(' Failed to copy');
            });
        }

        function setupKeyboardShortcuts() {
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    if (state.editingCell) {
                        exitEditMode(false);
                        return;
                    }

                    if (state.selectedCell) {
                        state.selectedCell.td.classList.remove('cell-selected');
                        state.selectedCell = null;
                        state.lastSelectedCell = null;
                        return;
                    }

                    const openMenus = document.querySelectorAll('.context-menu');
                    if (openMenus.length) {
                        openMenus.forEach(menu => menu.remove());
                        return;
                    }

                    if (state.modalStack.length > 0) {
                        closeModal(state.modalStack[state.modalStack.length - 1]);
                    }
                }

                if (e.key === 'Enter' && state.selectedCell && !state.editingCell) {
                    e.preventDefault();
                    const { td, recordId, fieldId } = state.selectedCell;
                    const set = getCurrentSet();
                    const field = set?.schema.find(f => f.id === fieldId);
                    if (field) enterEditMode(td, recordId, field);
                }

                if (e.key === 'Tab' && state.selectedCell && !state.editingCell) {
                    e.preventDefault();
                    navigateToNextCell(e.shiftKey ? -1 : 1);
                }
            });
        }

        function navigateToNextCell(direction) {
            if (!state.selectedCell) return;

            const currentTd = state.selectedCell.td;
            const row = currentTd.parentElement;
            const cells = Array.from(row.querySelectorAll('.cell-editable'));
            const currentIndex = cells.indexOf(currentTd);

            const nextIndex = currentIndex + direction;
            if (nextIndex >= 0 && nextIndex < cells.length) {
                const nextTd = cells[nextIndex];
                const recordId = nextTd.dataset.recordId;
                const fieldId = nextTd.dataset.fieldId;
                selectCell(nextTd, recordId, fieldId);
                return;
            }

            const tbody = row.parentElement;
            const rows = Array.from(tbody.querySelectorAll('tr'));
            const rowIndex = rows.indexOf(row);
            const nextRowIndex = direction > 0 ? rowIndex + 1 : rowIndex - 1;

            if (nextRowIndex >= 0 && nextRowIndex < rows.length) {
                const nextRow = rows[nextRowIndex];
                const targetIndex = direction > 0 ? 0 : cells.length - 1;
                const nextTd = nextRow.querySelectorAll('.cell-editable')[targetIndex];
                if (nextTd) {
                    const recordId = nextTd.dataset.recordId;
                    const fieldId = nextTd.dataset.fieldId;
                    selectCell(nextTd, recordId, fieldId);
                }
            }
        }

        function openAddSetModal(setId = null) {
            const titleEl = document.getElementById('addSetModalTitle');
            const saveBtn = document.getElementById('saveAddSetBtn');
            const nameInput = document.getElementById('newSetName');
            const iconInput = document.getElementById('newSetIcon');
            const worldSelect = document.getElementById('newSetWorld');

            if (worldSelect) {
                worldSelect.innerHTML = '';
                state.worlds.forEach((world, id) => {
                    const opt = document.createElement('option');
                    opt.value = id;
                    opt.textContent = world.name;
                    worldSelect.appendChild(opt);
                });
            }

            if (setId) {
                const set = state.sets.get(setId);
                state.setEditorContext = { setId };
                if (titleEl) titleEl.textContent = 'Edit Set';
                if (saveBtn) saveBtn.textContent = 'Save';
                if (nameInput) nameInput.value = set?.name || '';
                if (iconInput) iconInput.value = extractIconToken(set?.icon || 'ph-squares-four');
                if (worldSelect && set?.worldId) worldSelect.value = set.worldId;
            } else {
                state.setEditorContext = null;
                if (titleEl) titleEl.textContent = 'Create Set';
                if (saveBtn) saveBtn.textContent = 'Create';
                if (nameInput) nameInput.value = '';
                if (iconInput) iconInput.value = 'ph-squares-four';
                if (worldSelect) worldSelect.value = state.currentWorldId || worldSelect.options[0]?.value || '';
            }
            syncIconSelector('newSetIcon');
            openModal('addSetModal');
        }

        // LEAN CONTEXT TESTING
        function testLeanContextEfficiency() {
            if (!state.leanContext) {
                console.warn('Lean context not initialized');
                return;
            }

            console.log('=== LEAN CONTEXT EFFICIENCY TEST ===');

            // Get current state size
            const currentStateSize = JSON.stringify({
                sets: Array.from(state.sets.entries()),
                eventStream: state.eventStream
            }).length;

            // Get lean context overhead
            const leanContextSize = state.leanContext.estimateStorageSize();

            console.log('\n STORAGE METRICS:');
            console.log(`Current state size: ${(currentStateSize / 1024).toFixed(2)} KB`);
            console.log(`\nLean Context Overhead:`);
            console.log(`  - Templates: ${(leanContextSize.templates / 1024).toFixed(2)} KB (${leanContextSize.templateCount} templates)`);
            console.log(`  - String table: ${(leanContextSize.strings / 1024).toFixed(2)} KB (${leanContextSize.stringCount} strings)`);
            console.log(`  - Total overhead: ${(leanContextSize.total / 1024).toFixed(2)} KB`);

            // Calculate overhead percentage
            const overheadPercent = (leanContextSize.total / currentStateSize * 100).toFixed(2);
            console.log(`\n Context overhead: ${overheadPercent}% of state size`);

            // Count records with lean context
            let leanRecordCount = 0;
            let totalRecordCount = 0;

            state.sets.forEach(set => {
                set.records.forEach(record => {
                    totalRecordCount++;
                    if (record.__ctx) {
                        leanRecordCount++;
                    }
                });
            });

            console.log(`\n RECORD METRICS:`);
            console.log(`  - Total records: ${totalRecordCount}`);
            console.log(`  - Lean records: ${leanRecordCount}`);
            console.log(`  - Coverage: ${totalRecordCount > 0 ? ((leanRecordCount / totalRecordCount) * 100).toFixed(1) : 0}%`);

            // Event compression stats
            const compactEventCount = state.eventStream.filter(e => e.v && e.o && e.t && !e.id.startsWith('event-')).length;
            console.log(`\n EVENT METRICS:`);
            console.log(`  - Total events: ${state.eventStream.length}`);
            console.log(`  - Compact events: ${compactEventCount}`);
            console.log(`  - Compression rate: ${state.eventStream.length > 0 ? ((compactEventCount / state.eventStream.length) * 100).toFixed(1) : 0}%`);

            console.log('\n GOAL: Keep overhead < 15% for optimal performance');
            console.log(`${overheadPercent < 15 ? ' PASSED' : '  REVIEW NEEDED'}: Current overhead is ${overheadPercent}%`);

            return {
                stateSize: currentStateSize,
                overhead: leanContextSize.total,
                overheadPercent: parseFloat(overheadPercent),
                recordCoverage: totalRecordCount > 0 ? (leanRecordCount / totalRecordCount) * 100 : 0,
                eventCompression: state.eventStream.length > 0 ? (compactEventCount / state.eventStream.length) * 100 : 0
            };
        }

        // Export test function to global scope
        window.testLeanContextEfficiency = testLeanContextEfficiency;

        // INITIALIZE
        document.addEventListener('DOMContentLoaded', async () => {
            applyTimeBasedBranding();
            await initializeApp();
            setInterval(applyTimeBasedBranding, 30 * 60 * 1000);
        });
    </script>
</body>
</html>
