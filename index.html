<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Workbase - Enhanced Database</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/@phosphor-icons/web"></script>
    <script src="formula_engine.js"></script>
    <script src="formula_field_service.js"></script>
    <style>
        :root {
            --primary: #111827;
            --primary-dark: #0f172a;
            --surface: #ffffff;
            --muted-surface: #f4f5f7;
            --border: #e5e7eb;
            --border-strong: #0f172a;
            --text: #0b1324;
            --text-secondary: #4b5563;
            --sidebar-width: 260px;
            --sidebar-collapsed-width: 64px;
        }

        * { box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            margin: 0;
            background: var(--muted-surface);
            color: var(--text);
        }

        i.ph {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            line-height: 1;
        }
        
        /* LAYOUT */
        .app-container {
            display: grid;
            grid-template-areas: "sidebar header" "sidebar main";
            grid-template-columns: var(--sidebar-width) 1fr;
            grid-template-rows: auto 1fr;
            height: 100vh;
            transition: grid-template-columns 0.3s ease;
            background: var(--muted-surface);
        }
        .app-container.sidebar-collapsed { grid-template-columns: var(--sidebar-collapsed-width) 1fr; }
        .app-sidebar {
            grid-area: sidebar;
            background: #0f172a;
            color: white;
            border-right: 1px solid #111827;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        .app-header {
            grid-area: header;
            background: var(--surface);
            border-bottom: 1px solid var(--border);
            z-index: 10;
        }
        .app-main { grid-area: main; overflow: auto; background: var(--muted-surface); }
        
        /* SIDEBAR */
        .sidebar-header {
            padding: 18px 16px 18px 20px;
            border-bottom: 1px solid #2a2e38;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
        }
        .sidebar-collapsed .sidebar-header { padding: 18px 10px; justify-content: center; }
        .sidebar-brand { font-size: 18px; font-weight: 700; letter-spacing: -0.02em; transition: opacity 0.2s; }
        .sidebar-collapsed .sidebar-brand { opacity: 0; width: 0; overflow: hidden; }
        .sidebar-toggle {
            background: transparent;
            border: 1px solid #2f343d;
            color: #e5e7eb;
            padding: 8px;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .sidebar-toggle:hover { background: rgba(255,255,255,0.05); color: #fff; border-color: #fff; }
        .sidebar-section { padding: 16px 12px 12px 12px; flex: 1; overflow-y: auto; display: flex; flex-direction: column; gap: 8px; }
        .sidebar-section-title {
            font-size: 11px;
            font-weight: 700;
            text-transform: uppercase;
            color: #6b7280;
            letter-spacing: 0.05em;
            padding: 8px 12px 6px;
            margin-bottom: 6px;
            transition: opacity 0.2s;
        }
        .sidebar-collapsed .sidebar-section-title { opacity: 0; height: 0; overflow: hidden; margin: 0; }
        
        .set-item {
            margin-bottom: 4px;
        }
        
        .set-header {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 12px;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.15s;
            color: #cbd5e1;
            border: 1px solid transparent;
        }
        .set-header:hover { background: rgba(255,255,255,0.04); border-color: rgba(255,255,255,0.08); color: #fff; }
        .set-header.active { background: #111827; color: #ffffff; border-color: #111827; box-shadow: none; }
        .set-icon { font-size: 18px; flex-shrink: 0; display: inline-flex; align-items: center; justify-content: center; }
        .set-icon i, .view-item-icon i { font-size: 18px; }
        .set-name { flex: 1; transition: opacity 0.2s; font-weight: 600; letter-spacing: -0.01em; }
        .set-expand-icon { 
            font-size: 12px; 
            transition: transform 0.2s;
            opacity: 0.7;
        }
        .set-item.expanded .set-expand-icon { transform: rotate(90deg); }
        .sidebar-collapsed .set-name { opacity: 0; width: 0; overflow: hidden; }
        .sidebar-collapsed .set-expand-icon { display: none; }
        .sidebar-collapsed .set-header { justify-content: center; padding: 10px; }
        
        .views-list {
            max-height: 0;
            overflow: hidden;
            opacity: 0;
            transition: max-height 0.3s ease, opacity 0.3s ease;
            margin-left: 32px;
            margin-top: 6px;
        }
        .set-item.expanded .views-list {
            max-height: 500px;
            opacity: 1;
        }
        .sidebar-collapsed .views-list { display: none; }
        
        .view-item {
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.15s;
            margin-bottom: 3px;
            display: flex;
            align-items: center;
            gap: 8px;
            color: #9ca3af;
            position: relative;
        }
        .view-item:hover { background: #252931; color: #e5e7eb; }
        .view-item.active { background: #2f343d; color: #ffffff; font-weight: 600; }
        .view-item-icon { font-size: 16px; opacity: 0.9; }
        
        .add-view-btn {
            padding: 6px 12px;
            font-size: 13px;
            color: #6b7280;
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.15s;
            margin-top: 6px;
        }
        .add-view-btn:hover { background: #252931; color: #e5e7eb; }

        .new-set-btn {
            margin-top: auto;
            padding: 14px 12px;
            display: flex;
            align-items: center;
            gap: 10px;
            color: #6b7280;
            font-weight: 600;
            border: none;
            background: transparent;
            cursor: pointer;
            transition: color 0.15s ease;
        }
        .new-set-btn:hover { color: #9ca3af; }
        
        /* TOOLBAR */
        .toolbar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px 28px;
            background: var(--surface);
            border-bottom: 1px solid var(--border);
        }

        .toolbar .sort-sequence-badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 8px;
            border-radius: 8px;
            background: #f3f4f6;
            color: #4b5563;
            font-size: 13px;
        }
        
        .view-type-switcher {
            display: flex;
            gap: 8px;
        }

        .view-type-btn {
            padding: 8px 14px;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.15s;
            border: 1px solid var(--border);
            background: var(--surface);
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: none;
        }

        .view-type-btn:hover { background: var(--muted-surface); border-color: var(--text); color: var(--text); }
        .view-type-btn.active { background: var(--primary); color: #ffffff; border-color: var(--primary); }
        
        /* CELLS */
        .cell-editable {
            min-height: 36px;
            padding: 12px 16px;
            cursor: text;
            border-right: 1px solid #f0f0f0;
            transition: all 0.2s ease;
            position: relative;
        }
        .cell-editable:hover:not(.cell-editing):not(.cell-selected) {
            background: linear-gradient(to right, transparent, rgba(59, 130, 246, 0.03), transparent);
            cursor: pointer;
            border-left: 2px solid rgba(59, 130, 246, 0.15);
        }
        .cell-selected {
            outline: 2px solid #3b82f6 !important;
            outline-offset: -2px;
            background: #eff6ff !important;
            position: relative;
            z-index: 1;
        }
        .cell-editing {
            outline: 2px solid #3b82f6 !important;
            outline-offset: -2px;
            background: white !important;
            box-shadow: 0 0 0 4px rgba(59, 130, 246, 0.12) !important;
            z-index: 2;
        }
        .cell-recently-changed { animation: none; }
        @keyframes flash-yellow { 0% { background-color: #fef3c7; } 100% { background-color: transparent; } }
        .cell-keyboard-focus {
            outline: 2px dashed #3b82f6;
            outline-offset: -2px;
        }
        .cell-loading {
            position: relative;
            pointer-events: none;
        }
        .cell-loading::after {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.6), transparent);
            animation: shimmer 1.5s infinite;
        }
        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }
        
        /* TABLE HEADERS */
        .column-header {
            background: var(--surface);
            padding: 12px 16px;
            font-weight: 600;
            font-size: 11px;
            letter-spacing: 0.5px;
            text-transform: uppercase;
            color: #666;
            border-bottom: 1px solid var(--border);
            cursor: pointer;
            transition: background 0.15s;
            user-select: none;
            position: relative;
        }
        .column-resizer {
            position: absolute;
            top: 0;
            right: -4px;
            bottom: 0;
            width: 8px;
            cursor: col-resize;
            z-index: 5;
        }
        body.resizing {
            cursor: col-resize;
        }
        .column-header:hover { background: var(--muted-surface); }

        body.column-dragging { cursor: grabbing; }
        .column-being-dragged { opacity: 0.5; }

        .column-drag-ghost {
            position: fixed;
            pointer-events: none;
            background: white;
            border: 1px dashed #cbd5e1;
            border-radius: 8px;
            padding: 10px 14px;
            box-shadow: 0 10px 30px rgba(15, 23, 42, 0.15);
            opacity: 0.95;
            z-index: 1200;
            transform: translate3d(0, 0, 0);
        }

        .column-drop-before::before,
        .column-drop-after::after {
            content: '';
            position: absolute;
            top: 6px;
            bottom: 6px;
            width: 3px;
            background: #cbd5e1;
            border-radius: 999px;
        }
        .column-drop-before::before { left: -2px; }
        .column-drop-after::after { right: -2px; }

        table { width: auto; border-collapse: collapse; table-layout: fixed; }
        thead { background: #f9fafb; border-bottom: 1px solid #e5e7eb; }
        th {
            padding: 12px 16px;
            text-align: left;
            font-size: 12px;
            font-weight: 700;
            text-transform: uppercase;
            color: #6b7280;
            letter-spacing: 0.05em;
            min-width: 80px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            cursor: pointer;
        }

        th .sort-indicator {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            margin-left: 8px;
            color: var(--text-secondary);
            font-weight: 500;
            font-size: 12px;
        }

        th .sort-indicator .order-badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-width: 18px;
            height: 18px;
            padding: 0 6px;
            border-radius: 999px;
            background: #e5e7eb;
            color: #111827;
            font-size: 11px;
            font-weight: 700;
        }

        th .sort-indicator .direction-icon { font-size: 10px; }

        th .sort-indicator.muted { opacity: 0.5; }
        tbody tr {
            border-bottom: 1px solid #f3f4f6;
            transition: all 0.1s ease;
        }
        tbody tr:hover { background: #fafafa; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.02); }
        tbody tr:hover td:first-child { color: #3b82f6; font-weight: 700; }
        tbody tr:last-child { border-bottom: none; }
        td {
            padding: 16px;
            font-size: 14px;
            color: #1f2937;
            vertical-align: middle;
            min-width: 80px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        td:first-child {
            color: #9ca3af;
            font-weight: 600;
            font-size: 13px;
            min-width: 60px;
        }
        tr:hover { background-color: #fafafa; }

        #dataTable thead th,
        #dataTable tbody td { background-clip: padding-box; transition: background-color 0.2s ease; }
        #dataTable thead th:nth-child(odd),
        #dataTable tbody td:nth-child(odd) { box-shadow: inset 0 0 0 9999px rgba(15, 23, 42, 0.012); }
        #dataTable thead th:nth-child(even),
        #dataTable tbody td:nth-child(even) { box-shadow: inset 0 0 0 9999px rgba(15, 23, 42, 0.024); }
        #dataTable tbody tr:nth-child(odd) { background-color: rgba(15, 23, 42, 0.02); }
        #dataTable tbody tr:nth-child(even) { background-color: rgba(15, 23, 42, 0.03); }
        #dataTable tbody tr:hover td { background: #f4f6fb; }
        #dataTable th:not(:last-child), #dataTable td:not(:last-child) { border-right: 1px solid #eef2f7; }
        .table-footer {
            display: flex;
            justify-content: flex-end;
            align-items: center;
            gap: 8px;
            padding: 10px 16px;
            background: #f9fafb;
            border-top: 1px solid #e5e7eb;
            color: #4b5563;
            font-size: 13px;
        }
        .record-counter {
            font-weight: 700;
            color: #111827;
        }

        /* Enhanced select dropdown */
        .custom-select-dropdown {
            position: absolute;
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            z-index: 1000;
            min-width: 250px;
            max-width: 400px;
            max-height: 400px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .custom-select-search {
            padding: 8px 12px;
            border: none;
            border-bottom: 1px solid #e5e7eb;
            font-size: 14px;
            outline: none;
        }

        .custom-select-search:focus { border-bottom-color: #3b82f6; }

        .custom-select-options { overflow-y: auto; flex: 1; }

        .custom-select-option {
            padding: 10px 16px;
            font-size: 14px;
            cursor: pointer;
            transition: background 0.1s;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .custom-select-option:hover { background: #f3f4f6; }
        .custom-select-option.highlighted { background: #eff6ff; color: #1e40af; }
        .custom-select-option.selected { background: #3b82f6; color: white; font-weight: 600; }

        .custom-select-option-icon {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
        }

        .custom-select-option-text { flex: 1; }

        .custom-select-option-badge {
            font-size: 11px;
            padding: 2px 6px;
            border-radius: 4px;
            background: #f3f4f6;
            color: #6b7280;
        }

        .custom-select-empty {
            padding: 40px 20px;
            text-align: center;
            color: #9ca3af;
        }

        .custom-select-empty-icon {
            font-size: 32px;
            margin-bottom: 8px;
            opacity: 0.5;
        }

        .custom-select-footer {
            border-top: 1px solid #e5e7eb;
            padding: 8px;
            display: flex;
            gap: 4px;
        }

        .custom-select-footer button {
            flex: 1;
            padding: 6px 12px;
            font-size: 13px;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            background: white;
            cursor: pointer;
            transition: all 0.15s;
        }

        .custom-select-footer button:hover { background: #f3f4f6; border-color: #d1d5db; }

        .search-match {
            background: #fef3c7;
            font-weight: 600;
            padding: 0 2px;
            border-radius: 2px;
        }

        .table-scroll {
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
        }
        
        /* CARD VIEW */
        .cards-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 20px;
            padding: 20px;
        }
        
        .card {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 16px;
            cursor: pointer;
            transition: all 0.15s ease;
            box-shadow: none;
        }

        .card:hover {
            transform: translateY(-2px);
            border-color: var(--border-strong);
        }
        
        .card-title {
            font-size: 16px;
            font-weight: 600;
            color: #111827;
            margin-bottom: 12px;
        }
        
        .card-field {
            margin-bottom: 8px;
            font-size: 13px;
        }
        
        .card-field-label {
            color: #6b7280;
            font-weight: 500;
            margin-bottom: 2px;
        }
        
        .card-field-value {
            color: #111827;
        }
        
        /* KANBAN VIEW */
        .kanban-board {
            display: flex;
            gap: 16px;
            padding: 20px;
            overflow-x: auto;
            min-height: calc(100vh - 200px);
        }
        
        .kanban-column {
            min-width: 300px;
            background: var(--muted-surface);
            border-radius: 10px;
            padding: 12px;
            display: flex;
            flex-direction: column;
            border: 1px solid var(--border);
        }
        
        .kanban-column-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 12px;
            margin-bottom: 12px;
            border-radius: 8px;
            background: var(--surface);
            border: 1px solid var(--border);
        }
        
        .kanban-column-title {
            font-weight: 600;
            font-size: 14px;
            color: #374151;
        }
        
        .kanban-column-count {
            font-size: 12px;
            color: #6b7280;
            background: #f3f4f6;
            padding: 2px 8px;
            border-radius: 4px;
        }
        
        .kanban-cards {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 8px;
            min-height: 100px;
        }
        
        .kanban-card {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 12px;
            cursor: move;
            transition: all 0.15s ease;
        }

        .kanban-card:hover {
            border-color: var(--border-strong);
        }
        
        .kanban-card.dragging {
            opacity: 0.5;
            transform: rotate(2deg);
        }
        
        .kanban-column.drag-over {
            background: #e0f2fe;
        }
        
        .kanban-empty-state {
            text-align: center;
            padding: 40px 20px;
            color: #9ca3af;
            font-size: 14px;
        }
        
        /* CONTEXT MENU */
        .context-menu {
            position: fixed;
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15);
            z-index: 1000;
            min-width: 200px;
            overflow: hidden;
        }
        .context-menu-item {
            padding: 10px 16px;
            font-size: 14px;
            cursor: pointer;
            transition: background 0.15s;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .context-menu-item:hover { background: #f3f4f6; }
        .context-menu-item.danger:hover { background: #fee2e2; color: #dc2626; }
        .context-menu-separator { height: 1px; background: #e5e7eb; margin: 4px 0; }
        
        /* MODALS */
        .modal-overlay { backdrop-filter: blur(2px); animation: fadeIn 0.2s ease; }
        .modal-container { border-radius: 8px; box-shadow: 0 20px 50px rgba(0, 0, 0, 0.2); animation: slideUp 0.25s cubic-bezier(0.16, 1, 0.3, 1); }
        #expandedRecordModal .modal-container { height: 90vh; }
        #addFieldModal .modal-container { max-width: 540px; width: 100%; border-radius: 10px; }
        #addFieldModal .modal-container, #addFieldModal .modal-body { overflow: visible; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes slideUp { from { transform: translateY(20px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
        .modal-header { padding: 24px 24px 16px 24px; border-bottom: 1px solid #f0f0f0; }
        .modal-body { padding: 24px; }
        .modal-footer { padding: 16px 24px; border-top: 1px solid #f0f0f0; background: #fafafa; }
        #addFieldModal .modal-header { padding: 16px 18px 10px 18px; }
        #addFieldModal .modal-body { padding: 16px 18px 18px 18px; }
        #addFieldModal .modal-footer { padding: 14px 18px; background: #f8fafc; }
        .icon-picker-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(96px, 1fr)); gap: 10px; }
        .icon-option { display: flex; flex-direction: column; align-items: center; gap: 8px; padding: 12px; border-radius: 12px; border: 1px solid #e2e8f0; background: #ffffff; cursor: pointer; transition: all 0.12s ease; box-shadow: 0 2px 6px rgba(15, 23, 42, 0.04); }
        .icon-option:hover { border-color: #cbd5e1; background: #f8fafc; transform: translateY(-1px); }
        .icon-option.active { border-color: #2563eb; background: #eff6ff; color: #1d4ed8; box-shadow: 0 0 0 2px rgba(37,99,235,0.15); }
        .icon-option .icon-chip { width: 44px; height: 44px; border-radius: 12px; display: inline-flex; align-items: center; justify-content: center; background: #f1f5f9; color: #0f172a; border: 1px solid #e2e8f0; font-size: 22px; }
        .icon-option .icon-label { font-size: 13px; font-weight: 600; color: #0f172a; text-align: center; line-height: 1.2; }

        .icon-selector { display: flex; align-items: center; gap: 10px; padding: 10px 12px; border: 1px solid #e2e8f0; border-radius: 8px; background: #f8fafc; cursor: pointer; transition: all 0.15s ease; }
        .icon-selector:hover { border-color: #cbd5e1; background: #f1f5f9; box-shadow: inset 0 0 0 1px #e2e8f0; }
        .icon-selector-icon { width: 40px; height: 40px; border-radius: 10px; background: #ffffff; border: 1px solid #e2e8f0; display: inline-flex; align-items: center; justify-content: center; font-size: 22px; color: #0f172a; }
        .icon-selector-text { flex: 1; min-width: 0; }
        .icon-selector-label { font-size: 13px; color: #475569; }
        .icon-selector-token { font-size: 12px; color: #64748b; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .icon-selector-chevron { color: #94a3b8; font-size: 12px; }
        .config-section { max-height: 0; overflow: hidden; opacity: 0; transition: max-height 0.3s ease, opacity 0.3s ease, margin 0.3s ease; margin-top: 0; }
        .config-section.visible { max-height: 500px; opacity: 1; margin-top: 16px; }

        /* POPUP CONFIGURATOR */
        .popup-config-shell { max-width: 1200px; width: 100%; max-height: 90vh; overflow: hidden; display: flex; flex-direction: column; padding: 20px 24px; }
        .popup-config-header { display: flex; justify-content: space-between; align-items: flex-start; gap: 16px; padding: 0 0 12px 0; border-bottom: 1px solid #e2e8f0; background: transparent; }
        .popup-config-tabs { display: flex; gap: 4px; padding: 12px 0; border-bottom: 1px solid #e2e8f0; background: transparent; }
        .popup-config-tab { padding: 10px 14px; border: none; background: transparent; cursor: pointer; font-weight: 600; color: #6b7280; border-bottom: 2px solid transparent; display: inline-flex; gap: 8px; align-items: center; border-radius: 8px 8px 0 0; transition: all 0.2s ease; }
        .popup-config-tab:hover { color: #0f172a; background: #f8fafc; }
        .popup-config-tab.active { color: #1d4ed8; border-bottom-color: #1d4ed8; background: #eff6ff; }
        .popup-config-body { display: grid; grid-template-columns: 1fr 320px; gap: 20px; padding: 16px 0 0 0; background: #fff; flex: 1; overflow: hidden; }
        .popup-tab-panel { display: none; height: 100%; overflow: hidden; }
        .popup-tab-panel.active { display: block; }
        .popup-panel-scroll { height: 100%; overflow: auto; padding-right: 6px; }
        .popup-quick-filters { display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 14px; }
        .popup-filter { padding: 8px 12px; border-radius: 8px; border: 1px solid #e2e8f0; background: #fff; cursor: pointer; color: #475569; font-weight: 600; transition: all 0.15s ease; }
        .popup-filter:hover { border-color: #cbd5e1; background: #f8fafc; }
        .popup-filter.active { background: #eef2ff; border-color: #1d4ed8; color: #1d4ed8; }
        .popup-info { display: flex; gap: 10px; padding: 12px; background: #eef2ff; border: 1px solid #c7d2fe; border-radius: 8px; color: #1e3a8a; margin-bottom: 14px; font-size: 14px; }
        .popup-field-card { border: 1px solid #e2e8f0; border-radius: 6px; padding: 16px; display: flex; align-items: center; gap: 12px; margin-bottom: 12px; background: #fff; transition: all 0.2s ease; }
        .popup-field-card:hover { border-color: #cbd5e1; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04); }
        .popup-field-card.dragging { opacity: 0.6; }
        .popup-field-card.drag-over { border-color: #1d4ed8; background: #eef2ff; }
        .popup-field-card .drag-handle { cursor: grab; color: #94a3b8; font-size: 18px; }
        .popup-field-icon { width: 38px; height: 38px; border-radius: 10px; border: 1px solid #e2e8f0; background: #f8fafc; display: inline-flex; align-items: center; justify-content: center; font-size: 18px; color: #0f172a; }
        .popup-field-meta { flex: 1; min-width: 0; }
        .popup-field-name { font-weight: 700; color: #0f172a; display: flex; gap: 6px; align-items: center; }
        .popup-field-type { font-size: 13px; color: #64748b; }
        .field-type { font-size: 11px; color: #64748b; text-transform: uppercase; letter-spacing: 0.05em; font-weight: 500; }
        .popup-badge { display: inline-flex; align-items: center; gap: 4px; padding: 4px 8px; border-radius: 999px; background: #f8fafc; border: 1px solid #e2e8f0; font-size: 12px; color: #475569; font-weight: 600; }
        .popup-badge.warn { background: #fef3c7; border-color: #fde68a; color: #b45309; }
        .popup-toggle { width: 46px; height: 26px; border-radius: 999px; background: #e5e7eb; position: relative; cursor: pointer; transition: all 0.2s ease; }
        .popup-toggle::after { content: ''; position: absolute; width: 20px; height: 20px; border-radius: 50%; background: #fff; top: 3px; left: 3px; box-shadow: 0 2px 8px rgba(0,0,0,0.12); transition: all 0.2s ease; }
        .popup-toggle.active { background: #1d4ed8; }
        .popup-toggle.active::after { transform: translateX(20px); }
        .popup-side { display: flex; flex-direction: column; gap: 16px; height: 100%; }
        .popup-card { background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 8px; padding: 16px; }
        .popup-card h4 { margin: 0 0 8px 0; font-size: 14px; color: #0f172a; font-weight: 700; }
        .popup-stat-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; }
        .popup-stat { background: #fff; border: 1px solid #e2e8f0; border-radius: 8px; padding: 12px; }
        .popup-stat .value { font-size: 24px; font-weight: 800; color: #0f172a; }
        .popup-stat .label { font-size: 12px; color: #6b7280; }
        .popup-preview { border: 1px solid #e2e8f0; border-radius: 8px; background: #fafafa; padding: 14px; }
        .popup-preview-header { font-weight: 700; margin-bottom: 10px; color: #0f172a; display: flex; justify-content: space-between; align-items: center; }
        .popup-preview-fields { display: grid; gap: 10px; }
        .popup-preview-fields.cols-1 { grid-template-columns: 1fr; }
        .popup-preview-fields.cols-2 { grid-template-columns: repeat(2, 1fr); }
        .popup-preview-fields.cols-3 { grid-template-columns: repeat(3, 1fr); }
        .popup-preview-field { background: #fff; border: 1px solid #e5e7eb; border-radius: 8px; padding: 10px; }
        .popup-preview-field .label { font-size: 11px; color: #6b7280; text-transform: uppercase; letter-spacing: 0.05em; margin-bottom: 4px; }
        .popup-preview-field .value { font-size: 13px; color: #0f172a; }
        .popup-layout-options { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; }
        .popup-layout-option { border: 2px solid #e2e8f0; border-radius: 8px; padding: 12px; cursor: pointer; text-align: center; transition: all 0.15s ease; background: #fff; }
        .popup-layout-option.active { border-color: #1d4ed8; background: #eef2ff; color: #1d4ed8; }
        .popup-event-stream { display: flex; flex-direction: column; gap: 10px; }
        .popup-event { border: 1px solid #e2e8f0; border-radius: 8px; padding: 12px; background: #fff; }
        .popup-event-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px; color: #0f172a; font-weight: 700; font-size: 14px; }
        .popup-event-time { color: #94a3b8; font-size: 12px; font-weight: 600; }
        .popup-conditions { display: grid; gap: 10px; }
        .popup-condition-card { border: 1px solid #e2e8f0; border-radius: 8px; padding: 12px; background: #fff; }
        .popup-condition-title { font-weight: 700; color: #0f172a; margin-bottom: 8px; display: flex; align-items: center; gap: 8px; }
        .popup-condition-row { display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 8px; margin-bottom: 10px; }
        .popup-pill { display: inline-flex; align-items: center; gap: 6px; padding: 6px 10px; border-radius: 999px; background: #f3f4f6; color: #475569; font-weight: 600; font-size: 12px; }
        .popup-template-buttons { display: flex; flex-direction: column; gap: 8px; }
        @media (max-width: 1100px) { .popup-config-body { grid-template-columns: 1fr; } .popup-side { order: -1; flex-direction: row; overflow-x: auto; } .popup-side .popup-card { min-width: 240px; } }
        
        /* BUTTONS */
        .btn {
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.15s ease;
            border: 1px solid var(--border);
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }
        .btn-primary {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
            box-shadow: none;
        }
        .btn-primary:hover { background: transparent; color: var(--text); border-color: var(--text); box-shadow: none; }
        .btn-secondary { background: transparent; border: 1px solid var(--border); color: var(--text-secondary); box-shadow: none; }
        .btn-secondary:hover { background: var(--muted-surface); border-color: var(--text); color: var(--text); }
        .btn-danger { background: #ef4444; color: white; }
        .btn-danger:hover { background: #dc2626; }
        .btn-sm { padding: 6px 12px; font-size: 13px; }
        
        /* BADGES */
        .badge {
            display: inline-flex;
            align-items: center;
            padding: 3px 10px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            white-space: nowrap;
        }
        .badge-green { background-color: #d1fae5; color: #065f46; }
        .badge-yellow { background-color: #fef3c7; color: #92400e; }
        .badge-red { background-color: #fee2e2; color: #991b1b; }
        .badge-blue { background-color: #dbeafe; color: #1e40af; }
        .badge-purple { background-color: #e9d5ff; color: #6b21a8; }
        .badge-gray { background-color: #f3f4f6; color: #374151; }
        .badge-cyan { background-color: #cffafe; color: #155e75; }
        .badge-pink { background-color: #fce7f3; color: #9f1239; }
        
        /* FIELD TYPE DROPDOWN */
        .field-type-select { position: relative; }
        .field-type-trigger {
            width: 100%;
            padding: 12px 14px;
            border: 1px solid #cbd5e1;
            border-radius: 10px;
            background: white;
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            transition: all 0.2s;
            min-height: 64px;
        }
        .field-type-trigger:hover { border-color: #94a3b8; box-shadow: 0 6px 18px rgba(15, 23, 42, 0.05); }
        .field-type-trigger.active { border-color: #3b82f6; box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.12), 0 10px 30px rgba(15, 23, 42, 0.12); }
        .field-type-trigger-content { display: flex; align-items: center; gap: 12px; }
        .field-type-trigger-icon { width: 36px; height: 36px; display: flex; align-items: center; justify-content: center; background: #f1f5f9; border-radius: 10px; font-size: 20px; }
        .field-type-trigger-text { display: flex; flex-direction: column; gap: 3px; text-align: left; }
        .field-type-trigger-arrow { color: #64748b; font-size: 13px; }
        .field-type-dropdown {
            position: absolute;
            top: calc(100% + 10px);
            left: 50%;
            transform: translateX(-50%);
            width: min(760px, calc(100vw - 48px));
            padding: 12px;
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 14px;
            box-shadow: 0 20px 40px rgba(15, 23, 42, 0.16);
            max-height: 520px;
            overflow-y: auto;
            z-index: 1000;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(230px, 1fr));
            gap: 10px;
        }
        .field-type-dropdown.hidden { display: none; }
        .field-type-option {
            padding: 12px;
            display: flex;
            align-items: flex-start;
            gap: 12px;
            cursor: pointer;
            transition: all 0.15s ease;
            border: 1px solid #e2e8f0;
            border-radius: 12px;
            background: white;
        }
        .field-type-option:hover { background: #f8fafc; box-shadow: 0 12px 30px rgba(15, 23, 42, 0.08); }
        .field-type-option.selected { background: #eff6ff; border: 1px solid #3b82f6; box-shadow: 0 14px 32px rgba(59, 130, 246, 0.18); }
        .field-type-icon { width: 36px; height: 36px; display: flex; align-items: center; justify-content: center; background: #f1f5f9; border-radius: 10px; font-size: 20px; }
        .field-type-option.selected .field-type-icon { background: #3b82f6; color: white; }
        .field-type-info { display: flex; flex-direction: column; gap: 3px; min-width: 0; }
        .field-type-name { font-size: 14px; font-weight: 700; color: #0f172a; }
        .field-type-description { font-size: 12px; color: #64748b; line-height: 1.5; }
        .field-type-check { margin-left: auto; color: #3b82f6; font-weight: 700; font-size: 14px; }
        
        /* FILTER BUILDER */
        .filter-group { background: #f9fafb; border: 2px solid #e5e7eb; border-radius: 8px; padding: 16px; margin-bottom: 12px; }
        .filter-group-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px; }
        .filter-operator-toggle { display: flex; background: white; border: 1px solid #e5e7eb; border-radius: 6px; overflow: hidden; }
        .filter-operator-toggle button {
            padding: 4px 12px;
            font-size: 12px;
            font-weight: 600;
            border: none;
            background: transparent;
            cursor: pointer;
            transition: all 0.15s;
        }
        .filter-operator-toggle button.active { background: #3b82f6; color: white; }
        .filter-rule { display: grid; grid-template-columns: 1fr 1fr 1fr auto; gap: 8px; align-items: center; padding: 8px; background: white; border-radius: 6px; margin-bottom: 8px; }
        
        /* UTILITIES */
          .form-label { display: block; font-size: 13px; font-weight: 600; color: #374151; margin-bottom: 8px; }
          .form-hint { font-size: 12px; color: #6b7280; margin-top: 6px; }
          .form-error { font-size: 12px; color: #b91c1c; margin-top: 6px; }
          input[type="text"], input[type="number"], input[type="date"], input[type="email"], input[type="url"], select, textarea {
              width: 100%;
              padding: 8px 12px;
              border: 1px solid #cbd5e1;
              border-radius: 6px;
            font-size: 13px;
            transition: all 0.15s ease;
            background: white;
          }
          input:focus, select:focus, textarea:focus { outline: none; border-color: #3b82f6; box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1); }
          .input-error { border-color: #ef4444; box-shadow: 0 0 0 3px rgba(239, 68, 68, 0.15); }
          ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: #f3f4f6; }
        ::-webkit-scrollbar-thumb { background: #d1d5db; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #9ca3af; }
        
        .toast {
            position: fixed;
            bottom: 24px;
            right: 24px;
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            padding: 16px 20px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            z-index: 2000;
            animation: slideInToast 0.3s ease;
        }
        @keyframes slideInToast { from { transform: translateX(400px); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
        
        .side-panel {
            position: fixed;
            right: 0;
            top: 0;
            height: 100vh;
            width: 420px;
            background: white;
            box-shadow: -4px 0 24px rgba(0, 0, 0, 0.12);
            transform: translateX(100%);
            transition: transform 0.3s ease;
            z-index: 1000;
            display: flex;
            flex-direction: column;
        }
        .side-panel.open { transform: translateX(0); }

        .csv-helper-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
            gap: 12px;
        }

        .csv-helper-card {
            border: 1px solid #e5e7eb;
            border-radius: 10px;
            padding: 12px;
            background: white;
        }

        .csv-preview-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
            border: 1px solid #e5e7eb;
        }

        .csv-preview-table th, .csv-preview-table td {
            border: 1px solid #e5e7eb;
            padding: 6px 8px;
            text-align: left;
            background: white;
        }

        .csv-preview-table th { background: #f9fafb; font-weight: 700; }

        .csv-match-pill {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 10px;
            border-radius: 9999px;
            background: #eef2ff;
            color: #4338ca;
            font-weight: 600;
            font-size: 12px;
        }

        .fuzzy-match-row {
            border: 1px solid #e5e7eb;
            border-radius: 10px;
            padding: 12px;
            margin-bottom: 10px;
            background: #fff;
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .fuzzy-match-row strong { display: block; font-size: 14px; }

        .fuzzy-score {
            font-weight: 700;
            color: #16a34a;
        }

        .panel-controls {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            margin-bottom: 12px;
        }
        
        .option-row { display: flex; gap: 8px; align-items: center; margin-bottom: 8px; }
        .option-row input { flex: 1; }
        .color-picker { display: flex; gap: 4px; flex-wrap: wrap; }
        .color-option {
            width: 24px;
            height: 24px;
            border-radius: 4px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.15s;
        }
        .color-option:hover { transform: scale(1.1); }
        .color-option.selected { border-color: #1e293b; }
        
        .field-editor { border: 1px solid #e5e7eb; border-radius: 6px; padding: 12px; transition: all 0.15s; }
        .field-editor:hover { border-color: #d1d5db; background: #fafafa; }
        .field-editor:focus-within { border-color: #3b82f6; box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1); }
        .field-editor input, .field-editor textarea, .field-editor select { width: 100%; padding: 8px 12px; border: 1px solid #e5e7eb; border-radius: 4px; font-size: 14px; }
        
        .record-tabs { display: flex; border-bottom: 1px solid #e5e7eb; padding: 0 24px; background: #fafafa; }
        .record-tab {
            padding: 12px 16px;
            font-size: 14px;
            font-weight: 500;
            color: #6b7280;
            cursor: pointer;
            border-bottom: 2px solid transparent;
            margin-bottom: -1px;
            transition: all 0.15s ease;
        }
        .record-tab:hover { color: #374151; }
        .record-tab.active { color: #2563eb; border-bottom-color: #2563eb; }
        
        .json-tab {
            padding: 12px 20px;
            font-size: 14px;
            font-weight: 500;
            color: #6b7280;
            cursor: pointer;
            border-bottom: 2px solid transparent;
            background: transparent;
            border: none;
            transition: all 0.15s ease;
        }
        .json-tab:hover { color: #374151; background: #f9fafb; }
        .json-tab.active { color: #3b82f6; border-bottom-color: #3b82f6; }
        
        .json-key { color: #b45309; font-weight: 600; }
        .json-string { color: #15803d; }
        .json-number { color: #1e40af; }
        .json-boolean { color: #7c2d12; }
        .json-null { color: #991b1b; font-style: italic; }
        
        #jsonContent {
            line-height: 1.5;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        
        .profile-selector { display: flex; gap: 8px; padding: 12px 0; overflow-x: auto; }
        .profile-tab {
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s;
            border: 1px solid #e5e7eb;
            background: white;
            white-space: nowrap;
        }
        .profile-tab:hover { background: #f3f4f6; }
        .profile-tab.active { background: #8b5cf6; color: white; border-color: #8b5cf6; }
        
        .history-entry {
            border-left: 3px solid #e5e7eb;
            padding: 12px;
            margin-bottom: 8px;
            transition: all 0.15s ease;
            cursor: pointer;
            border-radius: 4px;
        }
        .history-entry:hover { border-left-color: #3b82f6; background-color: #f9fafb; }

        .mobile-sidebar-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.35);
            z-index: 30;
        }

        @media (max-width: 1024px) {
            :root { --sidebar-width: 240px; }
            .app-container { grid-template-areas: "header" "main"; grid-template-columns: 1fr; grid-template-rows: auto 1fr; }
            .app-sidebar {
                position: fixed;
                inset: 0 auto 0 0;
                width: var(--sidebar-width);
                transform: translateX(-100%);
                transition: transform 0.3s ease;
                z-index: 40;
            }
            .mobile-sidebar-overlay { display: none; }
            .mobile-layout.sidebar-open-mobile .app-sidebar { transform: translateX(0); box-shadow: 8px 0 24px rgba(0,0,0,0.18); }
            .mobile-layout.sidebar-open-mobile .mobile-sidebar-overlay { display: block; }
            .app-header { position: sticky; top: 0; z-index: 20; }
            .toolbar { flex-direction: column; align-items: flex-start; gap: 12px; }
            .toolbar .view-type-switcher { width: 100%; overflow-x: auto; padding-bottom: 4px; }
            .toolbar-actions { width: 100%; flex-wrap: wrap; }
            .toolbar-actions button { flex: 1 1 calc(50% - 8px); min-width: 140px; }
            .cards-grid { grid-template-columns: repeat(auto-fill, minmax(240px, 1fr)); }
            .kanban-board { min-height: auto; }
        }

        @media (max-width: 640px) {
            .toolbar-actions button { flex: 1 1 100%; }
            .cards-grid { grid-template-columns: 1fr; }
            .kanban-column { min-width: 260px; }
        }
    </style>
</head>
<body>
    <div class="app-container" id="appContainer">
        <!-- Sidebar -->
        <div class="app-sidebar">
            <div class="sidebar-header">
                <div class="sidebar-brand">Workbase</div>
                <button class="sidebar-toggle" onclick="toggleSidebar()">
                    <i class="ph ph-list text-lg"></i>
                </button>
            </div>
            <div class="sidebar-section">
                <div class="sidebar-section-title">Sets</div>
                <div id="setsList"></div>
                <button onclick="openAddSetModal()" class="new-set-btn">
                    <span class="set-icon"><i class="ph ph-plus"></i></span>
                    <span class="set-name">New Set</span>
                </button>
            </div>
        </div>

        <div class="mobile-sidebar-overlay" id="mobileSidebarOverlay" onclick="closeMobileSidebar()"></div>

        <!-- Header -->
        <div class="app-header">
            <div class="toolbar">
                <div class="flex items-center gap-3">
                    <div class="view-type-switcher">
                        <button class="view-type-btn active" data-type="grid" onclick="switchViewType('grid')">
                            <i class="ph ph-table"></i>
                            <span>Grid</span>
                        </button>
                        <button class="view-type-btn" data-type="card" onclick="switchViewType('card')">
                            <i class="ph ph-cards-three"></i>
                            <span>Card</span>
                        </button>
                        <button class="view-type-btn" data-type="kanban" onclick="switchViewType('kanban')">
                            <i class="ph ph-kanban"></i>
                            <span>Kanban</span>
                        </button>
                    </div>
                    <button id="filterBtn" class="btn btn-secondary btn-sm">
                        <i class="ph ph-funnel-simple"></i>
                        Filter
                    </button>
                    <button id="sortBtn" class="btn btn-secondary btn-sm">
                        <i class="ph ph-arrows-down-up"></i>
                        Sort
                    </button>
                    <button id="popupSettingsBtn" class="btn btn-secondary btn-sm">
                        <i class="ph ph-popcorn"></i>
                        Modal Fields
                    </button>
                    <button id="historyBtn" class="btn btn-secondary btn-sm">
                        <i class="ph ph-clock-counter-clockwise"></i>
                        History
                    </button>
                </div>
                <div class="flex items-center gap-2 toolbar-actions">
                    <button id="addRecordBtn" class="btn btn-primary btn-sm">+ Add Record</button>
                    <button id="addFieldBtn" class="btn btn-secondary btn-sm">+ Add Field</button>
                    <button id="viewJsonBtn" class="btn btn-secondary btn-sm">View JSON</button>
                    <button id="importCsvBtn" class="btn btn-secondary btn-sm">
                        <i class="ph ph-upload-simple"></i>
                        Import CSV
                    </button>
                    <button id="exportBtn" class="btn btn-secondary btn-sm">Export</button>
                    <button id="fuzzyPanelBtn" class="btn btn-secondary btn-sm">
                        <i class="ph ph-graph"></i>
                        Fuzzy Matches
                    </button>
                </div>
            </div>
        </div>
        
        <!-- Main Content -->
        <div class="app-main">
            <div id="viewContainer"></div>
        </div>
    </div>

    <!-- All Modals from previous version -->
    <div id="confirmModal" class="hidden fixed inset-0 bg-black bg-opacity-20 modal-overlay flex items-center justify-center p-6 z-50">
        <div class="modal-container bg-white w-full max-w-md">
            <div class="modal-header">
                <h2 class="text-xl font-bold text-gray-900">Confirm Action</h2>
            </div>
            <div class="modal-body">
                <p class="text-gray-700" id="confirmMessage"></p>
            </div>
            <div class="modal-footer flex justify-end gap-2">
                <button id="confirmCancelBtn" class="btn btn-secondary">Cancel</button>
                <button id="confirmOkBtn" class="btn btn-danger">Confirm</button>
            </div>
        </div>
    </div>

    <div id="expandedRecordModal" class="hidden fixed inset-0 bg-black bg-opacity-20 modal-overlay flex items-center justify-center p-6 z-50">
        <div class="modal-container bg-white w-full max-w-5xl max-h-[90vh] overflow-hidden flex flex-col">
            <div class="modal-header flex items-center justify-between flex-shrink-0">
                <div class="flex items-center gap-4 flex-1">
                    <h2 class="text-2xl font-bold text-gray-900" id="expandedRecordTitle">Record Details</h2>
                    <div class="profile-selector" id="recordProfileSelector"></div>
                </div>
                <div class="flex items-center gap-2">
                    <button id="toggleHistorySidebarBtn" class="btn btn-secondary btn-sm">Hide History</button>
                    <button id="closeExpandedRecordBtn" class="text-gray-400 hover:text-gray-600 transition p-2">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                        </svg>
                    </button>
                </div>
            </div>
            <div class="flex-1 overflow-hidden">
                <div class="grid grid-cols-1 md:grid-cols-3 h-full">
                    <div id="expandedRecordMainWrapper" class="md:col-span-2 p-6 overflow-y-auto border-r border-gray-200">
                        <div id="expandedRecordMain"></div>
                    </div>
                    <div id="expandedRecordHistoryColumn" class="overflow-hidden bg-gray-50 flex flex-col">
                        <div class="record-tabs">
                            <div class="record-tab active" data-tab="history" onclick="switchRecordTab('history')">History</div>
                            <div class="record-tab" data-tab="connections" onclick="switchRecordTab('connections')">Connections</div>
                        </div>
                        <div class="flex-1 overflow-y-auto p-6" id="expandedRecordSidebar"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="filterModal" class="hidden fixed inset-0 bg-black bg-opacity-20 modal-overlay flex items-center justify-center p-6 z-50">
        <div class="modal-container bg-white w-full max-w-xl max-h-[90vh] overflow-hidden flex flex-col">
            <div class="modal-header flex items-center justify-between">
                <div>
                    <h2 class="text-xl font-bold text-gray-900">Filter View</h2>
                    <p class="text-sm text-gray-500 mt-1">Create advanced filter conditions</p>
                </div>
                <button id="closeFilterBtn" class="text-gray-400 hover:text-gray-600 transition p-2">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>
            <div class="flex-1 overflow-y-auto modal-body">
                <div id="filterGroupsContainer"></div>
                <button id="addFilterGroupBtn" class="btn btn-secondary btn-sm mt-4">+ Add Filter Group</button>
            </div>
            <div class="modal-footer flex justify-end gap-2">
                <button id="clearFiltersBtn" class="btn btn-secondary">Clear All</button>
                <button id="applyFiltersBtn" class="btn btn-primary">Apply Filters</button>
            </div>
        </div>
    </div>

    <div id="sortModal" class="hidden fixed inset-0 bg-black bg-opacity-20 modal-overlay flex items-center justify-center p-6 z-50">
        <div class="modal-container bg-white w-full max-w-3xl max-h-[80vh] overflow-hidden flex flex-col">
            <div class="modal-header flex items-center justify-between">
                <div>
                    <h2 class="text-xl font-bold text-gray-900">Sort View</h2>
                    <p class="text-sm text-gray-500 mt-1">Create a sorting sequence for this view</p>
                </div>
                <button id="closeSortBtn" class="text-gray-400 hover:text-gray-600 transition p-2">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>
            <div class="flex-1 overflow-y-auto modal-body space-y-3">
                <div id="sortRulesContainer" class="space-y-3"></div>
                <button id="addSortRuleBtn" class="btn btn-secondary btn-sm">+ Add Sort</button>
            </div>
            <div class="modal-footer flex justify-between gap-2">
                <div class="flex items-center gap-2 text-sm text-gray-500">
                    <span class="sort-sequence-badge"><i class="ph ph-arrow-line-up"></i>Earlier sorts run first</span>
                </div>
                <div class="flex gap-2">
                    <button id="clearSortsBtn" class="btn btn-secondary">Clear All</button>
                    <button id="applySortsBtn" class="btn btn-primary">Apply Sorts</button>
                </div>
            </div>
        </div>
    </div>

    <div id="popupSettingsModal" class="hidden fixed inset-0 bg-black bg-opacity-20 modal-overlay flex items-center justify-center p-6 z-50">
        <div class="modal-container bg-white popup-config-shell">
            <div class="popup-config-header">
                <div>
                    <h2 class="text-2xl font-bold text-gray-900">Modal Configuration</h2>
                    <p class="text-sm text-gray-600 mt-1">Curate which fields show in record modals, define conditional visibility, and preview layouts.</p>
                </div>
                <div class="flex items-center gap-2">
                    <button class="btn btn-secondary btn-sm" onclick="resetPopupLayout()">Reset</button>
                    <button id="closePopupSettingsBtn" class="btn btn-secondary btn-sm">Close</button>
                </div>
            </div>

            <div class="popup-config-tabs">
                <button class="popup-config-tab active" data-tab="popupFields" onclick="setPopupTab('popupFields')"> Fields <span class="popup-badge" id="popupFieldCountBadge">0</span></button>
                <button class="popup-config-tab" data-tab="popupLayout" onclick="setPopupTab('popupLayout')"> Layout</button>
                <button class="popup-config-tab" data-tab="popupConditions" onclick="setPopupTab('popupConditions')"> Conditions</button>
            </div>

            <div class="popup-config-body">
                <div class="popup-tab-panel active" id="popupFields">
                    <div class="popup-panel-scroll">
                        <div class="popup-quick-filters" id="popupFilters"></div>
                        <div class="popup-info"><span></span><span><strong>Drag to reorder</strong> and toggle visibility. Click the gear to set conditional rules per field.</span></div>
                        <div id="popupFieldList"></div>
                    </div>
                </div>

                <div class="popup-tab-panel" id="popupLayout">
                    <div class="popup-panel-scroll space-y-4">
                        <div class="popup-card">
                            <h4>Modal Size</h4>
                            <div class="popup-layout-options" id="popupSizeOptions"></div>
                        </div>
                        <div class="popup-card">
                            <h4>Column Layout</h4>
                            <div class="popup-layout-options" id="popupColumnOptions"></div>
                        </div>
                        <div class="popup-card">
                            <h4>Preview</h4>
                            <div id="popupPreview" class="popup-preview"></div>
                        </div>
                    </div>
                </div>

                <div class="popup-tab-panel" id="popupConditions">
                    <div class="popup-panel-scroll">
                        <div class="popup-info"><span></span><span><strong>Conditional visibility</strong> lets you keep modals focused and contextual.</span></div>
                        <div id="popupConditionsList" class="popup-conditions"></div>
                    </div>
                </div>

                <div class="popup-side">
                    <div class="popup-card">
                        <h4>Quick Stats</h4>
                        <div class="popup-stat-grid">
                            <div class="popup-stat">
                                <div class="value" id="popupVisibleCount">0</div>
                                <div class="label">Visible Fields</div>
                            </div>
                            <div class="popup-stat">
                                <div class="value" id="popupConditionalCount">0</div>
                                <div class="label">Conditional Rules</div>
                            </div>
                        </div>
                    </div>
                    <div class="popup-card">
                        <h4>Templates</h4>
                        <div class="popup-template-buttons">
                            <button class="btn btn-secondary btn-sm" onclick="applyPopupTemplate('minimal')"> Minimal View</button>
                            <button class="btn btn-secondary btn-sm" onclick="applyPopupTemplate('detailed')"> Detailed View</button>
                            <button class="btn btn-secondary btn-sm" onclick="applyPopupTemplate('compact')"> Compact View</button>
                        </div>
                    </div>
                    <div class="popup-card">
                        <h4>Recent Changes</h4>
                        <div id="popupRecentChanges" class="text-sm text-gray-600 space-y-1"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="addFieldModal" class="hidden fixed inset-0 bg-black bg-opacity-20 modal-overlay flex items-center justify-center p-6 z-50">
        <div class="modal-container bg-white w-full max-w-xl max-h-[90vh] overflow-hidden flex flex-col">
            <div class="modal-header flex items-center justify-between">
                <div>
                    <h2 class="text-xl font-bold text-gray-900">Add Field</h2>
                    <p class="text-sm text-gray-500 mt-1">Create a new field for your set</p>
                </div>
                <button id="closeAddFieldBtn" class="text-gray-400 hover:text-gray-600 transition p-2">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>
            <div class="flex-1 overflow-y-auto modal-body space-y-5">
                  <div>
                      <label class="form-label">Field Name</label>
                      <input type="text" id="newFieldName" placeholder="e.g., Status, Amount, Contact Person" autofocus aria-describedby="fieldNameError">
                      <p class="form-hint">A descriptive name for your field</p>
                      <p id="fieldNameError" class="form-error hidden" role="alert"></p>
                  </div>
                <div>
                    <label class="form-label">Field Type</label>
                    <div class="field-type-select">
                        <button type="button" id="fieldTypeTrigger" class="field-type-trigger">
                            <div class="field-type-trigger-content">
                                <span class="field-type-trigger-icon" aria-hidden="true"></span>
                                <div class="field-type-trigger-text">
                                    <div class="field-type-name" id="selectedFieldTypeName"></div>
                                    <div class="field-type-description" id="selectedFieldTypeDescription"></div>
                                </div>
                            </div>
                            <span class="field-type-trigger-arrow" aria-hidden="true"></span>
                        </button>
                        <div id="fieldTypeDropdown" class="field-type-dropdown hidden"></div>
                    </div>
                    <input type="hidden" id="newFieldType" value="TEXT">
                </div>
                <div id="singleSelectConfig" class="config-section">
                    <div class="bg-orange-50 border border-orange-200 rounded-lg p-4">
                        <label class="form-label">Options</label>
                        <div id="selectOptionsList" class="space-y-2 mb-3"></div>
                        <button onclick="addSelectOption()" class="btn btn-secondary btn-sm">+ Add Option</button>
                    </div>
                </div>
                <div id="linkToRecordConfig" class="config-section">
                    <div class="bg-blue-50 border border-blue-200 rounded-lg p-4">
                        <label class="form-label">Link to Set</label>
                        <select id="linkToSet"></select>
                        <p class="form-hint">Select which set to link to</p>
                    </div>
                </div>
                <div id="formulaFieldConfig" class="config-section">
                    <div class="bg-sky-50 border border-sky-200 rounded-lg p-4">
                        <label class="form-label">Formula</label>
                        <div class="space-y-2">
                            <textarea id="formulaExpression" rows="3" placeholder="e.g., {budget} * 1.1"></textarea>
                            <div class="flex items-center gap-2">
                                <button type="button" class="btn btn-secondary btn-sm" onclick="launchFormulaEditorFromConfig()">
                                    <i class="ph ph-magic-wand"></i>
                                    Open Formula Editor
                                </button>
                                <span class="text-xs text-gray-600">Autocomplete, validation, and preview included.</span>
                            </div>
                        </div>
                        <p class="form-hint">Compose expressions using the JavaScript-style formula rules defined in the repo's formula engine.</p>
                    </div>
                </div>
            </div>
            <div class="modal-footer flex justify-end gap-2">
                <button id="cancelAddFieldBtn" class="btn btn-secondary">Cancel</button>
                <button id="saveAddFieldBtn" class="btn btn-primary">Add Field</button>
            </div>
        </div>
    </div>

    <div id="addSetModal" class="hidden fixed inset-0 bg-black bg-opacity-20 modal-overlay flex items-center justify-center p-6 z-50">
        <div class="modal-container bg-white w-full max-w-md">
            <div class="modal-header">
                <h2 id="addSetModalTitle" class="text-xl font-bold text-gray-900">Create Set</h2>
            </div>
            <div class="modal-body space-y-4">
                <div>
                    <label class="form-label">Set Name</label>
                    <input type="text" id="newSetName" placeholder="e.g., Projects, Contacts">
                </div>
                <div>
                    <label class="form-label">Icon</label>
                    <div id="newSetIconSelector" class="icon-selector" role="button" tabindex="0">
                        <div id="newSetIconPreview" class="icon-selector-icon" aria-hidden="true"></div>
                        <div class="icon-selector-text">
                            <div class="icon-selector-label">Pick a visual icon</div>
                            <div id="newSetIconToken" class="icon-selector-token"></div>
                        </div>
                        <span class="icon-selector-chevron"></span>
                    </div>
                    <input type="hidden" id="newSetIcon" value="ph-squares-four">
                </div>
            </div>
            <div class="modal-footer flex justify-end gap-2">
                <button id="cancelAddSetBtn" class="btn btn-secondary">Cancel</button>
                <button id="saveAddSetBtn" class="btn btn-primary">Create</button>
            </div>
        </div>
    </div>

    <div id="addViewModal" class="hidden fixed inset-0 bg-black bg-opacity-20 modal-overlay flex items-center justify-center p-6 z-50">
        <div class="modal-container bg-white w-full max-w-md">
            <div class="modal-header">
                <h2 id="addViewModalTitle" class="text-xl font-bold text-gray-900">Create View</h2>
            </div>
            <div class="modal-body space-y-4">
                <div>
                    <label class="form-label">View Name</label>
                    <input type="text" id="newViewName" placeholder="e.g., Active Items">
                </div>
                <div>
                    <label class="form-label">View Icon</label>
                    <div id="newViewIconSelector" class="icon-selector" role="button" tabindex="0">
                        <div id="newViewIconPreview" class="icon-selector-icon" aria-hidden="true"></div>
                        <div class="icon-selector-text">
                            <div class="icon-selector-label">Choose an icon visually</div>
                            <div id="newViewIconToken" class="icon-selector-token"></div>
                        </div>
                        <span class="icon-selector-chevron"></span>
                    </div>
                    <input type="hidden" id="newViewIcon" value="ph-table">
                </div>
                <div>
                    <label class="form-label">Nest Under</label>
                    <select id="newViewParent"></select>
                    <p class="form-hint">Optionally place this view under another view</p>
                </div>
            </div>
            <div class="modal-footer flex justify-end gap-2">
                <button id="cancelAddViewBtn" class="btn btn-secondary">Cancel</button>
                <button id="saveAddViewBtn" class="btn btn-primary">Create</button>
            </div>
        </div>
    </div>

    <div id="iconPickerModal" class="hidden fixed inset-0 bg-black bg-opacity-20 modal-overlay flex items-center justify-center p-6 z-50">
        <div class="modal-container bg-white w-full max-w-2xl">
            <div class="modal-header flex items-center justify-between">
                <h2 class="text-xl font-bold text-gray-900">Pick an icon</h2>
                <button id="closeIconPickerBtn" class="btn btn-secondary btn-sm">Close</button>
            </div>
            <div class="modal-body space-y-4">
                <input type="text" id="iconPickerSearch" placeholder="Search icons (e.g., table, folder)" class="w-full">
                <div id="iconPickerOptions" class="icon-picker-grid"></div>
            </div>
        </div>
    </div>

    <div id="kanbanConfigModal" class="hidden fixed inset-0 bg-black bg-opacity-20 modal-overlay flex items-center justify-center p-6 z-50">
        <div class="modal-container bg-white w-full max-w-md">
            <div class="modal-header">
                <h2 class="text-xl font-bold text-gray-900">Configure Kanban</h2>
            </div>
            <div class="modal-body space-y-4">
                <div>
                    <label class="form-label">Group By Field</label>
                    <select id="kanbanGroupField"></select>
                    <p class="form-hint">Select a single-select field to group records by</p>
                </div>
            </div>
            <div class="modal-footer flex justify-end gap-2">
                <button id="cancelKanbanConfigBtn" class="btn btn-secondary">Cancel</button>
                <button id="saveKanbanConfigBtn" class="btn btn-primary">Apply</button>
            </div>
        </div>
    </div>

    <div id="csvImportModal" class="hidden fixed inset-0 bg-black bg-opacity-20 modal-overlay flex items-center justify-center p-6 z-50">
        <div class="modal-container bg-white w-full max-w-4xl max-h-[90vh] overflow-hidden flex flex-col">
            <div class="modal-header flex items-center justify-between">
                <div>
                    <h2 class="text-xl font-bold text-gray-900">Import CSV into Current Set</h2>
                    <p class="text-sm text-gray-500 mt-1">Upload a CSV, map columns to fields, and preview fuzzy matches before importing.</p>
                </div>
                <button id="closeCsvImportBtn" class="text-gray-400 hover:text-gray-600 transition p-2">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>
            <div class="flex-1 overflow-y-auto modal-body space-y-4">
                <div class="csv-helper-grid">
                    <div class="csv-helper-card">
                        <label class="form-label">Upload CSV File</label>
                        <input type="file" id="csvFileInput" accept=".csv" />
                        <p class="form-hint">Headers are required. We will auto-map matching field names.</p>
                    </div>
                    <div class="csv-helper-card">
                        <label class="form-label">Or Paste CSV Text</label>
                        <textarea id="csvTextInput" rows="5" placeholder="name,industry\nAcme,Technology"></textarea>
                        <div class="mt-2 flex justify-end">
                            <button id="parseCsvTextBtn" class="btn btn-secondary btn-sm">Preview CSV</button>
                        </div>
                    </div>
                </div>

                <div class="csv-helper-card">
                    <div class="flex items-center justify-between mb-2">
                        <div>
                            <h3 class="text-lg font-semibold">Field Mapping</h3>
                            <p class="text-sm text-gray-500">Match CSV columns to fields in the current set.</p>
                        </div>
                        <span class="csv-match-pill" id="csvRowCountBadge">0 rows</span>
                    </div>
                    <div id="csvMappingContainer" class="space-y-2"></div>
                </div>

                <div class="csv-helper-card">
                    <div class="flex items-center justify-between mb-2">
                        <div>
                            <h3 class="text-lg font-semibold">Preview</h3>
                            <p class="text-sm text-gray-500">First few records with applied mapping.</p>
                        </div>
                        <button id="refreshCsvPreviewBtn" class="btn btn-secondary btn-sm">Refresh Preview</button>
                    </div>
                    <div id="csvPreviewContainer" class="overflow-auto"></div>
                </div>

                <div class="csv-helper-card">
                    <div class="flex items-center justify-between mb-2">
                        <div>
                            <h3 class="text-lg font-semibold">Fuzzy Match Suggestions</h3>
                            <p class="text-sm text-gray-500">We surface potential duplicates against existing records.</p>
                        </div>
                        <div class="text-xs text-gray-500">Score  0.6 shown</div>
                    </div>
                    <div id="csvMatchSuggestions" class="space-y-2"></div>
                </div>
            </div>
            <div class="modal-footer flex justify-end gap-2">
                <button id="cancelCsvImportBtn" class="btn btn-secondary">Cancel</button>
                <button id="runCsvImportBtn" class="btn btn-primary">Import Records</button>
            </div>
        </div>
    </div>

    <div id="historyPanel" class="side-panel">
        <div class="bg-gradient-to-r from-indigo-600 to-purple-600 text-white p-6 flex-shrink-0">
            <div class="flex items-center justify-between mb-4">
                <div>
                    <h3 class="text-xl font-bold">Edit History</h3>
                    <p class="text-sm opacity-90 mt-1">Full audit trail</p>
                </div>
                <button id="closeHistoryBtn" class="text-white hover:bg-white hover:bg-opacity-20 p-2 rounded-lg transition">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>
            <input type="text" id="historySearch" class="w-full text-gray-900 rounded-lg" placeholder="Search history...">
        </div>
        <div class="flex-1 overflow-y-auto p-6" id="historyContent"></div>
    </div>

    <div id="fuzzyMatchPanel" class="side-panel">
        <div class="bg-gradient-to-r from-emerald-500 to-blue-600 text-white p-6 flex-shrink-0">
            <div class="flex items-center justify-between mb-4">
                <div>
                    <h3 class="text-xl font-bold">Fuzzy Matches</h3>
                    <p class="text-sm opacity-90 mt-1">Possible duplicate or related records</p>
                </div>
                <button id="closeFuzzyPanelBtn" class="text-white hover:bg-white hover:bg-opacity-20 p-2 rounded-lg transition">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>
            <div class="panel-controls">
                <label class="text-sm flex-1">Similarity threshold
                    <input id="fuzzyThresholdInput" type="range" min="0.4" max="0.95" step="0.01" value="0.65" class="w-full">
                </label>
                <button id="refreshFuzzyMatchesBtn" class="btn btn-secondary btn-sm">Recompute</button>
            </div>
        </div>
        <div class="flex-1 overflow-y-auto p-6" id="fuzzyMatchList"></div>
    </div>

    <!-- Cell History Modal -->
    <div id="cellHistoryModal" class="hidden fixed inset-0 bg-black bg-opacity-20 modal-overlay flex items-center justify-center p-6 z-50">
        <div class="modal-container bg-white w-full max-w-3xl max-h-[90vh] overflow-hidden flex flex-col">
            <div class="modal-header flex items-center justify-between">
                <div>
                    <h2 class="text-xl font-bold text-gray-900" id="cellHistoryTitle">Cell History</h2>
                    <p class="text-sm text-gray-500 mt-1" id="cellHistorySubtitle"></p>
                </div>
                <button class="text-gray-400 hover:text-gray-600 transition p-2" onclick="closeModal('cellHistoryModal')">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>
            <div class="p-6 overflow-auto" id="cellHistoryContent"></div>
        </div>
    </div>

    <!-- JSON Viewer Modal -->
    <div id="jsonViewerModal" class="hidden fixed inset-0 bg-black bg-opacity-20 modal-overlay flex items-center justify-center p-6 z-50">
        <div class="modal-container bg-white w-full max-w-6xl h-[90vh] max-h-[90vh] overflow-hidden flex flex-col">
            <div class="modal-header flex items-center justify-between">
                <div>
                    <h2 class="text-xl font-bold text-gray-900">JSON Data</h2>
                    <p class="text-sm text-gray-500 mt-1">View the complete data structure</p>
                </div>
                <button id="closeJsonViewerBtn" class="text-gray-400 hover:text-gray-600 transition p-2">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>
            <div class="flex border-b border-gray-200">
                <button class="json-tab active" data-tab="all" onclick="switchJsonTab('all')">All Data</button>
                <button class="json-tab" data-tab="sets" onclick="switchJsonTab('sets')">Sets</button>
                <button class="json-tab" data-tab="current" onclick="switchJsonTab('current')">Current Set</button>
                <button class="json-tab" data-tab="events" onclick="switchJsonTab('events')">Event Stream</button>
            </div>
            <div class="flex-1 overflow-hidden relative">
                <pre id="jsonContent" class="p-6 overflow-auto h-full text-sm bg-gray-50 font-mono"></pre>
                <button id="copyJsonBtn" class="absolute top-4 right-4 btn btn-secondary btn-sm">
                    <i class="ph ph-clipboard-text"></i>
                    Copy
                </button>
            </div>
        </div>
    </div>

    <script>
        // STATE
        const state = {
            sets: new Map(),
            currentSetId: null,
            currentViewId: null,
            currentProfileId: 'default',
            eventStream: [],
            eventIdCounter: 1,
            currentUser: { type: 'Person', id: 'user_1', name: 'User' },
            operatorSet: {},
            interpretationRules: [],
            connections: new Map(),
            connectionBuilder: { targetSetId: null, targetRecordId: '', metadataJson: '', searchQuery: '' },
            sidebarCollapsed: false,
            sidebarOpenMobile: false,
            modalStack: [],
            currentRecordTab: 'history',
            recordHistoryVisible: true,
            confirmCallback: null,
            selectOptions: [{ value: 'Option 1', color: 'blue' }],
            fieldTypeDropdownOpen: false,
            expandedSets: new Set(),
            draggedRecord: null,
            cellHistoryContext: null,
            setEditorContext: null,
            viewEditorContext: null,
            iconPickerTarget: null,
            iconPickerQuery: '',
            popupUi: { filter: 'all', activeTab: 'popupFields' },
            popupEventStream: [],
            popupDraggedField: null,
            selectedCell: null,
            lastSelectedCell: null,
            editingCell: null,
            csvImportState: { headers: [], rows: [], mappings: {}, previewRows: [], matches: [] },
            fuzzyPanelState: { threshold: 0.65, matches: [] },
            formulaFieldService: null,
            formulaEditor: {
                isOpen: false,
                fieldId: null,
                currentFormula: '',
                cursorPosition: 0,
                autocomplete: {
                    isVisible: false,
                    items: [],
                    selectedIndex: 0,
                    trigger: null,
                    filterText: ''
                },
                validation: {
                    isValid: true,
                    errors: [],
                    warnings: []
                },
                preview: {
                    result: null,
                    error: null
                },
                mode: 'code',
                visualBlocks: [],
                onSave: null
            }
        };

        const columnDragState = {
            timer: null,
            draggedFieldId: null,
            dropFieldId: null,
            dropPosition: null,
            ghost: null,
            offsetX: 0,
            offsetY: 0,
            sourceElement: null
        };

        const COLUMN_WIDTH_MIN = 60;
        const COLUMN_WIDTH_MAX = 600;

        function clampColumnWidth(width) {
            if (isNaN(width)) return 150;
            return Math.min(COLUMN_WIDTH_MAX, Math.max(COLUMN_WIDTH_MIN, width));
        }

        const formulaEditorCSS = `
            .formula-editor-modal {
                position: fixed;
                inset: 0;
                background: rgba(0, 0, 0, 0.4);
                backdrop-filter: blur(4px);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 1000;
            }

            .formula-editor-container {
                background: white;
                border-radius: 12px;
                box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
                width: 90%;
                max-width: 900px;
                max-height: 90vh;
                display: flex;
                flex-direction: column;
                overflow: hidden;
            }

            .formula-editor-header {
                padding: 20px 24px;
                border-bottom: 1px solid #e5e7eb;
                display: flex;
                align-items: center;
                justify-content: space-between;
            }

            .formula-editor-tabs {
                display: flex;
                gap: 4px;
                border-bottom: 1px solid #e5e7eb;
                padding: 0 24px;
            }

            .formula-editor-tab {
                padding: 12px 16px;
                border: none;
                background: transparent;
                cursor: pointer;
                font-weight: 500;
                color: #6b7280;
                border-bottom: 2px solid transparent;
                transition: all 0.15s;
            }

            .formula-editor-tab:hover {
                color: #111827;
                background: #f9fafb;
            }

            .formula-editor-tab.active {
                color: #3b82f6;
                border-bottom-color: #3b82f6;
            }

            .formula-editor-body {
                flex: 1;
                overflow: hidden;
                display: flex;
                flex-direction: column;
            }

            .formula-input-wrapper {
                position: relative;
                padding: 16px 24px;
                border-bottom: 1px solid #e5e7eb;
            }

            .formula-input {
                width: 100%;
                min-height: 120px;
                padding: 12px;
                border: 2px solid #e5e7eb;
                border-radius: 8px;
                font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
                font-size: 14px;
                line-height: 1.6;
                resize: vertical;
                transition: border-color 0.15s;
            }

            .formula-input:focus {
                outline: none;
                border-color: #3b82f6;
                box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
            }

            .formula-input.error {
                border-color: #ef4444;
            }

            .formula-autocomplete {
                position: absolute;
                background: white;
                border: 1px solid #e5e7eb;
                border-radius: 8px;
                box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15);
                max-height: 300px;
                overflow-y: auto;
                z-index: 1001;
                min-width: 280px;
            }

            .autocomplete-item {
                padding: 10px 14px;
                cursor: pointer;
                transition: background 0.1s;
                border-bottom: 1px solid #f3f4f6;
            }

            .autocomplete-item:last-child {
                border-bottom: none;
            }

            .autocomplete-item:hover {
                background: #f9fafb;
            }

            .autocomplete-item.selected {
                background: #eff6ff;
                color: #1e40af;
            }

            .autocomplete-item-main {
                display: flex;
                align-items: center;
                gap: 8px;
                font-weight: 600;
                margin-bottom: 4px;
            }

            .autocomplete-item-icon {
                width: 20px;
                height: 20px;
                display: flex;
                align-items: center;
                justify-content: center;
                border-radius: 4px;
                font-size: 12px;
            }

            .autocomplete-item-icon.field {
                background: #dbeafe;
                color: #1e40af;
            }

            .autocomplete-item-icon.function {
                background: #fef3c7;
                color: #92400e;
            }

            .autocomplete-item-description {
                font-size: 12px;
                color: #6b7280;
                line-height: 1.4;
            }

            .autocomplete-item-syntax {
                font-size: 11px;
                font-family: 'Monaco', 'Menlo', monospace;
                color: #3b82f6;
                margin-top: 4px;
            }

            .formula-validation {
                padding: 12px 24px;
                border-bottom: 1px solid #e5e7eb;
            }

            .validation-message {
                display: flex;
                align-items: start;
                gap: 8px;
                padding: 8px 12px;
                border-radius: 6px;
                font-size: 13px;
                margin-bottom: 8px;
            }

            .validation-message:last-child {
                margin-bottom: 0;
            }

            .validation-message.error {
                background: #fee2e2;
                color: #991b1b;
                border: 1px solid #fecaca;
            }

            .validation-message.warning {
                background: #fef3c7;
                color: #92400e;
                border: 1px solid #fde68a;
            }

            .validation-message.success {
                background: #d1fae5;
                color: #065f46;
                border: 1px solid #a7f3d0;
            }

            .formula-preview {
                padding: 16px 24px;
                background: #f9fafb;
                border-bottom: 1px solid #e5e7eb;
            }

            .preview-label {
                font-size: 12px;
                font-weight: 600;
                color: #6b7280;
                text-transform: uppercase;
                letter-spacing: 0.05em;
                margin-bottom: 8px;
            }

            .preview-result {
                padding: 12px;
                background: white;
                border: 1px solid #e5e7eb;
                border-radius: 6px;
                font-family: 'Monaco', 'Menlo', monospace;
                font-size: 14px;
                color: #111827;
            }

            .preview-error {
                color: #dc2626;
            }

            .formula-helpers {
                flex: 1;
                overflow-y: auto;
                padding: 16px 24px;
            }

            .helper-section {
                margin-bottom: 24px;
            }

            .helper-section-title {
                font-weight: 600;
                font-size: 14px;
                color: #111827;
                margin-bottom: 12px;
                display: flex;
                align-items: center;
                gap: 8px;
            }

            .helper-items {
                display: grid;
                grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
                gap: 8px;
            }

            .helper-item {
                padding: 8px 12px;
                background: #f9fafb;
                border: 1px solid #e5e7eb;
                border-radius: 6px;
                cursor: pointer;
                transition: all 0.15s;
                font-size: 13px;
            }

            .helper-item:hover {
                background: #eff6ff;
                border-color: #3b82f6;
                color: #1e40af;
            }

            .helper-item-name {
                font-weight: 600;
                margin-bottom: 4px;
            }

            .helper-item-desc {
                font-size: 11px;
                color: #6b7280;
            }

            .formula-editor-footer {
                padding: 16px 24px;
                border-top: 1px solid #e5e7eb;
                display: flex;
                justify-content: space-between;
                align-items: center;
            }

            .formula-shortcuts {
                display: flex;
                gap: 16px;
                font-size: 12px;
                color: #6b7280;
            }

            .shortcut-hint {
                display: flex;
                align-items: center;
                gap: 4px;
            }

            .shortcut-key {
                padding: 2px 6px;
                background: #f3f4f6;
                border: 1px solid #d1d5db;
                border-radius: 4px;
                font-family: monospace;
                font-size: 11px;
            }

            .visual-formula-builder {
                padding: 24px;
            }

            .formula-blocks {
                display: flex;
                flex-direction: column;
                gap: 12px;
            }

            .formula-block {
                background: white;
                border: 2px solid #e5e7eb;
                border-radius: 8px;
                padding: 16px;
                display: flex;
                align-items: center;
                gap: 12px;
            }

            .formula-block-type {
                padding: 4px 8px;
                background: #f3f4f6;
                border-radius: 4px;
                font-size: 11px;
                font-weight: 600;
                text-transform: uppercase;
                color: #6b7280;
            }

            .formula-block-content {
                flex: 1;
                display: flex;
                align-items: center;
                gap: 8px;
            }

            .formula-block select,
            .formula-block input {
                padding: 6px 10px;
                border: 1px solid #d1d5db;
                border-radius: 4px;
                font-size: 14px;
            }

            .formula-block-actions {
                display: flex;
                gap: 4px;
            }

            .formula-block-action {
                padding: 6px;
                background: transparent;
                border: none;
                cursor: pointer;
                color: #6b7280;
                transition: color 0.15s;
            }

            .formula-block-action:hover {
                color: #111827;
            }

            .formula-block-action.delete:hover {
                color: #dc2626;
            }

            .add-block-btn {
                padding: 12px;
                border: 2px dashed #d1d5db;
                border-radius: 8px;
                background: transparent;
                color: #6b7280;
                cursor: pointer;
                transition: all 0.15s;
                font-weight: 500;
            }

            .add-block-btn:hover {
                border-color: #3b82f6;
                color: #3b82f6;
                background: #eff6ff;
            }
        `;

        if (!document.getElementById('formulaEditorStyles')) {
            const style = document.createElement('style');
            style.id = 'formulaEditorStyles';
            style.textContent = formulaEditorCSS;
            document.head.appendChild(style);
        }

        function getFieldWidth(field) {
            const numericWidth = parseInt(field?.width || '150', 10);
            return clampColumnWidth(numericWidth);
        }

        async function initializeFormulaSupport() {
            if (typeof FormulaFieldService === 'undefined' || typeof FormulaEngine === 'undefined') {
                console.warn('Formula libraries are not available. Formula fields will be disabled.');
                return;
            }

            try {
                const response = await fetch('formula_language.json');
                const spec = await response.json();
                window.FormulaLanguageSpec = spec;
                state.formulaFieldService = new FormulaFieldService({
                    spec,
                    engine: new FormulaEngine()
                });
                recomputeAllFormulas();
            } catch (error) {
                console.warn('Unable to initialize formula support', error);
            }
        }

        function recomputeAllFormulas() {
            state.sets.forEach(set => recomputeFormulasForSet(set));
        }

        function recomputeFormulasForSet(set) {
            if (!state.formulaFieldService || !set) return;
            const formulaFields = set.schema.filter(f => f.type === 'FORMULA');
            if (!formulaFields.length) return;
            set.records.forEach(record => {
                formulaFields.forEach(field => evaluateFormulaField(record, field));
            });
        }

        function evaluateFormulaField(record, field) {
            if (!state.formulaFieldService || !field?.config?.formula) return;
            const evaluation = state.formulaFieldService.evaluateForRecord(field.config.formula, record);
            record.__formulaMeta = record.__formulaMeta || {};
            record.__formulaMeta[field.id] = evaluation;
            record[field.id] = evaluation.success ? evaluation.result : '';
        }

        function getFormulaSpec() {
            return window.FormulaLanguageSpec || { functions: {}, operators: [] };
        }

        function openFormulaEditor(fieldId = null, onSave = null) {
            const set = getCurrentSet();
            if (!set) return;

            const field = fieldId ? set.schema.find(f => f.id === fieldId) : null;

            state.formulaEditor = {
                ...state.formulaEditor,
                isOpen: true,
                fieldId,
                currentFormula: field?.config?.formula || document.getElementById('formulaExpression')?.value || '',
                cursorPosition: 0,
                autocomplete: {
                    isVisible: false,
                    items: [],
                    selectedIndex: 0,
                    trigger: null,
                    filterText: ''
                },
                validation: {
                    isValid: true,
                    errors: [],
                    warnings: []
                },
                preview: {
                    result: null,
                    error: null
                },
                mode: 'code',
                onSave,
                visualBlocks: field?.config?.visualBlocks || []
            };

            renderFormulaEditor();
        }

        function renderFormulaEditor() {
            const modal = `
                <div class="formula-editor-modal" id="formulaEditorModal">
                    <div class="formula-editor-container">
                        <div class="formula-editor-header">
                            <div>
                                <h2 class="text-xl font-bold">Formula Editor</h2>
                                <p class="text-sm text-gray-600 mt-1">Build formulas with autocomplete and live preview</p>
                            </div>
                            <button onclick="closeFormulaEditor()" class="text-gray-400 hover:text-gray-600">
                                <i class="ph ph-x text-xl"></i>
                            </button>
                        </div>
                        <div class="formula-editor-tabs">
                            <button 
                                class="formula-editor-tab ${state.formulaEditor.mode === 'code' ? 'active' : ''}"
                                onclick="switchFormulaMode('code')"
                            >
                                <i class="ph ph-code"></i>
                                Code Editor
                            </button>
                            <button 
                                class="formula-editor-tab ${state.formulaEditor.mode === 'visual' ? 'active' : ''}"
                                onclick="switchFormulaMode('visual')"
                            >
                                <i class="ph ph-flow-arrow"></i>
                                Visual Builder
                            </button>
                            <button 
                                class="formula-editor-tab"
                                onclick="showFormulaExamples()"
                            >
                                <i class="ph ph-lightbulb"></i>
                                Examples
                            </button>
                        </div>
                        <div class="formula-editor-body">
                            ${state.formulaEditor.mode === 'code' ? renderCodeEditor() : renderVisualBuilder()}
                        </div>
                        <div class="formula-editor-footer">
                            <div class="formula-shortcuts">
                                <div class="shortcut-hint">
                                    <span class="shortcut-key">{</span>
                                    <span>Field reference</span>
                                </div>
                                <div class="shortcut-hint">
                                    <span class="shortcut-key">Ctrl+Space</span>
                                    <span>Functions</span>
                                </div>
                                <div class="shortcut-hint">
                                    <span class="shortcut-key">Tab</span>
                                    <span>Accept suggestion</span>
                                </div>
                            </div>
                            <div class="flex gap-2">
                                <button onclick="closeFormulaEditor()" class="btn btn-secondary">Cancel</button>
                                <button onclick="saveFormula()" class="btn btn-primary">Save Formula</button>
                            </div>
                        </div>
                    </div>
                </div>
            `;

            document.getElementById('formulaEditorModal')?.remove();
            document.body.insertAdjacentHTML('beforeend', modal);

            setTimeout(() => {
                const input = document.getElementById('formulaInput');
                if (input) {
                    input.focus();
                    input.setSelectionRange(state.formulaEditor.currentFormula.length, state.formulaEditor.currentFormula.length);
                }
            }, 100);
        }

        function renderCodeEditor() {
            const validation = state.formulaEditor.validation;
            const preview = state.formulaEditor.preview;

            return `
                <div class="formula-input-wrapper">
                    <textarea
                        id="formulaInput"
                        class="formula-input ${!validation.isValid ? 'error' : ''}"
                        placeholder="Enter your formula... Type { for field references or Ctrl+Space for functions"
                        oninput="handleFormulaInput(event)"
                        onkeydown="handleFormulaKeydown(event)"
                    >${state.formulaEditor.currentFormula}</textarea>
                    ${state.formulaEditor.autocomplete.isVisible ? renderAutocomplete() : ''}
                </div>
                ${validation.errors.length > 0 || validation.warnings.length > 0 ? `
                    <div class="formula-validation">
                        ${validation.errors.map(error => `
                            <div class="validation-message error">
                                <i class="ph ph-warning-circle"></i>
                                <span>${error}</span>
                            </div>
                        `).join('')}
                        ${validation.warnings.map(warning => `
                            <div class="validation-message warning">
                                <i class="ph ph-warning"></i>
                                <span>${warning}</span>
                            </div>
                        `).join('')}
                    </div>
                ` : ''}
                ${state.formulaEditor.currentFormula ? `
                    <div class="formula-preview">
                        <div class="preview-label">Preview</div>
                        <div class="preview-result ${preview.error ? 'preview-error' : ''}">
                            ${preview.error || preview.result || 'Enter a formula to see preview'}
                        </div>
                    </div>
                ` : ''}
                <div class="formula-helpers">
                    ${renderFormulaHelpers()}
                </div>
            `;
        }

        function renderAutocomplete() {
            const { items, selectedIndex } = state.formulaEditor.autocomplete;
            if (!items.length) return '';

            const input = document.getElementById('formulaInput');
            if (!input) return '';

            return `
                <div class="formula-autocomplete" id="autocompleteMenu" style="top: 140px; left: 36px;">
                    ${items.map((item, index) => `
                        <div class="autocomplete-item ${index === selectedIndex ? 'selected' : ''}" onclick="selectAutocompleteItem(${index})">
                            <div class="autocomplete-item-main">
                                <div class="autocomplete-item-icon ${item.type}">
                                    ${item.type === 'field' ? '' : ''}
                                </div>
                                <span>${item.name}</span>
                            </div>
                            ${item.description ? `<div class="autocomplete-item-description">${item.description}</div>` : ''}
                            ${item.syntax ? `<div class="autocomplete-item-syntax">${item.syntax}</div>` : ''}
                        </div>
                    `).join('')}
                </div>
            `;
        }

        function renderFormulaHelpers() {
            const set = getCurrentSet();
            if (!set) return '';

            return `
                <div class="helper-section">
                    <div class="helper-section-title">
                        <i class="ph ph-file-text text-blue-600"></i>
                        <span>Available Fields</span>
                    </div>
                    <div class="helper-items">
                        ${set.schema.map(field => `
                            <div class="helper-item" onclick="insertField('${field.id}')">
                                <div class="helper-item-name">{${field.name}}</div>
                                <div class="helper-item-desc">${field.type}</div>
                            </div>
                        `).join('')}
                    </div>
                </div>
                <div class="helper-section">
                    <div class="helper-section-title">
                        <i class="ph ph-function text-yellow-600"></i>
                        <span>Common Functions</span>
                    </div>
                    <div class="helper-items">
                        ${renderCommonFunctions()}
                    </div>
                </div>
            `;
        }

        function renderCommonFunctions() {
            const common = [
                { name: 'IF', syntax: 'IF(condition, value1, value2)', desc: 'Conditional logic' },
                { name: 'SUM', syntax: 'SUM(number1, number2, ...)', desc: 'Add numbers' },
                { name: 'CONCATENATE', syntax: 'CONCATENATE(text1, text2, ...)', desc: 'Join text' },
                { name: 'DATESTR', syntax: 'DATESTR(date)', desc: 'Format date' },
                { name: 'ROUND', syntax: 'ROUND(value, precision)', desc: 'Round number' },
                { name: 'UPPER', syntax: 'UPPER(text)', desc: 'Uppercase text' }
            ];

            return common.map(fn => `
                <div class="helper-item" onclick="insertFunction('${fn.syntax}')">
                    <div class="helper-item-name">${fn.name}</div>
                    <div class="helper-item-desc">${fn.desc}</div>
                </div>
            `).join('');
        }

        function handleFormulaInput(event) {
            const input = event.target;
            const value = input.value;
            const cursorPos = input.selectionStart;

            state.formulaEditor.currentFormula = value;
            state.formulaEditor.cursorPosition = cursorPos;

            checkAutocompleteTrigger(value, cursorPos);
            validateFormula(value);
            updateFormulaPreview(value);
            renderFormulaEditor();
        }

        function checkAutocompleteTrigger(formula, cursorPos) {
            const beforeCursor = formula.substring(0, cursorPos);
            const fieldMatch = beforeCursor.match(/\{([^}]*)$/);
            if (fieldMatch) {
                const filterText = fieldMatch[1];
                showFieldAutocomplete(filterText);
                return;
            }

            const functionMatch = beforeCursor.match(/([A-Z_]+)\(([^)]*)$/i);
            if (functionMatch) {
                const functionName = functionMatch[1];
                showFunctionAutocomplete(functionName);
                return;
            }

            state.formulaEditor.autocomplete.isVisible = false;
        }

        function showFieldAutocomplete(filterText) {
            const set = getCurrentSet();
            if (!set) return;

            const fields = set.schema.filter(field =>
                field.name.toLowerCase().includes(filterText.toLowerCase())
            );

            state.formulaEditor.autocomplete = {
                isVisible: fields.length > 0,
                items: fields.map(field => ({
                    type: 'field',
                    name: field.name,
                    value: `{${field.name}}`,
                    description: `${field.type} field`,
                    syntax: null
                })),
                selectedIndex: 0,
                trigger: 'field',
                filterText
            };
        }

        function showFunctionAutocomplete(functionName) {
            const functions = [];
            Object.values(getFormulaSpec().functions || {}).forEach(category => {
                category.forEach(fn => {
                    if (fn.name.toLowerCase().includes((functionName || '').toLowerCase())) {
                        functions.push({
                            type: 'function',
                            name: fn.name,
                            value: fn.syntax,
                            description: fn.description,
                            syntax: fn.syntax
                        });
                    }
                });
            });

            state.formulaEditor.autocomplete = {
                isVisible: functions.length > 0,
                items: functions,
                selectedIndex: 0,
                trigger: 'function',
                filterText: functionName
            };
        }

        function handleFormulaKeydown(event) {
            const autocomplete = state.formulaEditor.autocomplete;

            if (!autocomplete.isVisible) {
                if (event.key === ' ' && event.ctrlKey) {
                    event.preventDefault();
                    showFunctionAutocomplete('');
                    renderFormulaEditor();
                }
                return;
            }

            if (event.key === 'ArrowDown') {
                event.preventDefault();
                autocomplete.selectedIndex = Math.min(
                    autocomplete.selectedIndex + 1,
                    autocomplete.items.length - 1
                );
                renderFormulaEditor();
            } else if (event.key === 'ArrowUp') {
                event.preventDefault();
                autocomplete.selectedIndex = Math.max(autocomplete.selectedIndex - 1, 0);
                renderFormulaEditor();
            } else if (event.key === 'Enter' || event.key === 'Tab') {
                event.preventDefault();
                selectAutocompleteItem(autocomplete.selectedIndex);
            } else if (event.key === 'Escape') {
                event.preventDefault();
                autocomplete.isVisible = false;
                renderFormulaEditor();
            }
        }

        function selectAutocompleteItem(index) {
            const autocomplete = state.formulaEditor.autocomplete;
            const item = autocomplete.items[index];
            if (!item) return;

            const input = document.getElementById('formulaInput');
            if (!input) return;

            const formula = state.formulaEditor.currentFormula;
            const cursorPos = state.formulaEditor.cursorPosition;

            let newFormula = formula;
            let newCursorPos = cursorPos;

            if (autocomplete.trigger === 'field') {
                const beforeCursor = formula.substring(0, cursorPos);
                const afterCursor = formula.substring(cursorPos);
                const match = beforeCursor.match(/\{([^}]*)$/);

                if (match) {
                    const startPos = beforeCursor.length - match[0].length;
                    newFormula = formula.substring(0, startPos) + item.value + afterCursor;
                    newCursorPos = startPos + item.value.length;
                }
            } else if (autocomplete.trigger === 'function') {
                const beforeCursor = formula.substring(0, cursorPos);
                const afterCursor = formula.substring(cursorPos);
                const match = beforeCursor.match(/([A-Z_]+)\(([^)]*)$/i);

                if (match) {
                    const startPos = beforeCursor.length - match[0].length;
                    newFormula = formula.substring(0, startPos) + item.syntax + afterCursor;
                    newCursorPos = startPos + item.name.length + 1;
                }
            }

            state.formulaEditor.currentFormula = newFormula;
            state.formulaEditor.cursorPosition = newCursorPos;
            state.formulaEditor.autocomplete.isVisible = false;

            renderFormulaEditor();

            setTimeout(() => {
                input.focus();
                input.setSelectionRange(newCursorPos, newCursorPos);
            }, 0);
        }

        function insertField(fieldId) {
            const set = getCurrentSet();
            if (!set) return;
            const field = set.schema.find(f => f.id === fieldId);
            if (!field) return;

            const input = document.getElementById('formulaInput');
            const cursorPos = input?.selectionStart ?? state.formulaEditor.cursorPosition;
            const formula = state.formulaEditor.currentFormula;

            const insertion = `{${field.name}}`;
            const newFormula = formula.substring(0, cursorPos) + insertion + formula.substring(cursorPos);

            state.formulaEditor.currentFormula = newFormula;
            state.formulaEditor.cursorPosition = cursorPos + insertion.length;

            renderFormulaEditor();

            setTimeout(() => {
                const activeInput = document.getElementById('formulaInput');
                if (activeInput) {
                    activeInput.focus();
                    activeInput.setSelectionRange(state.formulaEditor.cursorPosition, state.formulaEditor.cursorPosition);
                }
            }, 0);
        }

        function insertFunction(syntax) {
            const input = document.getElementById('formulaInput');
            const cursorPos = input?.selectionStart ?? state.formulaEditor.cursorPosition;
            const formula = state.formulaEditor.currentFormula;

            const newFormula = formula.substring(0, cursorPos) + syntax + formula.substring(cursorPos);
            const firstParenPos = syntax.indexOf('(') + 1;
            const newCursorPos = cursorPos + firstParenPos;

            state.formulaEditor.currentFormula = newFormula;
            state.formulaEditor.cursorPosition = newCursorPos;

            renderFormulaEditor();

            setTimeout(() => {
                const activeInput = document.getElementById('formulaInput');
                if (activeInput) {
                    activeInput.focus();
                    activeInput.setSelectionRange(newCursorPos, newCursorPos);
                }
            }, 0);
        }

        function validateFormula(formula) {
            const set = getCurrentSet();
            const errors = [];
            const warnings = [];

            const openBraces = (formula.match(/\{/g) || []).length;
            const closeBraces = (formula.match(/\}/g) || []).length;
            if (openBraces !== closeBraces) {
                errors.push('Unmatched curly braces in formula');
            }

            const openParens = (formula.match(/\(/g) || []).length;
            const closeParens = (formula.match(/\)/g) || []).length;
            if (openParens !== closeParens) {
                errors.push('Unmatched parentheses in formula');
            }

            const fieldRefs = formula.match(/\{([^}]+)\}/g) || [];
            fieldRefs.forEach(ref => {
                const fieldName = ref.slice(1, -1);
                const exists = set?.schema?.some(f => f.name === fieldName || f.id === fieldName);
                if (!exists) {
                    errors.push(`Unknown field: ${fieldName}`);
                }
            });

            const functionCalls = formula.match(/\b([A-Z_]+)\s*\(/g) || [];
            functionCalls.forEach(call => {
                const functionName = call.match(/([A-Z_]+)/)[1];
                const exists = Object.values(getFormulaSpec().functions || {})
                    .flat()
                    .some(fn => fn.name === functionName);

                if (!exists) {
                    errors.push(`Unknown function: ${functionName}`);
                }
            });

            if (formula.includes('&')) {
                warnings.push('Using & for concatenation will convert values to text');
            }

            state.formulaEditor.validation = {
                isValid: errors.length === 0,
                errors,
                warnings
            };
        }

        function updateFormulaPreview(formula) {
            if (!formula.trim()) {
                state.formulaEditor.preview = { result: null, error: null };
                return;
            }

            try {
                const set = getCurrentSet();
                if (!set) {
                    state.formulaEditor.preview = { result: null, error: 'No set available for preview' };
                    return;
                }
                const sampleRecord = Array.from(set.records.values())[0] || {};

                const engine = new FormulaEngine();
                const service = new FormulaFieldService({ engine });

                const result = service.evaluateForRecord(formula, sampleRecord);

                if (result.success) {
                    state.formulaEditor.preview = {
                        result: result.preview,
                        error: null
                    };
                } else {
                    state.formulaEditor.preview = {
                        result: null,
                        error: result.error.message
                    };
                }
            } catch (error) {
                state.formulaEditor.preview = {
                    result: null,
                    error: error.message
                };
            }
        }

        function renderVisualBuilder() {
            return `
                <div class="visual-formula-builder">
                    <div class="mb-4">
                        <h3 class="font-semibold mb-2">Build your formula visually</h3>
                        <p class="text-sm text-gray-600">Drag and drop blocks to create your formula</p>
                    </div>
                    <div class="formula-blocks" id="visualFormulaBlocks">
                        ${renderVisualBlocks()}
                    </div>
                    <button class="add-block-btn w-full" onclick="addFormulaBlock()">
                        <i class="ph ph-plus"></i>
                        Add Block
                    </button>
                    <div class="mt-6 p-4 bg-gray-50 border border-gray-200 rounded-lg">
                        <div class="text-xs font-semibold text-gray-500 uppercase mb-2">Generated Formula</div>
                        <div class="font-mono text-sm">${generateFormulaFromBlocks()}</div>
                    </div>
                </div>
            `;
        }

        function renderVisualBlocks() {
            if (!state.formulaEditor.visualBlocks || state.formulaEditor.visualBlocks.length === 0) {
                return '<p class="text-gray-500 text-center py-8">No blocks yet. Click "Add Block" to start building your formula.</p>';
            }

            return state.formulaEditor.visualBlocks.map((block, index) => `
                <div class="formula-block">
                    <div class="formula-block-type">${block.type}</div>
                    <div class="formula-block-content">
                        ${renderBlockContent(block, index)}
                    </div>
                    <div class="formula-block-actions">
                        <button class="formula-block-action" onclick="moveBlock(${index}, -1)" ${index === 0 ? 'disabled' : ''}>
                            <i class="ph ph-arrow-up"></i>
                        </button>
                        <button class="formula-block-action" onclick="moveBlock(${index}, 1)" ${index === state.formulaEditor.visualBlocks.length - 1 ? 'disabled' : ''}>
                            <i class="ph ph-arrow-down"></i>
                        </button>
                        <button class="formula-block-action delete" onclick="removeBlock(${index})">
                            <i class="ph ph-trash"></i>
                        </button>
                    </div>
                </div>
            `).join('');
        }

        function renderBlockContent(block, index) {
            const set = getCurrentSet();

            switch (block.type) {
                case 'field':
                    return `
                        <select onchange="updateBlock(${index}, 'field', this.value)">
                            <option value="">Select field...</option>
                            ${set.schema.map(f => `
                                <option value="${f.id}" ${block.field === f.id ? 'selected' : ''}>${f.name}</option>
                            `).join('')}
                        </select>
                    `;
                case 'function':
                    const functions = Object.values(getFormulaSpec().functions || {}).flat();
                    return `
                        <select onchange="updateBlock(${index}, 'function', this.value)">
                            <option value="">Select function...</option>
                            ${functions.map(fn => `
                                <option value="${fn.name}" ${block.function === fn.name ? 'selected' : ''}>${fn.name}</option>
                            `).join('')}
                        </select>
                        <input 
                            type="text" 
                            placeholder="Arguments" 
                            value="${block.args || ''}"
                            onchange="updateBlock(${index}, 'args', this.value)"
                        >
                    `;
                case 'operator':
                    return `
                        <select onchange="updateBlock(${index}, 'operator', this.value)">
                            <option value="">Select operator...</option>
                            <option value="+" ${block.operator === '+' ? 'selected' : ''}>+ (Add)</option>
                            <option value="-" ${block.operator === '-' ? 'selected' : ''}>- (Subtract)</option>
                            <option value="*" ${block.operator === '*' ? 'selected' : ''}>* (Multiply)</option>
                            <option value="/" ${block.operator === '/' ? 'selected' : ''}>/ (Divide)</option>
                            <option value="&" ${block.operator === '&' ? 'selected' : ''}>& (Concatenate)</option>
                            <option value=">" ${block.operator === '>' ? 'selected' : ''}>> (Greater than)</option>
                            <option value="<" ${block.operator === '<' ? 'selected' : ''}>< (Less than)</option>
                            <option value="=" ${block.operator === '=' ? 'selected' : ''}>= (Equal)</option>
                        </select>
                    `;
                case 'value':
                    return `
                        <input 
                            type="text" 
                            placeholder="Enter value" 
                            value="${block.value || ''}"
                            onchange="updateBlock(${index}, 'value', this.value)"
                        >
                    `;
                default:
                    return '';
            }
        }

        function addFormulaBlock() {
            if (!state.formulaEditor.visualBlocks) {
                state.formulaEditor.visualBlocks = [];
            }

            state.formulaEditor.visualBlocks.push({ type: 'field', field: '' });
            renderFormulaEditor();
        }

        function updateBlock(index, property, value) {
            if (!state.formulaEditor.visualBlocks[index]) return;
            state.formulaEditor.visualBlocks[index][property] = value;
            renderFormulaEditor();
        }

        function removeBlock(index) {
            state.formulaEditor.visualBlocks.splice(index, 1);
            renderFormulaEditor();
        }

        function moveBlock(index, direction) {
            const newIndex = index + direction;
            if (newIndex < 0 || newIndex >= state.formulaEditor.visualBlocks.length) return;

            const blocks = state.formulaEditor.visualBlocks;
            [blocks[index], blocks[newIndex]] = [blocks[newIndex], blocks[index]];
            renderFormulaEditor();
        }

        function generateFormulaFromBlocks() {
            if (!state.formulaEditor.visualBlocks || state.formulaEditor.visualBlocks.length === 0) {
                return 'No formula yet';
            }

            const currentSet = getCurrentSet();
            const parts = state.formulaEditor.visualBlocks.map(block => {
                switch (block.type) {
                    case 'field':
                        const field = currentSet?.schema?.find(f => f.id === block.field);
                        return field ? `{${field.name}}` : '[field]';
                    case 'function':
                        return `${block.function}(${block.args || ''})`;
                    case 'operator':
                        return block.operator || '[op]';
                    case 'value':
                        return typeof block.value === 'string' ? `"${block.value}"` : block.value;
                    default:
                        return '';
                }
            });

            return parts.join(' ');
        }

        function switchFormulaMode(mode) {
            if (mode === 'visual' && state.formulaEditor.mode === 'code') {
                state.formulaEditor.visualBlocks = [];
            } else if (mode === 'code' && state.formulaEditor.mode === 'visual') {
                state.formulaEditor.currentFormula = generateFormulaFromBlocks();
            }

            state.formulaEditor.mode = mode;
            renderFormulaEditor();
        }

        function saveFormula() {
            const formula = state.formulaEditor.mode === 'visual'
                ? generateFormulaFromBlocks()
                : state.formulaEditor.currentFormula;

            validateFormula(formula);

            if (!state.formulaEditor.validation.isValid) {
                showToast(' Please fix errors before saving');
                return;
            }

            if (typeof state.formulaEditor.onSave === 'function') {
                state.formulaEditor.onSave(formula, state.formulaEditor.visualBlocks);
                closeFormulaEditor();
                return;
            }

            const set = getCurrentSet();
            const fieldId = state.formulaEditor.fieldId;

            if (fieldId) {
                const field = set.schema.find(f => f.id === fieldId);
                if (field) {
                    field.config = field.config || {};
                    field.config.formula = formula;
                    field.config.visualBlocks = state.formulaEditor.visualBlocks;
                    recalculateFormulaField(fieldId);
                }
            }

            closeFormulaEditor();
            renderCurrentView();
            showToast(' Formula saved');
        }

        function recalculateFormulaField(fieldId) {
            const set = getCurrentSet();
            const field = set.schema.find(f => f.id === fieldId);

            if (!field || field.type !== 'FORMULA') return;

            const engine = new FormulaEngine();
            const service = new FormulaFieldService({ engine });

            set.records.forEach(record => {
                try {
                    const result = service.evaluateForRecord(field.config.formula, record);
                    if (result.success) {
                        record[fieldId] = result.result;
                    } else {
                        record[fieldId] = '#ERROR';
                    }
                } catch (error) {
                    record[fieldId] = '#ERROR';
                }
            });
        }

        function closeFormulaEditor() {
            document.getElementById('formulaEditorModal')?.remove();
            state.formulaEditor.isOpen = false;
        }

        function showFormulaExamples() {
            showToast('Coming soon: curated formula examples');
        }

        function launchFormulaEditorFromConfig() {
            const textarea = document.getElementById('formulaExpression');
            const existingFormula = textarea?.value || '';

            openFormulaEditor(null, (formula, blocks = []) => {
                if (textarea) {
                    textarea.value = formula;
                    textarea.dataset.visualBlocks = JSON.stringify(blocks || []);
                }
            });

            state.formulaEditor.currentFormula = existingFormula;
        }

        const FIELD_TYPES = {
            TEXT: { id: 'TEXT', name: 'Single Line Text', description: 'Quick text field for titles and short labels', defaultValue: '', icon: 'ph-text-t' },
            LONG_TEXT: { id: 'LONG_TEXT', name: 'Long Text', description: 'Multi-line notes, descriptions, or comments', defaultValue: '', icon: 'ph-article' },
            NUMBER: { id: 'NUMBER', name: 'Number', description: 'Store numeric values with sorting and calculations', defaultValue: 0, icon: 'ph-hash' },
            CURRENCY: { id: 'CURRENCY', name: 'Currency', description: 'Track prices, budgets, and financial amounts', defaultValue: 0, icon: 'ph-currency-dollar' },
            DATE: { id: 'DATE', name: 'Date', description: 'Capture due dates, milestones, and schedules', defaultValue: '', icon: 'ph-calendar-blank' },
            EMAIL: { id: 'EMAIL', name: 'Email', description: 'Contact email addresses with validation', defaultValue: '', icon: 'ph-envelope-simple' },
            URL: { id: 'URL', name: 'URL', description: 'Links to webpages, docs, or media', defaultValue: '', icon: 'ph-link-simple' },
            PHONE: { id: 'PHONE', name: 'Phone', description: 'International phone numbers for contacts', defaultValue: '', icon: 'ph-phone' },
            LINK_RECORD: { id: 'LINK_RECORD', name: 'Link to Record', description: 'Connect records across sets with relationships', defaultValue: '', icon: 'ph-link-simple-horizontal', needsConfig: true },
            SINGLE_SELECT: { id: 'SINGLE_SELECT', name: 'Single Select', description: 'Choose one option from a defined list', defaultValue: '', icon: 'ph-list-bullets', needsConfig: true },
            CHECKBOX: { id: 'CHECKBOX', name: 'Checkbox', description: 'Quick yes/no or done/undone tracking', defaultValue: false, icon: 'ph-check-square' },
            FORMULA: { id: 'FORMULA', name: 'Formula', description: 'Calculated values using the repo\'s JavaScript formula rules', defaultValue: '', icon: 'ph-equals', needsConfig: true }
        };

        const VIEW_TYPE_ICONS = { grid: 'ph-table', card: 'ph-cards-three', kanban: 'ph-kanban' };

        const ICON_OPTIONS = [
            // Organization & Layout
            { token: 'ph-squares-four', label: 'Grid', keywords: ['dashboard', 'board', 'overview', 'layout'] },
            { token: 'ph-table', label: 'Table', keywords: ['grid', 'sheet', 'records', 'spreadsheet'] },
            { token: 'ph-cards-three', label: 'Cards', keywords: ['gallery', 'kanban', 'tiles', 'card'] },
            { token: 'ph-kanban', label: 'Kanban', keywords: ['workflow', 'board', 'columns', 'agile'] },
            { token: 'ph-list', label: 'List', keywords: ['items', 'menu', 'rows'] },
            { token: 'ph-list-bullets', label: 'List Bullets', keywords: ['todo', 'tasks', 'rows', 'items'] },
            { token: 'ph-list-checks', label: 'List Checks', keywords: ['todo', 'tasks', 'checklist', 'complete'] },
            { token: 'ph-list-dashes', label: 'List Dashes', keywords: ['items', 'menu', 'rows'] },
            { token: 'ph-list-numbers', label: 'List Numbers', keywords: ['ordered', 'sequence', 'steps'] },
            { token: 'ph-rows', label: 'Rows', keywords: ['layout', 'horizontal', 'lines'] },
            { token: 'ph-columns', label: 'Columns', keywords: ['layout', 'vertical', 'split'] },
            { token: 'ph-sidebar', label: 'Sidebar', keywords: ['navigation', 'menu', 'panel'] },
            { token: 'ph-sidebar-simple', label: 'Sidebar Simple', keywords: ['navigation', 'menu', 'panel'] },
            { token: 'ph-layout', label: 'Layout', keywords: ['design', 'structure', 'template'] },
            { token: 'ph-app-window', label: 'App Window', keywords: ['browser', 'application', 'screen'] },

            // Files & Folders
            { token: 'ph-folder', label: 'Folder', keywords: ['directory', 'files', 'organize'] },
            { token: 'ph-folders', label: 'Folders', keywords: ['files', 'library', 'taxonomy', 'organize'] },
            { token: 'ph-folder-open', label: 'Folder Open', keywords: ['directory', 'files', 'browse'] },
            { token: 'ph-folder-plus', label: 'Folder Plus', keywords: ['create', 'new', 'add'] },
            { token: 'ph-file', label: 'File', keywords: ['document', 'page', 'content'] },
            { token: 'ph-file-text', label: 'File Text', keywords: ['document', 'page', 'text'] },
            { token: 'ph-file-plus', label: 'File Plus', keywords: ['create', 'new', 'add'] },
            { token: 'ph-files', label: 'Files', keywords: ['documents', 'pages', 'multiple'] },
            { token: 'ph-note', label: 'Note', keywords: ['memo', 'text', 'write'] },
            { token: 'ph-note-blank', label: 'Note Blank', keywords: ['new', 'empty', 'create'] },
            { token: 'ph-notebook', label: 'Notebook', keywords: ['notes', 'doc', 'wiki', 'journal'] },
            { token: 'ph-notepad', label: 'Notepad', keywords: ['notes', 'memo', 'write'] },
            { token: 'ph-article', label: 'Article', keywords: ['blog', 'post', 'content'] },
            { token: 'ph-newspaper', label: 'Newspaper', keywords: ['news', 'article', 'media'] },
            { token: 'ph-book', label: 'Book', keywords: ['library', 'reading', 'documentation'] },
            { token: 'ph-book-open', label: 'Book Open', keywords: ['reading', 'documentation', 'learn'] },
            { token: 'ph-books', label: 'Books', keywords: ['library', 'reading', 'education'] },

            // Documents & Text
            { token: 'ph-clipboard', label: 'Clipboard', keywords: ['copy', 'paste', 'temp'] },
            { token: 'ph-clipboard-text', label: 'Clipboard Text', keywords: ['notes', 'summary', 'doc', 'copy'] },
            { token: 'ph-article-medium', label: 'Article Medium', keywords: ['blog', 'post', 'medium'] },
            { token: 'ph-textbox', label: 'Textbox', keywords: ['input', 'field', 'form'] },
            { token: 'ph-text-aa', label: 'Text AA', keywords: ['font', 'typography', 'letters'] },
            { token: 'ph-text-t', label: 'Text T', keywords: ['font', 'type', 'letter'] },
            { token: 'ph-quotes', label: 'Quotes', keywords: ['citation', 'text', 'speech'] },
            { token: 'ph-signature', label: 'Signature', keywords: ['sign', 'approve', 'autograph'] },

            // Communication
            { token: 'ph-chat', label: 'Chat', keywords: ['message', 'conversation', 'talk'] },
            { token: 'ph-chat-circle', label: 'Chat Circle', keywords: ['message', 'bubble', 'talk'] },
            { token: 'ph-chat-dots', label: 'Chat Dots', keywords: ['message', 'typing', 'conversation'] },
            { token: 'ph-chats', label: 'Chats', keywords: ['messages', 'conversations', 'multiple'] },
            { token: 'ph-envelope', label: 'Envelope', keywords: ['email', 'mail', 'message'] },
            { token: 'ph-envelope-open', label: 'Envelope Open', keywords: ['email', 'read', 'mail'] },
            { token: 'ph-envelope-simple', label: 'Envelope Simple', keywords: ['email', 'mail', 'send'] },
            { token: 'ph-paper-plane-tilt', label: 'Paper Plane', keywords: ['send', 'message', 'mail'] },
            { token: 'ph-phone', label: 'Phone', keywords: ['contact', 'call', 'support', 'telephone'] },
            { token: 'ph-phone-call', label: 'Phone Call', keywords: ['calling', 'telephone', 'contact'] },
            { token: 'ph-megaphone', label: 'Megaphone', keywords: ['announcement', 'broadcast', 'marketing'] },
            { token: 'ph-speaker-high', label: 'Speaker High', keywords: ['volume', 'sound', 'audio'] },
            { token: 'ph-bell', label: 'Bell', keywords: ['alerts', 'reminders', 'updates', 'notifications'] },
            { token: 'ph-bell-ringing', label: 'Bell Ringing', keywords: ['alert', 'notification', 'alarm'] },

            // Users & People
            { token: 'ph-user', label: 'User', keywords: ['person', 'profile', 'account'] },
            { token: 'ph-user-circle', label: 'User Circle', keywords: ['profile', 'account', 'avatar'] },
            { token: 'ph-user-plus', label: 'User Plus', keywords: ['add', 'invite', 'new'] },
            { token: 'ph-users', label: 'Users', keywords: ['people', 'group', 'team'] },
            { token: 'ph-users-three', label: 'Users Three', keywords: ['people', 'collaboration', 'group', 'team'] },
            { token: 'ph-user-gear', label: 'User Gear', keywords: ['settings', 'profile', 'account'] },
            { token: 'ph-identification-card', label: 'ID Card', keywords: ['profile', 'identity', 'badge'] },
            { token: 'ph-address-book', label: 'Address Book', keywords: ['contacts', 'people', 'directory'] },

            // Time & Calendar
            { token: 'ph-calendar', label: 'Calendar', keywords: ['dates', 'schedule', 'events', 'day'] },
            { token: 'ph-calendar-blank', label: 'Calendar Blank', keywords: ['dates', 'schedule', 'events', 'empty'] },
            { token: 'ph-calendar-check', label: 'Calendar Check', keywords: ['event', 'confirmed', 'scheduled'] },
            { token: 'ph-calendar-plus', label: 'Calendar Plus', keywords: ['add', 'event', 'new'] },
            { token: 'ph-calendar-x', label: 'Calendar X', keywords: ['cancel', 'delete', 'remove'] },
            { token: 'ph-clock', label: 'Clock', keywords: ['time', 'schedule', 'hour'] },
            { token: 'ph-clock-countdown', label: 'Clock Countdown', keywords: ['timer', 'countdown', 'deadline'] },
            { token: 'ph-timer', label: 'Timer', keywords: ['stopwatch', 'time', 'clock'] },
            { token: 'ph-hourglass', label: 'Hourglass', keywords: ['time', 'waiting', 'pending'] },
            { token: 'ph-alarm', label: 'Alarm', keywords: ['clock', 'reminder', 'alert'] },

            // Actions & Controls
            { token: 'ph-plus', label: 'Plus', keywords: ['add', 'create', 'new'] },
            { token: 'ph-plus-circle', label: 'Plus Circle', keywords: ['add', 'create', 'new'] },
            { token: 'ph-minus', label: 'Minus', keywords: ['remove', 'subtract', 'delete'] },
            { token: 'ph-minus-circle', label: 'Minus Circle', keywords: ['remove', 'delete', 'subtract'] },
            { token: 'ph-x', label: 'X', keywords: ['close', 'cancel', 'delete'] },
            { token: 'ph-x-circle', label: 'X Circle', keywords: ['close', 'cancel', 'remove'] },
            { token: 'ph-check', label: 'Check', keywords: ['done', 'complete', 'confirm'] },
            { token: 'ph-check-circle', label: 'Check Circle', keywords: ['done', 'complete', 'success'] },
            { token: 'ph-trash', label: 'Trash', keywords: ['delete', 'remove', 'bin'] },
            { token: 'ph-pencil', label: 'Pencil', keywords: ['edit', 'write', 'modify'] },
            { token: 'ph-pencil-simple', label: 'Pencil Simple', keywords: ['edit', 'write', 'modify'] },
            { token: 'ph-pen', label: 'Pen', keywords: ['write', 'edit', 'signature'] },
            { token: 'ph-eraser', label: 'Eraser', keywords: ['delete', 'remove', 'clear'] },
            { token: 'ph-copy', label: 'Copy', keywords: ['duplicate', 'clone', 'paste'] },
            { token: 'ph-scissors', label: 'Scissors', keywords: ['cut', 'trim', 'clip'] },
            { token: 'ph-floppy-disk', label: 'Floppy Disk', keywords: ['save', 'store', 'disk'] },
            { token: 'ph-download', label: 'Download', keywords: ['save', 'export', 'get'] },
            { token: 'ph-upload', label: 'Upload', keywords: ['import', 'add', 'send'] },
            { token: 'ph-export', label: 'Export', keywords: ['download', 'save', 'output'] },
            { token: 'ph-share', label: 'Share', keywords: ['send', 'distribute', 'forward'] },
            { token: 'ph-share-network', label: 'Share Network', keywords: ['social', 'distribute', 'connect'] },

            // Navigation
            { token: 'ph-arrow-left', label: 'Arrow Left', keywords: ['back', 'previous', 'return'] },
            { token: 'ph-arrow-right', label: 'Arrow Right', keywords: ['forward', 'next', 'continue'] },
            { token: 'ph-arrow-up', label: 'Arrow Up', keywords: ['top', 'scroll', 'increase'] },
            { token: 'ph-arrow-down', label: 'Arrow Down', keywords: ['bottom', 'scroll', 'decrease'] },
            { token: 'ph-caret-left', label: 'Caret Left', keywords: ['previous', 'back', 'nav'] },
            { token: 'ph-caret-right', label: 'Caret Right', keywords: ['next', 'forward', 'nav'] },
            { token: 'ph-caret-up', label: 'Caret Up', keywords: ['expand', 'show', 'nav'] },
            { token: 'ph-caret-down', label: 'Caret Down', keywords: ['dropdown', 'expand', 'nav'] },
            { token: 'ph-house', label: 'House', keywords: ['home', 'main', 'start'] },
            { token: 'ph-house-line', label: 'House Line', keywords: ['overview', 'landing', 'summary', 'home'] },
            { token: 'ph-compass', label: 'Compass', keywords: ['navigation', 'explore', 'direction'] },
            { token: 'ph-map-pin', label: 'Map Pin', keywords: ['location', 'marker', 'place'] },
            { token: 'ph-map-trifold', label: 'Map Trifold', keywords: ['location', 'routes', 'navigation', 'geography'] },
            { token: 'ph-navigation-arrow', label: 'Navigation Arrow', keywords: ['direction', 'gps', 'location'] },

            // Search & View
            { token: 'ph-magnifying-glass', label: 'Search', keywords: ['find', 'search', 'look'] },
            { token: 'ph-magnifying-glass-plus', label: 'Zoom In', keywords: ['enlarge', 'magnify', 'expand'] },
            { token: 'ph-magnifying-glass-minus', label: 'Zoom Out', keywords: ['reduce', 'shrink', 'minimize'] },
            { token: 'ph-eye', label: 'Eye', keywords: ['view', 'see', 'preview'] },
            { token: 'ph-eye-closed', label: 'Eye Closed', keywords: ['hide', 'hidden', 'invisible'] },
            { token: 'ph-eye-slash', label: 'Eye Slash', keywords: ['hide', 'hidden', 'invisible'] },
            { token: 'ph-binoculars', label: 'Binoculars', keywords: ['search', 'find', 'explore'] },
            { token: 'ph-funnel', label: 'Funnel', keywords: ['filter', 'sort', 'refine'] },
            { token: 'ph-funnel-simple', label: 'Funnel Simple', keywords: ['filter', 'sort', 'refine'] },
            { token: 'ph-sliders', label: 'Sliders', keywords: ['settings', 'adjust', 'control'] },
            { token: 'ph-sliders-horizontal', label: 'Sliders Horizontal', keywords: ['settings', 'adjust', 'filter'] },
            { token: 'ph-adjustments', label: 'Adjustments', keywords: ['settings', 'controls', 'tune'] },

            // Business & Work
            { token: 'ph-briefcase', label: 'Briefcase', keywords: ['portfolio', 'business', 'clients', 'work'] },
            { token: 'ph-suitcase', label: 'Suitcase', keywords: ['travel', 'business', 'luggage'] },
            { token: 'ph-bank', label: 'Bank', keywords: ['finance', 'money', 'institution'] },
            { token: 'ph-buildings', label: 'Buildings', keywords: ['city', 'office', 'company'] },
            { token: 'ph-storefront', label: 'Storefront', keywords: ['shop', 'store', 'retail'] },
            { token: 'ph-shopping-bag', label: 'Shopping Bag', keywords: ['purchase', 'buy', 'retail'] },
            { token: 'ph-shopping-cart', label: 'Shopping Cart', keywords: ['sales', 'store', 'orders', 'ecommerce'] },
            { token: 'ph-shopping-cart-simple', label: 'Cart Simple', keywords: ['purchase', 'buy', 'shop'] },
            { token: 'ph-currency-dollar', label: 'Dollar', keywords: ['money', 'price', 'payment'] },
            { token: 'ph-money', label: 'Money', keywords: ['cash', 'payment', 'finance'] },
            { token: 'ph-credit-card', label: 'Credit Card', keywords: ['payment', 'transaction', 'purchase'] },
            { token: 'ph-coin', label: 'Coin', keywords: ['money', 'currency', 'payment'] },
            { token: 'ph-receipt', label: 'Receipt', keywords: ['invoice', 'payment', 'transaction'] },
            { token: 'ph-invoice', label: 'Invoice', keywords: ['bill', 'payment', 'receipt'] },
            { token: 'ph-wallet', label: 'Wallet', keywords: ['money', 'payment', 'finance'] },

            // Analytics & Data
            { token: 'ph-chart-line', label: 'Chart Line', keywords: ['metrics', 'reporting', 'dash', 'analytics', 'graph'] },
            { token: 'ph-chart-bar', label: 'Chart Bar', keywords: ['graph', 'statistics', 'data'] },
            { token: 'ph-chart-bar-horizontal', label: 'Chart Bar Horizontal', keywords: ['graph', 'statistics', 'data'] },
            { token: 'ph-chart-pie', label: 'Chart Pie', keywords: ['graph', 'statistics', 'distribution'] },
            { token: 'ph-chart-pie-slice', label: 'Chart Pie Slice', keywords: ['graph', 'statistics', 'portion'] },
            { token: 'ph-chart-line-up', label: 'Chart Line Up', keywords: ['growth', 'increase', 'trending'] },
            { token: 'ph-chart-line-down', label: 'Chart Line Down', keywords: ['decrease', 'decline', 'trending'] },
            { token: 'ph-trend-up', label: 'Trend Up', keywords: ['growth', 'increase', 'positive'] },
            { token: 'ph-trend-down', label: 'Trend Down', keywords: ['decrease', 'decline', 'negative'] },
            { token: 'ph-presentation', label: 'Presentation', keywords: ['slides', 'meeting', 'report'] },
            { token: 'ph-presentation-chart', label: 'Presentation Chart', keywords: ['slides', 'analytics', 'report'] },

            // Tech & Development
            { token: 'ph-code', label: 'Code', keywords: ['development', 'programming', 'developer'] },
            { token: 'ph-terminal', label: 'Terminal', keywords: ['console', 'command', 'cli'] },
            { token: 'ph-terminal-window', label: 'Terminal Window', keywords: ['console', 'command', 'shell'] },
            { token: 'ph-brackets-curly', label: 'Brackets Curly', keywords: ['code', 'json', 'programming'] },
            { token: 'ph-bug', label: 'Bug', keywords: ['error', 'issue', 'debug'] },
            { token: 'ph-cpu', label: 'CPU', keywords: ['processor', 'hardware', 'computing'] },
            { token: 'ph-hard-drive', label: 'Hard Drive', keywords: ['storage', 'disk', 'data'] },
            { token: 'ph-database', label: 'Database', keywords: ['storage', 'records', 'warehouse', 'data'] },
            { token: 'ph-server', label: 'Server', keywords: ['database', 'hosting', 'backend'] },
            { token: 'ph-cloud', label: 'Cloud', keywords: ['sync', 'storage', 'backup', 'online'] },
            { token: 'ph-cloud-arrow-up', label: 'Cloud Upload', keywords: ['sync', 'upload', 'backup'] },
            { token: 'ph-cloud-arrow-down', label: 'Cloud Download', keywords: ['sync', 'download', 'retrieve'] },
            { token: 'ph-git-branch', label: 'Git Branch', keywords: ['version', 'control', 'code'] },
            { token: 'ph-git-commit', label: 'Git Commit', keywords: ['version', 'control', 'save'] },
            { token: 'ph-git-merge', label: 'Git Merge', keywords: ['version', 'control', 'combine'] },
            { token: 'ph-github-logo', label: 'GitHub', keywords: ['code', 'repository', 'git'] },

            // Security
            { token: 'ph-lock', label: 'Lock', keywords: ['security', 'private', 'secure'] },
            { token: 'ph-lock-key', label: 'Lock Key', keywords: ['permissions', 'security', 'access', 'roles'] },
            { token: 'ph-lock-open', label: 'Lock Open', keywords: ['unlock', 'access', 'open'] },
            { token: 'ph-key', label: 'Key', keywords: ['password', 'access', 'security'] },
            { token: 'ph-shield', label: 'Shield', keywords: ['security', 'protection', 'safety'] },
            { token: 'ph-shield-check', label: 'Shield Check', keywords: ['security', 'verified', 'protected'] },
            { token: 'ph-fingerprint', label: 'Fingerprint', keywords: ['biometric', 'security', 'identity'] },
            { token: 'ph-password', label: 'Password', keywords: ['security', 'login', 'access'] },

            // Media & Design
            { token: 'ph-image', label: 'Image', keywords: ['photo', 'picture', 'media'] },
            { token: 'ph-images', label: 'Images', keywords: ['photos', 'gallery', 'media'] },
            { token: 'ph-camera', label: 'Camera', keywords: ['photo', 'picture', 'capture'] },
            { token: 'ph-video-camera', label: 'Video Camera', keywords: ['recording', 'film', 'media'] },
            { token: 'ph-play', label: 'Play', keywords: ['video', 'start', 'media'] },
            { token: 'ph-pause', label: 'Pause', keywords: ['stop', 'media', 'video'] },
            { token: 'ph-film-strip', label: 'Film Strip', keywords: ['video', 'movie', 'cinema'] },
            { token: 'ph-music-notes', label: 'Music Notes', keywords: ['audio', 'sound', 'song'] },
            { token: 'ph-palette', label: 'Palette', keywords: ['color', 'design', 'art'] },
            { token: 'ph-paint-brush', label: 'Paint Brush', keywords: ['design', 'art', 'draw'] },
            { token: 'ph-paint-roller', label: 'Paint Roller', keywords: ['design', 'theme', 'style'] },
            { token: 'ph-eyedropper', label: 'Eyedropper', keywords: ['color', 'picker', 'design'] },

            // Symbols & Shapes
            { token: 'ph-star', label: 'Star', keywords: ['favorite', 'rating', 'important'] },
            { token: 'ph-heart', label: 'Heart', keywords: ['like', 'favorite', 'love'] },
            { token: 'ph-flag', label: 'Flag', keywords: ['marker', 'important', 'report'] },
            { token: 'ph-bookmark', label: 'Bookmark', keywords: ['save', 'favorite', 'mark'] },
            { token: 'ph-bookmark-simple', label: 'Bookmark Simple', keywords: ['save', 'favorite', 'mark'] },
            { token: 'ph-tag', label: 'Tag', keywords: ['labels', 'categories', 'taxonomy', 'label'] },
            { token: 'ph-hash', label: 'Hash', keywords: ['hashtag', 'number', 'tag'] },
            { token: 'ph-at', label: 'At', keywords: ['mention', 'email', 'address'] },
            { token: 'ph-info', label: 'Info', keywords: ['information', 'help', 'about'] },
            { token: 'ph-question', label: 'Question', keywords: ['help', 'faq', 'support'] },
            { token: 'ph-warning', label: 'Warning', keywords: ['alert', 'caution', 'danger'] },
            { token: 'ph-warning-circle', label: 'Warning Circle', keywords: ['alert', 'caution', 'error'] },
            { token: 'ph-prohibit', label: 'Prohibit', keywords: ['blocked', 'forbidden', 'no'] },
            { token: 'ph-circle', label: 'Circle', keywords: ['shape', 'dot', 'round'] },
            { token: 'ph-square', label: 'Square', keywords: ['shape', 'box', 'rectangle'] },
            { token: 'ph-triangle', label: 'Triangle', keywords: ['shape', 'arrow', 'pointer'] },
            { token: 'ph-diamond', label: 'Diamond', keywords: ['shape', 'gem', 'special'] },

            // Actions & Ideas
            { token: 'ph-rocket', label: 'Rocket', keywords: ['project', 'ship', 'release', 'launch'] },
            { token: 'ph-rocket-launch', label: 'Rocket Launch', keywords: ['start', 'deploy', 'begin'] },
            { token: 'ph-lightbulb', label: 'Lightbulb', keywords: ['brainstorm', 'concepts', 'innovation', 'ideas'] },
            { token: 'ph-target', label: 'Target', keywords: ['goal', 'objective', 'aim'] },
            { token: 'ph-trophy', label: 'Trophy', keywords: ['achievement', 'success', 'award'] },
            { token: 'ph-medal', label: 'Medal', keywords: ['award', 'achievement', 'winner'] },
            { token: 'ph-gift', label: 'Gift', keywords: ['present', 'reward', 'bonus'] },
            { token: 'ph-crown', label: 'Crown', keywords: ['premium', 'vip', 'royal'] },
            { token: 'ph-magic-wand', label: 'Magic Wand', keywords: ['auto', 'ai', 'magic'] },
            { token: 'ph-sparkle', label: 'Sparkle', keywords: ['new', 'special', 'shine'] },
            { token: 'ph-lightning', label: 'Lightning', keywords: ['fast', 'quick', 'speed'] },
            { token: 'ph-fire', label: 'Fire', keywords: ['hot', 'trending', 'popular'] },

            // Connectivity & Links
            { token: 'ph-link', label: 'Link', keywords: ['url', 'connection', 'attach'] },
            { token: 'ph-link-simple', label: 'Link Simple', keywords: ['connection', 'attach', 'url', 'hyperlink'] },
            { token: 'ph-link-break', label: 'Link Break', keywords: ['unlink', 'disconnect', 'remove'] },
            { token: 'ph-paperclip', label: 'Paperclip', keywords: ['attach', 'file', 'attachment'] },
            { token: 'ph-anchor', label: 'Anchor', keywords: ['link', 'fixed', 'permanent'] },
            { token: 'ph-wireless', label: 'Wireless', keywords: ['wifi', 'connection', 'network'] },
            { token: 'ph-wifi-high', label: 'WiFi High', keywords: ['wireless', 'connection', 'network'] },
            { token: 'ph-globe', label: 'Globe', keywords: ['world', 'internet', 'global'] },
            { token: 'ph-globe-hemisphere-west', label: 'Globe West', keywords: ['world', 'map', 'earth'] },

            // Settings & Configuration
            { token: 'ph-gear', label: 'Gear', keywords: ['settings', 'configuration', 'options'] },
            { token: 'ph-gear-six', label: 'Gear Six', keywords: ['settings', 'config', 'preferences'] },
            { token: 'ph-wrench', label: 'Wrench', keywords: ['tools', 'fix', 'maintenance'] },
            { token: 'ph-nut', label: 'Nut', keywords: ['settings', 'configuration', 'hardware'] },
            { token: 'ph-faders', label: 'Faders', keywords: ['settings', 'adjust', 'mixer'] },
            { token: 'ph-toggle-left', label: 'Toggle Left', keywords: ['switch', 'off', 'disable'] },
            { token: 'ph-toggle-right', label: 'Toggle Right', keywords: ['switch', 'on', 'enable'] },

            // Miscellaneous
            { token: 'ph-smiley', label: 'Smiley', keywords: ['emoji', 'happy', 'face'] },
            { token: 'ph-package', label: 'Package', keywords: ['box', 'delivery', 'product'] },
            { token: 'ph-cube', label: 'Cube', keywords: ['3d', 'box', 'object'] },
            { token: 'ph-puzzle-piece', label: 'Puzzle Piece', keywords: ['plugin', 'extension', 'addon'] },
            { token: 'ph-tree', label: 'Tree', keywords: ['nature', 'hierarchy', 'branch'] },
            { token: 'ph-plant', label: 'Plant', keywords: ['nature', 'growing', 'organic'] }
        ];

        function renderIcon(icon) {
            if (!icon) return '';
            const trimmed = icon.toString().trim();
            if (trimmed.startsWith('<')) return trimmed;
            if (trimmed.startsWith('ph ')) return `<i class="${trimmed}"></i>`;
            if (trimmed.startsWith('ph-')) return `<i class="ph ${trimmed}"></i>`;
            return trimmed;
        }

        function extractIconToken(icon) {
            if (!icon) return '';
            const trimmed = icon.toString().trim();
            const match = trimmed.match(/ph-[\w-]+/);
            if (match) return match[0];
            return trimmed;
        }

        function buildIconSearchText(option) {
            const keywords = (option.keywords || []).join(' ');
            return `${option.label} ${option.token} ${keywords}`.toLowerCase();
        }

        function fuzzyScore(query, text) {
            const normalizedQuery = (query || '').trim().toLowerCase();
            if (!normalizedQuery) return 1;
            const normalizedText = text.toLowerCase();
            const parts = normalizedQuery.split(/\s+/).filter(Boolean);

            let score = 0;
            parts.forEach(part => {
                if (normalizedText.includes(part)) {
                    score += 2;
                    return;
                }

                let lastIndex = -1;
                let subsequenceScore = 0;
                for (const char of part) {
                    const idx = normalizedText.indexOf(char, lastIndex + 1);
                    if (idx === -1) { subsequenceScore = 0; break; }
                    const distance = lastIndex === -1 ? 0 : idx - lastIndex - 1;
                    subsequenceScore += Math.max(0.1, 1 - distance * 0.08);
                    lastIndex = idx;
                }
                if (subsequenceScore > 0) {
                    const proximityBoost = Math.min(0.5, part.length / 12);
                    score += (subsequenceScore / part.length) + proximityBoost;
                }
            });

            return score / parts.length;
        }

        function findIconMeta(token) {
            const clean = extractIconToken(token);
            return ICON_OPTIONS.find(opt => opt.token === clean);
        }

        const ICON_SELECTOR_TARGETS = {
            newSetIcon: { selectorId: 'newSetIconSelector', previewId: 'newSetIconPreview', tokenId: 'newSetIconToken' },
            newViewIcon: { selectorId: 'newViewIconSelector', previewId: 'newViewIconPreview', tokenId: 'newViewIconToken' }
        };

        function syncIconSelector(inputId) {
            const config = ICON_SELECTOR_TARGETS[inputId];
            const input = document.getElementById(inputId);
            if (!config || !input) return;
            const token = extractIconToken(input.value || '');
            const meta = findIconMeta(token);
            const preview = document.getElementById(config.previewId);
            if (preview) preview.innerHTML = renderIcon(token || 'ph-squares-four');
            const tokenLabel = document.getElementById(config.tokenId);
            if (tokenLabel) tokenLabel.textContent = meta ? `${meta.label}  ${meta.token}` : (token || 'Select an icon');
        }

        function bindIconSelector(inputId) {
            const config = ICON_SELECTOR_TARGETS[inputId];
            if (!config) return;
            const selector = document.getElementById(config.selectorId);
            if (selector) {
                const trigger = () => openIconPicker(inputId);
                selector.onclick = trigger;
                selector.onkeydown = (event) => {
                    if (event.key === 'Enter' || event.key === ' ' || event.key === 'Spacebar') {
                        event.preventDefault();
                        trigger();
                    }
                };
            }
            const input = document.getElementById(inputId);
            if (input) input.addEventListener('change', () => syncIconSelector(inputId));
            syncIconSelector(inputId);
        }

        function openIconPicker(targetInputId) {
            state.iconPickerTarget = targetInputId;
            state.iconPickerQuery = '';
            const searchInput = document.getElementById('iconPickerSearch');
            if (searchInput) {
                searchInput.value = '';
                setTimeout(() => searchInput.focus(), 50);
            }
            renderIconPickerOptions();
            openModal('iconPickerModal');
        }

        function renderIconPickerOptions() {
            const container = document.getElementById('iconPickerOptions');
            if (!container) return;
            const search = (state.iconPickerQuery || '').toLowerCase();
            const currentValue = state.iconPickerTarget ? extractIconToken(document.getElementById(state.iconPickerTarget)?.value || '') : '';

            container.innerHTML = '';

            const scored = ICON_OPTIONS
                .map(opt => ({ ...opt, score: fuzzyScore(search, buildIconSearchText(opt)) }))
                .filter(entry => entry.score > 0)
                .sort((a, b) => b.score - a.score);

            if (scored.length === 0) {
                container.innerHTML = '<p class="text-sm text-gray-500">No icons match your search. Try a related term like table or board.</p>';
                return;
            }

            scored.forEach(opt => {
                const btn = document.createElement('button');
                btn.type = 'button';
                btn.className = `icon-option${opt.token === currentValue ? ' active' : ''}`;
                btn.innerHTML = `
                    <span class="icon-chip">${renderIcon(opt.token)}</span>
                    <span class="icon-label">${opt.label}</span>
                `;
                btn.onclick = () => selectIconFromPicker(opt.token);
                container.appendChild(btn);
            });
        }

        function selectIconFromPicker(token) {
            if (state.iconPickerTarget) {
                const input = document.getElementById(state.iconPickerTarget);
                if (input) {
                    input.value = token;
                    input.dispatchEvent(new Event('change'));
                }
            }
            closeModal('iconPickerModal');
        }

        const EO_OPERATOR_SET = {
            INS: { id: 'INS', name: 'Instantiate', description: 'Create a new object that did not exist before.' },
            DES: { id: 'DES', name: 'Designate', description: 'Assign a name, ID, label, alias, or classification.' },
            SEG: { id: 'SEG', name: 'Segment', description: 'Change boundaries, structure, or partition membership.' },
            CON: { id: 'CON', name: 'Connect', description: 'Create or remove a connection between objects.' },
            ALT: { id: 'ALT', name: 'Alternate', description: 'Toggle or switch between mutually exclusive states.' },
            SYN: { id: 'SYN', name: 'Synthesize', description: 'Combine two or more objects into a new unified whole.' },
            SUP: { id: 'SUP', name: 'Superposition', description: 'Hold contradictory states as simultaneously true without resolving them.' },
            REC: { id: 'REC', name: 'Recurse', description: 'Introduce a new layer of logic, rules, or self-reference.' },
            NUL: { id: 'NUL', name: 'Nullify', description: 'Declare absence, deletion, or erasure.' }
        };

        // INITIALIZATION
        function initializeApp() {
            state.operatorSet = EO_OPERATOR_SET;
            initializeOperatorRules();
            createSampleData();
            initializeFormulaSupport();
            renderSidebar();
            if (state.currentSetId) switchSet(state.currentSetId, state.currentViewId);
            setupEventListeners();
            setupKeyboardShortcuts();
            applyResponsiveLayout();
            window.addEventListener('resize', applyResponsiveLayout);
        }

        function applyResponsiveLayout() {
            const appContainer = document.getElementById('appContainer');
            const isMobile = window.matchMedia('(max-width: 1024px)').matches;

            if (isMobile) {
                appContainer.classList.add('mobile-layout');
                appContainer.classList.toggle('sidebar-open-mobile', state.sidebarOpenMobile);
                appContainer.classList.remove('sidebar-collapsed');
            } else {
                appContainer.classList.remove('mobile-layout');
                appContainer.classList.remove('sidebar-open-mobile');
                appContainer.classList.toggle('sidebar-collapsed', state.sidebarCollapsed);
            }
        }

        function initializeOperatorRules() {
            const defaultRules = [
                {
                    rule_id: 'rule_ins_requires_object',
                    applies_to_op: 'INS',
                    description: 'Instantiation must target an identifiable object.',
                    effect: 'require_object_id'
                },
                {
                    rule_id: 'rule_events_require_actor',
                    description: 'All events must be attributable to an actor.',
                    effect: 'require_actor'
                },
                {
                    rule_id: 'rule_con_requires_object',
                    applies_to_op: 'CON',
                    description: 'Connections must reference a concrete edge object.',
                    effect: 'require_object_id'
                },
                {
                    rule_id: 'rule_con_requires_endpoints',
                    applies_to_op: 'CON',
                    description: 'Connections must include both source and target references.',
                    effect: 'require_connection_endpoints'
                },
                {
                    rule_id: 'rule_nullify_marks_deleted',
                    applies_to_op: 'NUL',
                    description: 'Nullify operations explicitly mark the object as deleted in the payload.',
                    effect: 'mark_deleted'
                }
            ];

            defaultRules.forEach(rule => registerInterpretationRule(rule, { skipEvent: true }));
        }

        function createSampleData() {
            const projectsId = createSet('Projects', 'ph-kanban');
            const projectsSet = state.sets.get(projectsId);

            const contactsId = createSet('Clients', 'ph-users-three');
            const contactsSet = state.sets.get(contactsId);

            contactsSet.schema = [
                { id: 'name', name: 'Client Name', type: 'TEXT', width: '200px' },
                { id: 'industry', name: 'Industry', type: 'SINGLE_SELECT', width: '140px', config: {
                    options: ['Technology', 'Retail', 'Finance', 'Healthcare'],
                    colors: { 'Technology': 'blue', 'Retail': 'purple', 'Finance': 'green', 'Healthcare': 'yellow' }
                }},
                { id: 'website', name: 'Website', type: 'URL', width: '200px' }
            ];

            contactsSet.profiles = new Map([
                ['default', { id: 'default', name: 'All Fields', visibleFields: [] }]
            ]);

            const acmeId = addRecord(contactsId, { name: 'Acme Corp', industry: 'Technology', website: 'https://acme.example.com' });
            const harborId = addRecord(contactsId, { name: 'Harbor Retail', industry: 'Retail', website: 'https://harborretail.example.com' });
            const northbankId = addRecord(contactsId, { name: 'Northbank Finance', industry: 'Finance', website: 'https://northbank.example.com' });

            createView(contactsId, 'All Clients', { type: 'grid' });

            projectsSet.schema = [
                { id: 'name', name: 'Project Name', type: 'TEXT', width: '200px' },
                { id: 'client', name: 'Client', type: 'LINK_RECORD', width: '180px', config: { linkedSetId: contactsId } },
                { id: 'status', name: 'Status', type: 'SINGLE_SELECT', width: '130px', config: {
                    options: ['Planning', 'In Progress', 'On Hold', 'Completed'],
                    colors: { 'Planning': 'gray', 'In Progress': 'blue', 'On Hold': 'yellow', 'Completed': 'green' }
                }},
                { id: 'budget', name: 'Budget', type: 'CURRENCY', width: '120px' },
                { id: 'start_date', name: 'Start Date', type: 'DATE', width: '120px' },
                { id: 'priority', name: 'Priority', type: 'SINGLE_SELECT', width: '100px', config: {
                    options: ['Low', 'Medium', 'High', 'Critical'],
                    colors: { 'Low': 'gray', 'Medium': 'blue', 'High': 'yellow', 'Critical': 'red' }
                }},
                { id: 'notes', name: 'Notes', type: 'LONG_TEXT', width: '300px' }
            ];

            projectsSet.profiles = new Map([
                ['default', { id: 'default', name: 'All Fields', visibleFields: [] }]
            ]);

            addRecord(projectsId, {
                name: 'Website Redesign',
                client: acmeId,
                status: 'In Progress',
                budget: 50000,
                start_date: '2024-01-15',
                priority: 'High',
                notes: 'Complete overhaul of company website'
            });

            addRecord(projectsId, {
                name: 'Mobile App',
                client: harborId,
                status: 'Planning',
                budget: 120000,
                start_date: '2024-06-01',
                priority: 'Critical',
                notes: 'iOS and Android native apps'
            });

            addRecord(projectsId, {
                name: 'Database Migration',
                client: northbankId,
                status: 'Completed',
                budget: 30000,
                start_date: '2023-11-01',
                priority: 'High',
                notes: 'Migrate to new cloud infrastructure'
            });

            createView(projectsId, 'All Projects', { type: 'grid' });
            createView(projectsId, 'By Status', { type: 'kanban' });
            createView(projectsId, 'Card View', { type: 'card' });

            state.currentSetId = projectsId;
            state.currentViewId = Array.from(projectsSet.views.keys())[0];
            state.expandedSets.add(projectsId);
        }

        // SET MANAGEMENT
        function createSet(name, icon = 'ph-squares-four') {
            const setId = 'set_' + Date.now();
            state.sets.set(setId, {
                id: setId,
                name: name,
                icon: icon,
                schema: [],
                records: new Map(),
                views: new Map(),
                profiles: new Map([['default', { id: 'default', name: 'All Fields', visibleFields: [] }]])
            });
            createEvent(
                'Create Set',
                'INS',
                { type: 'Set', id: setId },
                { name },
                { summary: `Created set "${name}"`, scale: 'collection' }
            );
            return setId;
        }

        function createView(setId, name, config = {}) {
            const viewId = 'view_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            const set = state.sets.get(setId);
            set.views.set(viewId, {
                id: viewId,
                name: name,
                type: config.type || 'grid',
                icon: config.icon || VIEW_TYPE_ICONS[config.type || 'grid'] || '',
                filters: config.filters || [],
                sorts: config.sorts || [],
                hiddenFields: config.hiddenFields || [],
                popupVisibilityRules: config.popupVisibilityRules || [],
                kanbanGroupField: config.kanbanGroupField || null,
                cardFields: config.cardFields || [],
                parentId: config.parentId || null
            });
            return viewId;
        }

        function addRecord(setId, data) {
            const set = state.sets.get(setId);
            const recordId = 'rec_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            const record = { id: recordId, ...data };
            set.records.set(recordId, record);
            createEvent(
                'Create Record',
                'INS',
                { type: 'Record', id: recordId, setId },
                { setId, recordId, data, summary: 'Created record' }
            );
            recomputeFormulasForSet(set);
            return recordId;
        }

        function getRecordById(recordId) {
            for (const [setId, set] of state.sets.entries()) {
                if (set.records.has(recordId)) {
                    return { setId, set, record: set.records.get(recordId) };
                }
            }
            return null;
        }

        function getLinkedSet(field) {
            const linkedSetId = field?.config?.linkedSetId;
            if (!linkedSetId) return null;
            return state.sets.get(linkedSetId) || null;
        }

        function getLinkedRecordOptions(field) {
            const linkedSet = getLinkedSet(field);
            return linkedSet ? Array.from(linkedSet.records.values()) : [];
        }

        function createLinkedRecordOptionList(field) {
            const options = getLinkedRecordOptions(field);
            return options.map(opt => ({
                id: opt.id,
                label: opt.name || getRecordDisplayName(opt.id) || opt.id
            }));
        }

        // CSV IMPORT & FUZZY MATCHING
        const CREATE_FIELD_PREFIX = '__create__';
        const CSV_FIELD_MATCH_THRESHOLD = 0.75;

        function slugifyFieldId(name) {
            return (name || '').toLowerCase()
                .replace(/[^a-z0-9]/g, '_')
                .replace(/_+/g, '_')
                .replace(/^_+|_+$/g, '') || 'field';
        }

        function isCreateFieldValue(value) {
            return typeof value === 'string' && value.startsWith(CREATE_FIELD_PREFIX);
        }

        function buildCreateFieldValue(header) {
            return `${CREATE_FIELD_PREFIX}${slugifyFieldId(header)}`;
        }

        function findBestFieldMatch(header, schema) {
            const target = (header || '').trim();
            let best = null;
            schema.forEach(field => {
                const score = Math.max(
                    similarityScore(target, field.name),
                    similarityScore(target, field.id)
                );
                if (!best || score > best.score) {
                    best = { field, score };
                }
            });
            return best;
        }

        function resetCsvImportState() {
            state.csvImportState = { headers: [], rows: [], mappings: {}, previewRows: [], matches: [] };
            const badge = document.getElementById('csvRowCountBadge');
            if (badge) badge.textContent = '0 rows';
            const mappingEl = document.getElementById('csvMappingContainer');
            if (mappingEl) mappingEl.innerHTML = '<p class="text-sm text-gray-500">Load a CSV file or paste CSV text to start mapping.</p>';
            const previewEl = document.getElementById('csvPreviewContainer');
            if (previewEl) previewEl.innerHTML = '<p class="text-sm text-gray-500">Preview will appear after parsing.</p>';
            const matchesEl = document.getElementById('csvMatchSuggestions');
            if (matchesEl) matchesEl.innerHTML = '<p class="text-sm text-gray-500">No suggestions yet.</p>';
            const textInput = document.getElementById('csvTextInput');
            if (textInput) textInput.value = '';
            const fileInput = document.getElementById('csvFileInput');
            if (fileInput) fileInput.value = '';
        }

        function openCsvImportModal() {
            resetCsvImportState();
            openModal('csvImportModal');
        }

        function handleCsvFileSelected(event) {
            const file = event.target.files?.[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                const { headers, rows } = parseCsvContent(e.target.result || '');
                handleCsvData(headers, rows);
            };
            reader.readAsText(file);
        }

        function previewCsvFromText() {
            const text = document.getElementById('csvTextInput')?.value || '';
            const { headers, rows } = parseCsvContent(text);
            handleCsvData(headers, rows);
        }

        function parseCsvContent(text) {
            if (!text || !text.trim()) return { headers: [], rows: [] };
            const rows = [];
            let current = '';
            let inQuotes = false;
            const result = [];
            for (let i = 0; i < text.length; i++) {
                const char = text[i];
                const nextChar = text[i + 1];
                if (char === '"') {
                    if (inQuotes && nextChar === '"') {
                        current += '"';
                        i++;
                    } else {
                        inQuotes = !inQuotes;
                    }
                } else if (char === ',' && !inQuotes) {
                    rowPush(current);
                } else if ((char === '\n' || char === '\r') && !inQuotes) {
                    rowPush(current);
                    if (result.length) rows.push(result.splice(0));
                } else {
                    current += char;
                }
            }
            rowPush(current);
            if (result.length) rows.push(result);

            function rowPush(value) {
                result.push(value.trim());
                current = '';
            }

            const headers = rows.shift() || [];
            const normalizedRows = rows.filter(r => r.length && r.some(cell => cell !== '')).map(r => {
                const obj = {};
                headers.forEach((h, idx) => obj[h] = r[idx] || '');
                return obj;
            });
            return { headers, rows: normalizedRows };
        }

        function autoMapColumns(headers, set) {
            const mappings = {};
            headers.forEach(h => {
                const match = findBestFieldMatch(h, set.schema);
                if (match && match.score >= CSV_FIELD_MATCH_THRESHOLD) {
                    mappings[h] = match.field.id;
                } else {
                    mappings[h] = buildCreateFieldValue(h);
                }
            });
            return mappings;
        }

        function handleCsvData(headers, rows) {
            const set = getCurrentSet();
            if (!set) return;
            state.csvImportState.headers = headers;
            state.csvImportState.rows = rows;
            state.csvImportState.mappings = autoMapColumns(headers, set);
            const badge = document.getElementById('csvRowCountBadge');
            if (badge) badge.textContent = `${rows.length} rows`;
            renderCsvMapping();
            renderCsvPreview();
            renderCsvMatches();
        }

        function renderCsvMapping() {
            const container = document.getElementById('csvMappingContainer');
            const set = getCurrentSet();
            if (!container || !set) return;
            if (!state.csvImportState.headers.length) {
                container.innerHTML = '<p class="text-sm text-gray-500">No headers detected yet.</p>';
                return;
            }

            container.innerHTML = state.csvImportState.headers.map(header => {
                const mappedField = state.csvImportState.mappings[header] || '';
                const createValue = buildCreateFieldValue(header);
                const options = ['<option value="">Skip</option>']
                    .concat(`<option value="${createValue}" ${mappedField === createValue ? 'selected' : ''}> Create new field: "${header}"</option>`)
                    .concat(set.schema.map(f => `<option value="${f.id}" ${mappedField === f.id ? 'selected' : ''}>${f.name}</option>`))
                    .join('');
                return `
                    <div class="flex items-center gap-3">
                        <div class="w-1/3 font-medium">${header}</div>
                        <div class="flex-1">
                            <select data-csv-header="${header}" class="flex-1">${options}</select>
                            ${isCreateFieldValue(mappedField) ? `<p class="text-xs text-amber-600 mt-1">Will create a new text field named "${header}"</p>` : ''}
                        </div>
                    </div>
                `;
            }).join('');

            container.querySelectorAll('select').forEach(select => {
                select.onchange = (event) => {
                    const header = event.target.dataset.csvHeader;
                    state.csvImportState.mappings[header] = event.target.value;
                    renderCsvPreview();
                    renderCsvMatches();
                };
            });
        }

        function buildCsvPreviewRows(limit = 5) {
            const set = getCurrentSet();
            if (!set) return [];
            const mappedHeaders = state.csvImportState.headers
                .map(header => [header, state.csvImportState.mappings[header]])
                .filter(([, fieldId]) => fieldId);
            return state.csvImportState.rows.slice(0, limit).map(row => {
                const preview = { __original: row };
                mappedHeaders.forEach(([header, fieldId]) => {
                    const field = set.schema.find(f => f.id === fieldId);
                    let value = row[header] || '';
                    if (['NUMBER', 'CURRENCY'].includes(field?.type)) {
                        const numeric = parseFloat(value);
                        value = isNaN(numeric) ? '' : numeric;
                    }
                    preview[fieldId] = value;
                });
                return preview;
            });
        }

        function renderCsvPreview() {
            const container = document.getElementById('csvPreviewContainer');
            const set = getCurrentSet();
            if (!container || !set) return;
            const mappedEntries = state.csvImportState.headers
                .map(header => [header, state.csvImportState.mappings[header]])
                .filter(([, fieldId]) => fieldId);
            if (!mappedEntries.length || !state.csvImportState.rows.length) {
                container.innerHTML = '<p class="text-sm text-gray-500">Map at least one column to preview records.</p>';
                return;
            }

            const previewRows = buildCsvPreviewRows();
            state.csvImportState.previewRows = previewRows;
            const headerCells = mappedEntries.map(([header, fieldId]) => {
                const field = set.schema.find(f => f.id === fieldId);
                const label = field?.name || header;
                const badge = field ? '' : '<span class="ml-2 text-xs font-semibold text-amber-600">(creates field)</span>';
                return `<th>${label}${badge}</th>`;
            }).join('');

            const bodyRows = previewRows.map(row => {
                const cells = mappedEntries.map(([, fieldId]) => `<td>${row[fieldId] ?? ''}</td>`).join('');
                return `<tr>${cells}</tr>`;
            }).join('');

            container.innerHTML = `
                <table class="csv-preview-table">
                    <thead><tr>${headerCells}</tr></thead>
                    <tbody>${bodyRows}</tbody>
                </table>
            `;
        }

        function similarityScore(a, b) {
            const s1 = (a || '').toString().trim().toLowerCase();
            const s2 = (b || '').toString().trim().toLowerCase();
            if (!s1 || !s2) return 0;
            const distance = levenshteinDistance(s1, s2);
            return 1 - (distance / Math.max(s1.length, s2.length));
        }

        function levenshteinDistance(a, b) {
            const matrix = Array.from({ length: b.length + 1 }, () => []);
            for (let i = 0; i <= b.length; i++) matrix[i][0] = i;
            for (let j = 0; j <= a.length; j++) matrix[0][j] = j;
            for (let i = 1; i <= b.length; i++) {
                for (let j = 1; j <= a.length; j++) {
                    if (b.charAt(i - 1) === a.charAt(j - 1)) {
                        matrix[i][j] = matrix[i - 1][j - 1];
                    } else {
                        matrix[i][j] = Math.min(
                            matrix[i - 1][j - 1] + 1,
                            matrix[i][j - 1] + 1,
                            matrix[i - 1][j] + 1
                        );
                    }
                }
            }
            return matrix[b.length][a.length];
        }

        function resolvePrimaryFieldFromMappings(set) {
            const nameField = Object.entries(state.csvImportState.mappings).find(([, fieldId]) => fieldId === 'name');
            if (nameField) return nameField[1];
            const textFields = set.schema.filter(f => ['TEXT', 'LONG_TEXT'].includes(f.type));
            const mappedTextField = Object.entries(state.csvImportState.mappings)
                .map(([, fieldId]) => set.schema.find(f => f.id === fieldId))
                .find(f => f && ['TEXT', 'LONG_TEXT'].includes(f.type));
            return mappedTextField?.id || textFields[0]?.id || set.schema[0]?.id;
        }

        function renderCsvMatches() {
            const container = document.getElementById('csvMatchSuggestions');
            const set = getCurrentSet();
            if (!container || !set) return;
            if (!state.csvImportState.rows.length) {
                container.innerHTML = '<p class="text-sm text-gray-500">Load rows to see suggestions.</p>';
                return;
            }

            const keyFieldId = resolvePrimaryFieldFromMappings(set);
            if (!keyFieldId) {
                container.innerHTML = '<p class="text-sm text-gray-500">Map at least one text column to find duplicates.</p>';
                return;
            }

            const existing = Array.from(set.records.values());
            const matches = [];
            state.csvImportState.rows.forEach(row => {
                const mappedValue = Object.entries(state.csvImportState.mappings).find(([, fieldId]) => fieldId === keyFieldId);
                const candidateValue = mappedValue ? row[mappedValue[0]] : '';
                let bestMatch = null;
                existing.forEach(rec => {
                    const score = similarityScore(candidateValue, rec[keyFieldId]);
                    if (score >= 0.6 && (!bestMatch || score > bestMatch.score)) {
                        bestMatch = { csvValue: candidateValue, record: rec, score };
                    }
                });
                if (bestMatch) matches.push(bestMatch);
            });

            state.csvImportState.matches = matches;
            if (!matches.length) {
                container.innerHTML = '<p class="text-sm text-gray-500">No close matches detected.</p>';
                return;
            }

            container.innerHTML = matches.slice(0, 10).map(match => `
                <div class="fuzzy-match-row">
                    <div class="flex-1">
                        <div class="text-sm text-gray-500">CSV Value</div>
                        <strong>${match.csvValue || '(blank)'}</strong>
                    </div>
                    <div class="flex-1">
                        <div class="text-sm text-gray-500">Existing Record</div>
                        <strong>${match.record.name || match.record.id}</strong>
                        <div class="text-xs text-gray-500">Score: <span class="fuzzy-score">${match.score.toFixed(2)}</span></div>
                    </div>
                </div>
            `).join('');
        }

        function importCsvRecords() {
            const set = getCurrentSet();
            if (!set) return;
            const mappedHeaders = Object.entries(state.csvImportState.mappings).filter(([, fieldId]) => fieldId);
            if (!mappedHeaders.length) {
                showToast(' Map at least one column');
                return;
            }
            if (!state.csvImportState.rows.length) {
                showToast(' No rows to import');
                return;
            }

            const existingFieldIds = new Set(set.schema.map(f => f.id));
            mappedHeaders
                .filter(([, fieldId]) => isCreateFieldValue(fieldId))
                .forEach(([header, fieldId]) => {
                    const suggestedId = fieldId.replace(CREATE_FIELD_PREFIX, '') || slugifyFieldId(header);
                    const fieldName = header?.trim() || 'New Field';
                    let uniqueId = suggestedId;
                    let counter = 1;
                    while (existingFieldIds.has(uniqueId)) {
                        uniqueId = `${suggestedId}_${counter++}`;
                    }

                    const newField = { id: uniqueId, name: fieldName, type: 'TEXT', width: '150px', config: {} };
                    set.schema.push(newField);
                    set.records.forEach(r => r[uniqueId] = FIELD_TYPES.TEXT.defaultValue);
                    existingFieldIds.add(uniqueId);
                    state.csvImportState.mappings[header] = uniqueId;
                });

            const finalizedMappings = Object.entries(state.csvImportState.mappings).filter(([, fieldId]) => fieldId);

            state.csvImportState.rows.forEach(row => {
                const recordData = {};
                finalizedMappings.forEach(([header, fieldId]) => {
                    const field = set.schema.find(f => f.id === fieldId);
                    let value = row[header];
                    if (['NUMBER', 'CURRENCY'].includes(field?.type)) {
                        const numeric = parseFloat(value);
                        value = isNaN(numeric) ? 0 : numeric;
                    }
                    recordData[fieldId] = value;
                });
                addRecord(set.id, recordData);
            });

            renderCurrentView();
            showToast(` Imported ${state.csvImportState.rows.length} records`);
            closeModal('csvImportModal');
        }

        function computeFuzzyMatchesForSet(set, threshold = state.fuzzyPanelState.threshold) {
            if (!set) return [];
            const candidates = Array.from(set.records.values());
            const textFields = set.schema.filter(f => ['TEXT', 'LONG_TEXT'].includes(f.type));
            const fieldId = textFields[0]?.id || set.schema[0]?.id;
            const matches = [];
            for (let i = 0; i < candidates.length; i++) {
                for (let j = i + 1; j < candidates.length; j++) {
                    const a = candidates[i];
                    const b = candidates[j];
                    const score = similarityScore(a[fieldId], b[fieldId]);
                    if (score >= threshold) {
                        matches.push({ a, b, score, fieldId });
                    }
                }
            }
            return matches.sort((x, y) => y.score - x.score).slice(0, 50);
        }

        function renderFuzzyPanel() {
            const container = document.getElementById('fuzzyMatchList');
            const thresholdInput = document.getElementById('fuzzyThresholdInput');
            if (!container || !thresholdInput) return;
            const set = getCurrentSet();
            if (!set) return;
            const threshold = parseFloat(thresholdInput.value) || state.fuzzyPanelState.threshold;
            state.fuzzyPanelState.threshold = threshold;
            const matches = computeFuzzyMatchesForSet(set, threshold);
            state.fuzzyPanelState.matches = matches;

            if (!matches.length) {
                container.innerHTML = '<p class="text-sm text-gray-500">No matches at this threshold.</p>';
                return;
            }

            container.innerHTML = matches.map(match => `
                <div class="fuzzy-match-row">
                    <div class="flex-1">
                        <div class="text-sm text-gray-500">Record A</div>
                        <strong>${match.a.name || match.a.id}</strong>
                    </div>
                    <div class="flex-1">
                        <div class="text-sm text-gray-500">Record B</div>
                        <strong>${match.b.name || match.b.id}</strong>
                        <div class="text-xs text-gray-500">Score: <span class="fuzzy-score">${match.score.toFixed(2)}</span></div>
                    </div>
                    <div class="flex items-center gap-2">
                        <button class="btn btn-secondary btn-sm" data-link="${match.a.id}|${match.b.id}" data-score="${match.score}">Link</button>
                        <button class="btn btn-secondary btn-sm" data-dismiss="${match.a.id}|${match.b.id}">Dismiss</button>
                    </div>
                </div>
            `).join('');

            container.querySelectorAll('[data-link]').forEach(btn => {
                btn.onclick = () => {
                    const [sourceId, targetId] = btn.dataset.link.split('|');
                    const score = parseFloat(btn.dataset.score || '0');
                    createConnection(sourceId, targetId, { reason: 'fuzzy-match', score });
                    showToast(' Linked records');
                };
            });

            container.querySelectorAll('[data-dismiss]').forEach(btn => {
                btn.onclick = () => {
                    btn.closest('.fuzzy-match-row').remove();
                };
            });
        }

        function openFuzzyPanel() {
            renderFuzzyPanel();
            document.getElementById('fuzzyMatchPanel').classList.add('open');
        }

        function closeFuzzyPanel() {
            document.getElementById('fuzzyMatchPanel').classList.remove('open');
        }

        function validateConnectionPayload(sourceId, targetId, metadata = {}) {
            if (!sourceId || !targetId) {
                throw new Error('Connections require both sourceId and targetId');
            }

            const sourceRef = getRecordById(sourceId);
            const targetRef = getRecordById(targetId);

            if (!sourceRef) throw new Error(`Source record ${sourceId} not found`);
            if (!targetRef) throw new Error(`Target record ${targetId} not found`);
            if (metadata === null || typeof metadata !== 'object' || Array.isArray(metadata)) {
                throw new Error('Connection metadata must be an object');
            }

            return { sourceRef, targetRef, metadata };
        }

        function createConnection(sourceId, targetId, metadata = {}) {
            const { sourceRef, targetRef, metadata: normalizedMetadata } = validateConnectionPayload(sourceId, targetId, metadata);
            const connectionId = `edge_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            const connection = {
                id: connectionId,
                sourceId,
                targetId,
                metadata: normalizedMetadata,
                createdAt: new Date().toISOString()
            };

            state.connections.set(connectionId, connection);

            const summary = `Connected ${sourceRef.record.name || sourceId}  ${targetRef.record.name || targetId}`;
            createEvent(
                'Create Connection',
                'CON',
                { type: 'Connection', id: connectionId },
                {
                    edge: connection,
                    sourceId,
                    targetId,
                    summary
                },
                { frame: 'graph', scale: 'relationship' }
            );

            return connectionId;
        }

        function updateConnection(connectionId, updates = {}) {
            const existing = state.connections.get(connectionId);
            if (!existing) throw new Error(`Connection ${connectionId} not found`);

            const nextSourceId = updates.sourceId || existing.sourceId;
            const nextTargetId = updates.targetId || existing.targetId;
            const hasMetadataUpdate = Object.prototype.hasOwnProperty.call(updates, 'metadata');
            const nextMetadata = hasMetadataUpdate ? updates.metadata : existing.metadata;
            const { sourceRef, targetRef, metadata: normalizedMetadata } = validateConnectionPayload(nextSourceId, nextTargetId, nextMetadata);

            const updated = {
                ...existing,
                sourceId: nextSourceId,
                targetId: nextTargetId,
                metadata: normalizedMetadata,
                updatedAt: new Date().toISOString()
            };

            const changes = {};
            if (existing.sourceId !== nextSourceId) changes.sourceId = { from: existing.sourceId, to: nextSourceId };
            if (existing.targetId !== nextTargetId) changes.targetId = { from: existing.targetId, to: nextTargetId };
            if (JSON.stringify(existing.metadata) !== JSON.stringify(normalizedMetadata)) changes.metadata = { from: existing.metadata, to: normalizedMetadata };

            state.connections.set(connectionId, updated);

            const summary = `Updated connection ${connectionId} (${sourceRef.record.name || nextSourceId}  ${targetRef.record.name || nextTargetId})`;
            createEvent(
                'Update Connection',
                'CON',
                { type: 'Connection', id: connectionId },
                {
                    edge: updated,
                    sourceId: nextSourceId,
                    targetId: nextTargetId,
                    changes: Object.keys(changes).length ? changes : undefined,
                    summary
                },
                { frame: 'graph', scale: 'relationship' }
            );

            return updated;
        }

        function deleteConnection(connectionId) {
            const existing = state.connections.get(connectionId);
            if (!existing) throw new Error(`Connection ${connectionId} not found`);

            const { sourceRef, targetRef } = validateConnectionPayload(existing.sourceId, existing.targetId, existing.metadata);
            state.connections.delete(connectionId);

            const summary = `Removed connection ${sourceRef.record.name || existing.sourceId}  ${targetRef.record.name || existing.targetId}`;
            createEvent(
                'Delete Connection',
                'CON',
                { type: 'Connection', id: connectionId },
                {
                    edge: existing,
                    sourceId: existing.sourceId,
                    targetId: existing.targetId,
                    summary,
                    deleted: true
                },
                { frame: 'graph', scale: 'relationship' }
            );

            return existing;
        }

        // SIDEBAR
        function toggleSidebar() {
            const isMobile = window.matchMedia('(max-width: 1024px)').matches;
            if (isMobile) {
                state.sidebarOpenMobile = !state.sidebarOpenMobile;
            } else {
                state.sidebarCollapsed = !state.sidebarCollapsed;
            }
            applyResponsiveLayout();
        }

        function closeMobileSidebar() {
            if (!state.sidebarOpenMobile) return;
            state.sidebarOpenMobile = false;
            applyResponsiveLayout();
        }

        function toggleSetExpansion(setId) {
            if (state.expandedSets.has(setId)) {
                state.expandedSets.delete(setId);
            } else {
                state.expandedSets.add(setId);
            }
            renderSidebar();
        }

        function renderSidebar() {
            const container = document.getElementById('setsList');
            container.innerHTML = '';

            state.sets.forEach((set, setId) => {
                const isExpanded = state.expandedSets.has(setId);
                const isActive = setId === state.currentSetId;

                const setItem = document.createElement('div');
                setItem.className = `set-item ${isExpanded ? 'expanded' : ''}`;

                const setHeader = document.createElement('div');
                setHeader.className = `set-header ${isActive && !state.currentViewId ? 'active' : ''}`;
                setHeader.innerHTML = `
                    <span class="set-icon">${renderIcon(set.icon)}</span>
                    <span class="set-name">${set.name}</span>
                    <span class="set-expand-icon"></span>
                `;
                setHeader.onclick = (e) => { if (e.detail === 1) toggleSetExpansion(setId); };
                setHeader.ondblclick = (e) => { e.stopPropagation(); openAddSetModal(setId); };
                setHeader.oncontextmenu = (e) => { e.preventDefault(); e.stopPropagation(); openAddSetModal(setId); };
                setItem.appendChild(setHeader);

                if (isExpanded) {
                    const viewsList = document.createElement('div');
                    viewsList.className = 'views-list';

                    const orderedViews = Array.from(set.views.entries());
                    renderViewTree(orderedViews, setId, viewsList);

                    const addViewBtn = document.createElement('div');
                    addViewBtn.className = 'add-view-btn';
                    addViewBtn.textContent = '+ Add View';
                    addViewBtn.onclick = (e) => {
                        e.stopPropagation();
                        state.currentSetId = setId;
                        openAddViewModal(setId);
                    };
                    viewsList.appendChild(addViewBtn);

                    setItem.appendChild(viewsList);
                }

                container.appendChild(setItem);
            });
        }

        function renderViewTree(orderedViews, setId, container, parentId = null, depth = 0) {
            const normalizedParent = parentId || null;
            const childViews = orderedViews.filter(([_, view]) => (view.parentId || null) === normalizedParent);

            childViews.forEach(([viewId, view]) => {
                const viewItem = document.createElement('div');
                viewItem.className = `view-item ${viewId === state.currentViewId ? 'active' : ''}`;
                viewItem.style.paddingLeft = `${12 + depth * 16}px`;
                viewItem.innerHTML = `
                    <span class="view-item-icon">${renderIcon(view.icon || VIEW_TYPE_ICONS[view.type])}</span>
                    <span>${view.name}</span>
                `;
                viewItem.onclick = (e) => {
                    e.stopPropagation();
                    switchSet(setId, viewId);
                };
                viewItem.ondblclick = (e) => { e.stopPropagation(); openAddViewModal(setId, viewId); };
                viewItem.oncontextmenu = (e) => { e.preventDefault(); e.stopPropagation(); openAddViewModal(setId, viewId); };

                container.appendChild(viewItem);
                renderViewTree(orderedViews, setId, container, viewId, depth + 1);
            });
        }

        function isViewDescendant(set, startId, potentialAncestorId) {
            let currentParent = set.views.get(startId)?.parentId || null;
            while (currentParent) {
                if (currentParent === potentialAncestorId) return true;
                currentParent = set.views.get(currentParent)?.parentId || null;
            }
            return false;
        }

        function populateViewParentOptions(setId, excludeViewId = null, selectedParentId = null) {
            const select = document.getElementById('newViewParent');
            if (!select) return;

            select.innerHTML = '';
            const defaultOption = document.createElement('option');
            defaultOption.value = '';
            defaultOption.textContent = 'No parent';
            select.appendChild(defaultOption);

            const set = state.sets.get(setId);
            if (!set) return;

            const orderedViews = Array.from(set.views.entries());
            const renderOptions = (parentId = null, depth = 0) => {
                const children = orderedViews.filter(([id, view]) => (view.parentId || null) === (parentId || null));
                children.forEach(([id, view]) => {
                    if (excludeViewId && id === excludeViewId) return;
                    const option = document.createElement('option');
                    option.value = id;
                    option.innerHTML = `${' '.repeat(depth)}${renderIcon(view.icon || VIEW_TYPE_ICONS[view.type])} ${view.name}`;
                    select.appendChild(option);
                    renderOptions(id, depth + 1);
                });
            };

            renderOptions();
            select.value = selectedParentId || '';
        }

        function openAddViewModal(setId, viewId = null) {
            const set = state.sets.get(setId);
            if (!set) return;

            const titleEl = document.getElementById('addViewModalTitle');
            const saveBtn = document.getElementById('saveAddViewBtn');
            const nameInput = document.getElementById('newViewName');
            const iconInput = document.getElementById('newViewIcon');

            state.currentSetId = setId;
            if (viewId) {
                const view = set.views.get(viewId);
                state.viewEditorContext = { setId, viewId };
                if (titleEl) titleEl.textContent = 'Edit View';
                if (saveBtn) saveBtn.textContent = 'Save';
                if (nameInput) nameInput.value = view?.name || '';
                if (iconInput) iconInput.value = extractIconToken(view?.icon || VIEW_TYPE_ICONS[view?.type]);
                populateViewParentOptions(setId, viewId, view?.parentId || null);
            } else {
                state.viewEditorContext = { setId, viewId: null };
                if (titleEl) titleEl.textContent = 'Create View';
                if (saveBtn) saveBtn.textContent = 'Create';
                if (nameInput) nameInput.value = '';
                if (iconInput) iconInput.value = 'ph-table';
                populateViewParentOptions(setId);
            }

            syncIconSelector('newViewIcon');
            openModal('addViewModal');
        }

        function switchSet(setId, viewId) {
            state.currentSetId = setId;
            state.currentViewId = viewId;
            const set = state.sets.get(setId);
            if (!viewId && set.views.size > 0) {
                state.currentViewId = Array.from(set.views.keys())[0];
            }
            closeMobileSidebar();
            renderSidebar();
            renderCurrentView();
        }

        function getCurrentSet() { return state.sets.get(state.currentSetId); }
        function getCurrentView() { const set = getCurrentSet(); return set?.views.get(state.currentViewId); }
        function getCurrentProfile() { const set = getCurrentSet(); return set?.profiles.get(state.currentProfileId); }

        // VIEW SWITCHING
        function switchViewType(type) {
            const view = getCurrentView();
            if (!view) return;
            view.type = type;
            
            // Update button states
            document.querySelectorAll('.view-type-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.type === type) btn.classList.add('active');
            });
            
            renderCurrentView();
        }

        function renderCurrentView() {
            const view = getCurrentView();
            if (!view) return;

            ensureViewDefaults(view);

            // Update view type buttons
            document.querySelectorAll('.view-type-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.type === view.type) btn.classList.add('active');
            });

            switch(view.type) {
                case 'grid':
                    renderGridView();
                    break;
                case 'card':
                    renderCardView();
                    break;
                case 'kanban':
                    renderKanbanView();
                    break;
            }
        }

        function ensureViewDefaults(view) {
            if (!view.icon) view.icon = VIEW_TYPE_ICONS[view.type] || 'ph-note';
            if (!view.sorts) view.sorts = [];
        }

        function applyColumnWidth(fieldId, width) {
            const normalizedWidth = clampColumnWidth(width);
            const widthPx = `${normalizedWidth}px`;
            const set = getCurrentSet();
            const field = set?.schema.find(f => f.id === fieldId);
            if (field) field.width = widthPx;

            document.querySelectorAll(`[data-field-id="${fieldId}"]`).forEach(el => {
                el.style.width = widthPx;
            });

            const table = document.getElementById('dataTable');
            if (table && set) {
                const totalWidth = set.schema.reduce((sum, f) => sum + getFieldWidth(f), 0);
                table.style.minWidth = `${Math.max(totalWidth, 600)}px`;
            }
        }

        function addColumnResizer(element, field) {
            const existingResizer = element.querySelector('.column-resizer');
            if (existingResizer) return;

            const resizer = document.createElement('div');
            resizer.className = 'column-resizer';
            element.appendChild(resizer);

            let startX = 0;
            let startWidth = getFieldWidth(field);

            const onMouseMove = (event) => {
                const delta = event.clientX - startX;
                applyColumnWidth(field.id, startWidth + delta);
            };

            const onMouseUp = () => {
                document.body.classList.remove('resizing');
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
            };

            resizer.addEventListener('mousedown', (event) => {
                event.stopPropagation();
                event.preventDefault();
                startX = event.clientX;
                startWidth = getFieldWidth(field);
                document.body.classList.add('resizing');
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            });
        }

        function getPointerPosition(event) {
            if (!event) return { clientX: 0, clientY: 0 };
            if (event.touches && event.touches.length > 0) {
                return { clientX: event.touches[0].clientX, clientY: event.touches[0].clientY };
            }
            if (event.changedTouches && event.changedTouches.length > 0) {
                return { clientX: event.changedTouches[0].clientX, clientY: event.changedTouches[0].clientY };
            }
            return { clientX: event.clientX, clientY: event.clientY };
        }

        function createColumnGhost(element, position) {
            const ghost = document.createElement('div');
            ghost.className = 'column-drag-ghost';
            ghost.style.width = `${element.offsetWidth}px`;
            ghost.innerHTML = element.innerHTML;
            ghost.style.left = `${position.clientX - columnDragState.offsetX}px`;
            ghost.style.top = `${position.clientY - columnDragState.offsetY}px`;
            document.body.appendChild(ghost);
            return ghost;
        }

        function clearColumnDropIndicators() {
            document.querySelectorAll('#tableHeader .column-header').forEach(header => {
                header.classList.remove('column-drop-before', 'column-drop-after');
            });
        }

        function updateColumnDropTarget(clientX) {
            const headers = Array.from(document.querySelectorAll('#tableHeader .column-header'));
            clearColumnDropIndicators();

            const target = headers.find(h => {
                const rect = h.getBoundingClientRect();
                return clientX >= rect.left && clientX <= rect.right;
            });

            if (!target || target.dataset.fieldId === columnDragState.draggedFieldId) {
                columnDragState.dropFieldId = null;
                columnDragState.dropPosition = null;
                return;
            }

            const rect = target.getBoundingClientRect();
            const position = clientX < rect.left + rect.width / 2 ? 'before' : 'after';
            target.classList.add(position === 'before' ? 'column-drop-before' : 'column-drop-after');
            columnDragState.dropFieldId = target.dataset.fieldId;
            columnDragState.dropPosition = position;
        }

        function reorderSchemaField(draggedFieldId, targetFieldId, position) {
            const set = getCurrentSet();
            if (!set) return;

            const fromIndex = set.schema.findIndex(f => f.id === draggedFieldId);
            let targetIndex = set.schema.findIndex(f => f.id === targetFieldId);
            if (fromIndex === -1 || targetIndex === -1) return;

            const [field] = set.schema.splice(fromIndex, 1);
            if (fromIndex < targetIndex) targetIndex -= 1;
            const insertIndex = position === 'after' ? targetIndex + 1 : targetIndex;
            set.schema.splice(insertIndex, 0, field);
        }

        function endColumnDrag() {
            document.body.classList.remove('column-dragging');
            document.removeEventListener('mousemove', handleColumnDragMove);
            document.removeEventListener('touchmove', handleColumnDragMove);
            document.removeEventListener('mouseup', endColumnDrag);
            document.removeEventListener('touchend', endColumnDrag);
            document.removeEventListener('touchcancel', endColumnDrag);

            if (columnDragState.ghost) columnDragState.ghost.remove();
            if (columnDragState.sourceElement) columnDragState.sourceElement.classList.remove('column-being-dragged');
            clearColumnDropIndicators();

            if (columnDragState.draggedFieldId && columnDragState.dropFieldId) {
                reorderSchemaField(columnDragState.draggedFieldId, columnDragState.dropFieldId, columnDragState.dropPosition);
                renderCurrentView();
            }

            columnDragState.draggedFieldId = null;
            columnDragState.dropFieldId = null;
            columnDragState.dropPosition = null;
            columnDragState.ghost = null;
            columnDragState.sourceElement = null;
        }

        function handleColumnDragMove(event) {
            if (!columnDragState.draggedFieldId || !columnDragState.ghost) return;
            if (event.cancelable) event.preventDefault();
            const position = getPointerPosition(event);
            columnDragState.ghost.style.left = `${position.clientX - columnDragState.offsetX}px`;
            columnDragState.ghost.style.top = `${position.clientY - columnDragState.offsetY}px`;
            updateColumnDropTarget(position.clientX);
        }

        function startColumnDrag(startPosition, element, field) {
            columnDragState.timer = null;
            columnDragState.draggedFieldId = field.id;
            columnDragState.sourceElement = element;

            const rect = element.getBoundingClientRect();
            columnDragState.offsetX = startPosition.clientX - rect.left;
            columnDragState.offsetY = startPosition.clientY - rect.top;

            columnDragState.ghost = createColumnGhost(element, startPosition);
            element.classList.add('column-being-dragged');
            document.body.classList.add('column-dragging');

            document.addEventListener('mousemove', handleColumnDragMove);
            document.addEventListener('touchmove', handleColumnDragMove, { passive: false });
            document.addEventListener('mouseup', endColumnDrag);
            document.addEventListener('touchend', endColumnDrag);
            document.addEventListener('touchcancel', endColumnDrag);
        }

        function setupColumnDragInteractions(element, field) {
            const cancelTimer = () => {
                if (columnDragState.timer) {
                    clearTimeout(columnDragState.timer);
                    columnDragState.timer = null;
                }
            };

            const startTimer = (event) => {
                if (event.button !== undefined && event.button !== 0) return;
                if (event.target.closest('.column-resizer')) return;
                const startPosition = getPointerPosition(event);
                cancelTimer();
                columnDragState.timer = setTimeout(() => startColumnDrag(startPosition, element, field), 400);
            };

            element.addEventListener('mousedown', startTimer);
            element.addEventListener('touchstart', startTimer);
            element.addEventListener('mouseup', cancelTimer);
            element.addEventListener('mouseleave', cancelTimer);
            element.addEventListener('mousemove', cancelTimer);
            element.addEventListener('touchend', cancelTimer);
            element.addEventListener('touchcancel', cancelTimer);
        }

        // GRID VIEW
        function renderGridView() {
            const set = getCurrentSet();
            if (!set) return;

            const previousSelection = state.selectedCell
                ? { recordId: state.selectedCell.recordId, fieldId: state.selectedCell.fieldId }
                : state.lastSelectedCell;
            state.selectedCell = null;
            state.editingCell = null;

            const view = getCurrentView();
            const profile = getCurrentProfile();
            const schema = set.schema.filter(f =>
                !profile || profile.visibleFields.length === 0 || profile.visibleFields.includes(f.id)
            );

            let records = Array.from(set.records.values());
            if (view && view.filters.length > 0) records = applyFilterGroups(records, view.filters, schema);
            if (view?.sorts?.length) records = applySorts(records, view.sorts, schema);

            const recordCount = records.length;
            const recordLabel = recordCount === 1 ? 'record' : 'records';

            const container = document.getElementById('viewContainer');
            container.innerHTML = `
                <div class="max-w-full px-6 py-6">
                    <div class="bg-white rounded-lg shadow-sm border border-gray-200 overflow-hidden">
                        <div class="table-scroll">
                            <table id="dataTable" class="border-collapse">
                                <thead><tr id="tableHeader"></tr></thead>
                                <tbody id="tableBody"></tbody>
                            </table>
                        </div>
                        <div class="table-footer">
                            <span class="record-counter" id="recordCounter">${recordCount} ${recordLabel}</span>
                        </div>
                    </div>
                </div>
            `;

            const headerRow = document.getElementById('tableHeader');
            schema.forEach(field => {
                const th = document.createElement('th');
                th.className = 'column-header';
                th.dataset.type = field.type;
                th.dataset.fieldId = field.id;
                const width = `${getFieldWidth(field)}px`;
                th.style.width = width;
                const sortIndex = view?.sorts?.findIndex(s => s.fieldId === field.id) ?? -1;
                const sortConfig = sortIndex >= 0 ? view.sorts[sortIndex] : null;
                const directionIcon = sortConfig ? (sortConfig.direction === 'desc' ? '' : '') : '';
                const indicatorClass = sortConfig ? 'sort-indicator' : 'sort-indicator muted';
                const orderBadge = sortConfig ? `<span class="order-badge">${sortIndex + 1}</span>` : '';
                th.innerHTML = `<span>${field.name}</span><span class="${indicatorClass}"><span class="direction-icon">${directionIcon}</span>${orderBadge}</span>`;
                th.onclick = () => toggleColumnSort(field.id);
                addColumnResizer(th, field);
                setupColumnDragInteractions(th, field);
                th.oncontextmenu = (e) => { e.preventDefault(); showColumnMenu(e, field); };
                headerRow.appendChild(th);
            });

            const table = document.getElementById('dataTable');
            const minimumTableWidth = schema.reduce((sum, field) => sum + getFieldWidth(field), 0);
            table.style.minWidth = `${Math.max(minimumTableWidth, 600)}px`;

            const tbody = document.getElementById('tableBody');
            records.forEach((record, index) => {
                const tr = document.createElement('tr');
                tr.dataset.recordId = record.id;
                tr.ondblclick = () => openExpandedRecord(record.id);

                schema.forEach(field => {
                    const td = document.createElement('td');
                    td.className = 'cell-editable';
                    td.dataset.recordId = record.id;
                    td.dataset.fieldId = field.id;
                    td.style.width = `${getFieldWidth(field)}px`;
                    const value = record[field.id];
                    td.innerHTML = renderCellValue(value, field, record);
                    addColumnResizer(td, field);
                    if (field.type === 'CHECKBOX') {
                        td.onclick = (e) => {
                            e.stopPropagation();
                            const now = Date.now();
                            if (td._lastToggleTime && now - td._lastToggleTime < 250) return;
                            td._lastToggleTime = now;
                            toggleCheckbox(record.id, field.id);
                        };
                        td.ondblclick = (e) => {
                            e.stopPropagation();
                            openExpandedRecord(record.id);
                        };
                    } else {
                        td.onclick = (e) => {
                            e.stopPropagation();
                            handleCellClick(td, record.id, field);
                        };
                        td.ondblclick = (e) => {
                            e.stopPropagation();
                            openExpandedRecord(record.id);
                        };
                    }
                    td.oncontextmenu = (e) => { e.preventDefault(); showCellMenu(e, record.id, field); };
                    tr.appendChild(td);
                });

                tbody.appendChild(tr);
            });

            if (previousSelection) {
                const match = tbody.querySelector(`[data-record-id="${previousSelection.recordId}"][data-field-id="${previousSelection.fieldId}"]`);
                if (match) {
                    selectCell(match, previousSelection.recordId, previousSelection.fieldId);
                }
            }
        }

        function renderCellValue(value, field, record) {
            switch(field.type) {
                case 'TEXT': case 'LONG_TEXT': case 'EMAIL': case 'URL': case 'PHONE':
                    return value || '';
                case 'NUMBER':
                    return value ? Number(value).toLocaleString() : '';
                case 'CURRENCY':
                    return value ? new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD' }).format(value) : '';
                case 'DATE':
                    return value ? new Date(value).toLocaleDateString() : '';
                case 'CHECKBOX':
                    return value ? '' : '';
                case 'LINK_RECORD':
                    if (!value) return '';
                    const linkedName = getRecordDisplayName(value);
                    return `<button class="text-blue-600 hover:underline" onclick="event.stopPropagation(); openLinkedRecord('${value}')">${linkedName}</button>`;
                case 'SINGLE_SELECT':
                    if (!value) return '';
                    const color = field.config?.colors?.[value] || 'gray';
                    return `<span class="badge badge-${color}">${value}</span>`;
                case 'FORMULA':
                    if (record?.__formulaMeta?.[field.id]?.success) {
                        const meta = record.__formulaMeta[field.id];
                        return meta.preview || meta.result || '';
                    }
                    if (record?.__formulaMeta?.[field.id]?.error) {
                        const message = record.__formulaMeta[field.id].error.message;
                        return `<span class="text-red-600" title="${message}">${message}</span>`;
                    }
                    return value || '';
                default:
                    return value || '';
            }
        }

        // CARD VIEW
        function renderCardView() {
            const set = getCurrentSet();
            if (!set) return;
            
            const view = getCurrentView();
            let records = Array.from(set.records.values());
            if (view && view.filters.length > 0) records = applyFilterGroups(records, view.filters, set.schema);
            if (view?.sorts?.length) records = applySorts(records, view.sorts, set.schema);

            const container = document.getElementById('viewContainer');
            container.innerHTML = '<div class="cards-grid" id="cardsGrid"></div>';
            
            const grid = document.getElementById('cardsGrid');
            records.forEach(record => {
                const card = document.createElement('div');
                card.className = 'card';
                card.onclick = () => openExpandedRecord(record.id);
                
                const primaryField = set.schema[0];
                const displayFields = set.schema.slice(1, 6);
                
                card.innerHTML = `
                    <div class="card-title">${record[primaryField.id] || 'Untitled'}</div>
                    ${displayFields.map(field => {
                        const value = record[field.id];
                        if (!value && value !== 0 && value !== false) return '';
                        return `
                            <div class="card-field">
                                <div class="card-field-label">${field.name}</div>
                                <div class="card-field-value">${renderCellValue(value, field, record)}</div>
                            </div>
                        `;
                    }).join('')}
                `;
                
                grid.appendChild(card);
            });
        }

        // KANBAN VIEW
        function renderKanbanView() {
            const set = getCurrentSet();
            const view = getCurrentView();
            if (!set || !view) return;
            
            if (!view.kanbanGroupField) {
                const container = document.getElementById('viewContainer');
                container.innerHTML = `
                    <div class="kanban-empty-state">
                        <div class="text-4xl mb-4"></div>
                        <p class="text-lg font-semibold mb-2">Configure Kanban Board</p>
                        <p class="mb-4">Select a single-select field to group your records</p>
                        <button onclick="openKanbanConfig()" class="btn btn-primary">Configure Kanban</button>
                    </div>
                `;
                return;
            }
            
            const groupField = set.schema.find(f => f.id === view.kanbanGroupField);
            if (!groupField || groupField.type !== 'SINGLE_SELECT') {
                showToast(' Invalid kanban configuration');
                return;
            }
            
            let records = Array.from(set.records.values());
            if (view.filters.length > 0) records = applyFilterGroups(records, view.filters, set.schema);
            if (view?.sorts?.length) records = applySorts(records, view.sorts, set.schema);
            
            const container = document.getElementById('viewContainer');
            container.innerHTML = '<div class="kanban-board" id="kanbanBoard"></div>';
            
            const board = document.getElementById('kanbanBoard');
            const options = groupField.config.options || [];
            
            options.forEach(option => {
                const columnRecords = records.filter(r => r[groupField.id] === option);
                const column = createKanbanColumn(option, columnRecords, groupField);
                board.appendChild(column);
            });
            
            // Uncategorized column
            const uncategorized = records.filter(r => !r[groupField.id]);
            if (uncategorized.length > 0) {
                const column = createKanbanColumn('Uncategorized', uncategorized, groupField);
                board.appendChild(column);
            }
        }

        function createKanbanColumn(title, records, groupField) {
            const column = document.createElement('div');
            column.className = 'kanban-column';
            column.dataset.value = title;
            
            const color = groupField.config?.colors?.[title] || 'gray';
            
            column.innerHTML = `
                <div class="kanban-column-header">
                    <div class="kanban-column-title">
                        <span class="badge badge-${color}">${title}</span>
                    </div>
                    <span class="kanban-column-count">${records.length}</span>
                </div>
                <div class="kanban-cards" data-column="${title}"></div>
            `;
            
            const cardsContainer = column.querySelector('.kanban-cards');
            
            // Enable drop
            cardsContainer.addEventListener('dragover', (e) => {
                e.preventDefault();
                column.classList.add('drag-over');
            });
            
            cardsContainer.addEventListener('dragleave', () => {
                column.classList.remove('drag-over');
            });
            
            cardsContainer.addEventListener('drop', (e) => {
                e.preventDefault();
                column.classList.remove('drag-over');
                
                if (state.draggedRecord) {
                    const newValue = title === 'Uncategorized' ? '' : title;
                    updateRecord(state.draggedRecord.id, groupField.id, newValue, state.draggedRecord[groupField.id]);
                    state.draggedRecord = null;
                    renderKanbanView();
                }
            });
            
            records.forEach(record => {
                const card = createKanbanCard(record);
                cardsContainer.appendChild(card);
            });
            
            return column;
        }

        function createKanbanCard(record) {
            const set = getCurrentSet();
            const card = document.createElement('div');
            card.className = 'kanban-card';
            card.draggable = true;
            card.dataset.recordId = record.id;
            
            const primaryField = set.schema[0];
            const displayFields = set.schema.slice(1, 4);
            
            card.innerHTML = `
                <div class="font-semibold mb-2">${record[primaryField.id] || 'Untitled'}</div>
                ${displayFields.map(field => {
                    const value = record[field.id];
                    if (!value && value !== 0 && value !== false) return '';
                    return `<div class="text-sm text-gray-600 mb-1">${renderCellValue(value, field, record)}</div>`;
                }).join('')}
            `;
            
            card.addEventListener('dragstart', (e) => {
                state.draggedRecord = record;
                card.classList.add('dragging');
            });
            
            card.addEventListener('dragend', () => {
                card.classList.remove('dragging');
            });
            
            card.onclick = (e) => {
                if (!card.classList.contains('dragging')) {
                    openExpandedRecord(record.id);
                }
            };
            
            return card;
        }

        function openKanbanConfig() {
            const set = getCurrentSet();
            const select = document.getElementById('kanbanGroupField');
            select.innerHTML = '<option value="">Select a field...</option>';
            
            set.schema.forEach(field => {
                if (field.type === 'SINGLE_SELECT') {
                    select.innerHTML += `<option value="${field.id}">${field.name}</option>`;
                }
            });
            
            const view = getCurrentView();
            if (view.kanbanGroupField) {
                select.value = view.kanbanGroupField;
            }
            
            openModal('kanbanConfigModal');
        }

        function saveKanbanConfig() {
            const fieldId = document.getElementById('kanbanGroupField').value;
            if (!fieldId) {
                showConfirm('Please select a field to group by', () => {});
                return;
            }
            
            const view = getCurrentView();
            view.kanbanGroupField = fieldId;
            
            closeModal('kanbanConfigModal');
            renderKanbanView();
            showToast(' Kanban configured');
        }

        // CELL EDITING
        function handleCellClick(td, recordId, field) {
            if (state.editingCell && state.editingCell.td !== td) {
                exitEditMode();
            }

            if (state.selectedCell?.td === td && state.selectedCell?.recordId === recordId) {
                enterEditMode(td, recordId, field);
                return;
            }

            selectCell(td, recordId, field.id);
        }

        function selectCell(td, recordId, fieldId) {
            if (state.editingCell) exitEditMode();

            if (state.selectedCell?.td) {
                state.selectedCell.td.classList.remove('cell-selected');
                state.selectedCell.td.tabIndex = -1;
            }

            td.classList.add('cell-selected');
            td.tabIndex = 0;
            td.focus();

            state.selectedCell = { td, recordId, fieldId };
            state.lastSelectedCell = { recordId, fieldId };
        }

        function enterEditMode(td, recordId, field) {
            exitEditMode(false);

            if (field.type === 'FORMULA') {
                td.classList.add('cell-selected');
                state.editingCell = null;
                showToast('Formula fields are calculated automatically');
                return;
            }

            td.classList.remove('cell-selected');
            td.classList.add('cell-editing');
            state.editingCell = { td, recordId, fieldId: field.id };

            if (field.type === 'DATE') {
                showDatePicker(td, recordId, field);
            } else if (field.type === 'SINGLE_SELECT') {
                showSelectDropdown(td, recordId, field);
            } else if (field.type === 'LINK_RECORD') {
                showLinkedRecordDropdown(td, recordId, field);
            } else {
                makeContentEditable(td, recordId, field);
            }
        }

        function exitEditMode(save = true) {
            if (!state.editingCell) return;

            const { td, recordId, fieldId } = state.editingCell;

            if (td.contentEditable === 'true') {
                td.contentEditable = false;
                if (save) {
                    finalizeContentEdit(td, recordId, fieldId);
                }
            }

            td.classList.remove('cell-editing');
            td.classList.add('cell-selected');
            td.tabIndex = 0;

            state.editingCell = null;
            state.selectedCell = { td, recordId, fieldId };
            state.lastSelectedCell = { recordId, fieldId };
        }

        function makeContentEditable(td, recordId, field) {
            const set = getCurrentSet();
            const record = set.records.get(recordId);
            const currentValue = record[field.id];

            td.contentEditable = true;
            td.textContent = currentValue || '';
            td.focus();

            const range = document.createRange();
            range.selectNodeContents(td);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
        }

        function finalizeContentEdit(td, recordId, fieldId) {
            const set = getCurrentSet();
            const record = set.records.get(recordId);
            const field = set.schema.find(f => f.id === fieldId);
            const currentValue = record[fieldId];

            let newValue = td.textContent.trim();
            if (field.type === 'NUMBER' || field.type === 'CURRENCY') {
                newValue = parseFloat(newValue) || 0;
            }

            if (String(newValue) !== String(currentValue)) {
                updateRecord(recordId, fieldId, newValue, currentValue);
            } else {
                renderCurrentView();
            }
        }

        function toggleCheckbox(recordId, fieldId) {
            const set = getCurrentSet();
            const record = set.records.get(recordId);
            const currentValue = record[fieldId];
            updateRecord(recordId, fieldId, !currentValue, currentValue);
        }

        function showDatePicker(cell, recordId, field) {
            const set = getCurrentSet();
            const record = set.records.get(recordId);
            const currentValue = record[field.id];

            const input = document.createElement('input');
            input.type = 'date';
            input.value = currentValue || '';
            input.className = 'w-full px-2 py-1';
            cell.innerHTML = '';
            cell.appendChild(input);
            input.focus();
            input.onblur = () => {
                exitEditMode(false);
                const newValue = input.value;
                if (newValue !== currentValue) updateRecord(recordId, field.id, newValue, currentValue);
                else renderCurrentView();
            };
        }

        function showSelectDropdown(td, recordId, field) {
            const options = field.config.options.map(opt => ({
                value: opt,
                label: opt,
                color: field.config.colors?.[opt] || '#f3f4f6',
                icon: ''
            }));

            showEnhancedSelectDropdown(td, recordId, field, options);
        }

        function showEnhancedSelectDropdown(td, recordId, field, options) {
            const set = getCurrentSet();
            const record = set.records.get(recordId);
            const currentValue = record[field.id];

            document.querySelectorAll('.custom-select-dropdown').forEach(d => d.remove());

            const dropdown = document.createElement('div');
            dropdown.className = 'custom-select-dropdown';

            const rect = td.getBoundingClientRect();
            const spaceBelow = window.innerHeight - rect.bottom;
            const spaceAbove = rect.top;
            const dropdownHeight = Math.min(400, options.length * 40 + 100);

            if (spaceBelow >= dropdownHeight || spaceBelow > spaceAbove) {
                dropdown.style.top = `${rect.bottom + 4}px`;
            } else {
                dropdown.style.bottom = `${window.innerHeight - rect.top + 4}px`;
            }
            dropdown.style.left = `${rect.left}px`;
            dropdown.style.minWidth = `${rect.width}px`;

            dropdown.innerHTML = `
                <input 
                    type="text" 
                    class="custom-select-search" 
                    placeholder="Search or type to filter..."
                    autocomplete="off"
                    spellcheck="false"
                >
                <div class="custom-select-options"></div>
                <div class="custom-select-footer">
                    <button class="clear-btn">Clear</button>
                </div>
            `;

            document.body.appendChild(dropdown);

            const searchInput = dropdown.querySelector('.custom-select-search');
            const optionsContainer = dropdown.querySelector('.custom-select-options');
            const clearBtn = dropdown.querySelector('.clear-btn');

            let highlightedIndex = -1;
            let filteredOptions = [...options];

            function updateHighlight() {
                optionsContainer.querySelectorAll('.custom-select-option').forEach((el, i) => {
                    el.classList.toggle('highlighted', i === highlightedIndex);
                });
            }

            function scrollToHighlighted() {
                const highlighted = optionsContainer.querySelector('.highlighted');
                if (highlighted) {
                    highlighted.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
                }
            }

            function selectOption(value) {
                if (value !== currentValue) {
                    updateRecord(recordId, field.id, value, currentValue);
                }
                dropdown.remove();
                exitEditMode();
            }

            function renderOptions(query = '') {
                filteredOptions = query.trim() === ''
                    ? [...options]
                    : options.filter(opt => opt.label.toLowerCase().includes(query.toLowerCase()));

                if (filteredOptions.length === 0) {
                    optionsContainer.innerHTML = `
                        <div class="custom-select-empty">
                            <div class="custom-select-empty-icon"></div>
                            <div>No matches found</div>
                            <div style="font-size: 12px; margin-top: 4px;">Try a different search term</div>
                        </div>
                    `;
                    return;
                }

                optionsContainer.innerHTML = filteredOptions.map((opt, index) => {
                    const isSelected = opt.value === currentValue;
                    const isHighlighted = index === highlightedIndex;

                    let displayLabel = opt.label;
                    if (query.trim() !== '') {
                        const regex = new RegExp(`(${query})`, 'gi');
                        displayLabel = opt.label.replace(regex, '<span class="search-match">$1</span>');
                    }

                    return `
                        <div 
                            class="custom-select-option ${isSelected ? 'selected' : ''} ${isHighlighted ? 'highlighted' : ''}"
                            data-value="${opt.value}"
                            data-index="${index}"
                        >
                            <div class="custom-select-option-icon" style="background: ${opt.color || '#f3f4f6'}">
                                ${opt.icon || ''}
                            </div>
                            <div class="custom-select-option-text">${displayLabel}</div>
                            ${isSelected ? '<span class="custom-select-option-badge">Current</span>' : ''}
                        </div>
                    `;
                }).join('');

                optionsContainer.querySelectorAll('.custom-select-option').forEach(el => {
                    el.onclick = () => selectOption(el.dataset.value);
                    el.onmouseenter = () => {
                        highlightedIndex = parseInt(el.dataset.index);
                        updateHighlight();
                    };
                });
            }

            searchInput.oninput = (e) => {
                highlightedIndex = 0;
                renderOptions(e.target.value);
            };

            searchInput.onkeydown = (e) => {
                if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    highlightedIndex = Math.min(highlightedIndex + 1, filteredOptions.length - 1);
                    updateHighlight();
                    scrollToHighlighted();
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    highlightedIndex = Math.max(highlightedIndex - 1, 0);
                    updateHighlight();
                    scrollToHighlighted();
                } else if (e.key === 'Enter') {
                    e.preventDefault();
                    if (highlightedIndex >= 0 && highlightedIndex < filteredOptions.length) {
                        selectOption(filteredOptions[highlightedIndex].value);
                    }
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    dropdown.remove();
                    exitEditMode(false);
                }
            };

            clearBtn.onclick = () => {
                selectOption('');
            };

            setTimeout(() => {
                document.addEventListener('click', function closeDropdown(e) {
                    if (!dropdown.contains(e.target) && e.target !== td) {
                        dropdown.remove();
                        exitEditMode(false);
                        document.removeEventListener('click', closeDropdown);
                    }
                });
            }, 0);

            renderOptions();
            searchInput.focus();
        }

        function showLinkedRecordDropdown(td, recordId, field) {
            const linkedSet = getLinkedSet(field);
            if (!linkedSet) {
                showToast(' Configure linked set first');
                exitEditMode(false);
                return;
            }

            const options = Array.from(linkedSet.records.values()).map(rec => ({
                value: rec.id,
                label: rec.name || rec.id,
                icon: '',
                color: '#e0f2fe'
            }));

            if (options.length === 0) {
                showToast(' No records in linked set');
                exitEditMode(false);
                return;
            }

            showEnhancedSelectDropdown(td, recordId, field, options);
        }

        function filterLinkedRecordSelect(selectId, query) {
            const select = document.getElementById(selectId);
            if (!select) return;

            const optionsData = select.dataset.options
                ? JSON.parse(decodeURIComponent(select.dataset.options))
                : [];
            const normalizedQuery = query.trim().toLowerCase();
            const filtered = optionsData.filter(opt => opt.label.toLowerCase().includes(normalizedQuery));
            const previousValue = select.value;

            select.innerHTML = '<option value="">Select a record</option>';

            if (filtered.length === 0) {
                const placeholder = document.createElement('option');
                placeholder.disabled = true;
                placeholder.textContent = 'No matches';
                select.appendChild(placeholder);
                select.value = '';
                select.disabled = true;
                return;
            }

            filtered.forEach(opt => {
                const option = document.createElement('option');
                option.value = opt.id;
                option.textContent = opt.label;
                select.appendChild(option);
            });

            const stillExists = filtered.some(opt => opt.id === previousValue);
            select.value = stillExists ? previousValue : '';
            select.disabled = false;
        }

      function updateRecord(recordId, fieldId, newValue, oldValue) {
          const set = getCurrentSet();
          const record = set.records.get(recordId);
          const field = set.schema.find(f => f.id === fieldId);
          record[fieldId] = newValue;
            createEvent(
                'Update Cell',
                'SEG',
                { type: 'Record', id: recordId, setId: set.id },
                {
                    fieldId: fieldId,
                    fieldName: field.name,
                    oldValue: oldValue,
                    newValue: newValue,
                    setId: set.id,
                    recordId: recordId,
                    summary: `Updated ${field.name}`
                }
            );
            recomputeFormulasForSet(set);
            renderCurrentView();
          showToast(` Updated ${field.name}`);
      }

      // FIELD MANAGEMENT
      function resetFieldNameValidation() {
          const nameInput = document.getElementById('newFieldName');
          const nameError = document.getElementById('fieldNameError');
          if (nameInput) {
              nameInput.classList.remove('input-error');
              nameInput.removeAttribute('aria-invalid');
          }
          if (nameError) {
              nameError.classList.add('hidden');
              nameError.textContent = '';
          }
      }

      function openAddFieldModal() {
          state.selectOptions = [{ value: 'Option 1', color: 'blue' }];
          const nameInput = document.getElementById('newFieldName');
          if (nameInput) nameInput.value = '';
          resetFieldNameValidation();
          document.getElementById('newFieldType').value = 'TEXT';
          const formulaInput = document.getElementById('formulaExpression');
          if (formulaInput) {
              formulaInput.value = '';
              delete formulaInput.dataset.visualBlocks;
          }
          renderFieldTypeGrid('TEXT');
            closeFieldTypeDropdown();
            updateFieldConfig('TEXT');

            const linkSelect = document.getElementById('linkToSet');
            linkSelect.innerHTML = '';
            state.sets.forEach((set, setId) => {
                const label = setId === state.currentSetId ? `${set.name} (this set)` : set.name;
                linkSelect.innerHTML += `<option value="${setId}">${label}</option>`;
            });
            if (linkSelect.options.length === 0) {
                linkSelect.innerHTML = '<option value="">No sets available</option>';
                linkSelect.disabled = true;
            } else {
                linkSelect.disabled = false;
                const defaultValue = state.sets.has(state.currentSetId) ? state.currentSetId : linkSelect.options[0].value;
                linkSelect.value = defaultValue;
            }

            openModal('addFieldModal');
        }

        function renderFieldTypeGrid(selectedType) {
            const trigger = document.getElementById('fieldTypeTrigger');
            const dropdown = document.getElementById('fieldTypeDropdown');
            const selectedName = document.getElementById('selectedFieldTypeName');
            const selectedDescription = document.getElementById('selectedFieldTypeDescription');

            if (!trigger || !dropdown) return;

            const fieldType = FIELD_TYPES[selectedType] || Object.values(FIELD_TYPES)[0];
            const iconTarget = trigger.querySelector('.field-type-trigger-icon');
            if (iconTarget) iconTarget.innerHTML = renderIcon(fieldType.icon);
            if (selectedName) selectedName.textContent = fieldType.name;
            if (selectedDescription) selectedDescription.textContent = fieldType.description || fieldType.id.replace(/_/g, ' ');

            dropdown.innerHTML = '';
            Object.values(FIELD_TYPES).forEach(optionType => {
                const option = document.createElement('div');
                option.className = `field-type-option ${optionType.id === selectedType ? 'selected' : ''}`;
                option.dataset.typeId = optionType.id;
                option.innerHTML = `
                    <div class="field-type-icon">${renderIcon(optionType.icon)}</div>
                    <div class="field-type-info">
                        <div class="field-type-name">${optionType.name}</div>
                        <div class="field-type-description">${optionType.description || optionType.id.replace(/_/g, ' ')}</div>
                    </div>
                    <span class="field-type-check">${optionType.id === selectedType ? '' : ''}</span>
                `;
                option.onclick = () => selectFieldType(optionType.id);
                dropdown.appendChild(option);
            });
        }

        function selectFieldType(typeId) {
            document.getElementById('newFieldType').value = typeId;
            renderFieldTypeGrid(typeId);
            updateFieldConfig(typeId);
            closeFieldTypeDropdown();
        }

        function toggleFieldTypeDropdown() {
            if (state.fieldTypeDropdownOpen) {
                closeFieldTypeDropdown();
            } else {
                openFieldTypeDropdown();
            }
        }

        function openFieldTypeDropdown() {
            const dropdown = document.getElementById('fieldTypeDropdown');
            const trigger = document.getElementById('fieldTypeTrigger');
            if (!dropdown || !trigger) return;
            dropdown.classList.remove('hidden');
            trigger.classList.add('active');
            state.fieldTypeDropdownOpen = true;
        }

        function closeFieldTypeDropdown() {
            const dropdown = document.getElementById('fieldTypeDropdown');
            const trigger = document.getElementById('fieldTypeTrigger');
            if (!dropdown || !trigger) return;
            dropdown.classList.add('hidden');
            trigger.classList.remove('active');
            state.fieldTypeDropdownOpen = false;
        }

        function updateFieldConfig(typeId) {
            document.getElementById('singleSelectConfig').classList.remove('visible');
            document.getElementById('linkToRecordConfig').classList.remove('visible');
            document.getElementById('formulaFieldConfig').classList.remove('visible');
            if (typeId === 'SINGLE_SELECT') {
                document.getElementById('singleSelectConfig').classList.add('visible');
                renderSelectOptions();
            } else if (typeId === 'LINK_RECORD') {
                document.getElementById('linkToRecordConfig').classList.add('visible');
            } else if (typeId === 'FORMULA') {
                document.getElementById('formulaFieldConfig').classList.add('visible');
            }
        }

        function renderSelectOptions() {
            const container = document.getElementById('selectOptionsList');
            container.innerHTML = state.selectOptions.map((opt, i) => `
                <div class="option-row">
                    <input type="text" value="${opt.value}" onchange="updateSelectOption(${i}, this.value, '${opt.color}')" placeholder="Option ${i + 1}">
                    <div class="color-picker">
                        ${['blue', 'green', 'yellow', 'red', 'purple', 'gray'].map(c => `
                            <div class="color-option badge-${c} ${opt.color === c ? 'selected' : ''}" 
                                 onclick="updateSelectOption(${i}, '${opt.value}', '${c}')"></div>
                        `).join('')}
                    </div>
                    ${state.selectOptions.length > 1 ? `<button onclick="removeSelectOption(${i})" class="btn btn-secondary btn-sm"></button>` : ''}
                </div>
            `).join('');
        }

        function addSelectOption() {
            state.selectOptions.push({ value: `Option ${state.selectOptions.length + 1}`, color: 'blue' });
            renderSelectOptions();
        }

        function updateSelectOption(index, value, color) {
            state.selectOptions[index] = { value, color };
            renderSelectOptions();
        }

        function removeSelectOption(index) {
            state.selectOptions.splice(index, 1);
            renderSelectOptions();
        }

      function saveField() {
          const nameInput = document.getElementById('newFieldName');
          const nameError = document.getElementById('fieldNameError');
          const name = nameInput.value.trim();
          const type = document.getElementById('newFieldType').value;

          if (!name) {
              if (nameError) {
                  nameError.textContent = 'Please add a field name to continue.';
                  nameError.classList.remove('hidden');
              }
              nameInput.classList.add('input-error');
              nameInput.setAttribute('aria-invalid', 'true');
              nameInput.focus();
              return;
          }

          resetFieldNameValidation();

          const set = getCurrentSet();
          const fieldId = name.toLowerCase().replace(/[^a-z0-9]/g, '_');
            
            if (set.schema.find(f => f.id === fieldId)) {
                showConfirm('A field with this name already exists', () => {});
                return;
            }
            
            const newField = { id: fieldId, name: name, type: type, width: '150px', config: {} };

            if (type === 'SINGLE_SELECT') {
                newField.config = {
                    options: state.selectOptions.map(o => o.value),
                    colors: Object.fromEntries(state.selectOptions.map(o => [o.value, o.color]))
                };
            } else if (type === 'LINK_RECORD') {
                const linkedSetId = document.getElementById('linkToSet').value;
                if (!linkedSetId) { showConfirm('Select a set to link to', () => {}); return; }
                newField.config = { linkedSetId };
            } else if (type === 'FORMULA') {
                const formulaValue = document.getElementById('formulaExpression').value.trim();
                if (!formulaValue) { showConfirm('Enter a formula expression for this field', () => {}); return; }
                let visualBlocks = [];
                const visualBlocksRaw = document.getElementById('formulaExpression')?.dataset?.visualBlocks;
                if (visualBlocksRaw) {
                    try { visualBlocks = JSON.parse(visualBlocksRaw); } catch (error) { visualBlocks = []; }
                }
                newField.config = { formula: formulaValue, visualBlocks };
            }

            set.schema.push(newField);
            set.records.forEach(r => r[fieldId] = FIELD_TYPES[type].defaultValue);
            recomputeFormulasForSet(set);

            closeModal('addFieldModal');
            renderCurrentView();
            
            // Scroll to new field
            setTimeout(() => {
                const header = document.querySelector(`[data-field-id="${fieldId}"]`);
                if (header) {
                    header.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'end' });
                    header.style.animation = 'flash-yellow 0.5s ease-out';
                }
            }, 100);
            
            showToast(' Field added');
        }

        // FILTERING (simplified for space)
        function openFilterModal() {
            renderFilterBuilder();
            openModal('filterModal');
        }

        function renderFilterBuilder() {
            const view = getCurrentView();
            const container = document.getElementById('filterGroupsContainer');
            if (!view.filters || view.filters.length === 0) view.filters = [[{ field: '', operator: 'equals', value: '' }]];
            container.innerHTML = view.filters.map((group, groupIndex) => `
                <div class="filter-group">
                    <div class="filter-group-header">
                        <div class="filter-operator-toggle">
                            <button class="${group.operator !== 'OR' ? 'active' : ''}" onclick="setGroupOperator(${groupIndex}, 'AND')">AND</button>
                            <button class="${group.operator === 'OR' ? 'active' : ''}" onclick="setGroupOperator(${groupIndex}, 'OR')">OR</button>
                        </div>
                        <button onclick="removeFilterGroup(${groupIndex})" class="text-red-600 text-sm">Remove Group</button>
                    </div>
                    ${group.map((rule, ruleIndex) => renderFilterRule(groupIndex, ruleIndex, rule)).join('')}
                    <button onclick="addFilterRule(${groupIndex})" class="btn btn-secondary btn-sm mt-2">+ Add Rule</button>
                </div>
            `).join('');
        }

        function renderFilterRule(groupIndex, ruleIndex, rule) {
            const schema = getCurrentSet().schema;
            return `
                <div class="filter-rule">
                    <select onchange="updateFilterField(${groupIndex}, ${ruleIndex}, this.value)">
                        <option value="">Select field...</option>
                        ${schema.map(f => `<option value="${f.id}" ${f.id === rule.field ? 'selected' : ''}>${f.name}</option>`).join('')}
                    </select>
                    <select><option>equals</option></select>
                    <input type="text" value="${rule.value || ''}" onchange="updateFilterValue(${groupIndex}, ${ruleIndex}, this.value)">
                    <button onclick="removeFilterRule(${groupIndex}, ${ruleIndex})" class="text-red-600"></button>
                </div>
            `;
        }

        function applyFilterGroups(records, filterGroups, schema) {
            return records.filter(record => {
                return filterGroups.some(group => {
                    const operator = group.operator || 'AND';
                    const rules = group.filter(r => r.field);
                    if (operator === 'AND') return rules.every(rule => record[rule.field] === rule.value);
                    else return rules.some(rule => record[rule.field] === rule.value);
                });
            });
        }

        function getSortableValue(value, field) {
            if (value === undefined || value === null) return '';
            switch(field?.type) {
                case 'NUMBER':
                case 'CURRENCY':
                    return Number(value) || 0;
                case 'DATE':
                    return new Date(value).getTime() || 0;
                case 'CHECKBOX':
                    return value ? 1 : 0;
                default:
                    return String(value).toLowerCase();
            }
        }

        function applySorts(records, sorts, schema) {
            if (!sorts || sorts.length === 0) return records;
            const schemaMap = new Map(schema.map(f => [f.id, f]));
            const activeSorts = sorts.filter(sort => schemaMap.has(sort.fieldId));
            if (activeSorts.length === 0) return records;

            return [...records].sort((a, b) => {
                for (const sort of activeSorts) {
                    const field = schemaMap.get(sort.fieldId);
                    const aVal = getSortableValue(a[sort.fieldId], field);
                    const bVal = getSortableValue(b[sort.fieldId], field);

                    if (aVal < bVal) return sort.direction === 'desc' ? 1 : -1;
                    if (aVal > bVal) return sort.direction === 'desc' ? -1 : 1;
                }
                return 0;
            });
        }

        function toggleColumnSort(fieldId) {
            const view = getCurrentView();
            if (!view) return;

            ensureViewDefaults(view);
            const existingIndex = view.sorts.findIndex(s => s.fieldId === fieldId);
            if (existingIndex === -1) {
                view.sorts.unshift({ fieldId, direction: 'asc' });
            } else if (view.sorts[existingIndex].direction === 'asc') {
                view.sorts[existingIndex].direction = 'desc';
            } else {
                view.sorts.splice(existingIndex, 1);
            }

            renderCurrentView();
        }

        function openSortModal() {
            const view = getCurrentView();
            if (!view) return;

            ensureViewDefaults(view);
            renderSortBuilder();
            openModal('sortModal');
        }

        function renderSortBuilder() {
            const set = getCurrentSet();
            const view = getCurrentView();
            if (!set || !view) return;

            const container = document.getElementById('sortRulesContainer');
            const schema = set.schema;

            if (!view.sorts || view.sorts.length === 0) {
                container.innerHTML = '<p class="text-sm text-gray-500">No sorts configured. Add a field to start sorting.</p>';
                return;
            }

            container.innerHTML = view.sorts.map((sort, index) => `
                <div class="flex items-center gap-3 p-3 rounded-lg border border-gray-200 bg-gray-50">
                    <div class="text-xs font-semibold text-gray-500">#${index + 1}</div>
                    <select class="flex-1" onchange="updateSortField(${index}, this.value)">
                        <option value="">Select field...</option>
                        ${schema.map(f => `<option value="${f.id}" ${f.id === sort.fieldId ? 'selected' : ''}>${f.name}</option>`).join('')}
                    </select>
                    <select onchange="updateSortDirection(${index}, this.value)">
                        <option value="asc" ${sort.direction === 'asc' ? 'selected' : ''}>Ascending</option>
                        <option value="desc" ${sort.direction === 'desc' ? 'selected' : ''}>Descending</option>
                    </select>
                    <div class="flex items-center gap-1">
                        <button class="btn btn-secondary btn-sm" onclick="moveSort(${index}, -1)" ${index === 0 ? 'disabled' : ''}></button>
                        <button class="btn btn-secondary btn-sm" onclick="moveSort(${index}, 1)" ${index === view.sorts.length - 1 ? 'disabled' : ''}></button>
                        <button class="btn btn-danger btn-sm" onclick="removeSortRule(${index})"></button>
                    </div>
                </div>
            `).join('');
        }

        function addSortRule() {
            const set = getCurrentSet();
            const view = getCurrentView();
            if (!set || !view) return;

            const defaultField = set.schema[0]?.id || '';
            view.sorts.push({ fieldId: defaultField, direction: 'asc' });
            renderSortBuilder();
        }

        function updateSortField(index, fieldId) {
            const view = getCurrentView();
            if (!view) return;
            view.sorts[index].fieldId = fieldId;
            renderSortBuilder();
        }

        function updateSortDirection(index, direction) {
            const view = getCurrentView();
            if (!view) return;
            view.sorts[index].direction = direction;
            renderSortBuilder();
        }

        function moveSort(index, delta) {
            const view = getCurrentView();
            if (!view) return;
            const newIndex = index + delta;
            if (newIndex < 0 || newIndex >= view.sorts.length) return;
            const [item] = view.sorts.splice(index, 1);
            view.sorts.splice(newIndex, 0, item);
            renderSortBuilder();
        }

        function removeSortRule(index) {
            const view = getCurrentView();
            if (!view) return;
            view.sorts.splice(index, 1);
            renderSortBuilder();
        }

        function clearSorts() {
            const view = getCurrentView();
            if (!view) return;
            view.sorts = [];
            renderSortBuilder();
            renderCurrentView();
        }

        function applySortsFromModal() {
            closeModal('sortModal');
            renderCurrentView();
        }

        function setGroupOperator(groupIndex, operator) {
            const view = getCurrentView();
            view.filters[groupIndex].operator = operator;
            renderFilterBuilder();
        }

        function addFilterRule(groupIndex) {
            const view = getCurrentView();
            view.filters[groupIndex].push({ field: '', operator: 'equals', value: '' });
            renderFilterBuilder();
        }

        function removeFilterRule(groupIndex, ruleIndex) {
            const view = getCurrentView();
            view.filters[groupIndex].splice(ruleIndex, 1);
            if (view.filters[groupIndex].length === 0) view.filters.splice(groupIndex, 1);
            renderFilterBuilder();
        }

        function addFilterGroup() {
            const view = getCurrentView();
            view.filters.push([{ field: '', operator: 'equals', value: '' }]);
            renderFilterBuilder();
        }

        function removeFilterGroup(groupIndex) {
            const view = getCurrentView();
            view.filters.splice(groupIndex, 1);
            renderFilterBuilder();
        }

        function updateFilterField(groupIndex, ruleIndex, fieldId) {
            const view = getCurrentView();
            view.filters[groupIndex][ruleIndex].field = fieldId;
            renderFilterBuilder();
        }

        function updateFilterValue(groupIndex, ruleIndex, value) {
            const view = getCurrentView();
            view.filters[groupIndex][ruleIndex].value = value;
        }

        function applyFilters() {
            closeModal('filterModal');
            renderCurrentView();
            showToast(' Filters applied');
        }

        function clearFilters() {
            const view = getCurrentView();
            view.filters = [[{ field: '', operator: 'equals', value: '' }]];
            renderFilterBuilder();
        }

        // EXPANDED RECORD
        function openExpandedRecord(recordId) {
            const set = getCurrentSet();
            const record = set.records.get(recordId);
            state.currentRecordTab = 'history';
            state.recordHistoryVisible = true;
            document.getElementById('expandedRecordTitle').textContent = record.name || record.id;
            renderExpandedRecordMain(recordId);
            renderRecordSidebar(recordId);
            updateRecordHistoryVisibility();
            openModal('expandedRecordModal');
        }

        function openCellHistory(recordId, fieldId) {
            const set = getCurrentSet();
            const record = set.records.get(recordId);
            const field = set.schema.find(f => f.id === fieldId);
            const modal = document.getElementById('cellHistoryModal');

            const entries = state.eventStream
                .filter(e => e.op === 'SEG' && e.data?.recordId === recordId && e.data?.fieldId === fieldId)
                .sort((a, b) => new Date(a.published) - new Date(b.published));

            state.cellHistoryContext = {
                recordId,
                fieldId,
                fieldName: field?.name || fieldId,
                recordName: record?.name || recordId,
                entries,
                index: entries.length > 0 ? entries.length - 1 : 0,
                selectedValueSource: 'new'
            };

            renderCellHistoryModal();
            if (modal.classList.contains('hidden')) openModal('cellHistoryModal');
        }

        function renderCellHistoryModal() {
            const container = document.getElementById('cellHistoryContent');
            const title = document.getElementById('cellHistoryTitle');
            const subtitle = document.getElementById('cellHistorySubtitle');
            const ctx = state.cellHistoryContext;

            if (!ctx) return;

            title.textContent = `${ctx.fieldName} history`;
            subtitle.textContent = `Record: ${ctx.recordName}`;

            if (ctx.entries.length === 0) {
                container.innerHTML = '<p class="text-gray-500">No history for this cell yet.</p>';
                return;
            }

            if (ctx.index >= ctx.entries.length) ctx.index = ctx.entries.length - 1;

            const activeEntry = ctx.entries[ctx.index];
            const selectedValue = ctx.selectedValueSource === 'old'
                ? activeEntry.data?.oldValue
                : activeEntry.data?.newValue;

            container.innerHTML = `
                <div class="flex items-center justify-between mb-4">
                    <div class="text-sm text-gray-600">${ctx.entries.length} change${ctx.entries.length === 1 ? '' : 's'} found</div>
                    <div class="flex items-center gap-2">
                        <button class="btn btn-secondary btn-sm" ${ctx.index === 0 ? 'disabled' : ''} onclick="stepCellHistory(-1)"> Prev</button>
                        <button class="btn btn-secondary btn-sm" ${ctx.index >= ctx.entries.length - 1 ? 'disabled' : ''} onclick="stepCellHistory(1)">Next </button>
                    </div>
                </div>
                <div class="space-y-3 mb-4">
                    ${ctx.entries.map((entry, i) => `
                        <div class="border rounded-lg p-3 ${i === ctx.index ? 'border-blue-500 bg-blue-50' : 'border-gray-200 bg-white'}" onclick="selectCellHistoryEntry(${i})">
                            <div class="flex items-center justify-between">
                                <div class="font-medium">${entry.data?.fieldName || ctx.fieldName}</div>
                                <div class="text-xs text-gray-500">${new Date(entry.published).toLocaleString()}</div>
                            </div>
                            <div class="text-sm text-gray-600 mt-1">${entry.data?.summary || 'Updated value'}</div>
                            <div class="text-sm mt-2 flex items-center gap-2">
                                <span class="text-red-600">${entry.data?.oldValue ?? ''}</span>
                                <span></span>
                                <span class="text-green-600">${entry.data?.newValue ?? ''}</span>
                            </div>
                        </div>
                    `).join('')}
                </div>
                <div class="border-t pt-4">
                    <div class="flex items-center gap-3 flex-wrap">
                        <span class="text-sm text-gray-700">Apply value from selected change:</span>
                        <div class="flex items-center gap-2">
                            <button class="btn btn-secondary btn-sm ${ctx.selectedValueSource === 'old' ? 'bg-gray-200' : ''}" onclick="chooseHistoryValue('old')">Use old value</button>
                            <button class="btn btn-secondary btn-sm ${ctx.selectedValueSource === 'new' ? 'bg-gray-200' : ''}" onclick="chooseHistoryValue('new')">Use new value</button>
                        </div>
                        <button class="btn btn-primary btn-sm" onclick="applySelectedHistoricalValue()">Apply to cell</button>
                    </div>
                    <div class="mt-2 text-sm text-gray-600">Selected value preview: <span class="font-semibold text-gray-900">${selectedValue ?? ''}</span></div>
                </div>
            `;
        }

        function selectCellHistoryEntry(index) {
            if (!state.cellHistoryContext) return;
            state.cellHistoryContext.index = index;
            renderCellHistoryModal();
        }

        function stepCellHistory(direction) {
            if (!state.cellHistoryContext || state.cellHistoryContext.entries.length === 0) return;
            const newIndex = Math.min(Math.max(state.cellHistoryContext.index + direction, 0), state.cellHistoryContext.entries.length - 1);
            state.cellHistoryContext.index = newIndex;
            renderCellHistoryModal();
        }

        function chooseHistoryValue(source) {
            if (!state.cellHistoryContext) return;
            state.cellHistoryContext.selectedValueSource = source;
            renderCellHistoryModal();
        }

        function applySelectedHistoricalValue() {
            const ctx = state.cellHistoryContext;
            if (!ctx || ctx.entries.length === 0) return;

            const entry = ctx.entries[ctx.index];
            const selectedValue = ctx.selectedValueSource === 'old'
                ? entry.data?.oldValue
                : entry.data?.newValue;

            const set = getCurrentSet();
            const record = set.records.get(ctx.recordId);
            const currentValue = record ? record[ctx.fieldId] : undefined;

            updateRecord(ctx.recordId, ctx.fieldId, selectedValue, currentValue);

            if (!document.getElementById('expandedRecordModal').classList.contains('hidden')) {
                renderExpandedRecordMain(ctx.recordId);
                renderRecordSidebar(ctx.recordId);
            }

            openCellHistory(ctx.recordId, ctx.fieldId);
        }

        function ensurePopupRule(fieldId) {
            const view = getCurrentView();
            if (!view) return null;
            view.popupVisibilityRules = view.popupVisibilityRules || [];
            let rule = view.popupVisibilityRules.find(r => r.fieldId === fieldId);
            if (!rule) {
                rule = { fieldId, visibility: 'show', criteria: { type: 'always', value: '' } };
                view.popupVisibilityRules.push(rule);
            }
            return rule;
        }

        function evaluatePopupCriteria(criteria, value) {
            if (!criteria || criteria.type === 'always') return true;

            switch (criteria.type) {
                case 'equals':
                    return String(value ?? '').toLowerCase() === String(criteria.value ?? '').toLowerCase();
                case 'notEquals':
                    return String(value ?? '').toLowerCase() !== String(criteria.value ?? '').toLowerCase();
                case 'contains':
                    return String(value ?? '').toLowerCase().includes(String(criteria.value ?? '').toLowerCase());
                case 'empty':
                    return value === undefined || value === null || value === '';
                case 'notEmpty':
                    return !(value === undefined || value === null || value === '');
                default:
                    return true;
            }
        }

        function refreshOpenRecordModal() {
            const container = document.getElementById('expandedRecordMain');
            const recordId = container?.dataset?.recordId;
            if (recordId && !document.getElementById('expandedRecordModal').classList.contains('hidden')) {
                renderExpandedRecordMain(recordId);
            }
        }

        function shouldDisplayFieldInPopup(field, record) {
            const view = getCurrentView();
            if (!view) return true;
            view.popupVisibilityRules = view.popupVisibilityRules || [];
            const rule = view.popupVisibilityRules.find(r => r.fieldId === field.id);
            if (!rule) return true;

            const criteriaMet = evaluatePopupCriteria(rule.criteria, record[field.id]);
            if (!rule.criteria || criteriaMet) {
                return rule.visibility !== 'hide';
            }

            return true;
        }

        function renderExpandedRecordMain(recordId) {
            const set = getCurrentSet();
            const view = getCurrentView();
            const record = set.records.get(recordId);
            const container = document.getElementById('expandedRecordMain');
            container.dataset.recordId = recordId;

            const orderedFields = view ? getPopupOrderedFields(set, view) : set.schema;
            const visibleFields = orderedFields.filter(field => shouldDisplayFieldInPopup(field, record));

            container.innerHTML = visibleFields.length === 0
                ? '<p class="text-gray-500">No fields are visible in this modal based on the current view settings.</p>'
                : `
                <div class="space-y-4">
                    ${visibleFields.map(field => `
                        <div class="field-editor">
                            <label class="form-label">${field.name}</label>
                            ${renderFieldEditor(recordId, field, record[field.id])}
                        </div>
                    `).join('')}
                </div>
            `;
        }

        function renderFieldEditor(recordId, field, value) {
            switch(field.type) {
                case 'TEXT': case 'EMAIL': case 'URL': case 'PHONE':
                    return `<input type="text" value="${value || ''}" onchange="updateRecordField('${recordId}', '${field.id}', this.value)">`;
                case 'LONG_TEXT':
                    return `<textarea rows="4" onchange="updateRecordField('${recordId}', '${field.id}', this.value)">${value || ''}</textarea>`;
                case 'NUMBER': case 'CURRENCY':
                    return `<input type="number" value="${value || 0}" onchange="updateRecordField('${recordId}', '${field.id}', parseFloat(this.value))">`;
                case 'DATE':
                    return `<input type="date" value="${value || ''}" onchange="updateRecordField('${recordId}', '${field.id}', this.value)">`;
                case 'CHECKBOX':
                    return `<input type="checkbox" ${value ? 'checked' : ''} onchange="updateRecordField('${recordId}', '${field.id}', this.checked)">`;
                case 'LINK_RECORD': {
                    const linkedSet = getLinkedSet(field);
                    const options = createLinkedRecordOptionList(field);
                    const disableSelect = !linkedSet || options.length === 0;
                    const selectId = `linked-record-select-${recordId}-${field.id}`;
                    const optionsDataAttr = encodeURIComponent(JSON.stringify(options));
                    const hint = !linkedSet
                        ? '<p class="text-xs text-gray-500 mt-1">Configure a linked set to enable selection.</p>'
                        : options.length === 0
                            ? '<p class="text-xs text-gray-500 mt-1">Add records to the linked set to select one.</p>'
                            : '';

                    return `
                        <div class="space-y-1">
                            <input type="text" class="border rounded px-3 py-2 text-sm w-full" placeholder="Search linked records..." ${!linkedSet ? 'disabled' : ''} oninput="filterLinkedRecordSelect('${selectId}', this.value)">
                            <select id="${selectId}" class="border rounded px-3 py-2 text-sm w-full" data-options="${optionsDataAttr}" ${disableSelect ? 'disabled' : ''} onchange="updateRecordField('${recordId}', '${field.id}', this.value)">
                                <option value="">Select a record</option>
                                ${options.map(opt => `<option value="${opt.id}" ${opt.id === value ? 'selected' : ''}>${opt.label}</option>`).join('')}
                            </select>
                            ${hint}
                        </div>
                    `;
                }
                case 'SINGLE_SELECT':
                    return `<select onchange="updateRecordField('${recordId}', '${field.id}', this.value)">
                        <option value="">Select...</option>
                        ${field.config.options.map(opt => `<option value="${opt}" ${opt === value ? 'selected' : ''}>${opt}</option>`).join('')}
                    </select>`;
                default:
                    return `<input type="text" value="${value || ''}" onchange="updateRecordField('${recordId}', '${field.id}', this.value)">`;
            }
        }

        function updateRecordField(recordId, fieldId, value) {
            const set = getCurrentSet();
            const record = set.records.get(recordId);
            const oldValue = record[fieldId];
            updateRecord(recordId, fieldId, value, oldValue);
            renderExpandedRecordMain(recordId);
        }

        function switchRecordTab(tab) {
            state.currentRecordTab = tab;
            const recordId = document.getElementById('expandedRecordMain').dataset.recordId;
            renderExpandedRecordMain(recordId);
            renderRecordSidebar(recordId);
            updateRecordHistoryVisibility();
        }

        function renderRecordSidebar(recordId) {
            const container = document.getElementById('expandedRecordSidebar');
            document.querySelectorAll('.record-tab').forEach(t => {
                t.classList.toggle('active', t.dataset.tab === state.currentRecordTab);
            });

            if (!container) return;

            switch (state.currentRecordTab) {
                case 'connections':
                    renderConnectionsSidebar(container, recordId);
                    break;
                case 'history':
                default:
                    renderHistorySidebar(container, recordId);
                    break;
            }
        }

        function renderHistorySidebar(container, recordId) {
            const history = state.eventStream.filter(e => e.object?.id === recordId && e.op === 'SEG');
            container.innerHTML = `
                <h3 class="font-semibold mb-4">Change History</h3>
                ${history.length === 0 ? '<p class="text-gray-500">No changes yet</p>' : ''}
                ${history.map(e => `
                    <div class="history-entry">
                        <div class="font-medium">${e.data?.fieldName || 'Field change'}</div>
                        <div class="text-sm text-gray-500">${getTimeAgo(e.published)}</div>
                        <div class="text-sm mt-1">
                            <span class="text-red-600">${e.data?.oldValue}</span> 
                            <span class="text-green-600">${e.data?.newValue}</span>
                        </div>
                    </div>
                `).join('')}
            `;
        }

        function getConnectionBuilder() {
            if (!state.connectionBuilder) {
                state.connectionBuilder = { targetSetId: null, targetRecordId: '', metadataJson: '', searchQuery: '' };
            }
            return state.connectionBuilder;
        }

        function renderConnectionsSidebar(container, recordId) {
            const builder = getConnectionBuilder();
            const setEntries = Array.from(state.sets.entries());
            const selectedSetId = builder.targetSetId && state.sets.has(builder.targetSetId)
                ? builder.targetSetId
                : (setEntries[0]?.[0] || null);
            if (builder.targetSetId !== selectedSetId) builder.targetSetId = selectedSetId;

            const selectedSet = selectedSetId ? state.sets.get(selectedSetId) : null;
            const allAvailableRecords = selectedSet ? Array.from(selectedSet.records.values()).filter(r => r.id !== recordId) : [];
            const search = builder.searchQuery?.trim().toLowerCase() || '';
            const availableRecords = search
                ? allAvailableRecords.filter(rec => (rec.name || rec.id || '').toLowerCase().includes(search) || rec.id.toLowerCase().includes(search))
                : allAvailableRecords;
            const selectedRecordId = availableRecords.some(rec => rec.id === builder.targetRecordId) ? builder.targetRecordId : '';
            if (builder.targetRecordId !== selectedRecordId) builder.targetRecordId = selectedRecordId;

            const metadataText = builder.metadataJson || '';
            const connections = Array.from(state.connections.values()).filter(edge => edge.sourceId === recordId || edge.targetId === recordId);

            container.innerHTML = `
                <div class="space-y-4">
                    <div>
                        <h3 class="font-semibold">Connections</h3>
                        <p class="text-sm text-gray-600">Link this record to other records.</p>
                    </div>
                    <div class="border border-gray-200 bg-white rounded-lg p-4 space-y-3">
                        <label class="form-label">Select set</label>
                        <select id="newConnectionSet" class="border rounded px-3 py-2 text-sm w-full" onchange="handleConnectionSetChange('${recordId}', this.value)">
                            ${setEntries.length === 0 ? '<option value="">No sets available</option>' : ''}
                            ${setEntries.map(([id, set]) => `<option value="${id}" ${id === selectedSetId ? 'selected' : ''}>${set.name || id}</option>`).join('')}
                        </select>
                        <label class="form-label">Search records</label>
                        <input
                            type="text"
                            class="border rounded px-3 py-2 text-sm w-full"
                            placeholder="Search by name or ID"
                            value="${builder.searchQuery || ''}"
                            oninput="handleConnectionSearchChange('${recordId}', this.value)"
                            ${!selectedSetId ? 'disabled' : ''}
                        />
                        <label class="form-label">Connect to</label>
                        <select id="newConnectionTarget" class="border rounded px-3 py-2 text-sm w-full" onchange="handleConnectionRecordChange('${recordId}', this.value)" ${!selectedSetId ? 'disabled' : ''}>
                            <option value="">${selectedSetId ? 'Select a record' : 'Select a set first'}</option>
                            ${availableRecords.length === 0 && selectedSetId ? `<option value="" disabled>${allAvailableRecords.length === 0 ? 'No records available' : 'No matches found'}</option>` : ''}
                            ${availableRecords.map(rec => `<option value="${rec.id}" ${rec.id === selectedRecordId ? 'selected' : ''}>${rec.name || rec.id}</option>`).join('')}
                        </select>
                        <label class="form-label">Parameters (JSON object)</label>
                        <textarea id="newConnectionMetadata" class="border rounded px-3 py-2 text-sm w-full h-24" placeholder="{\"role\": \"depends-on\"}" oninput="updateConnectionBuilderMetadata('${recordId}', this.value)">${metadataText}</textarea>
                        <button class="btn btn-primary btn-sm" onclick="createConnectionFromSidebar('${recordId}')" ${(availableRecords.length === 0 || !selectedRecordId) ? 'disabled' : ''}>Add Connection</button>
                        ${availableRecords.length === 0
                            ? `<p class="text-xs text-gray-500">${allAvailableRecords.length === 0 ? 'Add records to the selected set to create connections.' : 'No records match your search.'}</p>`
                            : ''}
                    </div>
                    <div class="space-y-3">
                        ${connections.length === 0 ? '<p class="text-gray-500">No connections yet.</p>' : connections.map(edge => renderConnectionCard(edge, recordId)).join('')}
                    </div>
                </div>
            `;
        }

        function handleConnectionSetChange(recordId, setId) {
            const builder = getConnectionBuilder();
            builder.targetSetId = setId || null;
            builder.targetRecordId = '';
            builder.searchQuery = '';
            renderRecordSidebar(recordId);
        }

        function handleConnectionRecordChange(recordId, targetId) {
            const builder = getConnectionBuilder();
            builder.targetRecordId = targetId || '';
            renderRecordSidebar(recordId);
        }

        function handleConnectionSearchChange(recordId, query) {
            const builder = getConnectionBuilder();
            builder.searchQuery = query;
            builder.targetRecordId = '';
            renderRecordSidebar(recordId);
        }

        function updateConnectionBuilderMetadata(recordId, value) {
            const builder = getConnectionBuilder();
            builder.metadataJson = value;
        }

        function renderConnectionCard(edge, recordId) {
            const isSource = edge.sourceId === recordId;
            const otherId = isSource ? edge.targetId : edge.sourceId;
            const otherName = getRecordDisplayName(otherId);
            const direction = isSource ? '' : '';
            const timestamp = edge.updatedAt || edge.createdAt;

            return `
                <div class="border border-gray-200 rounded-lg p-3 bg-white">
                    <div class="flex items-center justify-between gap-3">
                        <div>
                            <div class="font-semibold">${direction} ${otherName}</div>
                            <div class="text-xs text-gray-500">${isSource ? 'Source' : 'Target'}  ${timestamp ? getTimeAgo(timestamp) : ''}</div>
                        </div>
                        <div class="flex items-center gap-3">
                            <button class="text-sm text-blue-600" onclick="editConnectionParameters('${edge.id}', '${recordId}')">Edit parameters</button>
                            <button class="text-sm text-red-500" onclick="deleteConnectionFromSidebar('${edge.id}', '${recordId}')">Remove</button>
                        </div>
                    </div>
                    <div class="mt-2">
                        <div class="text-xs font-semibold text-gray-600 mb-1">Parameters</div>
                        ${renderConnectionMetadata(edge.metadata)}
                    </div>
                </div>
            `;
        }

        function renderConnectionMetadata(metadata) {
            if (!metadata || !Object.keys(metadata).length) {
                return '<p class="text-xs text-gray-500">No parameters</p>';
            }

            return `<dl class="text-xs text-gray-700 space-y-1">
                ${Object.entries(metadata).map(([key, value]) => `
                    <div class="flex justify-between gap-2">
                        <dt class="font-medium text-gray-600">${key}</dt>
                        <dd class="text-right break-all text-gray-800">${typeof value === 'object' ? JSON.stringify(value) : value}</dd>
                    </div>
                `).join('')}
            </dl>`;
        }

        function parseConnectionMetadata(raw) {
            if (!raw || !raw.trim()) return {};

            let parsed;
            try {
                parsed = JSON.parse(raw);
            } catch (err) {
                throw new Error('Connection parameters must be valid JSON');
            }

            if (parsed === null || typeof parsed !== 'object' || Array.isArray(parsed)) {
                throw new Error('Connection parameters must be a JSON object');
            }

            return parsed;
        }

        function editConnectionParameters(connectionId, recordId) {
            const existing = state.connections.get(connectionId);
            if (!existing) {
                showToast('Connection not found');
                return;
            }

            const currentJson = JSON.stringify(existing.metadata || {}, null, 2);
            const input = prompt('Edit connection parameters (JSON object)', currentJson);
            if (input === null) return;

            let parsed;
            try {
                parsed = parseConnectionMetadata(input);
            } catch (err) {
                showToast(err.message);
                return;
            }

            updateConnection(connectionId, { metadata: parsed });
            renderRecordSidebar(recordId);
            showToast(' Parameters updated');
        }

        function getRecordDisplayName(recordId) {
            const ref = getRecordById(recordId);
            return ref?.record?.name || recordId;
        }

        function openLinkedRecord(recordId) {
            if (!recordId) return;
            const ref = getRecordById(recordId);
            if (!ref) {
                showToast('Linked record not found');
                return;
            }

            const firstViewId = ref.set.views.size ? Array.from(ref.set.views.keys())[0] : null;
            if (ref.setId !== state.currentSetId) {
                switchSet(ref.setId, firstViewId);
            }
            openExpandedRecord(recordId);
        }

        function createConnectionFromSidebar(recordId) {
            const builder = getConnectionBuilder();
            const target = builder.targetRecordId || document.getElementById('newConnectionTarget')?.value;
            if (!target) {
                showToast('Select a record to connect');
                return;
            }

            const rawMetadata = document.getElementById('newConnectionMetadata')?.value || builder.metadataJson || '';
            let metadata = {};
            try {
                metadata = parseConnectionMetadata(rawMetadata);
            } catch (err) {
                showToast(err.message);
                return;
            }

            builder.targetRecordId = '';
            createConnection(recordId, target, metadata);
            renderRecordSidebar(recordId);
            showToast(' Connection created');
        }

        function deleteConnectionFromSidebar(connectionId, recordId) {
            deleteConnection(connectionId);
            renderRecordSidebar(recordId);
            showToast(' Connection removed');
        }

        function updateRecordHistoryVisibility() {
            const historyColumn = document.getElementById('expandedRecordHistoryColumn');
            const mainWrapper = document.getElementById('expandedRecordMainWrapper');
            const toggleBtn = document.getElementById('toggleHistorySidebarBtn');
            const isVisible = state.recordHistoryVisible;

            if (historyColumn) historyColumn.classList.toggle('hidden', !isVisible);
            if (mainWrapper) {
                mainWrapper.classList.toggle('md:col-span-3', !isVisible);
                mainWrapper.classList.toggle('md:col-span-2', isVisible);
                mainWrapper.classList.toggle('border-r', isVisible);
            }
            if (toggleBtn) {
                toggleBtn.disabled = false;
                toggleBtn.textContent = state.recordHistoryVisible ? 'Hide History' : 'Show History';
            }
        }

        function toggleRecordHistoryVisibility() {
            state.recordHistoryVisible = !state.recordHistoryVisible;
            updateRecordHistoryVisibility();
        }

        function getPopupLayout(view) {
            view.popupLayout = view.popupLayout || { size: 'medium', columns: 2 };
            return view.popupLayout;
        }

        function getPopupOrderedFields(set, view) {
            const defaultOrder = set.schema.map(f => f.id);
            view.popupFieldOrder = Array.isArray(view.popupFieldOrder) && view.popupFieldOrder.length
                ? view.popupFieldOrder
                : defaultOrder;
            const orderMap = new Map(view.popupFieldOrder.map((id, idx) => [id, idx]));
            return [...set.schema].sort((a, b) => {
                const aIndex = orderMap.has(a.id) ? orderMap.get(a.id) : Number.MAX_SAFE_INTEGER;
                const bIndex = orderMap.has(b.id) ? orderMap.get(b.id) : Number.MAX_SAFE_INTEGER;
                return aIndex - bIndex;
            });
        }

        function renderPopupSettings(targetIds = ['popupSettingsFields', 'popupSettingsSidebar']) {
            const popupModal = document.getElementById('popupSettingsModal');
            const modalOpen = popupModal && !popupModal.classList.contains('hidden');
            if (modalOpen) {
                renderPopupConfigurator();
            }
            renderInlinePopupSettings(targetIds);
        }

        function renderInlinePopupSettings(targetIds = ['popupSettingsFields']) {
            const set = getCurrentSet();
            const view = getCurrentView();
            if (!set || !view) return;

            view.popupVisibilityRules = view.popupVisibilityRules || [];
            const fields = getPopupOrderedFields(set, view);
            const popupSettingsHtml = fields.map(field => {
                const rule = view.popupVisibilityRules.find(r => r.fieldId === field.id) || { visibility: 'show', criteria: { type: 'always', value: '' } };
                const criteriaType = rule.criteria?.type || 'always';
                const criteriaValue = rule.criteria?.value || '';
                const needsValue = ['equals', 'notEquals', 'contains'].includes(criteriaType);

                return `
                    <div class="border border-gray-200 rounded-lg p-4">
                        <div class="flex items-center justify-between gap-4 flex-wrap">
                            <div>
                                <div class="font-semibold text-gray-900">${field.name}</div>
                                <div class="text-sm text-gray-500">${field.type}</div>
                            </div>
                            <div class="flex items-center gap-3 flex-wrap">
                                <label class="text-sm text-gray-600 flex items-center gap-2">
                                    Visibility
                                    <select class="border rounded px-2 py-1" onchange="updatePopupVisibilityRule('${field.id}', this.value)">
                                        <option value="show" ${rule.visibility !== 'hide' ? 'selected' : ''}>Show</option>
                                        <option value="hide" ${rule.visibility === 'hide' ? 'selected' : ''}>Hide</option>
                                    </select>
                                </label>
                                <label class="text-sm text-gray-600 flex items-center gap-2">
                                    Criteria
                                    <select class="border rounded px-2 py-1" onchange="updatePopupCriteriaType('${field.id}', this.value)">
                                        <option value="always" ${criteriaType === 'always' ? 'selected' : ''}>Always</option>
                                        <option value="equals" ${criteriaType === 'equals' ? 'selected' : ''}>Value equals</option>
                                        <option value="notEquals" ${criteriaType === 'notEquals' ? 'selected' : ''}>Value not equal</option>
                                        <option value="contains" ${criteriaType === 'contains' ? 'selected' : ''}>Value contains</option>
                                        <option value="empty" ${criteriaType === 'empty' ? 'selected' : ''}>When empty</option>
                                        <option value="notEmpty" ${criteriaType === 'notEmpty' ? 'selected' : ''}>When not empty</option>
                                    </select>
                                </label>
                                <input
                                    type="text"
                                    class="border rounded px-3 py-1 text-sm ${needsValue ? '' : 'opacity-50'}"
                                    placeholder="Criteria value"
                                    value="${criteriaValue}"
                                    ${needsValue ? '' : 'disabled'}
                                    oninput="updatePopupCriteriaValue('${field.id}', this.value)">
                            </div>
                        </div>
                    </div>
                `;
            }).join('');

            const targets = Array.isArray(targetIds) ? targetIds : [targetIds];
            targets.forEach(id => {
                const container = document.getElementById(id);
                if (container) container.innerHTML = popupSettingsHtml;
            });
        }

        function openPopupSettingsModal() {
            state.popupUi = state.popupUi || { filter: 'all', activeTab: 'popupFields' };
            state.popupUi.filter = state.popupUi.filter || 'all';
            state.popupUi.activeTab = 'popupFields';
            renderPopupConfigurator();
            openModal('popupSettingsModal');
        }

        function updatePopupVisibilityRule(fieldId, visibility) {
            const rule = ensurePopupRule(fieldId);
            if (!rule) return;
            rule.visibility = visibility;
            logPopupEvent('visibility', { fieldId, visibility });
            renderPopupSettings();
            refreshOpenRecordModal();
        }

        function updatePopupCriteriaType(fieldId, type) {
            const rule = ensurePopupRule(fieldId);
            if (!rule) return;
            rule.criteria = rule.criteria || { type: 'always', value: '' };
            rule.criteria.type = type;
            if (!['equals', 'notEquals', 'contains'].includes(type)) {
                rule.criteria.value = '';
            }
            renderPopupSettings();
            logPopupEvent('criteriaType', { fieldId, type });
            refreshOpenRecordModal();
        }

        function updatePopupCriteriaValue(fieldId, value) {
            const rule = ensurePopupRule(fieldId);
            if (!rule) return;
            rule.criteria = rule.criteria || { type: 'always', value: '' };
            rule.criteria.value = value;
            logPopupEvent('criteriaValue', { fieldId, value });
            renderPopupSettings();
            refreshOpenRecordModal();
        }

        function setPopupTab(tab) {
            state.popupUi.activeTab = tab;
            document.querySelectorAll('.popup-config-tab').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.tab === tab);
            });
            document.querySelectorAll('.popup-tab-panel').forEach(panel => {
                panel.classList.toggle('active', panel.id === tab);
            });
            renderPopupConfigurator();
        }

        function setPopupFilter(filter) {
            state.popupUi.filter = filter;
            renderPopupConfigurator();
        }

        function renderPopupFilters() {
            const filters = [
                { id: 'all', label: 'All Fields' },
                { id: 'visible', label: ' Visible' },
                { id: 'hidden', label: ' Hidden' },
                { id: 'conditional', label: ' Conditional' }
            ];
            const container = document.getElementById('popupFilters');
            if (!container) return;
            container.innerHTML = filters.map(f => `
                <button class="popup-filter ${state.popupUi.filter === f.id ? 'active' : ''}" onclick="setPopupFilter('${f.id}')">${f.label}</button>
            `).join('');
        }

        function togglePopupFieldVisibility(fieldId) {
            const rule = ensurePopupRule(fieldId);
            if (!rule) return;
            const newVisibility = rule.visibility === 'hide' ? 'show' : 'hide';
            updatePopupVisibilityRule(fieldId, newVisibility);
        }

        function renderPopupFieldList() {
            const set = getCurrentSet();
            const view = getCurrentView();
            if (!set || !view) return;
            view.popupVisibilityRules = view.popupVisibilityRules || [];

            const fields = getPopupOrderedFields(set, view).filter(field => {
                const rule = view.popupVisibilityRules.find(r => r.fieldId === field.id);
                const isVisible = !rule || rule.visibility !== 'hide';
                const hasCondition = rule?.criteria?.type && rule.criteria.type !== 'always';
                if (state.popupUi.filter === 'visible') return isVisible;
                if (state.popupUi.filter === 'hidden') return !isVisible;
                if (state.popupUi.filter === 'conditional') return hasCondition;
                return true;
            });

            const container = document.getElementById('popupFieldList');
            if (!container) return;

            container.innerHTML = fields.map(field => {
                const rule = view.popupVisibilityRules.find(r => r.fieldId === field.id);
                const isVisible = !rule || rule.visibility !== 'hide';
                const hasCondition = rule?.criteria?.type && rule.criteria.type !== 'always';
                const typeMeta = FIELD_TYPES[field.type] || {};
                const typeLabel = typeMeta.name || field.type;
                return `
                    <div class="popup-field-card" draggable="true" data-field-id="${field.id}">
                        <div class="drag-handle"></div>
                        <div class="popup-field-icon">${renderIcon(typeMeta.icon || 'ph-app-window')}</div>
                        <div class="popup-field-meta">
                            <div class="popup-field-name">
                                ${field.name}
                                ${hasCondition ? '<span class="popup-badge warn">Conditional</span>' : ''}
                                ${!isVisible ? '<span class="popup-badge warn">Hidden</span>' : ''}
                            </div>
                            <div class="popup-field-type field-type">${typeLabel}</div>
                        </div>
                        <div class="flex items-center gap-2">
                            <div class="popup-toggle ${isVisible ? 'active' : ''}" onclick="togglePopupFieldVisibility('${field.id}')"></div>
                            <button class="btn btn-secondary btn-sm" onclick="focusPopupCondition('${field.id}')"><i class="ph ph-sliders-horizontal"></i></button>
                        </div>
                    </div>
                `;
            }).join('');

            const popupFieldCountBadge = document.getElementById('popupFieldCountBadge');
            if (popupFieldCountBadge) popupFieldCountBadge.textContent = fields.length;
            attachPopupFieldDragHandlers();
        }

        function attachPopupFieldDragHandlers() {
            document.querySelectorAll('.popup-field-card').forEach(card => {
                card.addEventListener('dragstart', handlePopupFieldDragStart);
                card.addEventListener('dragover', handlePopupFieldDragOver);
                card.addEventListener('drop', handlePopupFieldDrop);
                card.addEventListener('dragend', handlePopupFieldDragEnd);
            });
        }

        function handlePopupFieldDragStart(e) {
            state.popupDraggedField = e.currentTarget.dataset.fieldId;
            e.currentTarget.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
        }

        function handlePopupFieldDragOver(e) {
            e.preventDefault();
            const target = e.currentTarget;
            if (state.popupDraggedField && target.dataset.fieldId !== state.popupDraggedField) {
                target.classList.add('drag-over');
            }
        }

        function handlePopupFieldDrop(e) {
            e.preventDefault();
            const targetId = e.currentTarget.dataset.fieldId;
            if (state.popupDraggedField && targetId && targetId !== state.popupDraggedField) {
                updatePopupFieldOrder(state.popupDraggedField, targetId);
                logPopupEvent('reorder', { from: state.popupDraggedField, to: targetId });
            }
            document.querySelectorAll('.popup-field-card').forEach(el => el.classList.remove('drag-over'));
            state.popupDraggedField = null;
        }

        function handlePopupFieldDragEnd(e) {
            e.currentTarget.classList.remove('dragging');
            document.querySelectorAll('.popup-field-card').forEach(el => el.classList.remove('drag-over'));
            state.popupDraggedField = null;
        }

        function updatePopupFieldOrder(draggedId, targetId) {
            const set = getCurrentSet();
            const view = getCurrentView();
            if (!set || !view) return;

            const order = getPopupOrderedFields(set, view).map(f => f.id);
            const fromIndex = order.indexOf(draggedId);
            const toIndex = order.indexOf(targetId);
            if (fromIndex === -1 || toIndex === -1) return;

            order.splice(fromIndex, 1);
            order.splice(toIndex, 0, draggedId);
            view.popupFieldOrder = order;
            renderPopupConfigurator();
        }

        function renderPopupStats() {
            const set = getCurrentSet();
            const view = getCurrentView();
            if (!set || !view) return;
            view.popupVisibilityRules = view.popupVisibilityRules || [];
            const fields = getPopupOrderedFields(set, view);
            const visibleCount = fields.reduce((count, field) => {
                const rule = view.popupVisibilityRules.find(r => r.fieldId === field.id);
                return count + ((rule && rule.visibility === 'hide') ? 0 : 1);
            }, 0);
            const conditionalCount = view.popupVisibilityRules.filter(r => r.criteria?.type && r.criteria.type !== 'always').length;
            const popupVisibleCount = document.getElementById('popupVisibleCount');
            const popupConditionalCount = document.getElementById('popupConditionalCount');
            if (popupVisibleCount) popupVisibleCount.textContent = visibleCount;
            if (popupConditionalCount) popupConditionalCount.textContent = conditionalCount;
        }

        function renderPopupPreview() {
            const set = getCurrentSet();
            const view = getCurrentView();
            if (!set || !view) return;
            const layout = getPopupLayout(view);
            const preview = document.getElementById('popupPreview');
            if (!preview) return;

            const record = Array.from(set.records.values())[0] || {};
            const fields = getPopupOrderedFields(set, view).filter(field => shouldDisplayFieldInPopup(field, record)).slice(0, 9);

            preview.innerHTML = `
                <div class="popup-preview-header">
                    <span>Record Preview</span>
                    <span class="popup-pill">${layout.size}  ${layout.columns} columns</span>
                </div>
                <div class="popup-preview-fields cols-${layout.columns}">
                    ${fields.map(field => `
                        <div class="popup-preview-field">
                            <div class="label">${field.name}</div>
                            <div class="value">${record[field.id] ?? ''}</div>
                        </div>
                    `).join('')}
                </div>
            `;
        }

        function renderPopupLayoutOptions() {
            const view = getCurrentView();
            if (!view) return;
            const layout = getPopupLayout(view);

            const sizeOptions = [
                { id: 'small', label: 'Small', desc: 'Compact width' },
                { id: 'medium', label: 'Medium', desc: 'Balanced width' },
                { id: 'large', label: 'Large', desc: 'Full dialog' }
            ];
            const sizeContainer = document.getElementById('popupSizeOptions');
            if (sizeContainer) {
                sizeContainer.innerHTML = sizeOptions.map(opt => `
                    <div class="popup-layout-option ${layout.size === opt.id ? 'active' : ''}" onclick="updatePopupSize('${opt.id}')">
                        <div class="font-semibold">${opt.label}</div>
                        <div class="text-sm text-gray-600">${opt.desc}</div>
                    </div>
                `).join('');
            }

            const columnContainer = document.getElementById('popupColumnOptions');
            if (columnContainer) {
                columnContainer.innerHTML = [1, 2, 3].map(cols => `
                    <div class="popup-layout-option ${layout.columns === cols ? 'active' : ''}" onclick="updatePopupColumns(${cols})">
                        <div class="font-semibold">${cols} Column${cols > 1 ? 's' : ''}</div>
                        <div class="text-sm text-gray-600">${cols === 1 ? 'Single stack' : cols === 2 ? 'Split view' : 'Dense grid'}</div>
                    </div>
                `).join('');
            }
        }

        function updatePopupSize(size) {
            const view = getCurrentView();
            if (!view) return;
            const layout = getPopupLayout(view);
            layout.size = size;
            logPopupEvent('size', { size });
            renderPopupConfigurator();
        }

        function updatePopupColumns(columns) {
            const view = getCurrentView();
            if (!view) return;
            const layout = getPopupLayout(view);
            layout.columns = columns;
            logPopupEvent('columns', { columns });
            renderPopupConfigurator();
        }

        function renderPopupConditions() {
            const set = getCurrentSet();
            const view = getCurrentView();
            if (!set || !view) return;
            view.popupVisibilityRules = view.popupVisibilityRules || [];
            const container = document.getElementById('popupConditionsList');
            if (!container) return;

            const fields = getPopupOrderedFields(set, view);
            container.innerHTML = fields.map(field => {
                const rule = view.popupVisibilityRules.find(r => r.fieldId === field.id) || { visibility: 'show', criteria: { type: 'always', value: '' } };
                const criteriaType = rule.criteria?.type || 'always';
                const needsValue = ['equals', 'notEquals', 'contains'].includes(criteriaType);
                return `
                    <div class="popup-condition-card" data-condition-field="${field.id}">
                        <div class="popup-condition-title">${field.name} <span class="popup-pill">${rule.visibility === 'hide' ? 'Hidden' : 'Shown'}</span></div>
                        <div class="popup-condition-row">
                            <label class="text-sm text-gray-600 flex items-center gap-2">Visibility
                                <select class="border rounded px-2 py-2 text-sm" onchange="updatePopupVisibilityRule('${field.id}', this.value)">
                                    <option value="show" ${rule.visibility !== 'hide' ? 'selected' : ''}>Show</option>
                                    <option value="hide" ${rule.visibility === 'hide' ? 'selected' : ''}>Hide</option>
                                </select>
                            </label>
                            <label class="text-sm text-gray-600 flex items-center gap-2">Criteria
                                <select class="border rounded px-2 py-2 text-sm" onchange="updatePopupCriteriaType('${field.id}', this.value)">
                                    <option value="always" ${criteriaType === 'always' ? 'selected' : ''}>Always</option>
                                    <option value="equals" ${criteriaType === 'equals' ? 'selected' : ''}>Value equals</option>
                                    <option value="notEquals" ${criteriaType === 'notEquals' ? 'selected' : ''}>Value not equal</option>
                                    <option value="contains" ${criteriaType === 'contains' ? 'selected' : ''}>Value contains</option>
                                    <option value="empty" ${criteriaType === 'empty' ? 'selected' : ''}>When empty</option>
                                    <option value="notEmpty" ${criteriaType === 'notEmpty' ? 'selected' : ''}>When not empty</option>
                                </select>
                            </label>
                            <input class="border rounded px-3 py-2 text-sm ${needsValue ? '' : 'opacity-50'}" placeholder="Criteria value" value="${rule.criteria?.value || ''}" ${needsValue ? '' : 'disabled'} oninput="updatePopupCriteriaValue('${field.id}', this.value)">
                        </div>
                    </div>
                `;
            }).join('');
        }

        function renderPopupEvents() {
            const container = document.getElementById('popupEventStream');
            if (!container) return;
            if (state.popupEventStream.length === 0) {
                container.innerHTML = '<p class="text-sm text-gray-600">No recent configuration changes yet.</p>';
                return;
            }
            container.innerHTML = state.popupEventStream.map(evt => `
                <div class="popup-event">
                    <div class="popup-event-header">
                        <span>${evt.type}</span>
                        <span class="popup-event-time">${new Date(evt.timestamp).toLocaleTimeString()}</span>
                    </div>
                    <div class="text-sm text-gray-600">${describePopupEvent(evt)}</div>
                </div>
            `).join('');
        }

        function describePopupEvent(event) {
            const name = event.data?.fieldId ? getFieldNameById(event.data.fieldId) : '';
            switch (event.action) {
                case 'visibility':
                    return `${name || 'Field'} set to ${event.data.visibility}`;
                case 'criteriaType':
                    return `${name || 'Field'} criteria: ${event.data.type}`;
                case 'criteriaValue':
                    return `${name || 'Field'} criteria value updated`;
                case 'reorder':
                    return `Reordered fields (${event.data.from}  ${event.data.to})`;
                case 'size':
                    return `Modal size changed to ${event.data.size}`;
                case 'columns':
                    return `Layout updated to ${event.data.columns} columns`;
                case 'template':
                    return `Applied ${event.data.template} template`;
                default:
                    return event.type;
            }
        }

        function renderPopupRecentChanges() {
            const container = document.getElementById('popupRecentChanges');
            if (!container) return;
            const items = state.popupEventStream.slice(0, 4);
            container.innerHTML = items.length === 0
                ? '<p class="text-sm text-gray-500">No changes yet.</p>'
                : items.map(evt => `<div> ${describePopupEvent(evt)}</div>`).join('');
        }

        function logPopupEvent(action, data = {}) {
            const entry = { id: Date.now(), action, data, type: action, timestamp: new Date().toISOString() };
            state.popupEventStream.unshift(entry);
            state.popupEventStream = state.popupEventStream.slice(0, 25);
            renderPopupEvents();
            renderPopupRecentChanges();
        }

        function resetPopupLayout() {
            const set = getCurrentSet();
            const view = getCurrentView();
            if (!set || !view) return;
            view.popupLayout = { size: 'medium', columns: 2 };
            view.popupFieldOrder = set.schema.map(f => f.id);
            view.popupVisibilityRules = [];
            logPopupEvent('reset', {});
            renderPopupConfigurator();
            refreshOpenRecordModal();
        }

        function applyPopupTemplate(template) {
            const set = getCurrentSet();
            const view = getCurrentView();
            if (!set || !view) return;
            const ordered = getPopupOrderedFields(set, view);
            const layout = getPopupLayout(view);

            if (template === 'minimal') {
                layout.size = 'small';
                layout.columns = 1;
                view.popupVisibilityRules = ordered.map((field, idx) => ({ fieldId: field.id, visibility: idx < 4 ? 'show' : 'hide', criteria: { type: 'always', value: '' } }));
            } else if (template === 'detailed') {
                layout.size = 'large';
                layout.columns = 3;
                view.popupVisibilityRules = ordered.map(field => ({ fieldId: field.id, visibility: 'show', criteria: { type: 'always', value: '' } }));
            } else if (template === 'compact') {
                layout.size = 'medium';
                layout.columns = 2;
                view.popupVisibilityRules = ordered.map((field, idx) => ({ fieldId: field.id, visibility: idx < 6 ? 'show' : 'hide', criteria: { type: 'always', value: '' } }));
            }
            logPopupEvent('template', { template });
            renderPopupConfigurator();
            refreshOpenRecordModal();
        }

        function focusPopupCondition(fieldId) {
            setPopupTab('popupConditions');
            requestAnimationFrame(() => {
                const el = document.querySelector(`[data-condition-field="${fieldId}"]`);
                if (el) el.scrollIntoView({ behavior: 'smooth', block: 'center' });
            });
        }

        function getFieldNameById(fieldId) {
            const set = getCurrentSet();
            return set?.schema.find(f => f.id === fieldId)?.name || fieldId;
        }

        function renderPopupConfigurator() {
            const activeTab = state.popupUi?.activeTab || 'popupFields';
            document.querySelectorAll('.popup-config-tab').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.tab === activeTab);
            });
            document.querySelectorAll('.popup-tab-panel').forEach(panel => {
                panel.classList.toggle('active', panel.id === activeTab);
            });
            renderPopupFilters();
            renderPopupFieldList();
            renderPopupStats();
            renderPopupLayoutOptions();
            renderPopupPreview();
            renderPopupConditions();
            renderPopupEvents();
            renderPopupRecentChanges();
        }

        // CONTEXT MENUS
        function showColumnMenu(e, field) {
            showContextMenu(e, [
                { label: 'Hide Field', action: () => hideField(field.id) },
                { label: 'Delete Field', action: () => confirmDelete('field', field.id), danger: true }
            ]);
        }

        function showCellMenu(e, recordId, field) {
            showContextMenu(e, [
                { label: 'Open Cell History', action: () => openCellHistory(recordId, field.id) }
            ]);
        }

        function showContextMenu(e, items) {
            const menu = document.createElement('div');
            menu.className = 'context-menu';
            menu.style.top = `${e.clientY}px`;
            menu.style.left = `${e.clientX}px`;
            menu.innerHTML = items.map(item => `<div class="context-menu-item ${item.danger ? 'danger' : ''}">${item.label}</div>`).join('');
            menu.querySelectorAll('.context-menu-item').forEach((el, i) => {
                el.onclick = () => { items[i].action(); menu.remove(); };
            });
            document.body.appendChild(menu);
            setTimeout(() => {
                document.addEventListener('click', function close() { menu.remove(); document.removeEventListener('click', close); });
            }, 0);
        }

        function confirmDelete(type, id) {
            const messages = {
                field: 'Delete this field? This will remove data from all records.',
                record: 'Delete this record? This cannot be undone.'
            };
            showConfirm(messages[type], () => {
                if (type === 'field') deleteField(id);
                if (type === 'record') deleteRecord(id);
            });
        }

        function showConfirm(message, callback) {
            document.getElementById('confirmMessage').textContent = message;
            state.confirmCallback = callback;
            openModal('confirmModal');
        }

        function registerInterpretationRule(rule, options = {}) {
            const normalizedRule = {
                rule_id: rule.rule_id || `rule_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`,
                applies_to_op: rule.applies_to_op || null,
                description: rule.description || '',
                effect: rule.effect || 'none',
                frame: rule.frame || 'system',
                scale: rule.scale || 'system'
            };

            state.interpretationRules.push(normalizedRule);

            if (!options.skipEvent) {
                createEvent(
                    'Define Rule',
                    'REC',
                    { type: 'InterpretationRule', id: normalizedRule.rule_id },
                    { rule: normalizedRule, summary: normalizedRule.description },
                    { frame: normalizedRule.frame, scale: normalizedRule.scale }
                );
            }

            return normalizedRule;
        }

        function hideField(fieldId) {
            const view = getCurrentView();
            if (!view.hiddenFields.includes(fieldId)) view.hiddenFields.push(fieldId);
            renderCurrentView();
            showToast(' Field hidden');
        }

        function deleteField(fieldId) {
            const set = getCurrentSet();
            const fieldIndex = set.schema.findIndex(f => f.id === fieldId);
            if (fieldIndex === -1) return;
            const [field] = set.schema.splice(fieldIndex, 1);
            set.records.forEach(record => delete record[fieldId]);
            createEvent(
                'Delete Field',
                'NUL',
                { type: 'Field', id: fieldId, setId: set.id },
                { setId: set.id, fieldId, fieldName: field?.name, summary: `Deleted field ${field?.name || fieldId}` },
                { frame: 'schema', scale: 'collection' }
            );
            renderCurrentView();
            showToast(' Field deleted');
        }

        function deleteRecord(recordId) {
            const set = getCurrentSet();
            set.records.delete(recordId);
            createEvent(
                'Delete Record',
                'NUL',
                { type: 'Record', id: recordId, setId: set.id },
                { setId: set.id, recordId, summary: 'Record deleted' }
            );
            renderCurrentView();
            showToast(' Record deleted');
        }

        // UTILITIES
        function applyInterpretationRules(event) {
            const appliedRules = [];

            state.interpretationRules.forEach(rule => {
                if (rule.applies_to_op && rule.applies_to_op !== event.op) return;

                switch (rule.effect) {
                    case 'require_actor':
                        if (!event.actor || !event.actor.id) throw new Error('Events require an actor');
                        appliedRules.push(rule.rule_id);
                        break;
                    case 'require_object_id':
                        if (!event.object || !event.object.id) throw new Error('Operations require an object reference with an id');
                        appliedRules.push(rule.rule_id);
                        break;
                    case 'require_connection_endpoints':
                        if (!event.data?.sourceId || !event.data?.targetId) throw new Error('Connections require both sourceId and targetId');
                        appliedRules.push(rule.rule_id);
                        break;
                    case 'mark_deleted':
                        event.data = { ...event.data, deleted: true };
                        appliedRules.push(rule.rule_id);
                        break;
                    default:
                        break;
                }
            });

            return { ...event, appliedRules };
        }

        function createEvent(verb, op, object, data = {}, options = {}) {
            if (!state.operatorSet[op]) {
                throw new Error(`Invalid operator ${op}. Expected one of ${Object.keys(state.operatorSet).join(', ')}`);
            }

            const eventData = { ...data };

            if (options.summary && !eventData.summary) {
                eventData.summary = options.summary;
            }

            const event = {
                id: `event-${state.eventIdCounter++}`,
                verb: verb,
                op: op,
                frame: options.frame || 'ui',
                scale: options.scale || 'object',
                published: new Date().toISOString(),
                actor: { type: state.currentUser.type, id: state.currentUser.id },
                object: object,
                data: eventData
            };

            const interpretedEvent = applyInterpretationRules(event);
            state.eventStream.unshift(interpretedEvent);
            return interpretedEvent;
        }

        function getTimeAgo(timestamp) {
            const seconds = Math.floor((new Date() - new Date(timestamp)) / 1000);
            if (seconds < 60) return 'just now';
            if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
            if (seconds < 86400) return `${Math.floor(seconds / 3600)}h ago`;
            return `${Math.floor(seconds / 86400)}d ago`;
        }

        function showToast(message) {
            const toast = document.createElement('div');
            toast.className = 'toast';
            toast.innerHTML = `
                <div class="flex items-center gap-3">
                    <svg class="w-5 h-5 text-green-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>
                    </svg>
                    <span class="font-medium">${message}</span>
                </div>
            `;
            document.body.appendChild(toast);
            setTimeout(() => toast.remove(), 3000);
        }

        function closeAllContextMenus() {
            document.querySelectorAll('.context-menu').forEach(menu => menu.remove());
        }

        function closeAllModals(exceptId = null) {
            const remaining = [];
            state.modalStack.forEach(id => {
                if (id === exceptId) {
                    remaining.push(id);
                    return;
                }

                const modalEl = document.getElementById(id);
                if (modalEl) modalEl.classList.add('hidden');
            });
            state.modalStack = remaining;
        }

        function openModal(modalId) {
            closeAllContextMenus();
            closeAllModals(modalId);

            const modal = document.getElementById(modalId);
            if (!modal) return;

            modal.classList.remove('hidden');
            if (!state.modalStack.includes(modalId)) {
                state.modalStack.push(modalId);
            }
        }

        function closeModal(modalId) {
            closeAllContextMenus();
            const modal = document.getElementById(modalId);
            if (modal) modal.classList.add('hidden');
            state.modalStack = state.modalStack.filter(id => id !== modalId);
        }

        function exportJSON() {
            const data = {
                sets: Array.from(state.sets.values()).map(s => ({
                    ...s,
                    records: Array.from(s.records.values()),
                    views: Array.from(s.views.values()),
                    profiles: Array.from(s.profiles.values())
                })),
                connections: Array.from(state.connections.values()),
                eventStream: state.eventStream
            };
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'workbase-export.json';
            a.click();
            URL.revokeObjectURL(url);
            showToast(' Exported data');
        }

        function renderHistory() {
            const container = document.getElementById('historyContent');
            container.innerHTML = state.eventStream.map(e => `
                <div class="history-entry">
                    <div class="font-medium">${e.verb} <span class="text-xs text-gray-500">(${e.op})</span></div>
                    <div class="text-sm text-gray-500">${getTimeAgo(e.published)}  Frame: ${e.frame}  Scale: ${e.scale}</div>
                    <div class="text-sm">${e.data?.summary || e.verb}</div>
                    ${e.appliedRules?.length ? `<div class="text-xs text-gray-400">Rules: ${e.appliedRules.join(', ')}</div>` : ''}
                </div>
            `).join('');
        }

        // EVENT LISTENERS
        function setupEventListeners() {
            const fieldTypeTrigger = document.getElementById('fieldTypeTrigger');
            if (fieldTypeTrigger) fieldTypeTrigger.onclick = (event) => { event.preventDefault(); toggleFieldTypeDropdown(); };

            document.getElementById('addRecordBtn').onclick = () => {
                const set = getCurrentSet();
                const record = { id: `rec_${Date.now()}` };
                set.schema.forEach(f => record[f.id] = FIELD_TYPES[f.type].defaultValue);
                set.records.set(record.id, record);
                renderCurrentView();
                showToast(' Record added');
            };
            document.getElementById('addFieldBtn').onclick = openAddFieldModal;
            document.getElementById('filterBtn').onclick = openFilterModal;
            document.getElementById('sortBtn').onclick = openSortModal;
            document.getElementById('popupSettingsBtn').onclick = openPopupSettingsModal;
            document.getElementById('historyBtn').onclick = () => {
                document.getElementById('historyPanel').classList.add('open');
                renderHistory();
            };
            document.getElementById('viewJsonBtn').onclick = openJsonViewer;
            document.getElementById('exportBtn').onclick = exportJSON;
            document.getElementById('importCsvBtn').onclick = openCsvImportModal;
            document.getElementById('parseCsvTextBtn').onclick = previewCsvFromText;
            document.getElementById('csvFileInput').onchange = handleCsvFileSelected;
            document.getElementById('refreshCsvPreviewBtn').onclick = renderCsvPreview;
            document.getElementById('runCsvImportBtn').onclick = importCsvRecords;
            document.getElementById('cancelCsvImportBtn').onclick = () => closeModal('csvImportModal');
            document.getElementById('closeCsvImportBtn').onclick = () => closeModal('csvImportModal');
            document.getElementById('fuzzyPanelBtn').onclick = openFuzzyPanel;
            document.getElementById('closeFuzzyPanelBtn').onclick = closeFuzzyPanel;
            document.getElementById('refreshFuzzyMatchesBtn').onclick = renderFuzzyPanel;
            document.getElementById('fuzzyThresholdInput').oninput = renderFuzzyPanel;
            document.getElementById('closeHistoryBtn').onclick = () => document.getElementById('historyPanel').classList.remove('open');
            document.getElementById('toggleHistorySidebarBtn').onclick = toggleRecordHistoryVisibility;
            document.getElementById('closeExpandedRecordBtn').onclick = () => closeModal('expandedRecordModal');
            bindIconSelector('newSetIcon');
            bindIconSelector('newViewIcon');
            document.getElementById('closeIconPickerBtn').onclick = () => closeModal('iconPickerModal');
            document.getElementById('iconPickerSearch').oninput = (event) => {
                state.iconPickerQuery = event.target.value;
                renderIconPickerOptions();
            };
            document.getElementById('closeFilterBtn').onclick = () => closeModal('filterModal');
            document.getElementById('closePopupSettingsBtn').onclick = () => closeModal('popupSettingsModal');
            document.getElementById('applyFiltersBtn').onclick = applyFilters;
            document.getElementById('clearFiltersBtn').onclick = clearFilters;
            document.getElementById('addFilterGroupBtn').onclick = addFilterGroup;
            document.getElementById('confirmCancelBtn').onclick = () => {
                state.confirmCallback = null;
                closeModal('confirmModal');
            };
            document.getElementById('confirmOkBtn').onclick = () => {
                if (state.confirmCallback) state.confirmCallback();
                state.confirmCallback = null;
                closeModal('confirmModal');
            };
          document.getElementById('addSortRuleBtn').onclick = addSortRule;
          document.getElementById('clearSortsBtn').onclick = clearSorts;
          document.getElementById('applySortsBtn').onclick = applySortsFromModal;
          document.getElementById('closeSortBtn').onclick = () => closeModal('sortModal');
          const fieldNameInput = document.getElementById('newFieldName');
          if (fieldNameInput) fieldNameInput.addEventListener('input', resetFieldNameValidation);
          document.getElementById('saveAddFieldBtn').onclick = saveField;
          document.getElementById('cancelAddFieldBtn').onclick = () => closeModal('addFieldModal');
          document.getElementById('closeAddFieldBtn').onclick = () => closeModal('addFieldModal');
            document.getElementById('saveAddSetBtn').onclick = () => {
                const name = document.getElementById('newSetName').value.trim();
                const icon = extractIconToken(document.getElementById('newSetIcon').value.trim() || 'ph-squares-four');
                if (!name) { showConfirm('Please enter a set name', () => {}); return; }
                if (state.setEditorContext?.setId) {
                    const set = state.sets.get(state.setEditorContext.setId);
                    set.name = name;
                    set.icon = icon;
                    closeModal('addSetModal');
                    state.setEditorContext = null;
                    renderSidebar();
                    renderCurrentView();
                    showToast(' Set updated');
                } else {
                    const setId = createSet(name, icon);
                    closeModal('addSetModal');
                    document.getElementById('newSetName').value = '';
                    document.getElementById('newSetIcon').value = 'ph-squares-four';
                    syncIconSelector('newSetIcon');
                    createView(setId, 'All ' + name, { type: 'grid' });
                    state.expandedSets.add(setId);
                    renderSidebar();
                    switchSet(setId, null);
                    showToast(' Set created');
                }
            };
            document.getElementById('cancelAddSetBtn').onclick = () => { state.setEditorContext = null; closeModal('addSetModal'); };
            document.getElementById('saveAddViewBtn').onclick = () => {
                const name = document.getElementById('newViewName').value.trim();
                const icon = extractIconToken(document.getElementById('newViewIcon').value.trim() || 'ph-table');
                const parentId = document.getElementById('newViewParent').value || null;
                if (!name) { showConfirm('Please enter a view name', () => {}); return; }
                const set = state.sets.get(state.viewEditorContext?.setId || state.currentSetId);
                const setId = set?.id;
                if (!setId) return;
                if (state.viewEditorContext?.viewId && parentId && isViewDescendant(set, parentId, state.viewEditorContext.viewId)) {
                    showConfirm('You cannot nest a view under its own descendant.', () => {});
                    return;
                }

                if (state.viewEditorContext?.viewId) {
                    const view = set.views.get(state.viewEditorContext.viewId);
                    if (view) {
                        view.name = name;
                        view.icon = icon;
                        view.parentId = parentId;
                    }
                    closeModal('addViewModal');
                    state.viewEditorContext = null;
                    renderSidebar();
                    switchSet(setId, view?.id || state.currentViewId);
                    showToast(' View updated');
                } else {
                    const viewId = createView(setId, name, { type: 'grid', icon, parentId });
                    closeModal('addViewModal');
                    document.getElementById('newViewName').value = '';
                    document.getElementById('newViewIcon').value = 'ph-table';
                    syncIconSelector('newViewIcon');
                    state.viewEditorContext = null;
                    renderSidebar();
                    switchSet(setId, viewId);
                    showToast(' View created');
                }
            };
            document.getElementById('cancelAddViewBtn').onclick = () => { state.viewEditorContext = null; closeModal('addViewModal'); };
            document.getElementById('saveKanbanConfigBtn').onclick = saveKanbanConfig;
            document.getElementById('cancelKanbanConfigBtn').onclick = () => closeModal('kanbanConfigModal');
            document.getElementById('closeJsonViewerBtn').onclick = () => closeModal('jsonViewerModal');
            document.getElementById('copyJsonBtn').onclick = copyJsonToClipboard;
        }

        document.addEventListener('click', (event) => {
            const selector = document.querySelector('.field-type-select');
            if (!selector) return;
            if (!selector.contains(event.target)) closeFieldTypeDropdown();
        });

        // JSON VIEWER
        let currentJsonTab = 'all';
        
        function openJsonViewer() {
            currentJsonTab = 'all';
            renderJsonContent();
            openModal('jsonViewerModal');
        }
        
        function switchJsonTab(tab) {
            currentJsonTab = tab;
            document.querySelectorAll('.json-tab').forEach(t => t.classList.remove('active'));
            document.querySelector(`.json-tab[data-tab="${tab}"]`).classList.add('active');
            renderJsonContent();
        }
        
        function renderJsonContent() {
            let data;
            
            switch(currentJsonTab) {
                case 'all':
                    data = {
                        sets: Array.from(state.sets.values()).map(s => ({
                            ...s,
                            records: Array.from(s.records.values()),
                            views: Array.from(s.views.values()),
                            profiles: Array.from(s.profiles.values())
                        })),
                        connections: Array.from(state.connections.values()),
                        eventStream: state.eventStream,
                        operatorSet: state.operatorSet,
                        interpretationRules: state.interpretationRules,
                        currentSetId: state.currentSetId,
                        currentViewId: state.currentViewId
                    };
                    break;
                case 'sets':
                    data = Array.from(state.sets.values()).map(s => ({
                        id: s.id,
                        name: s.name,
                        icon: s.icon,
                        schema: s.schema,
                        recordCount: s.records.size,
                        viewCount: s.views.size,
                        records: Array.from(s.records.values()),
                        views: Array.from(s.views.values())
                    }));
                    break;
                case 'current':
                    const set = getCurrentSet();
                    const setRecordIds = set ? new Set(Array.from(set.records.keys())) : new Set();
                    data = set ? {
                        id: set.id,
                        name: set.name,
                        icon: set.icon,
                        schema: set.schema,
                        records: Array.from(set.records.values()),
                        views: Array.from(set.views.values()),
                        profiles: Array.from(set.profiles.values()),
                        connections: Array.from(state.connections.values()).filter(edge => setRecordIds.has(edge.sourceId) || setRecordIds.has(edge.targetId))
                    } : null;
                    break;
                case 'events':
                    data = state.eventStream;
                    break;
            }
            
            const jsonString = JSON.stringify(data, null, 2);
            const highlighted = syntaxHighlight(jsonString);
            document.getElementById('jsonContent').innerHTML = highlighted;
        }
        
        function syntaxHighlight(json) {
            json = json.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
            return json.replace(/("(\\u[a-zA-Z0-9]{4}|\\[^u]|[^\\"])*"(\s*:)?|\b(true|false|null)\b|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?)/g, function (match) {
                let cls = 'json-number';
                if (/^"/.test(match)) {
                    if (/:$/.test(match)) {
                        cls = 'json-key';
                    } else {
                        cls = 'json-string';
                    }
                } else if (/true|false/.test(match)) {
                    cls = 'json-boolean';
                } else if (/null/.test(match)) {
                    cls = 'json-null';
                }
                return '<span class="' + cls + '">' + match + '</span>';
            });
        }
        
        function copyJsonToClipboard() {
            const content = document.getElementById('jsonContent').textContent;
            navigator.clipboard.writeText(content).then(() => {
                const btn = document.getElementById('copyJsonBtn');
                const originalText = btn.textContent;
                btn.textContent = ' Copied!';
                btn.classList.add('btn-primary');
                btn.classList.remove('btn-secondary');
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.classList.remove('btn-primary');
                    btn.classList.add('btn-secondary');
                }, 2000);
            }).catch(err => {
                showToast(' Failed to copy');
            });
        }

        function setupKeyboardShortcuts() {
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    if (state.editingCell) {
                        exitEditMode(false);
                        return;
                    }

                    if (state.selectedCell) {
                        state.selectedCell.td.classList.remove('cell-selected');
                        state.selectedCell = null;
                        state.lastSelectedCell = null;
                        return;
                    }

                    const openMenus = document.querySelectorAll('.context-menu');
                    if (openMenus.length) {
                        openMenus.forEach(menu => menu.remove());
                        return;
                    }

                    if (state.modalStack.length > 0) {
                        closeModal(state.modalStack[state.modalStack.length - 1]);
                    }
                }

                if (e.key === 'Enter' && state.selectedCell && !state.editingCell) {
                    e.preventDefault();
                    const { td, recordId, fieldId } = state.selectedCell;
                    const set = getCurrentSet();
                    const field = set?.schema.find(f => f.id === fieldId);
                    if (field) enterEditMode(td, recordId, field);
                }

                if (e.key === 'Tab' && state.selectedCell && !state.editingCell) {
                    e.preventDefault();
                    navigateToNextCell(e.shiftKey ? -1 : 1);
                }
            });
        }

        function navigateToNextCell(direction) {
            if (!state.selectedCell) return;

            const currentTd = state.selectedCell.td;
            const row = currentTd.parentElement;
            const cells = Array.from(row.querySelectorAll('.cell-editable'));
            const currentIndex = cells.indexOf(currentTd);

            const nextIndex = currentIndex + direction;
            if (nextIndex >= 0 && nextIndex < cells.length) {
                const nextTd = cells[nextIndex];
                const recordId = nextTd.dataset.recordId;
                const fieldId = nextTd.dataset.fieldId;
                selectCell(nextTd, recordId, fieldId);
                return;
            }

            const tbody = row.parentElement;
            const rows = Array.from(tbody.querySelectorAll('tr'));
            const rowIndex = rows.indexOf(row);
            const nextRowIndex = direction > 0 ? rowIndex + 1 : rowIndex - 1;

            if (nextRowIndex >= 0 && nextRowIndex < rows.length) {
                const nextRow = rows[nextRowIndex];
                const targetIndex = direction > 0 ? 0 : cells.length - 1;
                const nextTd = nextRow.querySelectorAll('.cell-editable')[targetIndex];
                if (nextTd) {
                    const recordId = nextTd.dataset.recordId;
                    const fieldId = nextTd.dataset.fieldId;
                    selectCell(nextTd, recordId, fieldId);
                }
            }
        }

        function openAddSetModal(setId = null) {
            const titleEl = document.getElementById('addSetModalTitle');
            const saveBtn = document.getElementById('saveAddSetBtn');
            const nameInput = document.getElementById('newSetName');
            const iconInput = document.getElementById('newSetIcon');

            if (setId) {
                const set = state.sets.get(setId);
                state.setEditorContext = { setId };
                if (titleEl) titleEl.textContent = 'Edit Set';
                if (saveBtn) saveBtn.textContent = 'Save';
                if (nameInput) nameInput.value = set?.name || '';
                if (iconInput) iconInput.value = extractIconToken(set?.icon || 'ph-squares-four');
            } else {
                state.setEditorContext = null;
                if (titleEl) titleEl.textContent = 'Create Set';
                if (saveBtn) saveBtn.textContent = 'Create';
                if (nameInput) nameInput.value = '';
                if (iconInput) iconInput.value = 'ph-squares-four';
            }
            syncIconSelector('newSetIcon');
            openModal('addSetModal');
        }

        // INITIALIZE
        document.addEventListener('DOMContentLoaded', initializeApp);
    </script>
</body>
</html>
