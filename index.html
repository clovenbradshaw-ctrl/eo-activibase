<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EO - Enhanced Database</title>
    <link id="dynamicFavicon" rel="icon" type="image/svg+xml" href="assets/eo-icons/eo-bracket-light.svg">
    <link id="dynamicAppleIcon" rel="apple-touch-icon" href="assets/eo-icons/eo-bracket-light.svg">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/@phosphor-icons/web"></script>
    <!-- Removed unused libraries: vis-network, React, ReactDOM, Chart.js - saves ~150MB memory -->
    <script src="https://cdn.sheetjs.com/xlsx-0.20.1/package/dist/xlsx.full.min.js"></script>

    <!-- EO Foundation Layer - Load first for core utilities -->
    <script defer src="foundation/eo_constants.js"></script>
    <script defer src="foundation/eo_identity.js"></script>
    <script defer src="foundation/eo_registry.js"></script>
    <script defer src="foundation/eo_operator_executor.js"></script>
    <script defer src="foundation/eo_absence.js"></script>
    <script defer src="foundation/eo_segmentation.js"></script>
    <script defer src="foundation/eo_alternation.js"></script>
    <script defer src="foundation/eo_recursion.js"></script>
    <script defer src="foundation/eo_modal_base.js"></script>

    <!-- EO Core Modules -->
    <script defer src="eo_graph.js"></script>
    <script defer src="eo_lean_context.js"></script>
    <script defer src="eo_provenance_extractor.js"></script>
    <script defer src="eo_view_management.js"></script>
    <script defer src="eo_layout_management.js"></script>
    <script defer src="demo/eo_atomic_operators.js"></script>
    <script defer src="demo/eo_function_builder.js"></script>
    <script defer src="demo/eo_function_builder_ui.js"></script>
    <script defer src="demo/eo_rollup_engine.js"></script>
    <script defer src="demo/eo_linked_fields_modal.js"></script>
    <script defer src="demo/eo_link_column_modal.js"></script>
    <script defer src="demo/eo_linked_record_editor.js"></script>
    <script defer src="demo/eo_cell_profile_card.js"></script>
    <script defer src="demo/eo_type_detector.js"></script>
    <script defer src="demo/eo_import_manager.js"></script>
    <script defer src="demo/eo_file_explorer.js"></script>
    <script defer src="demo/eo_data_maturity.js"></script>
    <script defer src="eo_content_store.js"></script>
    <script defer src="eo_deduplication_ui.js"></script>
    <script defer src="demo/eo_import_integration.js"></script>
    <script defer src="demo/eo_toss_pile.js"></script>
    <script defer src="demo/eo_toss_pile_ui.js"></script>
    <script defer src="demo/eo_set_management.js"></script>
    <script defer src="demo/eo_column_width_settings.js"></script>
    <script defer src="demo/eo_relations_manager.js"></script>
    <script defer src="demo/eo_available_fields_explorer.js"></script>
    <script defer src="demo/eo_datetime_field.js"></script>
    <script defer src="demo/eo_custom_dropdown.js"></script>
    <script defer src="demo/eo_inline_cell_editor.js"></script>
    <link rel="stylesheet" href="demo/eo_custom_dropdown.css">
    <link rel="stylesheet" href="demo/eo_linked_fields_modal.css">
    <link rel="stylesheet" href="demo/eo_link_column_modal.css">
    <link rel="stylesheet" href="demo/eo_datetime_field.css">
    <link rel="stylesheet" href="demo/eo_available_fields_explorer.css">
    <link rel="stylesheet" href="demo/eo_file_explorer.css">
    <link rel="stylesheet" href="demo/eo_data_maturity.css">
    <link rel="stylesheet" href="demo/eo_toss_pile.css">
    <link rel="stylesheet" href="demo/eo_set_management.css">
    <link rel="stylesheet" href="demo/eo_column_width_settings.css">
    <link rel="stylesheet" href="demo/eo_relations_manager.css">
    <link rel="stylesheet" href="eo_workbench_styles.css">
    <style>
        :root {
            --primary: #111827;
            --primary-dark: #0f172a;
            --surface: #ffffff;
            --muted-surface: #f4f5f7;
            --border: #e5e7eb;
            --border-strong: #0f172a;
            --text: #0b1324;
            --text-secondary: #4b5563;
            --sidebar-width: 260px;
            --sidebar-collapsed-width: 64px;
            --mobile-padding: 16px;
            --mobile-bottom-bar-height: 72px;
        }

        * { box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            margin: 0;
            background: var(--muted-surface);
            color: var(--text);
        }

        .mobile-topbar {
            display: none;
            align-items: center;
            gap: 10px;
            padding: 12px var(--mobile-padding);
            position: sticky;
            top: 0;
            z-index: 50;
            background: var(--surface);
            border-bottom: 1px solid var(--border);
        }

        .mobile-topbar-title {
            font-weight: 700;
            font-size: 16px;
            letter-spacing: -0.01em;
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .mobile-icon-btn {
            width: 40px;
            height: 40px;
            border-radius: 10px;
            border: 1px solid var(--border);
            background: var(--surface);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: var(--text);
        }

        .mobile-bottom-bar {
            display: none;
            position: fixed;
            inset: auto 0 0;
            height: var(--mobile-bottom-bar-height);
            background: var(--surface);
            border-top: 1px solid var(--border);
            z-index: 40;
            padding: 10px var(--mobile-padding);
            grid-template-columns: repeat(4, 1fr) 64px;
            gap: 10px;
            box-shadow: 0 -6px 24px rgba(15, 23, 42, 0.08);
        }

        .mobile-bottom-action {
            display: inline-flex;
            flex-direction: column;
            gap: 6px;
            align-items: center;
            justify-content: center;
            padding: 8px;
            border-radius: 12px;
            border: 1px solid var(--border);
            background: var(--muted-surface);
            color: var(--text-secondary);
            font-size: 12px;
            font-weight: 600;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .mobile-bottom-action.active {
            border-color: var(--primary);
            background: #e0e7ff;
            color: var(--primary);
        }

        .mobile-fab {
            position: fixed;
            right: var(--mobile-padding);
            bottom: calc(var(--mobile-bottom-bar-height) + 12px);
            width: 56px;
            height: 56px;
            border-radius: 50%;
            border: none;
            background: linear-gradient(135deg, #3b82f6, #1d4ed8);
            color: #fff;
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 22px;
            box-shadow: 0 10px 30px rgba(37, 99, 235, 0.35);
            z-index: 45;
            cursor: pointer;
        }

        i.ph {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            line-height: 1;
        }
        
        /* LAYOUT */
        .app-container {
            display: grid;
            grid-template-areas: "sidebar header" "sidebar main";
            grid-template-columns: var(--sidebar-width) 1fr;
            grid-template-rows: auto 1fr;
            height: 100vh;
            transition: grid-template-columns 0.3s ease;
            background: var(--muted-surface);
        }
        .app-container.sidebar-collapsed { grid-template-columns: var(--sidebar-collapsed-width) 1fr; }
        .app-sidebar {
            grid-area: sidebar;
            background: #0f172a;
            color: white;
            border-right: 1px solid #111827;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        .sidebar-content {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
        }
        .sidebar-actions {
            flex-shrink: 0;
            border-top: 1px solid #1e293b;
        }

        /* Sidebar Collapse Button */
        .sidebar-header-row {
            border-bottom: 1px solid #1e293b;
            transition: padding 0.3s ease, justify-content 0.3s ease;
        }
        .sidebar-collapse-btn {
            background: transparent;
            border: 1px solid #334155;
            color: #94a3b8;
            width: 28px;
            height: 28px;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            flex-shrink: 0;
        }
        .sidebar-collapse-btn:hover {
            background: rgba(255,255,255,0.1);
            color: #fff;
            border-color: #475569;
        }
        .sidebar-collapse-btn i {
            font-size: 14px;
            transition: transform 0.3s ease;
        }
        .sidebar-collapsed .sidebar-header-row {
            justify-content: center;
            padding: 1rem 0.5rem;
        }
        .sidebar-collapsed .sidebar-brand {
            display: none;
        }
        .sidebar-collapsed .sidebar-collapse-btn i {
            transform: rotate(180deg);
        }
        .sidebar-collapsed .sidebar-content {
            display: none;
        }
        .sidebar-collapsed .sidebar-actions {
            display: none;
        }

        .app-header {
            grid-area: header;
            background: var(--surface);
            border-bottom: 1px solid var(--border);
            z-index: 10;
        }

        .world-toolbar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            padding: 14px 18px;
            border-bottom: 1px solid var(--border);
        }

        .world-toolbar-info {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .world-pill {
            display: inline-flex;
            align-items: center;
            gap: 10px;
            padding: 8px 12px;
            border-radius: 12px;
            border: 1px solid var(--border);
            background: var(--muted-surface);
            color: var(--text);
            font-weight: 600;
        }

        .world-pill i {
            color: #2563eb;
        }

        .world-toolbar-hint {
            margin: 0;
            color: var(--text-secondary);
            font-size: 13px;
        }

        .world-toolbar-actions {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .world-toolbar-actions .btn-sm {
            min-width: auto;
        }

        /* Global Search Bar - Browser URL Bar Style */
        .global-search-container {
            flex: 1;
            max-width: 600px;
            min-width: 280px;
            position: relative;
        }

        .global-search-bar {
            display: flex;
            align-items: center;
            width: 100%;
            height: 42px;
            padding: 0 14px;
            background: var(--muted-surface);
            border: 1.5px solid var(--border);
            border-radius: 21px;
            transition: all 0.2s ease;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.04);
        }

        .global-search-bar:hover {
            border-color: #cbd5e1;
            background: #ffffff;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
        }

        .global-search-bar:focus-within {
            border-color: #3b82f6;
            background: #ffffff;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.12), 0 2px 8px rgba(0, 0, 0, 0.06);
        }

        .global-search-icon {
            display: flex;
            align-items: center;
            justify-content: center;
            color: #9ca3af;
            font-size: 18px;
            margin-right: 10px;
            transition: color 0.2s ease;
        }

        .global-search-bar:focus-within .global-search-icon {
            color: #3b82f6;
        }

        .global-search-input {
            flex: 1;
            border: none;
            background: transparent;
            font-size: 14px;
            color: var(--text);
            outline: none;
            font-family: inherit;
        }

        .global-search-input::placeholder {
            color: #9ca3af;
        }

        .global-search-shortcut {
            display: flex;
            align-items: center;
            gap: 2px;
            padding: 3px 6px;
            background: #e5e7eb;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
            color: #6b7280;
            margin-left: 8px;
        }

        .global-search-clear {
            display: none;
            align-items: center;
            justify-content: center;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #e5e7eb;
            border: none;
            cursor: pointer;
            color: #6b7280;
            font-size: 12px;
            margin-left: 8px;
            transition: all 0.15s ease;
        }

        .global-search-clear:hover {
            background: #d1d5db;
            color: #374151;
        }

        .global-search-bar.has-value .global-search-clear {
            display: flex;
        }

        .global-search-bar.has-value .global-search-shortcut {
            display: none;
        }

        /* Search Results Dropdown */
        .global-search-results {
            position: absolute;
            top: calc(100% + 8px);
            left: 0;
            right: 0;
            background: #ffffff;
            border: 1px solid var(--border);
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.12), 0 2px 8px rgba(0, 0, 0, 0.06);
            max-height: 480px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
        }

        .global-search-results.active {
            display: block;
        }

        .global-search-results-header {
            padding: 12px 16px 8px;
            font-size: 11px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: #9ca3af;
            border-bottom: 1px solid var(--border);
            background: #f9fafb;
            position: sticky;
            top: 0;
        }

        .global-search-section {
            padding: 8px 0;
        }

        .global-search-section-title {
            padding: 8px 16px 6px;
            font-size: 10px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: #9ca3af;
        }

        .global-search-result-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 16px;
            cursor: pointer;
            transition: background 0.1s ease;
        }

        .global-search-result-item:hover,
        .global-search-result-item.focused {
            background: #f1f5f9;
        }

        .global-search-result-icon {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 32px;
            border-radius: 8px;
            background: #e0e7ff;
            color: #4f46e5;
            font-size: 14px;
            flex-shrink: 0;
        }

        .global-search-result-icon.set { background: #dbeafe; color: #2563eb; }
        .global-search-result-icon.view { background: #fae8ff; color: #a855f7; }
        .global-search-result-icon.record { background: #d1fae5; color: #059669; }
        .global-search-result-icon.field { background: #fef3c7; color: #d97706; }

        .global-search-result-content {
            flex: 1;
            min-width: 0;
        }

        .global-search-result-title {
            font-size: 14px;
            font-weight: 500;
            color: var(--text);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .global-search-result-title mark {
            background: #fef08a;
            color: inherit;
            border-radius: 2px;
            padding: 0 1px;
        }

        .global-search-result-meta {
            font-size: 12px;
            color: #9ca3af;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .global-search-result-badge {
            padding: 3px 8px;
            background: #f3f4f6;
            border-radius: 4px;
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.03em;
            color: #6b7280;
            flex-shrink: 0;
        }

        /* Multi-location result items */
        .global-search-result-item.has-locations {
            position: relative;
        }

        .global-search-result-item.has-locations:hover {
            background: #e0f2fe;
        }

        .global-search-result-item.expanded {
            background: #e0f2fe;
            border-bottom: none;
        }

        .global-search-expand-icon {
            font-size: 12px;
            color: #6b7280;
            transition: transform 0.2s ease;
            flex-shrink: 0;
        }

        .global-search-result-item.expanded .global-search-expand-icon {
            transform: rotate(180deg);
        }

        .global-search-result-locations-badge {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 3px 8px;
            background: #dbeafe;
            border-radius: 4px;
            font-size: 10px;
            font-weight: 600;
            color: #2563eb;
            flex-shrink: 0;
        }

        .global-search-result-locations-badge i {
            font-size: 10px;
        }

        /* Location picker dropdown */
        .global-search-locations {
            display: none;
            background: #f8fafc;
            border-top: 1px solid #e2e8f0;
            padding: 0;
            margin: 0;
        }

        .global-search-locations.expanded {
            display: block;
        }

        .global-search-locations-header {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 16px 8px;
            font-size: 11px;
            font-weight: 600;
            color: #64748b;
            background: #f1f5f9;
        }

        .global-search-locations-header i {
            color: #3b82f6;
        }

        .global-search-locations-list {
            padding: 4px 8px 8px;
        }

        .global-search-location-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 12px;
            margin: 2px 0;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.15s ease;
            font-size: 13px;
            color: #374151;
            background: white;
            border: 1px solid #e5e7eb;
        }

        .global-search-location-item:hover {
            background: #3b82f6;
            color: white;
            border-color: #3b82f6;
        }

        .global-search-location-item i {
            font-size: 14px;
            color: #6b7280;
        }

        .global-search-location-item:hover i {
            color: white;
        }

        .global-search-location-item span:first-of-type {
            flex: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .global-search-location-item .location-type {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.03em;
            padding: 2px 6px;
            background: #f3f4f6;
            border-radius: 3px;
            color: #6b7280;
            flex-shrink: 0;
        }

        .global-search-location-item:hover .location-type {
            background: rgba(255, 255, 255, 0.2);
            color: white;
        }

        /* Search result highlighting */
        .search-highlight {
            background-color: rgba(59, 130, 246, 0.15) !important;
            outline: 2px solid #3b82f6;
            outline-offset: -2px;
            border-radius: 4px;
            position: relative;
            z-index: 1;
        }

        .search-highlight-pulse {
            animation: searchHighlightPulse 0.6s ease-out 3;
        }

        @keyframes searchHighlightPulse {
            0% {
                outline-color: #3b82f6;
                outline-width: 2px;
                background-color: rgba(59, 130, 246, 0.15);
            }
            50% {
                outline-color: #60a5fa;
                outline-width: 4px;
                background-color: rgba(59, 130, 246, 0.3);
            }
            100% {
                outline-color: #3b82f6;
                outline-width: 2px;
                background-color: rgba(59, 130, 246, 0.15);
            }
        }

        /* Highlight for table cells */
        td.search-highlight,
        th.search-highlight {
            background-color: rgba(59, 130, 246, 0.2) !important;
        }

        /* Highlight for table rows */
        tr.search-highlight {
            background-color: rgba(59, 130, 246, 0.1) !important;
        }

        tr.search-highlight td {
            background-color: transparent !important;
        }

        .global-search-empty {
            padding: 32px 16px;
            text-align: center;
            color: #9ca3af;
        }

        .global-search-empty-icon {
            font-size: 32px;
            margin-bottom: 12px;
            opacity: 0.5;
        }

        .global-search-empty-text {
            font-size: 14px;
            margin-bottom: 4px;
        }

        .global-search-empty-hint {
            font-size: 12px;
            opacity: 0.7;
        }

        .global-search-loading {
            padding: 24px 16px;
            text-align: center;
            color: #9ca3af;
        }

        .global-search-loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 2px solid #e5e7eb;
            border-top-color: #3b82f6;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Import Loading Overlay Styles */
        .import-loading-overlay {
            position: absolute;
            inset: 0;
            background: rgba(15, 23, 42, 0.85);
            backdrop-filter: blur(4px);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            opacity: 0;
            transition: opacity 0.2s ease;
            pointer-events: none;
        }

        .import-loading-overlay.visible {
            opacity: 1;
            pointer-events: all;
        }

        .import-loading-spinner {
            width: 48px;
            height: 48px;
            border: 3px solid rgba(255, 255, 255, 0.1);
            border-top-color: #22c55e;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            margin-bottom: 16px;
        }

        .import-loading-text {
            color: #e2e8f0;
            font-size: 15px;
            font-weight: 500;
            margin-bottom: 8px;
        }

        .import-loading-subtext {
            color: #94a3b8;
            font-size: 13px;
        }

        .import-loading-progress {
            width: 200px;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            margin-top: 16px;
            overflow: hidden;
        }

        .import-loading-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #22c55e, #4ade80);
            border-radius: 2px;
            width: 0%;
            transition: width 0.3s ease;
        }

        .import-loading-progress-bar.indeterminate {
            width: 30%;
            animation: indeterminate-progress 1.5s ease-in-out infinite;
        }

        @keyframes indeterminate-progress {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(400%); }
        }

        /* Global Search Responsive Styles */
        @media (max-width: 900px) {
            .global-search-container {
                max-width: 400px;
                min-width: 200px;
            }
        }

        @media (max-width: 768px) {
            .global-search-container {
                max-width: 300px;
                min-width: 160px;
            }
            .global-search-bar {
                height: 38px;
                padding: 0 12px;
            }
            .global-search-input {
                font-size: 13px;
            }
            .global-search-shortcut {
                display: none;
            }
        }

        @media (max-width: 640px) {
            .global-search-container {
                flex: 0 1 auto;
                max-width: none;
                min-width: auto;
            }
            .global-search-bar {
                width: 44px;
                border-radius: 50%;
                padding: 0;
                justify-content: center;
            }
            .global-search-bar .global-search-input,
            .global-search-bar .global-search-clear,
            .global-search-bar .global-search-shortcut {
                display: none;
            }
            .global-search-bar .global-search-icon {
                margin-right: 0;
            }
            .global-search-bar:focus-within {
                width: 100%;
                border-radius: 21px;
                padding: 0 12px;
                position: absolute;
                left: 0;
                right: 0;
                z-index: 100;
            }
            .global-search-bar:focus-within .global-search-input {
                display: block;
            }
            .global-search-bar:focus-within .global-search-icon {
                margin-right: 10px;
            }
            .global-search-bar:focus-within .global-search-clear {
                display: flex;
            }
        }

        /* Mobile search bar in topbar */
        .mobile-search-container {
            flex: 1;
            max-width: 100%;
            position: relative;
            margin: 0 8px;
        }

        .mobile-search-container .global-search-bar {
            width: 100%;
            height: 40px;
        }

        .mobile-search-container .global-search-results {
            position: fixed;
            top: 60px;
            left: 8px;
            right: 8px;
            max-height: calc(100vh - 140px);
        }

        .view-toolbar-note {
            padding: 10px 18px;
            color: var(--text-secondary);
            font-size: 13px;
            border-bottom: 1px solid var(--border);
            background: #f9fafb;
        }
        .app-main {
            grid-area: main;
            overflow: auto;
            background: var(--muted-surface);
            padding: 16px 20px 24px;
        }

        .view-workspace { display: flex; flex-direction: column; gap: 4px; min-height: calc(100vh - 140px); }
        .view-tabs-rail {
            padding: 0 6px 0 6px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .import-tab-btn {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 8px 14px;
            background: linear-gradient(135deg, #10b981, #059669);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.2s;
            white-space: nowrap;
            box-shadow: 0 2px 8px rgba(16, 185, 129, 0.25);
        }
        .import-tab-btn:hover {
            background: linear-gradient(135deg, #059669, #047857);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.35);
        }
        .import-tab-btn i {
            font-size: 16px;
        }
        
        /* SIDEBAR */
        .sidebar-header {
            padding: 18px 16px 18px 20px;
            border-bottom: 1px solid #2a2e38;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
        }
        .sidebar-collapsed .sidebar-header { padding: 18px 10px; justify-content: center; }
        .sidebar-brand-logo {
            width: 52px;
            height: 52px;
            padding: 10px;
            border-radius: 14px;
            background: #0b1020;
            border: 1px solid #1f2937;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 8px 26px rgba(0, 0, 0, 0.2);
            transition: opacity 0.2s, width 0.2s, padding 0.2s, margin 0.2s;
        }
        .sidebar-brand-logo img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            border-radius: 10px;
            background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.12), rgba(255,255,255,0));
        }
        .sidebar-collapsed .sidebar-brand-logo { opacity: 0; width: 0; padding: 0; margin: 0; overflow: hidden; }
        .sidebar-toggle {
            background: transparent;
            border: 1px solid #2f343d;
            color: #e5e7eb;
            padding: 8px;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .sidebar-toggle:hover { background: rgba(255,255,255,0.05); color: #fff; border-color: #fff; }
        .sidebar-section { padding: 16px 12px 12px 12px; display: flex; flex-direction: column; gap: 8px; }
        .sidebar-section.grow { flex: 1; overflow-y: auto; }
        .sidebar-section-title {
            font-size: 11px;
            font-weight: 700;
            text-transform: uppercase;
            color: #6b7280;
            letter-spacing: 0.05em;
            padding: 8px 12px 6px;
            margin-bottom: 6px;
            transition: opacity 0.2s;
        }
        .sidebar-collapsed .sidebar-section-title { opacity: 0; height: 0; overflow: hidden; margin: 0; }

        .world-switcher {
            padding: 12px 12px 0 12px;
            border-bottom: 1px solid #111827;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .world-switcher-row {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .world-badge {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 8px 10px;
            background: rgba(255,255,255,0.04);
            border: 1px solid #1f2937;
            border-radius: 10px;
            color: #e5e7eb;
            flex: 1;
        }

        .world-badge small {
            display: block;
            color: #9ca3af;
            font-size: 11px;
            font-weight: 700;
            letter-spacing: 0.05em;
            text-transform: uppercase;
        }

        .world-actions {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .world-select {
            width: 100%;
            padding: 8px 10px;
            border-radius: 8px;
            border: 1px solid #334155;
            background: #1e293b;
            color: #e5e7eb;
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            outline: none;
            transition: border-color 0.15s ease, background-color 0.15s ease;
        }

        .world-select:hover {
            background: #263549;
            border-color: #475569;
        }

        .world-select:focus {
            border-color: #6ee7b7;
            box-shadow: 0 0 0 2px rgba(110, 231, 183, 0.15);
        }

        .btn-ghost {
            background: transparent;
            border: 1px solid #1f2937;
            color: #e5e7eb;
        }

        .sidebar-collapsed .world-switcher {
            padding: 12px 8px;
            align-items: center;
        }

        .sidebar-collapsed .world-badge {
            justify-content: center;
            padding: 10px;
        }

        .sidebar-collapsed .world-badge div { display: none; }

        .sidebar-collapsed .world-actions {
            flex-direction: column;
            align-items: center;
            gap: 6px;
        }

        .sidebar-collapsed .world-actions .world-select { display: none; }

        .sidebar-collapsed #addWorldBtn {
            width: 100%;
            display: flex;
            justify-content: center;
        }

        .btn-ghost:hover {
            border-color: #fff;
            color: #fff;
        }
        
        .set-item {
            margin-bottom: 4px;
        }
        
        .set-header {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 12px;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.15s;
            color: #cbd5e1;
            border: 1px solid transparent;
        }
        .set-header:hover { background: rgba(255,255,255,0.04); border-color: rgba(255,255,255,0.08); color: #fff; }
        .set-header.active { background: #111827; color: #ffffff; border-color: #111827; box-shadow: none; }
        .set-icon, .view-item-icon {
            font-size: 18px;
            width: 32px;
            height: 32px;
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.06);
            border: 1px solid rgba(255, 255, 255, 0.08);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }
        .set-icon i, .view-item-icon i { font-size: 18px; }
        .set-header.active .set-icon { background: rgba(255, 255, 255, 0.12); border-color: rgba(255, 255, 255, 0.18); }
        .world-badge .set-icon { background: rgba(255, 255, 255, 0.08); border-color: rgba(255, 255, 255, 0.12); }
        .set-name { flex: 1; transition: opacity 0.2s; font-weight: 600; letter-spacing: -0.01em; }
        .set-expand-icon {
            font-size: 12px;
            transition: transform 0.2s;
            opacity: 0.7;
        }
        .set-item.expanded .set-expand-icon { transform: rotate(90deg); }
        .sidebar-collapsed .set-name { opacity: 0; width: 0; overflow: hidden; }
        .sidebar-collapsed .set-expand-icon { display: none; }
        .sidebar-collapsed .set-header { justify-content: center; padding: 10px; }
        
        .views-list {
            max-height: 0;
            overflow: hidden;
            opacity: 0;
            transition: max-height 0.3s ease, opacity 0.3s ease;
            margin-left: 32px;
            margin-top: 6px;
        }
        .set-item.expanded .views-list {
            max-height: 500px;
            opacity: 1;
        }
        .sidebar-collapsed .views-list { display: none; }
        
        .view-item {
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.15s;
            margin-bottom: 3px;
            display: flex;
            align-items: center;
            gap: 8px;
            color: #9ca3af;
            position: relative;
        }
        .view-item:hover { background: #252931; color: #e5e7eb; }
        .view-item.active { background: #2f343d; color: #ffffff; font-weight: 600; }
        .view-item-icon { font-size: 16px; opacity: 0.9; color: #cbd5e1; }

        /* Sandbox view styling - muted appearance */
        .view-item.sandbox {
            opacity: 0.85;
        }
        .view-item.sandbox:hover { opacity: 1; }
        .view-item.sandbox .view-mode-badge {
            font-size: 9px;
            background: #374151;
            color: #9ca3af;
            padding: 1px 4px;
            border-radius: 3px;
            margin-left: auto;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Live view styling - solid, full presence */
        .view-item.live {
            /* Default styling, no special indicators */
        }
        .view-item.live .view-mode-badge {
            display: none; /* Don't show badge for live views - they're the default */
        }

        .add-view-btn {
            padding: 6px 12px;
            font-size: 13px;
            color: #6b7280;
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.15s;
            margin-top: 6px;
        }
        .add-view-btn:hover { background: #252931; color: #e5e7eb; }

        .new-set-btn {
            margin-top: auto;
            padding: 14px 12px;
            display: flex;
            align-items: center;
            gap: 10px;
            color: #6b7280;
            font-weight: 600;
            border: none;
            background: transparent;
            cursor: pointer;
            transition: color 0.15s ease;
        }
        .new-set-btn:hover { color: #9ca3af; }

        .knowledge-nav { display: flex; flex-direction: column; gap: 8px; margin-bottom: 6px; }
        .knowledge-nav-btn {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 12px;
            border-radius: 10px;
            border: 1px solid var(--border);
            background: var(--surface);
            color: var(--text);
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s ease;
        }
        .knowledge-nav-btn:hover { background: var(--muted-surface); }
        .knowledge-nav-btn.active { border-color: #3b82f6; color: #1d4ed8; background: #e0e7ff; }
        .knowledge-nav-btn i { color: inherit; }

        .sidebar-section-title.collapsible {
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            user-select: none;
        }
        .sidebar-section-title.collapsible:hover { color: #9ca3af; }
        .sidebar-section-title .collapse-icon {
            transition: transform 0.2s ease;
            font-size: 14px;
        }
        .sidebar-section-title.collapsed .collapse-icon { transform: rotate(-90deg); }
        .sidebar-section .knowledge-content {
            overflow: hidden;
            transition: max-height 0.3s ease, opacity 0.2s ease;
            max-height: 500px;
            opacity: 1;
        }
        .sidebar-section .knowledge-content.collapsed {
            max-height: 0;
            opacity: 0;
        }

        /* TOOLBAR */
        .toolbar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 16px;
            flex-wrap: wrap;
            padding: 16px 28px;
            background: var(--surface);
            border-bottom: 1px solid var(--border);
        }

        .toolbar-left {
            display: flex;
            align-items: center;
            gap: 12px;
            flex: 1;
            min-width: 0;
            flex-wrap: wrap;
        }

        .toolbar-inline-actions {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
        }

        .toolbar-actions {
            display: flex;
            align-items: center;
            gap: 12px;
            flex-wrap: wrap;
            justify-content: flex-end;
        }

        .primary-actions {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
        }

        .toolbar-menu { position: relative; }
        .toolbar-menu.open .toolbar-menu-panel { display: flex; }

        .toolbar-menu-toggle {
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .toolbar-menu-panel {
            display: none;
            position: absolute;
            right: 0;
            top: calc(100% + 10px);
            min-width: 240px;
            padding: 10px;
            border-radius: 12px;
            border: 1px solid var(--border);
            background: var(--surface);
            box-shadow: 0 12px 40px rgba(15, 23, 42, 0.15);
            flex-direction: column;
            gap: 6px;
            z-index: 15;
        }

        .toolbar-menu-divider {
            height: 1px;
            background: var(--border);
            margin: 2px 0;
        }

        .toolbar-menu-item {
            width: 100%;
            justify-content: flex-start;
            gap: 10px;
            color: var(--text-secondary);
            border: 1px solid var(--border);
            background: var(--muted-surface);
        }

        .toolbar-menu-item:hover {
            background: var(--surface);
            color: var(--text);
            border-color: var(--text);
        }

        /* Globe menu for world options */
        .globe-menu { position: relative; }
        .globe-menu.open .globe-menu-panel { display: flex; }

        .globe-menu-toggle {
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .globe-menu-toggle i:first-child {
            font-size: 1.1rem;
        }

        .globe-menu-toggle i:last-child {
            font-size: 0.75rem;
            opacity: 0.7;
        }

        .globe-menu-panel {
            display: none;
            position: absolute;
            right: 0;
            top: calc(100% + 10px);
            min-width: 200px;
            padding: 10px;
            border-radius: 12px;
            border: 1px solid var(--border);
            background: var(--surface);
            box-shadow: 0 12px 40px rgba(15, 23, 42, 0.15);
            flex-direction: column;
            gap: 6px;
            z-index: 15;
        }

        .globe-menu-divider {
            height: 1px;
            background: var(--border);
            margin: 2px 0;
        }

        .globe-menu-item {
            width: 100%;
            justify-content: flex-start;
            gap: 10px;
            color: var(--text-secondary);
            border: 1px solid var(--border);
            background: var(--muted-surface);
        }

        .globe-menu-item:hover {
            background: var(--surface);
            color: var(--text);
            border-color: var(--text);
        }

        .globe-menu-item-highlight {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }

        .globe-menu-item-highlight:hover {
            background: var(--primary-dark, #3730a3);
            color: white;
            border-color: var(--primary-dark, #3730a3);
        }

        .toolbar .sort-sequence-badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 8px;
            border-radius: 8px;
            background: #f3f4f6;
            color: #4b5563;
            font-size: 13px;
        }

        .view-type-switcher {
            display: flex;
            gap: 8px;
        }

        .view-type-btn {
            padding: 8px 14px;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.15s;
            border: 1px solid var(--border);
            background: var(--surface);
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: none;
        }

        .view-type-btn:hover { background: var(--muted-surface); border-color: var(--text); color: var(--text); }
        .view-type-btn.active { background: var(--primary); color: #ffffff; border-color: var(--primary); }
        
        /* CELLS */
        .cell-editable {
            min-height: 36px;
            padding: 12px 16px;
            cursor: text;
            border-right: 1px solid #f0f0f0;
            transition: all 0.2s ease;
            position: relative;
        }
        .cell-editable:hover:not(.cell-editing):not(.cell-selected) {
            background: linear-gradient(to right, transparent, rgba(59, 130, 246, 0.03), transparent);
            cursor: pointer;
            border-left: 2px solid rgba(59, 130, 246, 0.15);
        }
        .cell-static {
            min-height: 36px;
            padding: 12px 16px;
            border-right: 1px solid #f0f0f0;
            background: #f9fafb;
            color: #4b5563;
            font-weight: 600;
            letter-spacing: -0.01em;
        }
        .cell-selected {
            outline: 2px solid #3b82f6 !important;
            outline-offset: -2px;
            background: #eff6ff !important;
            position: relative;
            z-index: 1;
        }
        .cell-editing {
            outline: 2px solid #3b82f6 !important;
            outline-offset: -2px;
            background: white !important;
            box-shadow: 0 0 0 4px rgba(59, 130, 246, 0.12) !important;
            z-index: 2;
        }
        .cell-recently-changed { animation: none; }
        @keyframes flash-yellow { 0% { background-color: #fef3c7; } 100% { background-color: transparent; } }
        .cell-keyboard-focus {
            outline: 2px dashed #3b82f6;
            outline-offset: -2px;
        }
        .cell-loading {
            position: relative;
            pointer-events: none;
        }
        .cell-loading::after {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.6), transparent);
            animation: shimmer 1.5s infinite;
        }
        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        /* ROLLUP/SUPERPOSITION CELL BADGES */
        .sup-chip-container {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            align-items: center;
        }

        .sup-value-badge {
            display: inline-flex;
            align-items: center;
            padding: 4px 10px;
            background: linear-gradient(135deg, #eff6ff 0%, #dbeafe 100%);
            color: #1e40af;
            font-size: 13px;
            font-weight: 500;
            border-radius: 6px;
            border: 1px solid #bfdbfe;
            box-shadow: 0 1px 2px rgba(59, 130, 246, 0.08);
            white-space: nowrap;
            max-width: 150px;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .sup-count-badge {
            display: inline-flex;
            align-items: center;
            padding: 4px 10px;
            background: linear-gradient(135deg, #f3f4f6 0%, #e5e7eb 100%);
            color: #4b5563;
            font-size: 12px;
            font-weight: 600;
            border-radius: 6px;
            border: 1px solid #d1d5db;
            box-shadow: 0 1px 2px rgba(107, 114, 128, 0.08);
            white-space: nowrap;
        }

        .sup-value-badge:hover,
        .sup-count-badge:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(59, 130, 246, 0.15);
        }

        /* LINKED RECORD PILLS */
        .linked-record-container {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            align-items: center;
        }

        .linked-record-pill {
            display: inline-flex;
            align-items: center;
            padding: 4px 10px;
            background: linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%);
            color: #166534;
            font-size: 13px;
            font-weight: 500;
            border-radius: 6px;
            border: 1px solid #86efac;
            box-shadow: 0 1px 2px rgba(34, 197, 94, 0.08);
            white-space: nowrap;
            max-width: 150px;
            overflow: hidden;
            text-overflow: ellipsis;
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .linked-record-pill:hover {
            background: linear-gradient(135deg, #dcfce7 0%, #bbf7d0 100%);
            border-color: #4ade80;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(34, 197, 94, 0.15);
        }

        .linked-record-more {
            display: inline-flex;
            align-items: center;
            padding: 4px 8px;
            background: linear-gradient(135deg, #f3f4f6 0%, #e5e7eb 100%);
            color: #4b5563;
            font-size: 12px;
            font-weight: 600;
            border-radius: 6px;
            border: 1px solid #d1d5db;
        }

        /* LOOKUP FIELD PILLS */
        .lookup-value-container {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            align-items: center;
        }

        .lookup-value-pill {
            display: inline-flex;
            align-items: center;
            padding: 4px 10px;
            background: linear-gradient(135deg, #eff6ff 0%, #dbeafe 100%);
            color: #1e40af;
            font-size: 13px;
            font-weight: 500;
            border-radius: 6px;
            border: 1px solid #bfdbfe;
            box-shadow: 0 1px 2px rgba(59, 130, 246, 0.08);
            white-space: nowrap;
            max-width: 150px;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .lookup-array-container {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            align-items: center;
        }

        .lookup-value-more {
            display: inline-flex;
            align-items: center;
            padding: 4px 8px;
            background: linear-gradient(135deg, #f3f4f6 0%, #e5e7eb 100%);
            color: #4b5563;
            font-size: 12px;
            font-weight: 600;
            border-radius: 6px;
            border: 1px solid #d1d5db;
        }

        /* LINKED SUPERSCRIPT NUMBERS - for correlating linked records with lookups */
        .linked-superscript {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-size: 9px;
            font-weight: 700;
            min-width: 14px;
            height: 14px;
            padding: 0 3px;
            margin-left: 4px;
            background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
            color: white;
            border-radius: 7px;
            vertical-align: super;
            line-height: 1;
            box-shadow: 0 1px 2px rgba(99, 102, 241, 0.3);
        }

        .linked-record-pill .linked-superscript {
            background: linear-gradient(135deg, #059669 0%, #10b981 100%);
            box-shadow: 0 1px 2px rgba(5, 150, 105, 0.3);
        }

        .lookup-value-pill .linked-superscript {
            background: linear-gradient(135deg, #2563eb 0%, #3b82f6 100%);
            box-shadow: 0 1px 2px rgba(37, 99, 235, 0.3);
        }

        /* ROLLUP MODAL CARDS */
        .sup-modal-card {
            background: linear-gradient(135deg, #ffffff 0%, #f9fafb 100%);
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 12px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
            transition: all 0.2s ease;
        }

        .sup-modal-card:hover {
            border-color: #bfdbfe;
            box-shadow: 0 4px 6px rgba(59, 130, 246, 0.1);
            transform: translateY(-1px);
        }

        .sup-modal-card-index {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 28px;
            height: 28px;
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            color: white;
            font-size: 13px;
            font-weight: 700;
            border-radius: 6px;
            flex-shrink: 0;
            box-shadow: 0 2px 4px rgba(59, 130, 246, 0.2);
        }

        .sup-modal-card-value {
            font-size: 15px;
            font-weight: 600;
            color: #1f2937;
            margin-bottom: 6px;
            line-height: 1.4;
        }

        .sup-modal-card-source {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 12px;
            color: #6b7280;
            font-weight: 500;
        }

        /* TABLE HEADERS */
        .column-header {
            background: var(--surface);
            padding: 12px 16px;
            font-weight: 600;
            font-size: 11px;
            letter-spacing: 0.5px;
            text-transform: uppercase;
            color: #666;
            border-bottom: 1px solid var(--border);
            cursor: grab;
            transition: background 0.15s, box-shadow 0.15s;
            user-select: none;
            position: relative;
        }
        .column-header.column-grab-ready {
            cursor: grabbing;
            background: var(--muted-surface);
            box-shadow: inset 0 0 0 1px var(--border);
        }
        .column-resizer {
            position: absolute;
            top: 0;
            right: -3px;
            bottom: 0;
            width: 6px;
            cursor: col-resize;
            z-index: 5;
            background: transparent;
            transition: background 0.1s;
        }
        .column-resizer::after {
            content: '';
            position: absolute;
            top: 4px;
            bottom: 4px;
            left: 2px;
            width: 2px;
            background: transparent;
            border-radius: 1px;
            transition: background 0.15s;
        }
        .column-resizer:hover::after,
        body.resizing .column-resizer::after {
            background: #3b82f6;
        }
        body.resizing {
            cursor: col-resize;
            user-select: none;
        }
        body.resizing * {
            cursor: col-resize !important;
        }
        .column-header:hover { background: var(--muted-surface); }

        body.column-grab-ready { cursor: grab; }
        body.column-dragging { cursor: grabbing; }
        .column-being-dragged { opacity: 0.5; }

        .column-drag-ghost {
            position: fixed;
            pointer-events: none;
            background: white;
            border: 1px dashed #cbd5e1;
            border-radius: 8px;
            padding: 10px 14px;
            box-shadow: 0 10px 30px rgba(15, 23, 42, 0.15);
            opacity: 0.95;
            z-index: 1200;
            transform: translate3d(0, 0, 0);
        }

        .column-drop-before::before,
        .column-drop-after::after {
            content: '';
            position: absolute;
            top: 6px;
            bottom: 6px;
            width: 3px;
            background: #cbd5e1;
            border-radius: 999px;
        }
        .column-drop-before::before { left: -2px; }
        .column-drop-after::after { right: -2px; }

        table { width: auto; border-collapse: collapse; table-layout: fixed; }
        thead { background: #f9fafb; border-bottom: 1px solid #e5e7eb; }
        th {
            padding: 8px 16px;
            text-align: left;
            font-size: 12px;
            font-weight: 700;
            text-transform: uppercase;
            color: #6b7280;
            letter-spacing: 0.05em;
            min-width: 80px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            cursor: pointer;
        }

        th .sort-indicator {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            margin-left: 8px;
            color: var(--text-secondary);
            font-weight: 500;
            font-size: 12px;
        }

        th .sort-indicator .order-badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-width: 18px;
            height: 18px;
            padding: 0 6px;
            border-radius: 999px;
            background: #e5e7eb;
            color: #111827;
            font-size: 11px;
            font-weight: 700;
        }

        th .column-title {
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        th .column-badge {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 2px 8px;
            border-radius: 999px;
            background: #eef2ff;
            color: #3730a3;
            font-weight: 700;
            text-transform: none;
            font-size: 11px;
        }

        th .sort-indicator .direction-icon { font-size: 10px; }

        th .sort-indicator.muted { opacity: 0.5; }
        tbody tr {
            border-bottom: 1px solid #f3f4f6;
            transition: all 0.1s ease;
        }
        tbody tr:hover { background: #fafafa; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.02); }
        tbody tr:hover td:first-child { color: #3b82f6; font-weight: 700; }
        tbody tr:last-child { border-bottom: none; }
        td {
            padding: 10px 16px;
            font-size: 14px;
            color: #1f2937;
            vertical-align: middle;
            min-width: 80px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        td:first-child {
            color: #9ca3af;
            font-weight: 600;
            font-size: 13px;
            min-width: 60px;
        }
        tr:hover { background-color: #fafafa; }

        #dataTable thead th,
        #dataTable tbody td { background-clip: padding-box; transition: background-color 0.2s ease; }
        #dataTable thead th:nth-child(odd),
        #dataTable tbody td:nth-child(odd) { box-shadow: inset 0 0 0 9999px rgba(15, 23, 42, 0.012); }
        #dataTable thead th:nth-child(even),
        #dataTable tbody td:nth-child(even) { box-shadow: inset 0 0 0 9999px rgba(15, 23, 42, 0.024); }
        #dataTable tbody tr:nth-child(odd) { background-color: rgba(15, 23, 42, 0.02); }
        #dataTable tbody tr:nth-child(even) { background-color: rgba(15, 23, 42, 0.03); }
        #dataTable tbody tr:hover td { background: #f4f6fb; }
        #dataTable th:not(:last-child), #dataTable td:not(:last-child) { border-right: 1px solid #eef2f7; }
        .table-footer {
            display: flex;
            justify-content: flex-end;
            align-items: center;
            gap: 8px;
            padding: 10px 16px;
            background: #f9fafb;
            border-top: 1px solid #e5e7eb;
            color: #4b5563;
            font-size: 13px;
        }
        .record-counter {
            font-weight: 700;
            color: #111827;
        }

        /* Enhanced select dropdown */
        .custom-select-dropdown {
            position: absolute;
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            z-index: 1000;
            min-width: 250px;
            max-width: 400px;
            max-height: 400px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .custom-select-search {
            padding: 8px 12px;
            border: none;
            border-bottom: 1px solid #e5e7eb;
            font-size: 14px;
            outline: none;
        }

        .custom-select-search:focus { border-bottom-color: #3b82f6; }

        .custom-select-options { overflow-y: auto; flex: 1; }

        .custom-select-option {
            padding: 10px 16px;
            font-size: 14px;
            cursor: pointer;
            transition: background 0.1s;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .custom-select-option:hover { background: #f3f4f6; }
        .custom-select-option.highlighted { background: #eff6ff; color: #1e40af; }
        .custom-select-option.selected { background: #3b82f6; color: white; font-weight: 600; }

        .custom-select-option-icon {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
        }

        .custom-select-option-text { flex: 1; }

        .custom-select-option-badge {
            font-size: 11px;
            padding: 2px 6px;
            border-radius: 4px;
            background: #f3f4f6;
            color: #6b7280;
        }

        .custom-select-empty {
            padding: 40px 20px;
            text-align: center;
            color: #9ca3af;
        }

        .custom-select-empty-icon {
            font-size: 32px;
            margin-bottom: 8px;
            opacity: 0.5;
        }

        .custom-select-footer {
            border-top: 1px solid #e5e7eb;
            padding: 8px;
            display: flex;
            gap: 4px;
        }

        .custom-select-footer button {
            flex: 1;
            padding: 6px 12px;
            font-size: 13px;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            background: white;
            cursor: pointer;
            transition: all 0.15s;
        }

        .custom-select-footer button:hover { background: #f3f4f6; border-color: #d1d5db; }

        .search-match {
            background: #fef3c7;
            font-weight: 600;
            padding: 0 2px;
            border-radius: 2px;
        }

        /* Multi-select dropdown styles */
        .custom-select-dropdown.multi-select { max-height: 450px; }

        .multi-select-header {
            padding: 10px 12px;
            background: #f9fafb;
            border-bottom: 1px solid #e5e7eb;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .multi-select-count {
            font-size: 13px;
            font-weight: 500;
            color: #374151;
        }

        .multi-select-footer { justify-content: space-between; }

        .multi-select-footer .done-btn {
            background: #3b82f6 !important;
            color: white !important;
            border-color: #3b82f6 !important;
        }

        .multi-select-footer .done-btn:hover {
            background: #2563eb !important;
            border-color: #2563eb !important;
        }

        .custom-select-option.multi-option {
            padding: 10px 12px;
        }

        .custom-select-option.multi-option.selected {
            background: #eff6ff;
            color: #1e40af;
        }

        .multi-checkbox {
            width: 18px;
            height: 18px;
            border: 2px solid #d1d5db;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s;
            flex-shrink: 0;
        }

        .multi-checkbox.checked {
            background: #3b82f6;
            border-color: #3b82f6;
            color: white;
        }

        .multi-checkbox i { font-size: 12px; }

        /* Modal multi-linked record styles */
        .modal-linked-option {
            transition: background-color 0.1s;
        }

        .modal-linked-option:hover {
            background-color: #f3f4f6;
        }

        .modal-linked-option.bg-blue-50 {
            background-color: #eff6ff;
        }

        .modal-linked-checkbox {
            transition: all 0.15s;
        }

        /* SEARCH FOCUS PANEL */
        .search-shell {
            display: flex;
            gap: 16px;
            height: calc(90vh - 100px);
        }

        .search-surface {
            flex: 2;
            display: flex;
            flex-direction: column;
            min-width: 0;
        }

        .search-input-row {
            padding: 12px 20px 16px;
            border-bottom: 1px solid var(--border);
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .search-input-row input {
            flex: 1;
            border-radius: 999px;
            border: 1px solid #d1d5db;
            padding: 8px 14px;
            font-size: 14px;
        }

        .search-input-row input:focus {
            outline: none;
            border-color: #2563eb;
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.15);
        }

        .search-input-row .scope-pill {
            font-size: 12px;
            padding: 6px 10px;
            border-radius: 999px;
            border: 1px solid #d1d5db;
            background: #f9fafb;
            color: #4b5563;
            white-space: nowrap;
        }

        .search-results-container {
            padding: 8px 0 12px;
            overflow: auto;
            flex: 1;
        }

        .results-section {
            padding: 8px 20px 4px;
        }

        .results-section-title {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: #9ca3af;
            margin-bottom: 4px;
            font-weight: 600;
        }

        .result-item {
            padding: 8px 10px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
            cursor: pointer;
            transition: background 0.12s ease;
            margin-bottom: 4px;
        }

        .result-item:hover {
            background: #f3f4ff;
        }

        .result-item.focused {
            background: #eff6ff;
            border: 1px solid #2563eb;
        }

        .result-main {
            display: flex;
            flex-direction: column;
            gap: 2px;
            min-width: 0;
        }

        .result-label {
            font-size: 14px;
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .result-meta {
            font-size: 12px;
            color: #6b7280;
        }

        .focus-btn {
            border-radius: 999px;
            border: 1px solid #2563eb;
            background: #eff6ff;
            color: #1d4ed8;
            font-size: 12px;
            padding: 6px 10px;
            cursor: pointer;
            white-space: nowrap;
            flex-shrink: 0;
        }

        .focus-btn:hover {
            background: #dbeafe;
        }

        /* FOCUS PANEL */
        .focus-panel {
            flex: 1.2;
            min-width: 320px;
            max-width: 420px;
            display: flex;
            flex-direction: column;
            border-left: 1px solid var(--border);
            background: #f9fafb;
        }

        .focus-panel.hidden {
            display: none;
        }

        .focus-header {
            padding: 16px 18px 10px;
            border-bottom: 1px solid var(--border);
            background: white;
        }

        .focus-label {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: #9ca3af;
            margin-bottom: 4px;
        }

        .focus-title-row {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 8px;
        }

        .focus-title {
            font-size: 16px;
            font-weight: 600;
            color: var(--text);
        }

        .focus-tag {
            font-size: 11px;
            padding: 4px 8px;
            border-radius: 999px;
            background: #eef2ff;
            color: #3730a3;
            white-space: nowrap;
            flex-shrink: 0;
        }

        .focus-subtitle {
            font-size: 12px;
            color: #6b7280;
            margin-top: 4px;
        }

        .focus-clear {
            margin-top: 8px;
            padding: 4px 8px;
            font-size: 11px;
            border-radius: 999px;
            border: 1px solid var(--border);
            background: #f9fafb;
            color: #6b7280;
            cursor: pointer;
        }

        .focus-clear:hover {
            background: #e5e7eb;
        }

        .focus-body {
            padding: 12px 18px 16px;
            overflow: auto;
            flex: 1;
            background: white;
        }

        .focus-section {
            margin-bottom: 16px;
        }

        .focus-section h4 {
            margin: 0 0 8px;
            font-size: 12px;
            font-weight: 600;
            color: #4b5563;
            text-transform: uppercase;
            letter-spacing: 0.06em;
        }

        .focus-kv {
            font-size: 13px;
            margin-bottom: 6px;
            line-height: 1.5;
        }

        .focus-kv-label {
            color: #6b7280;
            font-weight: 500;
        }

        .focus-kv-value {
            color: var(--text);
        }

        .focus-badge-row {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .focus-badge {
            font-size: 11px;
            padding: 4px 8px;
            border-radius: 999px;
            border: 1px solid var(--border);
            background: #f9fafb;
            color: #4b5563;
        }

        .focus-actions {
            padding: 10px 18px 14px;
            border-top: 1px solid var(--border);
            background: #f9fafb;
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .focus-action-btn {
            font-size: 12px;
            padding: 6px 10px;
            border-radius: 999px;
            border: 1px solid #d1d5db;
            background: white;
            cursor: pointer;
            white-space: nowrap;
        }

        .focus-action-btn:hover {
            background: #eff6ff;
            border-color: #2563eb;
            color: #1d4ed8;
        }

        /* EXPLORE TABLE */
        .explore-page {
            background: white;
        }

        .table-row {
            cursor: pointer;
            transition: background-color 0.12s ease;
        }

        .table-row:hover {
            background-color: #f3f4f6;
        }

        .table-row.selected {
            background-color: #eff6ff;
        }

        .table-cell {
            padding: 12px 16px;
            border-bottom: 1px solid #f3f4f6;
            font-size: 13px;
            vertical-align: middle;
        }

        /* ZERO-INPUT SEARCH */
        .zero-input-section {
            padding: 8px 20px 12px;
        }

        .zero-input-section-title {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: #9ca3af;
            margin: 16px 0 6px;
            font-weight: 600;
        }

        .zero-input-section-title:first-child {
            margin-top: 0;
        }

        .zero-input-item {
            padding: 8px 10px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
            cursor: pointer;
            transition: background 0.12s ease;
            margin-bottom: 4px;
            font-size: 14px;
        }

        .zero-input-item:hover {
            background: #f3f4ff;
        }

        .zero-input-item-label {
            flex: 1;
            min-width: 0;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .zero-input-type-label {
            font-size: 11px;
            background: #eef2ff;
            padding: 2px 8px;
            border-radius: 6px;
            color: #3730a3;
            white-space: nowrap;
        }

        .browse-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin-top: 6px;
        }

        .browse-item {
            padding: 10px 12px;
            background: #f8fafc;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            text-align: center;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            color: #4b5563;
            transition: all 0.12s ease;
        }

        .browse-item:hover {
            background: #f3f4ff;
            border-color: #c7d2fe;
            color: #3730a3;
        }

        @media (max-width: 900px) {
            .search-shell {
                flex-direction: column;
            }
            .focus-panel {
                max-width: 100%;
                border-left: none;
                border-top: 1px solid var(--border);
            }
        }

        .table-scroll {
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
        }
        
        /* CARD VIEW */
        .cards-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 16px;
        }
        
        .card {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 16px;
            cursor: pointer;
            transition: all 0.15s ease;
            box-shadow: none;
        }

        .card:hover {
            transform: translateY(-2px);
            border-color: var(--border-strong);
        }
        
        .card-title {
            font-size: 16px;
            font-weight: 600;
            color: #111827;
            margin-bottom: 12px;
        }
        
        .card-field {
            margin-bottom: 8px;
            font-size: 13px;
        }
        
        .card-field-label {
            color: #6b7280;
            font-weight: 500;
            margin-bottom: 2px;
        }
        
        .card-field-value {
            color: #111827;
        }
        
        /* KANBAN VIEW */
        .kanban-board {
            display: flex;
            gap: 16px;
            padding: 8px;
            overflow-x: auto;
            min-height: calc(100vh - 200px);
        }
        
        .kanban-column {
            min-width: 300px;
            background: var(--muted-surface);
            border-radius: 10px;
            padding: 12px;
            display: flex;
            flex-direction: column;
            border: 1px solid var(--border);
        }
        
        .kanban-column-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 12px;
            margin-bottom: 12px;
            border-radius: 8px;
            background: var(--surface);
            border: 1px solid var(--border);
        }
        
        .kanban-column-title {
            font-weight: 600;
            font-size: 14px;
            color: #374151;
        }
        
        .kanban-column-count {
            font-size: 12px;
            color: #6b7280;
            background: #f3f4f6;
            padding: 2px 8px;
            border-radius: 4px;
        }
        
        .kanban-cards {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 8px;
            min-height: 100px;
        }
        
        .kanban-card {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 12px;
            cursor: move;
            transition: all 0.15s ease;
        }

        .kanban-card:hover {
            border-color: var(--border-strong);
        }
        
        .kanban-card.dragging {
            opacity: 0.5;
            transform: rotate(2deg);
        }
        
        .kanban-column.drag-over {
            background: #e0f2fe;
        }
        
        .kanban-empty-state {
            text-align: center;
            padding: 40px 20px;
            color: #9ca3af;
            font-size: 14px;
        }

        /* GRAPH VIEW */
        .graph-container {
            width: 100%;
            height: 600px;
            background: #fafbfc;
            border-radius: 8px;
            overflow: hidden;
            position: relative;
            border: 1px solid var(--border);
        }

        .graph-node:hover circle {
            fill: #2563eb;
            stroke: #1e3a8a;
        }

        /* vis-network navigation buttons styling */
        .graph-container .vis-button {
            background: var(--surface) !important;
            border: 1px solid var(--border) !important;
            border-radius: 6px !important;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1) !important;
        }

        .graph-container .vis-button:hover {
            background: var(--muted-surface) !important;
            border-color: var(--border-strong) !important;
        }

        /* Custom graph navigation buttons */
        .graph-nav-btn {
            transition: all 0.2s ease;
        }

        .graph-nav-btn:hover {
            background: #f3f4f6 !important;
            border-color: #d1d5db !important;
            transform: translateY(-1px);
            box-shadow: 0 4px 6px rgba(0,0,0,0.15) !important;
        }

        .graph-nav-btn:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1) !important;
        }

        /* Tooltip styling */
        .vis-tooltip {
            background: white !important;
            border: 1px solid var(--border) !important;
            border-radius: 8px !important;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15) !important;
            padding: 0 !important;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto !important;
        }

        /* CONTEXT MENU */
        .context-menu {
            position: fixed;
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15);
            z-index: 1000;
            min-width: 200px;
            overflow: hidden;
        }
        .context-menu-item {
            padding: 10px 16px;
            font-size: 14px;
            cursor: pointer;
            transition: background 0.15s;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .context-menu-item:hover { background: #f3f4f6; }
        .context-menu-item.danger:hover { background: #fee2e2; color: #dc2626; }
        .context-menu-separator { height: 1px; background: #e5e7eb; margin: 4px 0; }
        
        /* MODALS */
        .modal-overlay { backdrop-filter: blur(2px); animation: fadeIn 0.2s ease; }
        .modal-container { border-radius: 8px; box-shadow: 0 20px 50px rgba(0, 0, 0, 0.2); animation: slideUp 0.25s cubic-bezier(0.16, 1, 0.3, 1); }
        #expandedRecordModal .modal-container { height: 90vh; }
        #addFieldModal .modal-container { max-width: 540px; width: 100%; border-radius: 10px; }
        #addFieldModal .modal-container, #addFieldModal .modal-body { overflow: visible; }
        #changeFieldTypeModal .modal-container, #changeFieldTypeModal .modal-body { overflow: visible; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes slideUp { from { transform: translateY(20px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
        .modal-header { padding: 24px 24px 16px 24px; border-bottom: 1px solid #f0f0f0; }
        .modal-body { padding: 24px; }
        .modal-footer { padding: 16px 24px; border-top: 1px solid #f0f0f0; background: #fafafa; }

        /* SORT BUILDER - Custom Dropdowns */
        .sort-rule {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 16px;
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 10px;
            transition: all 0.15s ease;
        }
        .sort-rule:hover {
            border-color: #cbd5e1;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
        }
        .sort-rule-number {
            width: 28px;
            height: 28px;
            border-radius: 8px;
            background: #e2e8f0;
            color: #475569;
            font-size: 12px;
            font-weight: 700;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }
        .sort-dropdown {
            position: relative;
            flex: 1;
            min-width: 0;
        }
        .sort-dropdown-trigger {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
            width: 100%;
            padding: 10px 12px;
            background: #fff;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.15s ease;
            font-size: 14px;
            color: #0f172a;
            font-weight: 500;
        }
        .sort-dropdown-trigger:hover {
            border-color: #cbd5e1;
            background: #f8fafc;
        }
        .sort-dropdown-trigger.open {
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }
        .sort-dropdown-trigger .placeholder {
            color: #94a3b8;
            font-weight: 400;
        }
        .sort-dropdown-trigger i {
            color: #94a3b8;
            font-size: 12px;
            transition: transform 0.2s ease;
        }
        .sort-dropdown-trigger.open i {
            transform: rotate(180deg);
        }
        .sort-dropdown-menu {
            position: absolute;
            top: calc(100% + 4px);
            left: 0;
            right: 0;
            background: #fff;
            border: 1px solid #e2e8f0;
            border-radius: 10px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.12);
            z-index: 100;
            max-height: 240px;
            overflow-y: auto;
            display: none;
            animation: sortDropdownIn 0.15s ease;
        }
        @keyframes sortDropdownIn {
            from { opacity: 0; transform: translateY(-4px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .sort-dropdown-menu.open {
            display: block;
        }
        .sort-dropdown-option {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 14px;
            cursor: pointer;
            transition: all 0.1s ease;
            font-size: 14px;
            color: #374151;
        }
        .sort-dropdown-option:first-child {
            border-radius: 9px 9px 0 0;
        }
        .sort-dropdown-option:last-child {
            border-radius: 0 0 9px 9px;
        }
        .sort-dropdown-option:hover {
            background: #f1f5f9;
        }
        .sort-dropdown-option.selected {
            background: #eff6ff;
            color: #1d4ed8;
            font-weight: 600;
        }
        .sort-dropdown-option i {
            font-size: 16px;
            color: #64748b;
            width: 20px;
            text-align: center;
        }
        .sort-dropdown-option.selected i {
            color: #1d4ed8;
        }
        .sort-direction-toggle {
            display: flex;
            align-items: center;
            background: #fff;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            overflow: hidden;
            flex-shrink: 0;
        }
        .sort-direction-btn {
            padding: 8px 14px;
            border: none;
            background: transparent;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            color: #64748b;
            transition: all 0.15s ease;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .sort-direction-btn:first-child {
            border-right: 1px solid #e2e8f0;
        }
        .sort-direction-btn:hover {
            background: #f8fafc;
            color: #374151;
        }
        .sort-direction-btn.active {
            background: #0f172a;
            color: #fff;
        }
        .sort-direction-btn i {
            font-size: 14px;
        }
        .sort-rule-actions {
            display: flex;
            align-items: center;
            gap: 4px;
            flex-shrink: 0;
        }
        .sort-action-btn {
            width: 32px;
            height: 32px;
            border-radius: 6px;
            border: 1px solid #e2e8f0;
            background: #fff;
            color: #64748b;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s ease;
            font-size: 14px;
        }
        .sort-action-btn:hover:not(:disabled) {
            border-color: #cbd5e1;
            background: #f8fafc;
            color: #374151;
        }
        .sort-action-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }
        .sort-action-btn.danger:hover:not(:disabled) {
            border-color: #fecaca;
            background: #fef2f2;
            color: #dc2626;
        }
        .sort-empty-state {
            text-align: center;
            padding: 32px 24px;
            color: #64748b;
        }
        .sort-empty-state i {
            font-size: 32px;
            color: #cbd5e1;
            margin-bottom: 12px;
        }
        .sort-empty-state p {
            margin: 0;
            font-size: 14px;
        }

        #addFieldModal .modal-header { padding: 16px 18px 10px 18px; }
        #addFieldModal .modal-body { padding: 16px 18px 18px 18px; }
        #addFieldModal .modal-footer { padding: 14px 18px; background: #f8fafc; }
        .icon-picker-shell { max-height: 90vh; display: flex; flex-direction: column; }
        .icon-picker-body { display: flex; flex-direction: column; gap: 12px; flex: 1; }
        .icon-picker-controls { display: flex; align-items: center; gap: 12px; flex-wrap: wrap; }
        .icon-picker-search { flex: 1 1 260px; }
        .icon-picker-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(44px, 1fr)); gap: 8px; max-height: 60vh; overflow: auto; padding-right: 4px; }
        .icon-pagination { display: flex; align-items: center; gap: 12px; margin-left: auto; font-size: 13px; color: #475569; }
        .icon-pagination-count { font-weight: 700; }
        .icon-pagination-buttons { display: inline-flex; align-items: center; gap: 6px; }
        .icon-page-btn { padding: 6px 10px; border-radius: 8px; border: 1px solid #e2e8f0; background: #fff; font-weight: 600; color: #0f172a; cursor: pointer; transition: all 0.15s ease; }
        .icon-page-btn:hover { background: #f8fafc; border-color: #cbd5e1; }
        .icon-page-btn:disabled { opacity: 0.55; cursor: not-allowed; background: #f8fafc; }
        .icon-option { display: flex; align-items: center; justify-content: center; padding: 6px; border-radius: 12px; border: 1px solid #e2e8f0; background: #ffffff; cursor: pointer; transition: all 0.12s ease; box-shadow: 0 2px 6px rgba(15, 23, 42, 0.04); }
        .icon-option:hover { border-color: #cbd5e1; background: #f8fafc; transform: translateY(-1px); }
        .icon-option.active { border-color: #2563eb; background: #eff6ff; color: #1d4ed8; box-shadow: 0 0 0 2px rgba(37,99,235,0.15); }
        .icon-option .icon-chip { width: 36px; height: 36px; border-radius: 50%; display: inline-flex; align-items: center; justify-content: center; background: #f8fafc; color: #0f172a; border: 1px solid #e2e8f0; font-size: 18px; }
        .icon-option.active .icon-chip { background: #e0ecff; border-color: #bfdbfe; color: #1d4ed8; }
        .sr-only { position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0, 0, 0, 0); white-space: nowrap; border: 0; }

        .icon-selector { display: flex; align-items: center; gap: 10px; padding: 10px 12px; border: 1px solid #e2e8f0; border-radius: 8px; background: #f8fafc; cursor: pointer; transition: all 0.15s ease; }
        .icon-selector:hover { border-color: #cbd5e1; background: #f1f5f9; box-shadow: inset 0 0 0 1px #e2e8f0; }
        .icon-selector-icon { width: 40px; height: 40px; border-radius: 10px; background: #ffffff; border: 1px solid #e2e8f0; display: inline-flex; align-items: center; justify-content: center; font-size: 22px; color: #0f172a; }
        .icon-selector-text { flex: 1; min-width: 0; }
        .icon-selector-label { font-size: 13px; color: #475569; }
        .icon-selector-token { display: none; }
        .icon-selector-chevron { color: #94a3b8; font-size: 12px; }
        .config-section { max-height: 0; overflow: hidden; opacity: 0; transition: max-height 0.3s ease, opacity 0.3s ease, margin 0.3s ease; margin-top: 0; }
        .config-section.visible { max-height: 500px; opacity: 1; margin-top: 16px; }

        /* POPUP CONFIGURATOR */
        .popup-config-shell { max-width: 1200px; width: 100%; max-height: 90vh; overflow: hidden; display: flex; flex-direction: column; padding: 20px 24px; }
        .popup-config-header { display: flex; justify-content: space-between; align-items: flex-start; gap: 16px; padding: 0 0 12px 0; border-bottom: 1px solid #e2e8f0; background: transparent; }
        .popup-config-tabs { display: flex; gap: 4px; padding: 12px 0; border-bottom: 1px solid #e2e8f0; background: transparent; }
        .popup-config-tab { padding: 10px 14px; border: none; background: transparent; cursor: pointer; font-weight: 600; color: #6b7280; border-bottom: 2px solid transparent; display: inline-flex; gap: 8px; align-items: center; border-radius: 8px 8px 0 0; transition: all 0.2s ease; }
        .popup-config-tab:hover { color: #0f172a; background: #f8fafc; }
        .popup-config-tab.active { color: #1d4ed8; border-bottom-color: #1d4ed8; background: #eff6ff; }
        .popup-config-body { display: grid; grid-template-columns: 1fr 320px; gap: 20px; padding: 16px 0 0 0; background: #fff; flex: 1; overflow: hidden; }
        .popup-tab-panel { display: none; height: 100%; overflow: hidden; }
        .popup-tab-panel.active { display: block; }
        .popup-panel-scroll { height: 100%; overflow: auto; padding-right: 6px; }
        .popup-quick-filters { display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 14px; }
        .popup-filter { padding: 8px 12px; border-radius: 8px; border: 1px solid #e2e8f0; background: #fff; cursor: pointer; color: #475569; font-weight: 600; transition: all 0.15s ease; }
        .popup-filter:hover { border-color: #cbd5e1; background: #f8fafc; }
        .popup-filter.active { background: #eef2ff; border-color: #1d4ed8; color: #1d4ed8; }
        .popup-info { display: flex; gap: 10px; padding: 12px; background: #eef2ff; border: 1px solid #c7d2fe; border-radius: 8px; color: #1e3a8a; margin-bottom: 14px; font-size: 14px; }
        .popup-field-card { border: 1px solid #e2e8f0; border-radius: 6px; padding: 16px; display: flex; align-items: center; gap: 12px; margin-bottom: 12px; background: #fff; transition: all 0.2s ease; }
        .popup-field-card:hover { border-color: #cbd5e1; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04); }
        .popup-field-card.dragging { opacity: 0.6; }
        .popup-field-card.drag-over { border-color: #1d4ed8; background: #eef2ff; }
        .popup-field-card .drag-handle { cursor: grab; color: #94a3b8; font-size: 18px; }
        .popup-field-icon { width: 38px; height: 38px; border-radius: 10px; border: 1px solid #e2e8f0; background: #f8fafc; display: inline-flex; align-items: center; justify-content: center; font-size: 18px; color: #0f172a; }
        .popup-field-meta { flex: 1; min-width: 0; }
        .popup-field-name { font-weight: 700; color: #0f172a; display: flex; gap: 6px; align-items: center; }
        .popup-field-type { font-size: 13px; color: #64748b; }
        .field-type { font-size: 11px; color: #64748b; text-transform: uppercase; letter-spacing: 0.05em; font-weight: 500; }
        .popup-badge { display: inline-flex; align-items: center; gap: 4px; padding: 4px 8px; border-radius: 999px; background: #f8fafc; border: 1px solid #e2e8f0; font-size: 12px; color: #475569; font-weight: 600; }
        .popup-badge.warn { background: #fef3c7; border-color: #fde68a; color: #b45309; }
        .popup-toggle { width: 46px; height: 26px; border-radius: 999px; background: #e5e7eb; position: relative; cursor: pointer; transition: all 0.2s ease; }
        .popup-toggle::after { content: ''; position: absolute; width: 20px; height: 20px; border-radius: 50%; background: #fff; top: 3px; left: 3px; box-shadow: 0 2px 8px rgba(0,0,0,0.12); transition: all 0.2s ease; }
        .popup-toggle.active { background: #1d4ed8; }
        .popup-toggle.active::after { transform: translateX(20px); }
        .popup-side { display: flex; flex-direction: column; gap: 16px; height: 100%; }
        .popup-card { background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 8px; padding: 16px; }
        .popup-card h4 { margin: 0 0 8px 0; font-size: 14px; color: #0f172a; font-weight: 700; }
        .popup-stat-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; }
        .popup-stat { background: #fff; border: 1px solid #e2e8f0; border-radius: 8px; padding: 12px; }
        .popup-stat .value { font-size: 24px; font-weight: 800; color: #0f172a; }
        .popup-stat .label { font-size: 12px; color: #6b7280; }
        .popup-preview { border: 1px solid #e2e8f0; border-radius: 8px; background: #fafafa; padding: 14px; }
        .popup-preview-header { font-weight: 700; margin-bottom: 10px; color: #0f172a; display: flex; justify-content: space-between; align-items: center; }
        .popup-preview-fields { display: grid; gap: 10px; }
        .popup-preview-fields.cols-1 { grid-template-columns: 1fr; }
        .popup-preview-fields.cols-2 { grid-template-columns: repeat(2, 1fr); }
        .popup-preview-fields.cols-3 { grid-template-columns: repeat(3, 1fr); }
        .popup-preview-fields.cols-4 { grid-template-columns: repeat(4, 1fr); }
        .popup-preview-field { background: #fff; border: 1px solid #e5e7eb; border-radius: 8px; padding: 10px; }
        .popup-preview-field .label { font-size: 11px; color: #6b7280; text-transform: uppercase; letter-spacing: 0.05em; margin-bottom: 4px; }
        .popup-preview-field .value { font-size: 13px; color: #0f172a; }
        .popup-layout-options { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; }
        .popup-layout-option { border: 2px solid #e2e8f0; border-radius: 8px; padding: 12px; cursor: pointer; text-align: center; transition: all 0.15s ease; background: #fff; }
        .popup-layout-option.active { border-color: #1d4ed8; background: #eef2ff; color: #1d4ed8; }
        .popup-event-stream { display: flex; flex-direction: column; gap: 10px; }
        .popup-event { border: 1px solid #e2e8f0; border-radius: 8px; padding: 12px; background: #fff; }
        .popup-event-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px; color: #0f172a; font-weight: 700; font-size: 14px; }
        .popup-event-time { color: #94a3b8; font-size: 12px; font-weight: 600; }
        .popup-conditions { display: grid; gap: 10px; }
        .popup-condition-card { border: 1px solid #e2e8f0; border-radius: 8px; padding: 12px; background: #fff; }
        .popup-condition-title { font-weight: 700; color: #0f172a; margin-bottom: 8px; display: flex; align-items: center; gap: 8px; }
        .popup-condition-row { display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 8px; margin-bottom: 10px; }
        .popup-pill { display: inline-flex; align-items: center; gap: 6px; padding: 6px 10px; border-radius: 999px; background: #f3f4f6; color: #475569; font-weight: 600; font-size: 12px; }
        .popup-template-buttons { display: flex; flex-direction: column; gap: 8px; }
        @media (max-width: 1100px) { .popup-config-body { grid-template-columns: 1fr; } .popup-side { order: -1; flex-direction: row; overflow-x: auto; } .popup-side .popup-card { min-width: 240px; } }

        /* FIELD MANAGER */
        .field-manager-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            background: #fff;
            transition: all 0.2s ease;
            cursor: move;
        }
        .field-manager-item:hover {
            border-color: #cbd5e1;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
        }
        .field-manager-item.dragging {
            opacity: 0.5;
            cursor: grabbing;
        }
        .field-manager-item.drag-over {
            border-color: #1d4ed8;
            background: #eff6ff;
        }
        .field-drag-handle {
            cursor: grab;
            color: #94a3b8;
            font-size: 18px;
            padding: 4px;
        }
        .field-drag-handle:active {
            cursor: grabbing;
        }
        .field-manager-icon {
            width: 36px;
            height: 36px;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
            background: #f8fafc;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            color: #475569;
            flex-shrink: 0;
        }
        .field-manager-info {
            flex: 1;
            min-width: 0;
        }
        .field-manager-name {
            font-weight: 600;
            color: #0f172a;
            font-size: 14px;
            margin-bottom: 2px;
        }
        .field-manager-name input {
            font-weight: 600;
            color: #0f172a;
            font-size: 14px;
            border: 1px solid #cbd5e1;
            border-radius: 4px;
            padding: 2px 6px;
            width: 100%;
        }
        .field-manager-type-label {
            font-size: 11px;
            color: #64748b;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            font-weight: 500;
        }
        .field-manager-type-select {
            font-size: 12px;
            padding: 2px 4px;
            border: 1px solid #cbd5e1;
            border-radius: 4px;
            background: #fff;
            color: #475569;
        }
        .field-manager-actions {
            display: flex;
            gap: 4px;
            flex-shrink: 0;
        }
        .field-manager-action-btn {
            padding: 6px 8px;
            border-radius: 6px;
            border: 1px solid #e2e8f0;
            background: #fff;
            cursor: pointer;
            transition: all 0.15s ease;
            font-size: 14px;
            color: #64748b;
        }
        .field-manager-action-btn:hover {
            background: #f8fafc;
            border-color: #cbd5e1;
            color: #0f172a;
        }
        .field-manager-action-btn.danger:hover {
            background: #fee2e2;
            border-color: #fca5a5;
            color: #dc2626;
        }

        /* BUTTONS */
        .btn {
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.15s ease;
            border: 1px solid var(--border);
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }
        .btn-primary {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
            box-shadow: none;
        }
        .btn-primary:hover { background: transparent; color: var(--text); border-color: var(--text); box-shadow: none; }
        .btn-secondary { background: transparent; border: 1px solid var(--border); color: var(--text-secondary); box-shadow: none; }
        .btn-secondary:hover { background: var(--muted-surface); border-color: var(--text); color: var(--text); }
        .btn-danger { background: transparent; border: 1px solid var(--border); color: var(--text-secondary); box-shadow: none; }
        .btn-danger:hover { background: #fef2f2; border-color: #ef4444; color: #ef4444; }
        .btn-sm { padding: 5px 10px; font-size: 13px; }

        /* Ghost toggle button */
        #ghostToggleBtn { position: relative; }
        #ghostToggleBtn.ghost-visible { color: var(--text); }
        #ghostToggleBtn.ghost-hidden { color: var(--text-secondary); opacity: 0.7; }
        #ghostToggleBtn.ghost-visible:hover { background: var(--muted-surface); }
        #ghostToggleBtn.ghost-hidden:hover { background: var(--muted-surface); opacity: 1; }
        
        /* BADGES */
        .badge {
            display: inline-flex;
            align-items: center;
            padding: 3px 10px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            white-space: nowrap;
        }
        .badge-green { background-color: #d1fae5; color: #065f46; }
        .badge-yellow { background-color: #fef3c7; color: #92400e; }
        .badge-red { background-color: #fee2e2; color: #991b1b; }
        .badge-blue { background-color: #dbeafe; color: #1e40af; }
        .badge-purple { background-color: #e9d5ff; color: #6b21a8; }
        .badge-gray { background-color: #f3f4f6; color: #374151; }
        .badge-cyan { background-color: #cffafe; color: #155e75; }
        .badge-pink { background-color: #fce7f3; color: #9f1239; }
        
        /* FIELD TYPE DROPDOWN */
        .field-type-select { position: relative; }
        .field-type-trigger {
            width: 100%;
            padding: 12px 14px;
            border: 1px solid #cbd5e1;
            border-radius: 10px;
            background: white;
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            transition: all 0.2s;
            min-height: 64px;
        }
        .field-type-trigger:hover { border-color: #94a3b8; box-shadow: 0 6px 18px rgba(15, 23, 42, 0.05); }
        .field-type-trigger.active { border-color: #3b82f6; box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.12), 0 10px 30px rgba(15, 23, 42, 0.12); }
        .field-type-trigger-content { display: flex; align-items: center; gap: 12px; }
        .field-type-trigger-icon { width: 36px; height: 36px; display: flex; align-items: center; justify-content: center; background: #f1f5f9; border-radius: 10px; font-size: 20px; }
        .field-type-trigger-text { display: flex; flex-direction: column; gap: 3px; text-align: left; }
        .field-type-trigger-arrow { color: #64748b; font-size: 13px; }
        .field-type-dropdown {
            position: absolute;
            top: calc(100% + 10px);
            left: 50%;
            transform: translateX(-50%);
            width: min(760px, calc(100vw - 48px));
            padding: 12px;
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 14px;
            box-shadow: 0 20px 40px rgba(15, 23, 42, 0.16);
            max-height: 520px;
            overflow-y: auto;
            z-index: 1000;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(230px, 1fr));
            gap: 10px;
        }
        .field-type-dropdown.hidden { display: none; }
        .field-type-option {
            padding: 12px;
            display: flex;
            align-items: flex-start;
            gap: 12px;
            cursor: pointer;
            transition: all 0.15s ease;
            border: 1px solid #e2e8f0;
            border-radius: 12px;
            background: white;
        }
        .field-type-option:hover { background: #f8fafc; box-shadow: 0 12px 30px rgba(15, 23, 42, 0.08); }
        .field-type-option.selected { background: #eff6ff; border: 1px solid #3b82f6; box-shadow: 0 14px 32px rgba(59, 130, 246, 0.18); }
        .field-type-icon { width: 36px; height: 36px; display: flex; align-items: center; justify-content: center; background: #f1f5f9; border-radius: 10px; font-size: 20px; }
        .field-type-option.selected .field-type-icon { background: #3b82f6; color: white; }
        .field-type-info { display: flex; flex-direction: column; gap: 3px; min-width: 0; }
        .field-type-name { font-size: 14px; font-weight: 700; color: #0f172a; }
        .field-type-description { font-size: 12px; color: #64748b; line-height: 1.5; }
        .field-type-check { margin-left: auto; color: #3b82f6; font-weight: 700; font-size: 14px; }
        
        /* FILTER BUILDER */
        .filter-group { background: #f9fafb; border: 2px solid #e5e7eb; border-radius: 8px; padding: 16px; margin-bottom: 12px; }
        .filter-group-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px; }
        .filter-operator-toggle { display: flex; background: white; border: 1px solid #e5e7eb; border-radius: 6px; overflow: hidden; }
        .filter-operator-toggle button {
            padding: 4px 12px;
            font-size: 12px;
            font-weight: 600;
            border: none;
            background: transparent;
            cursor: pointer;
            transition: all 0.15s;
        }
        .filter-operator-toggle button.active { background: #3b82f6; color: white; }
        .filter-rule { display: grid; grid-template-columns: 1fr 1fr 1fr auto; gap: 8px; align-items: center; padding: 8px; background: white; border-radius: 6px; margin-bottom: 8px; }
        
        /* UTILITIES */
          .form-label { display: block; font-size: 13px; font-weight: 600; color: #374151; margin-bottom: 8px; }
          .form-hint { font-size: 12px; color: #6b7280; margin-top: 6px; }
          .form-error { font-size: 12px; color: #b91c1c; margin-top: 6px; }
          input[type="text"], input[type="number"], input[type="date"], input[type="email"], input[type="url"], select, textarea {
              width: 100%;
              padding: 8px 12px;
              border: 1px solid #cbd5e1;
              border-radius: 6px;
            font-size: 13px;
            transition: all 0.15s ease;
            background: white;
          }
          input:focus, select:focus, textarea:focus { outline: none; border-color: #3b82f6; box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1); }
          .input-error { border-color: #ef4444; box-shadow: 0 0 0 3px rgba(239, 68, 68, 0.15); }

          .view-type-option { position: relative; cursor: pointer; }
          .view-type-option input[type="radio"] { position: absolute; opacity: 0; pointer-events: none; }
          .view-type-option-content {
              display: flex;
              flex-direction: column;
              align-items: center;
              gap: 8px;
              padding: 16px;
              border: 2px solid #e5e7eb;
              border-radius: 8px;
              background: white;
              transition: all 0.15s ease;
          }
          .view-type-option-content i { font-size: 24px; color: #6b7280; }
          .view-type-option-content span { font-size: 13px; font-weight: 500; color: #374151; }
          .view-type-option:hover .view-type-option-content { border-color: #3b82f6; background: #f0f9ff; }
          .view-type-option input[type="radio"]:checked + .view-type-option-content {
              border-color: #3b82f6;
              background: #eff6ff;
          }
          .view-type-option input[type="radio"]:checked + .view-type-option-content i { color: #3b82f6; }

          ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: #f3f4f6; }
        ::-webkit-scrollbar-thumb { background: #d1d5db; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #9ca3af; }
        
        .toast {
            position: fixed;
            bottom: 24px;
            right: 24px;
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            padding: 16px 20px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            z-index: 2000;
            animation: slideInToast 0.3s ease;
        }
        @keyframes slideInToast { from { transform: translateX(400px); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
        
        .side-panel {
            position: fixed;
            right: 0;
            top: 0;
            height: 100vh;
            width: 420px;
            background: white;
            box-shadow: -4px 0 24px rgba(0, 0, 0, 0.12);
            transform: translateX(100%);
            transition: transform 0.3s ease;
            z-index: 1000;
            display: flex;
            flex-direction: column;
        }
        .side-panel.open { transform: translateX(0); }

        .csv-helper-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
            gap: 12px;
        }

        .csv-helper-card {
            border: 1px solid #e5e7eb;
            border-radius: 10px;
            padding: 12px;
            background: white;
        }

        #csvPreviewContainer {
            overflow: auto;
            max-height: 340px;
        }

        .csv-preview-table {
            width: 100%;
            min-width: max-content;
            border-collapse: collapse;
            font-size: 12px;
            border: 1px solid #e5e7eb;
        }

        .csv-preview-table th, .csv-preview-table td {
            border: 1px solid #e5e7eb;
            padding: 6px 8px;
            text-align: left;
            background: white;
        }

        .csv-preview-table th { background: #f9fafb; font-weight: 700; }

        .csv-match-pill {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 10px;
            border-radius: 9999px;
            background: #eef2ff;
            color: #4338ca;
            font-weight: 600;
            font-size: 12px;
        }

        .fuzzy-match-row {
            border: 1px solid #e5e7eb;
            border-radius: 10px;
            padding: 12px;
            margin-bottom: 10px;
            background: #fff;
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .fuzzy-match-row strong { display: block; font-size: 14px; }

        .fuzzy-score {
            font-weight: 700;
            color: #16a34a;
        }

        /* Type Assessment Styles */
        .type-assessment-row {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 8px 12px;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            background: white;
            transition: all 0.15s;
        }
        .type-assessment-row:hover {
            border-color: #c7d2fe;
            background: #fafafa;
        }
        .type-assessment-row.needs-review {
            border-color: #fbbf24;
            background: #fffbeb;
        }
        .type-assessment-field-name {
            flex: 1;
            font-weight: 600;
            font-size: 13px;
            color: #1e293b;
        }
        .type-assessment-type {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 10px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.15s;
        }
        .type-assessment-type:hover {
            filter: brightness(0.95);
        }
        .type-assessment-confidence {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 11px;
            color: #64748b;
        }
        .confidence-bar {
            width: 40px;
            height: 4px;
            background: #e5e7eb;
            border-radius: 2px;
            overflow: hidden;
        }
        .confidence-bar-fill {
            height: 100%;
            border-radius: 2px;
            transition: width 0.3s;
        }
        .confidence-high .confidence-bar-fill { background: #22c55e; }
        .confidence-medium .confidence-bar-fill { background: #f59e0b; }
        .confidence-low .confidence-bar-fill { background: #ef4444; }
        .type-assessment-samples {
            font-size: 11px;
            color: #94a3b8;
            max-width: 150px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .type-alternatives {
            display: flex;
            gap: 4px;
            flex-wrap: wrap;
        }
        .type-alternative-chip {
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 4px;
            background: #f1f5f9;
            color: #64748b;
            cursor: pointer;
            transition: all 0.15s;
        }
        .type-alternative-chip:hover {
            background: #e2e8f0;
            color: #334155;
        }
        .type-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            z-index: 100;
            min-width: 200px;
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            padding: 4px;
            margin-top: 4px;
        }
        .type-dropdown-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.15s;
        }
        .type-dropdown-item:hover {
            background: #f1f5f9;
        }
        .type-dropdown-item.selected {
            background: #eef2ff;
            color: #4338ca;
        }

        .panel-controls {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            margin-bottom: 12px;
        }
        
        .option-row { display: flex; gap: 8px; align-items: center; margin-bottom: 8px; }
        .option-row input { flex: 1; }
        .color-picker { display: flex; gap: 4px; flex-wrap: wrap; }
        .color-option {
            width: 24px;
            height: 24px;
            border-radius: 4px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.15s;
        }
        .color-option:hover { transform: scale(1.1); }
        .color-option.selected { border-color: #1e293b; }
        
        .field-editor { border: 1px solid #e5e7eb; border-radius: 6px; padding: 12px; transition: all 0.15s; }
        .field-editor:hover { border-color: #d1d5db; background: #fafafa; }
        .field-editor:focus-within { border-color: #3b82f6; box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1); }
        .field-editor input, .field-editor textarea, .field-editor select { width: 100%; padding: 8px 12px; border: 1px solid #e5e7eb; border-radius: 4px; font-size: 14px; }
        
        .record-tabs { display: flex; border-bottom: 1px solid #e5e7eb; padding: 0 24px; background: #fafafa; }
        .record-tab {
            padding: 12px 16px;
            font-size: 14px;
            font-weight: 500;
            color: #6b7280;
            cursor: pointer;
            border-bottom: 2px solid transparent;
            margin-bottom: -1px;
            transition: all 0.15s ease;
        }
        .record-tab:hover { color: #374151; }
        .record-tab.active { color: #2563eb; border-bottom-color: #2563eb; }
        .record-tab i { margin-right: 6px; }

        .view-tabs {
            display: flex;
            align-items: flex-end;
            gap: 2px;
            padding: 0 10px;
            background: transparent;
            overflow-x: auto;
            position: relative;
            border-bottom: 1px solid #e5e7eb;
            flex: 1;
        }
        .view-tabs.hidden {
            display: none;
        }

        .view-tab {
            position: relative;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            border: none;
            border-bottom: 2px solid transparent;
            background: transparent;
            cursor: pointer;
            transition: all 0.15s ease;
            color: #9ca3af;
            font-weight: 500;
            white-space: nowrap;
            flex-shrink: 0;
            user-select: none;
            border-radius: 8px 8px 0 0;
            margin-bottom: -1px;
        }

        .view-tab:hover {
            background: rgba(0, 0, 0, 0.04);
            color: #6b7280;
        }

        .view-tab.active {
            background: white;
            border-bottom: 2px solid #111827;
            color: #111827;
            font-weight: 600;
        }

        /* Import view tabs - distinctive green styling */
        .view-tab.import-view-tab {
            background: rgba(16, 185, 129, 0.08);
            border: none;
            border-bottom: 2px solid transparent;
            color: #047857;
        }
        .view-tab.import-view-tab:hover {
            background: rgba(16, 185, 129, 0.12);
            color: #065f46;
        }
        .view-tab.import-view-tab.active {
            background: white;
            border-bottom: 2px solid #10b981;
            color: #047857;
            font-weight: 600;
        }
        .view-tab.import-view-tab .view-tab-icon {
            color: #10b981;
        }
        .view-tab.import-view-tab .view-tab-meta {
            background: rgba(16, 185, 129, 0.15);
            color: #047857;
        }

        /* Floating import banner - doesn't affect layout */
        .floating-import-banner {
            position: fixed;
            top: 12px;
            right: 12px;
            background: #064e3b;
            border: 1px solid #10b981;
            border-radius: 10px;
            padding: 12px 16px;
            display: flex;
            align-items: flex-start;
            gap: 12px;
            max-width: 360px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.25);
            z-index: 1000;
            animation: slideInFromRight 0.3s ease-out;
        }
        @keyframes slideInFromRight {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        .floating-import-banner.hiding {
            animation: slideOutToRight 0.2s ease-in forwards;
        }
        @keyframes slideOutToRight {
            from { transform: translateX(0); opacity: 1; }
            to { transform: translateX(100%); opacity: 0; }
        }
        .floating-import-banner-icon {
            font-size: 20px;
            color: #10b981;
            flex-shrink: 0;
            margin-top: 2px;
        }
        .floating-import-banner-content {
            flex: 1;
            min-width: 0;
        }
        .floating-import-banner-title {
            font-weight: 600;
            color: #d1fae5;
            font-size: 14px;
            margin-bottom: 4px;
        }
        .floating-import-banner-text {
            font-size: 12px;
            color: #a7f3d0;
            line-height: 1.4;
        }
        .floating-import-banner-actions {
            display: flex;
            gap: 8px;
            margin-top: 10px;
        }
        .floating-import-banner-btn {
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            border: none;
            transition: all 0.15s ease;
        }
        .floating-import-banner-btn.primary {
            background: #10b981;
            color: #064e3b;
        }
        .floating-import-banner-btn.primary:hover {
            background: #34d399;
        }
        .floating-import-banner-close {
            position: absolute;
            top: 8px;
            right: 8px;
            background: none;
            border: none;
            color: #6ee7b7;
            cursor: pointer;
            padding: 4px;
            font-size: 16px;
            opacity: 0.7;
            transition: opacity 0.15s ease;
        }
        .floating-import-banner-close:hover {
            opacity: 1;
        }

        .view-tab.tab-being-dragged {
            opacity: 0.6;
        }

        .view-tab.tab-drop-before::before,
        .view-tab.tab-drop-after::after {
            content: '';
            position: absolute;
            top: 6px;
            bottom: 6px;
            width: 3px;
            background: #cbd5e1;
            border-radius: 999px;
        }
        .view-tab.tab-drop-before::before { left: -4px; }
        .view-tab.tab-drop-after::after { right: -4px; }

        .view-tab-add {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 28px;
            height: 28px;
            background: transparent;
            border: 1px dashed #cbd5e1;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            color: #6b7280;
            transition: all 0.15s;
            flex-shrink: 0;
        }
        .view-tab-add:hover {
            background: #f1f5f9;
            border-color: #94a3b8;
            color: #374151;
        }

        .view-tab-icon {
            color: inherit;
            font-size: 16px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            opacity: 0.7;
        }

        .view-tab.active .view-tab-icon {
            opacity: 1;
        }

        .view-tab-text { display: flex; align-items: center; gap: 4px; min-width: 0; }
        .view-tab-name { font-weight: 600; font-size: 12px; color: inherit; white-space: nowrap; }
        .view-tab-meta {
            font-size: 10px;
            color: #9ca3af;
            padding: 1px 7px;
            border-radius: 6px;
            background: #f3f4f6;
            letter-spacing: 0.01em;
        }

        .view-tab-actions {
            display: inline-flex;
            gap: 4px;
            margin-left: auto;
            padding-left: 8px;
            color: #6b7280;
            opacity: 0;
            transform: translateX(6px);
            transition: all 0.12s ease;
        }

        .view-tab:hover .view-tab-actions,
        .view-tab.active .view-tab-actions {
            opacity: 1;
            transform: translateX(0);
        }

        .view-tab-btn {
            border: 1px solid transparent;
            background: transparent;
            color: inherit;
            border-radius: 10px;
            padding: 6px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .view-tab-btn:hover { color: #111827; background: #ffffff; border-color: #d1d5db; }
        .view-tab-btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .view-tab-save-btn { color: #10b981; }
        .view-tab-save-btn:hover { color: #047857; background: rgba(16, 185, 129, 0.1); border-color: #10b981; }

        .view-surface {
            background: #ffffff;
            border: 1px solid #e5e7eb;
            border-top: none;
            border-radius: 0 0 8px 8px;
            overflow: hidden;
            min-height: 420px;
            display: flex;
            flex-direction: column;
        }

        #viewContainer {
            flex: 1;
            display: flex;
            flex-direction: column;
            position: relative;
            min-height: 400px;
        }

        .view-stage-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            padding: 12px 16px;
            border-bottom: 1px solid #e5e7eb;
            background: linear-gradient(180deg, #ffffff 0%, #f8fafc 100%);
            flex-wrap: wrap;
        }

        .view-stage-title {
            display: flex;
            align-items: center;
            gap: 12px;
            min-width: 0;
        }

        .view-stage-pill {
            padding: 6px 10px;
            border-radius: 10px;
            border: 1px solid #e2e8f0;
            background: #f8fafc;
            color: #475569;
            font-size: 12px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.04em;
        }

        .view-breadcrumb {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
            color: #94a3b8;
            margin-bottom: 4px;
        }

        .view-breadcrumb-item {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .view-breadcrumb-item.clickable {
            cursor: pointer;
            transition: color 0.15s;
        }

        .view-breadcrumb-item.clickable:hover {
            color: #3b82f6;
        }

        .view-breadcrumb-sep {
            color: #cbd5e1;
        }

        .view-stage-name { font-weight: 800; font-size: 16px; letter-spacing: -0.01em; color: #0f172a; }
        .view-stage-sub { color: #64748b; font-size: 13px; font-weight: 600; }

        /* View mode badge in header */
        .view-mode-header-badge {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            font-size: 10px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            padding: 2px 6px;
            border-radius: 4px;
            margin-left: 8px;
        }
        .view-mode-header-badge.sandbox {
            background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
            color: #92400e;
            border: 1px dashed #f59e0b;
        }
        .view-mode-header-badge.live {
            background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%);
            color: #1e40af;
            border: 1px solid #3b82f6;
        }
        .view-mode-header-badge i { font-size: 10px; }

        .view-stage-actions { display: flex; flex-direction: column; gap: 10px; width: 100%; margin-top: 20px; }
        .view-stage-actions .primary-actions { flex-wrap: wrap; }
        .view-stage-controls { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; min-width: 0; }
        .view-stage-inline-actions { display: inline-flex; align-items: center; gap: 6px; flex-wrap: wrap; }
        .toolbar-row { display: flex; align-items: center; gap: 10px; flex-wrap: wrap; justify-content: space-between; width: 100%; }
        .toolbar-row.scrollable { overflow-x: auto; padding-bottom: 4px; }
        .toolbar-group { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; min-width: 0; }
        .selection-group { display: inline-flex; align-items: center; gap: 8px; flex-wrap: wrap; }
        .selection-indicator { display: inline-flex; align-items: center; gap: 6px; padding: 6px 10px; border-radius: 999px; background: #eef2ff; color: #3730a3; font-weight: 700; font-size: 12px; }
        .selection-indicator.hidden { display: none; }
        .selection-indicator i { font-size: 14px; }
        .toss-selected-btn { background: #fef2f2 !important; border-color: #fecaca !important; color: #dc2626 !important; }
        .toss-selected-btn:hover { background: #fee2e2 !important; border-color: #f87171 !important; }
        .toss-selected-btn.hidden { display: none; }
        .toss-selected-btn i { color: #dc2626; }

        .view-stage-body { padding: 14px 16px 18px; background: #ffffff; flex: 1; }

        .view-table-shell {
            border: 1px solid #e2e8f0;
            border-radius: 12px;
            overflow: hidden;
            background: #ffffff;
            box-shadow: inset 0 1px 0 rgba(255,255,255,0.7);
        }

        /* Sandbox mode table styling - dashed border, subtle background */
        .view-table-shell.sandbox {
            border: 2px dashed #d97706;
            background: linear-gradient(135deg, #fffbeb 0%, #fef3c7 100%);
        }
        .view-table-shell.sandbox table {
            background: #ffffff;
        }

        /* Live mode table styling - solid, confident */
        .view-table-shell.live {
            border: 1px solid #3b82f6;
        }

        /* ============================================================
           SANDBOX PAGE STYLES - Imports, Sets, Views catalog
           ============================================================ */
        .sandbox-section {
            background: #ffffff;
            border: 1px solid #e2e8f0;
            border-radius: 12px;
            overflow: hidden;
        }

        .sandbox-section-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 16px;
            background: linear-gradient(180deg, #f8fafc 0%, #f1f5f9 100%);
            border-bottom: 1px solid #e2e8f0;
        }

        .sandbox-section-header h3 {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            font-weight: 700;
            color: #1e293b;
            margin: 0;
        }

        .sandbox-section-header h3 i {
            font-size: 16px;
            color: #64748b;
        }

        .sandbox-empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 32px;
            text-align: center;
            color: #94a3b8;
        }

        .sandbox-empty-state i {
            font-size: 32px;
            margin-bottom: 12px;
            opacity: 0.5;
        }

        .sandbox-empty-state p {
            margin: 0;
            font-size: 14px;
        }

        .sandbox-empty-state p.text-xs {
            font-size: 12px;
            margin-top: 4px;
        }

        .sandbox-count-badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-width: 18px;
            height: 18px;
            padding: 0 5px;
            margin-left: 4px;
            background: rgba(0, 0, 0, 0.08);
            border-radius: 9px;
            font-size: 11px;
            font-weight: 600;
        }

        .sandbox-mode-dot {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 4px;
        }

        .sandbox-mode-dot.live {
            background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
            box-shadow: 0 0 4px rgba(34, 197, 94, 0.4);
        }

        .sandbox-mode-dot.sandbox {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            box-shadow: 0 0 4px rgba(245, 158, 11, 0.4);
        }

        .sandbox-mode-badge {
            display: inline-flex;
            align-items: center;
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
        }

        .sandbox-mode-badge.live {
            background: linear-gradient(135deg, #dcfce7 0%, #bbf7d0 100%);
            color: #166534;
            border: 1px solid #86efac;
        }

        .sandbox-mode-badge.sandbox {
            background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
            color: #92400e;
            border: 1px dashed #f59e0b;
        }

        .selection-header {
            width: 36px; min-width: 36px; max-width: 36px;
            text-align: center; padding: 8px 6px;
            cursor: pointer;
            user-select: none;
        }
        .selection-header:hover { background: rgba(99, 102, 241, 0.08); }
        .row-select-cell {
            width: 36px; min-width: 36px; max-width: 36px;
            text-align: center; padding: 8px 6px;
            cursor: pointer;
            user-select: none;
        }
        .row-select-cell:hover { background: rgba(99, 102, 241, 0.08); }

        /* Custom checkbox styling */
        .row-select-cell input[type="checkbox"],
        .selection-header input[type="checkbox"] {
            appearance: none;
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border: 1.5px solid #d1d5db;
            border-radius: 4px;
            background: #fff;
            cursor: pointer;
            transition: all 0.15s ease;
            position: relative;
            vertical-align: middle;
        }
        .row-select-cell input[type="checkbox"]:hover,
        .selection-header input[type="checkbox"]:hover {
            border-color: #6366f1;
            background: #f5f3ff;
        }
        .row-select-cell input[type="checkbox"]:checked,
        .selection-header input[type="checkbox"]:checked {
            background: #6366f1;
            border-color: #6366f1;
        }
        .row-select-cell input[type="checkbox"]:checked::after,
        .selection-header input[type="checkbox"]:checked::after {
            content: '';
            position: absolute;
            left: 4.5px;
            top: 1.5px;
            width: 5px;
            height: 9px;
            border: solid #fff;
            border-width: 0 2px 2px 0;
            transform: rotate(45deg);
        }
        .selection-header input[type="checkbox"]:indeterminate {
            background: #6366f1;
            border-color: #6366f1;
        }
        .selection-header input[type="checkbox"]:indeterminate::after {
            content: '';
            position: absolute;
            left: 3px;
            top: 6px;
            width: 8px;
            height: 2px;
            background: #fff;
            border-radius: 1px;
        }
        .row-select-cell input[type="checkbox"]:focus,
        .selection-header input[type="checkbox"]:focus {
            outline: none;
            box-shadow: 0 0 0 2px rgba(99, 102, 241, 0.25);
        }

        .row-number-header { width: 36px; min-width: 36px; max-width: 36px; text-align: right; padding-right: 8px; color: #9ca3af; font-size: 11px; font-weight: 500; user-select: none; }
        .row-number-cell { width: 36px; min-width: 36px; max-width: 36px; text-align: right; padding-right: 8px; color: #9ca3af; font-size: 11px; user-select: none; }
        .row-selected td { background: #eef2ff; }
        .row-selected:hover td { background: #e0e7ff; }
        .row-selected .row-select-cell { background: rgba(99, 102, 241, 0.12); }
        .row-selected .row-select-cell:hover { background: rgba(99, 102, 241, 0.18); }

        /* Hidden fields column */
        .hidden-fields-header {
            width: 100px;
            min-width: 100px;
            text-align: center;
            background: #fef3c7 !important;
            border-left: 2px dashed #d97706;
        }
        .hidden-fields-header:hover {
            background: #fde68a !important;
        }
        .hidden-fields-trigger {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            color: #92400e;
            font-size: 12px;
            font-weight: 500;
        }
        .hidden-fields-trigger i {
            font-size: 14px;
        }
        .hidden-count {
            white-space: nowrap;
        }
        .hidden-fields-cell {
            width: 100px;
            min-width: 100px;
            background: #fffbeb;
            border-left: 2px dashed #d97706;
        }

        /* Add column button (last column) */
        .add-column-header {
            width: 60px;
            min-width: 60px;
            text-align: center;
            background: var(--surface, #fff) !important;
        }
        .add-column-header:hover {
            background: #f8fafc !important;
        }
        .add-column-trigger {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            color: #94a3b8;
            font-size: 18px;
            transition: color 0.15s ease;
        }
        .add-column-header:hover .add-column-trigger {
            color: #3b82f6;
        }
        .add-column-trigger i {
            font-size: 18px;
        }
        .add-column-cell {
            width: 60px;
            min-width: 60px;
            background: var(--surface, #fff);
        }

        .json-tab {
            padding: 12px 20px;
            font-size: 14px;
            font-weight: 500;
            color: #6b7280;
            cursor: pointer;
            border-bottom: 2px solid transparent;
            background: transparent;
            border: none;
            transition: all 0.15s ease;
        }
        .json-tab:hover { color: #374151; background: #f9fafb; }
        .json-tab.active { color: #3b82f6; border-bottom-color: #3b82f6; }
        
        .json-key { color: #b45309; font-weight: 600; }
        .json-string { color: #15803d; }
        .json-number { color: #1e40af; }
        .json-boolean { color: #7c2d12; }
        .json-null { color: #991b1b; font-style: italic; }
        .json-bracket { color: #6b7280; }
        .json-index { color: #9333ea; font-size: 0.85em; }

        /* JSON Cell Display (DISPLAY subtype) */
        .json-cell-display {
            max-height: 100px;
            overflow: hidden;
            cursor: pointer;
            position: relative;
        }
        .json-cell-display:hover { background: #f0f9ff; }
        .json-cell-display::after {
            content: 'Click to expand';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(transparent, white 60%);
            padding: 16px 8px 4px;
            font-size: 10px;
            color: #6b7280;
            text-align: center;
            opacity: 0;
            transition: opacity 0.15s;
        }
        .json-cell-display:hover::after { opacity: 1; }
        .json-code-preview {
            font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Fira Code', monospace;
            font-size: 11px;
            line-height: 1.4;
            margin: 0;
            white-space: pre-wrap;
            word-break: break-word;
        }

        /* JSON Tree Visualization (RENDER subtype) */
        .json-tree-container {
            font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Fira Code', monospace;
            font-size: 12px;
            line-height: 1.5;
            max-height: 200px;
            overflow: auto;
        }
        .json-tree-node { margin-left: 0; }
        .json-tree-children { margin-left: 16px; border-left: 1px dashed #e5e7eb; padding-left: 8px; }
        .json-tree-item { margin: 2px 0; }
        .json-toggle {
            display: inline-block;
            width: 12px;
            cursor: pointer;
            color: #9ca3af;
            transition: transform 0.15s;
            user-select: none;
        }
        .json-tree-node.collapsed > .json-toggle { transform: rotate(-90deg); }
        .json-tree-node.collapsed > .json-tree-children { display: none; }
        .json-tree-node.collapsed > .json-collapse-hint { display: inline; }
        .json-collapse-hint {
            display: none;
            color: #9ca3af;
            font-style: italic;
            font-size: 0.9em;
            margin-left: 4px;
        }

        #jsonContent {
            line-height: 1.5;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        
        .profile-selector { display: flex; gap: 8px; padding: 12px 0; overflow-x: auto; }
        .profile-tab {
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s;
            border: 1px solid #e5e7eb;
            background: white;
            white-space: nowrap;
        }
        .profile-tab:hover { background: #f3f4f6; }
        .profile-tab.active { background: #8b5cf6; color: white; border-color: #8b5cf6; }
        
        .history-entry {
            border-left: 3px solid #e5e7eb;
            padding: 12px;
            margin-bottom: 8px;
            transition: all 0.15s ease;
            cursor: pointer;
            border-radius: 4px;
        }
        .history-entry:hover { border-left-color: #3b82f6; background-color: #f9fafb; }

        .provenance-section {
            padding: 12px;
            background: white;
            border-radius: 6px;
            border: 1px solid #e5e7eb;
        }
        .provenance-section h4 {
            margin-bottom: 8px;
            color: #374151;
        }

        .mobile-sidebar-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.35);
            z-index: 30;
        }

        @media (min-width: 1100px) {
            .view-stage-actions { flex-direction: column; }
            .toolbar-row { flex: 1; }
            .toolbar-row.secondary { justify-content: flex-end; }
        }

        @media (max-width: 640px) {
            .toolbar-row { flex-direction: column; align-items: stretch; }
            .toolbar-row.secondary { gap: 12px; }
            .toolbar-row .toolbar-group, .selection-group { width: 100%; justify-content: space-between; }
        }

        @media (max-width: 1024px) {
            body { padding-bottom: var(--mobile-bottom-bar-height); }
            .mobile-topbar { display: flex; }
            .mobile-bottom-bar { display: grid; }
            .mobile-fab { display: inline-flex; }
            .app-header { display: none; }
            .app-main { padding: 12px var(--mobile-padding); }
        }

        @media (max-width: 768px) {
            .toolbar-actions button,
            .toolbar-menu-toggle { min-height: 44px; }
            .grid-table-wrapper { overflow-x: auto; -webkit-overflow-scrolling: touch; margin: 0 -16px; padding: 0 16px; }
            .grid-table { min-width: 720px; }
            .view-type-btn { padding: 10px 12px; }
        }

        @media (max-width: 1024px) {
            :root { --sidebar-width: 240px; }
            .app-container { grid-template-areas: "header" "main"; grid-template-columns: 1fr; grid-template-rows: auto 1fr; }
            .app-sidebar {
                position: fixed;
                inset: 0 auto 0 0;
                width: var(--sidebar-width);
                transform: translateX(-100%);
                transition: transform 0.3s ease;
                z-index: 40;
            }
            .mobile-sidebar-overlay { display: none; }
            .mobile-layout.sidebar-open-mobile .app-sidebar { transform: translateX(0); box-shadow: 8px 0 24px rgba(0,0,0,0.18); }
            .mobile-layout.sidebar-open-mobile .mobile-sidebar-overlay { display: block; }
            .app-header { position: sticky; top: 0; z-index: 20; }
            .toolbar { flex-direction: column; align-items: stretch; gap: 12px; }
            .toolbar .view-type-switcher { width: 100%; overflow-x: auto; padding-bottom: 4px; }
            .toolbar-left { width: 100%; flex-direction: column; align-items: flex-start; }
            .toolbar-inline-actions { width: 100%; }
            .toolbar-actions { width: 100%; justify-content: space-between; }
            .primary-actions { flex: 1; }
            .toolbar-actions, .primary-actions { flex-wrap: wrap; }
            .toolbar-actions button { flex: 1 1 calc(50% - 8px); min-width: 140px; }
            .toolbar-menu { width: 100%; display: flex; justify-content: flex-end; }
            .toolbar-menu-panel { width: min(100%, 360px); }
            .cards-grid { grid-template-columns: repeat(auto-fill, minmax(240px, 1fr)); }
            .kanban-board { min-height: auto; }
        }

        @media (max-width: 640px) {
            .toolbar-actions button { flex: 1 1 100%; }
            .toolbar-menu-toggle { width: 100%; justify-content: center; }
            .cards-grid { grid-template-columns: 1fr; }
            .kanban-column { min-width: 260px; }
        }

        /* NEW NAVIGATION STYLES - Tab-like appearance */
        .nav-item {
            padding: 0.5rem 0.75rem;
            cursor: pointer;
            border-radius: 0.5rem;
            font-size: 0.875rem;
            transition: all 0.15s ease;
            color: #9ca3af;
            font-weight: 500;
            border: 1px solid transparent;
            background: transparent;
        }
        .nav-item:hover {
            background: rgba(55, 65, 81, 0.5);
            border-color: rgba(75, 85, 99, 0.5);
            color: #e5e7eb;
        }
        .nav-item.active {
            background: linear-gradient(135deg, rgba(37, 99, 235, 0.15), rgba(59, 130, 246, 0.1));
            border-color: rgba(59, 130, 246, 0.4);
            color: #93c5fd;
            font-weight: 600;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
        }

        .nav-section-title {
            padding: 0.75rem 1rem 0.5rem 1rem;
            text-transform: uppercase;
            font-size: 0.75rem;
            letter-spacing: 0.05em;
            color: #9ca3af;
            font-weight: 600;
        }

        .world-nav-parent {
            padding: 0.5rem 1rem;
            border-radius: 0.375rem;
            margin: 0 0.5rem;
            transition: background-color 0.15s ease;
            font-weight: 500;
        }
        .world-nav-parent:hover {
            background-color: transparent;
        }

        .world-nav-children {
            margin-left: 1rem;
            margin-top: 0.25rem;
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        /* DASHBOARD/LANDING PAGE STYLES */
        .card {
            background-color: white;
            border-radius: 0.5rem;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1);
            border: 1px solid #e5e7eb;
            padding: 1rem;
        }

        .summary-card {
            background-color: white;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            padding: 1.5rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .summary-card:hover {
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.15);
            transform: translateY(-2px);
        }
        .summary-card-count {
            font-size: 1.5rem;
            font-weight: 600;
            line-height: 2rem;
            color: var(--text);
        }
        .summary-card-title {
            color: #6b7280;
            margin-top: 0.5rem;
            font-size: 0.875rem;
        }

        .entity-type-card {
            background-color: #f9fafb;
            border: 1px solid #e5e7eb;
            border-radius: 0.5rem;
            padding: 1rem;
            cursor: pointer;
            transition: background-color 0.15s ease;
        }
        .entity-type-card:hover {
            background-color: #f3f4f6;
        }
        .entity-type-card-label {
            font-size: 1.125rem;
            font-weight: 500;
            line-height: 1.75rem;
        }
        .entity-type-card-count {
            font-size: 0.875rem;
            color: #6b7280;
            margin-top: 0.25rem;
        }

        .dashboard-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2.5rem;
        }
        .dashboard-header h1 {
            font-size: 1.875rem;
            font-weight: 600;
            line-height: 2.25rem;
            margin: 0;
        }
        .dashboard-actions {
            display: flex;
            gap: 0.75rem;
        }

        .dashboard-section {
            margin-bottom: 2.5rem;
        }
        .dashboard-section h2 {
            font-size: 1.125rem;
            font-weight: 500;
            line-height: 1.75rem;
            margin: 0 0 0.75rem 0;
        }

        .summary-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 1.5rem;
        }

        .entity-type-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1rem;
        }

        .discovery-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
        }

        .discovery-card {
            padding: 1rem;
            background-color: white;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1);
            border-radius: 0.5rem;
            border: 1px solid #e5e7eb;
        }
        .discovery-card-title {
            font-weight: 500;
            margin-bottom: 0.5rem;
        }
        .discovery-card-description {
            font-size: 0.875rem;
            color: #6b7280;
            margin-bottom: 0.75rem;
        }

        .recent-changes-list {
            list-style: none;
            padding: 0;
            margin: 0;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        .recent-changes-list li {
            font-size: 0.875rem;
            color: #4b5563;
            padding: 0.5rem 0;
            border-bottom: 1px solid #f3f4f6;
        }
        .recent-changes-list li:last-child {
            border-bottom: none;
        }

        @media (max-width: 1024px) {
            .summary-grid { grid-template-columns: repeat(2, 1fr); }
            .entity-type-grid { grid-template-columns: repeat(2, 1fr); }
            .discovery-grid { grid-template-columns: 1fr; }
        }

        @media (max-width: 640px) {
            .summary-grid { grid-template-columns: 1fr; }
            .entity-type-grid { grid-template-columns: 1fr; }
        }

        /* Entity and Relation Search Dropdowns */
        .entity-search-container,
        .relation-search-container {
            position: relative;
        }

        .entity-dropdown,
        .relation-dropdown {
            position: absolute;
            z-index: 100;
            width: 100%;
            max-height: 300px;
            overflow-y: auto;
            background: white;
            border: 1px solid var(--border);
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            margin-top: 4px;
        }

        .entity-option,
        .relation-option {
            padding: 10px 12px;
            cursor: pointer;
            border-bottom: 1px solid #f3f4f6;
            transition: background-color 0.15s ease;
        }

        .entity-option:last-child,
        .relation-option:last-child {
            border-bottom: none;
        }

        .entity-option:hover,
        .relation-option:hover {
            background-color: #f0f9ff;
        }

        .entity-option .font-medium,
        .relation-option .font-medium {
            font-weight: 500;
            color: var(--text);
            margin-bottom: 2px;
        }

        .entity-option .text-xs,
        .relation-option .text-xs {
            font-size: 11px;
            color: var(--text-secondary);
        }

        .relation-dropdown .px-3.py-1.bg-gray-50 {
            position: sticky;
            top: 0;
            background: #f9fafb;
            font-size: 11px;
            font-weight: 600;
        }

        /* Connection Wizard Styles */
        .connection-wizard-steps {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .wizard-step {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }

        .wizard-step .step-circle {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: #e5e7eb;
            color: #6b7280;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 14px;
            transition: all 0.2s ease;
        }

        .wizard-step.active .step-circle {
            background: #3b82f6;
            color: white;
        }

        .wizard-step.completed .step-circle {
            background: #10b981;
            color: white;
        }

        .wizard-step .step-label {
            font-size: 11px;
            color: #6b7280;
            font-weight: 500;
        }

        .wizard-step.active .step-label {
            color: #3b82f6;
            font-weight: 600;
        }

        .wizard-step.completed .step-label {
            color: #10b981;
        }

        .step-connector {
            flex: 1;
            height: 2px;
            background: #e5e7eb;
            margin: 0 8px;
            margin-bottom: 20px;
            max-width: 60px;
        }

        .wizard-panel {
            min-height: 350px;
        }

        /* Entity Selection Grid */
        .entity-selection-grid {
            display: grid;
            gap: 8px;
        }

        .entity-selection-item {
            padding: 12px 16px;
            background: white;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.15s ease;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .entity-selection-item:hover {
            border-color: #3b82f6;
            background: #f0f9ff;
        }

        .entity-selection-item.selected {
            border-color: #3b82f6;
            background: #eff6ff;
        }

        .entity-selection-item .entity-icon {
            width: 36px;
            height: 36px;
            border-radius: 8px;
            background: #f3f4f6;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
        }

        .entity-selection-item .entity-info {
            flex: 1;
            min-width: 0;
        }

        .entity-selection-item .entity-name {
            font-weight: 600;
            color: #111827;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .entity-selection-item .entity-meta {
            font-size: 12px;
            color: #6b7280;
        }

        .entity-selection-item.drill-down {
            background: #f9fafb;
        }

        .entity-selection-item.drill-down .entity-icon {
            background: #e5e7eb;
        }

        /* Relation Selection */
        .relation-selection-grid {
            display: grid;
            gap: 8px;
        }

        .relation-selection-item {
            padding: 14px 16px;
            background: white;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .relation-selection-item:hover {
            border-color: #10b981;
            background: #f0fdf4;
        }

        .relation-selection-item.selected {
            border-color: #10b981;
            background: #ecfdf5;
        }

        .relation-selection-item .relation-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 4px;
        }

        .relation-selection-item .relation-mode {
            font-weight: 600;
            color: #111827;
        }

        .relation-selection-item .relation-operator {
            font-size: 11px;
            padding: 2px 6px;
            background: #e5e7eb;
            border-radius: 4px;
            color: #6b7280;
            font-weight: 600;
        }

        .relation-selection-item .relation-description {
            font-size: 12px;
            color: #6b7280;
        }

        /* Hierarchy Breadcrumb */
        .hierarchy-breadcrumb {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 8px 12px;
            background: #f3f4f6;
            border-radius: 6px;
            margin-bottom: 12px;
            font-size: 13px;
        }

        .hierarchy-breadcrumb-item {
            color: #6b7280;
            cursor: pointer;
        }

        .hierarchy-breadcrumb-item:hover {
            color: #3b82f6;
            text-decoration: underline;
        }

        .hierarchy-breadcrumb-item.current {
            color: #111827;
            font-weight: 600;
            cursor: default;
        }

        .hierarchy-breadcrumb-sep {
            color: #9ca3af;
            color: var(--text-secondary);
            padding: 6px 12px;
            border-bottom: 1px solid #e5e7eb;
        }

        /* ALL IMPORTS TAB PANEL */
        .imports-tab-panel {
            position: fixed;
            top: 0;
            right: 0;
            width: 900px;
            max-width: 95vw;
            height: 100vh;
            background: #0f172a;
            color: #e2e8f0;
            box-shadow: -4px 0 24px rgba(0, 0, 0, 0.3);
            transform: translateX(100%);
            transition: transform 0.3s cubic-bezier(0.16, 1, 0.3, 1);
            z-index: 1000;
            display: flex;
            flex-direction: column;
        }
        .imports-tab-panel.open {
            transform: translateX(0);
        }
        .imports-tab-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 1.5rem;
            border-bottom: 1px solid #1e293b;
            background: #0f172a;
            flex-shrink: 0;
        }
        .imports-tab-header-left {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        .imports-tab-header-left i {
            font-size: 20px;
            color: #22c55e;
        }
        .imports-tab-header-left h2 {
            margin: 0;
            font-size: 1.25rem;
            font-weight: 600;
        }
        .imports-tab-header-left .imports-count {
            background: #334155;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 12px;
        }
        .imports-tab-header-right {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        .imports-tab-close {
            background: none;
            border: none;
            color: #94a3b8;
            font-size: 24px;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
            line-height: 1;
            transition: background 0.15s, color 0.15s;
        }
        .imports-tab-close:hover {
            background: #1e293b;
            color: #e2e8f0;
        }
        .imports-tab-content {
            flex: 1;
            overflow: auto;
        }
        .imports-tab-table {
            width: 100%;
            border-collapse: collapse;
        }
        .imports-tab-table thead {
            background: #0f172a;
            position: sticky;
            top: 0;
            z-index: 10;
        }
        .imports-tab-table th {
            padding: 12px;
            text-align: left;
            font-weight: 500;
            color: #94a3b8;
            border-bottom: 1px solid #334155;
        }
        .imports-tab-table th.text-right {
            text-align: right;
        }
        .imports-tab-table tbody tr {
            border-bottom: 1px solid #1e293b;
            cursor: pointer;
            transition: background 0.15s;
        }
        .imports-tab-table tbody tr:hover {
            background: #1e293b;
        }
        .imports-tab-table td {
            padding: 12px;
        }
        .imports-tab-table td.text-right {
            text-align: right;
        }
        .imports-tab-file-cell {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .imports-tab-file-cell i {
            font-size: 18px;
            color: #22c55e;
        }
        .imports-tab-file-name {
            font-weight: 500;
        }
        .imports-tab-file-format {
            font-size: 11px;
            color: #64748b;
        }
        .imports-tab-status-badge {
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 500;
        }
        .imports-tab-status-badge.in-use {
            background: #22c55e;
            color: #0f172a;
        }
        .imports-tab-status-badge.available {
            background: #334155;
            color: #94a3b8;
        }
        .imports-tab-date {
            color: #64748b;
            font-size: 12px;
        }
        .imports-tab-empty {
            text-align: center;
            padding: 3rem;
            color: #64748b;
        }
        .imports-tab-empty i {
            font-size: 48px;
            display: block;
            margin-bottom: 12px;
            opacity: 0.5;
        }
        .imports-tab-empty p {
            margin: 0;
            font-size: 14px;
        }
        .imports-tab-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.4);
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s, visibility 0.3s;
            z-index: 999;
        }
        .imports-tab-overlay.open {
            opacity: 1;
            visibility: visible;
        }
    </style>
</head>
<body>
    <div class="mobile-topbar" id="mobileTopbar">
        <button class="mobile-icon-btn" onclick="toggleSidebar()" aria-label="Toggle navigation">
            <i class="ph ph-list"></i>
        </button>
        <!-- Mobile Search Bar -->
        <div class="mobile-search-container" id="mobileSearchContainer">
            <div class="global-search-bar" id="mobileSearchBar">
                <span class="global-search-icon">
                    <i class="ph ph-magnifying-glass"></i>
                </span>
                <input
                    type="text"
                    class="global-search-input"
                    id="mobileSearchInput"
                    placeholder="Search..."
                    autocomplete="off"
                    spellcheck="false"
                />
                <button class="global-search-clear" id="mobileSearchClear" title="Clear search">
                    <i class="ph ph-x"></i>
                </button>
            </div>
            <div class="global-search-results" id="mobileSearchResults"></div>
        </div>
        <button class="mobile-icon-btn" onclick="triggerPrimaryAction()" aria-label="Add record">
            <i class="ph ph-plus"></i>
        </button>
    </div>

        <div class="app-container" id="appContainer">
        <!-- Sidebar -->
        <div class="app-sidebar">
            <!-- Brand Logo and Collapse Toggle -->
            <div class="sidebar-header-row" style="display: flex; align-items: center; justify-content: space-between; padding: 1rem;">
                <div class="sidebar-brand" style="font-weight: 700; letter-spacing: 0.05em; font-size: 1.125rem;">[EO]</div>
                <button class="sidebar-collapse-btn" onclick="toggleSidebar()" aria-label="Collapse sidebar" title="Collapse sidebar">
                    <i id="sidebarCollapseIcon" class="ph ph-caret-left"></i>
                </button>
            </div>

            <!-- Scrollable Content Area -->
            <div class="sidebar-content">
                <!-- WORLD Section -->
                <div class="nav-section-title" style="display: flex; align-items: center; justify-content: space-between; cursor: pointer;" onclick="toggleNavSection('world')">
                    <span>World</span>
                    <i id="worldSectionChevron" class="ph ph-caret-down" style="font-size: 12px; opacity: 0.7;"></i>
                </div>
                <div id="worldNavContent">
                    <div class="world-nav-parent" id="worldNavParent">
                        <select id="worldSelect" class="world-select" onchange="switchWorld(this.value)">
                            <!-- Options populated by renderWorldSelector() -->
                        </select>
                    </div>
                    <div class="world-nav-children" style="padding: 0 1rem;">
                        <div class="nav-item" id="navDashboard" onclick="navigateTo('dashboard')">Dashboard</div>
                        <div class="nav-item" id="navEntities" onclick="navigateTo('entities')">Entities</div>
                        <div class="nav-item" id="navRelations" onclick="navigateTo('relations')">Relations</div>
                        <div class="nav-item" id="navDefinitions" onclick="navigateTo('definitions')">Definitions</div>
                        <div class="nav-item" id="navViews" onclick="navigateTo('views')">Views</div>
                        <div class="nav-item" id="navSandbox" onclick="navigateTo('sandbox')"><i class="ph ph-flask" style="margin-right: 6px; opacity: 0.7;"></i>Sandbox</div>
                    </div>
                </div>

                <!-- EXPLORE Section (hidden for now) -->
                <div class="nav-section-title" style="display: none; margin-top: 1rem; align-items: center; justify-content: space-between; cursor: pointer;" onclick="toggleNavSection('explore')">
                    <span>Explore</span>
                    <i id="exploreSectionChevron" class="ph ph-caret-down" style="font-size: 12px; opacity: 0.7;"></i>
                </div>
                <div id="exploreNavContent" style="display: none;">
                    <div class="world-nav-children" style="padding: 0 1rem;">
                        <div class="nav-item" id="navExplore" onclick="navigateTo('explore')">Explore</div>
                    </div>
                </div>

                <!-- IMPORTS Section - File Explorer Style -->
                <div class="nav-section-title" style="margin-top: 1rem; display: flex; align-items: center; justify-content: space-between; cursor: pointer;" onclick="toggleNavSection('dataImports')">
                    <span style="display: flex; align-items: center; gap: 8px;">
                        Imports
                        <i class="ph ph-upload-simple" style="font-size: 14px; opacity: 0.7; cursor: pointer; padding: 2px; border-radius: 4px;" onclick="event.stopPropagation(); triggerFileImport();" onmouseover="this.style.opacity='1'; this.style.background='rgba(255,255,255,0.1)';" onmouseout="this.style.opacity='0.7'; this.style.background='transparent';" title="Import file (CSV, JSON, Excel)"></i>
                    </span>
                    <i id="dataImportsSectionChevron" class="ph ph-caret-down" style="font-size: 12px; opacity: 0.7;"></i>
                </div>
                <div id="dataImportsNavContent">
                    <!-- File drop zone -->
                    <div id="sidebarDropZone" style="margin: 0.5rem 1rem; padding: 12px; border: 2px dashed #334155; border-radius: 8px; text-align: center; cursor: pointer; transition: all 0.2s;" onclick="triggerFileImport()">
                        <i class="ph ph-cloud-arrow-up" style="font-size: 20px; opacity: 0.6;"></i>
                        <div style="font-size: 11px; opacity: 0.6; margin-top: 4px;">Drop CSV, JSON, or Excel</div>
                    </div>
                    <!-- Imports list -->
                    <div id="navImportsContainer" style="padding: 0 1rem; margin-bottom: 0.5rem;">
                        <!-- Imports will be populated here dynamically -->
                    </div>
                </div>

                <!-- SETS Section (dynamically populated) -->
                <div class="nav-section-title" style="margin-top: 1.5rem; display: flex; align-items: center; justify-content: space-between; cursor: pointer;" onclick="toggleNavSection('sets')">
                    <span style="display: flex; align-items: center; gap: 8px;">
                        Sets
                        <i class="ph ph-plus" style="font-size: 14px; opacity: 0.7; cursor: pointer; padding: 2px; border-radius: 4px;" onclick="event.stopPropagation(); openAddSetModal();" onmouseover="this.style.opacity='1'; this.style.background='rgba(255,255,255,0.1)';" onmouseout="this.style.opacity='0.7'; this.style.background='transparent';" title="Add Set"></i>
                    </span>
                    <i id="setsSectionChevron" class="ph ph-caret-down" style="font-size: 12px; opacity: 0.7;"></i>
                </div>
                <div id="setsNavContent">
                    <div class="world-nav-children" style="padding: 0 1rem; margin-bottom: 0.5rem;">
                        <div style="position: relative; margin-bottom: 0.75rem;">
                            <input type="text" id="setsSearchInput" placeholder="Search sets and views..." style="width: 100%; padding: 6px 8px 6px 28px; background: #1e293b; border: 1px solid #334155; border-radius: 6px; color: white; font-size: 0.875rem; outline: none;" oninput="filterSets(this.value)">
                            <i class="ph ph-magnifying-glass" style="position: absolute; left: 8px; top: 50%; transform: translateY(-50%); font-size: 14px; opacity: 0.5;"></i>
                        </div>
                    </div>
                    <div id="navSetsContainer" style="padding: 0 1rem; margin-bottom: 0.5rem;"></div>
                    <div class="world-nav-children" style="padding: 0 1rem; margin-bottom: 1rem;">
                        <div class="nav-item" style="color: #6ee7b7;" onclick="handleAddViewClick()">+ Add View</div>
                    </div>
                </div>
            </div>

            <!-- Fixed Actions Section at Bottom -->
            <div class="sidebar-actions">
                <div class="nav-section-title" style="padding-top: 1rem; display: flex; align-items: center; justify-content: space-between; cursor: pointer;" onclick="toggleNavSection('actions')">
                    <span>Actions</span>
                    <i id="actionsSectionChevron" class="ph ph-caret-down" style="font-size: 12px; opacity: 0.7;"></i>
                </div>
                <div id="actionsNavContent">
                    <div class="world-nav-children" style="padding: 0 1rem; margin-bottom: 1.5rem;">
                        <div class="nav-item" onclick="TossPileUI.openPanel()"><i class="ph ph-trash" style="margin-right: 6px; opacity: 0.7;"></i>Toss Pile</div>
                        <div class="nav-item" onclick="openImportsTableView()"><i class="ph ph-table" style="margin-right: 6px; opacity: 0.7;"></i>All Imports</div>
                        <div class="nav-item" onclick="openEditHistoryModal()"><i class="ph ph-clock-counter-clockwise" style="margin-right: 6px; opacity: 0.7;"></i>Edit History</div>
                        <div class="nav-item" onclick="openAddRecordModal()">+ Add Record</div>
                        <div class="nav-item" onclick="openAddSetModal()">+ Add Set</div>
                    </div>
                </div>
            </div>
        </div>

        <div class="mobile-sidebar-overlay" id="mobileSidebarOverlay" onclick="closeMobileSidebar()"></div>

        <!-- Header -->
        <div class="app-header">
            <div class="world-toolbar">
                <div class="world-toolbar-info">
                    <div class="world-pill">
                        <i class="ph ph-globe-hemisphere-west"></i>
                        <span id="currentWorldHeaderLabel">Loading world...</span>
                    </div>
                </div>

                <!-- Global Search Bar -->
                <div class="global-search-container" id="globalSearchContainer">
                    <div class="global-search-bar" id="globalSearchBar">
                        <span class="global-search-icon">
                            <i class="ph ph-magnifying-glass"></i>
                        </span>
                        <input
                            type="text"
                            class="global-search-input"
                            id="globalSearchInput"
                            placeholder="Search everything in this world..."
                            autocomplete="off"
                            spellcheck="false"
                        />
                        <button class="global-search-clear" id="globalSearchClear" title="Clear search">
                            <i class="ph ph-x"></i>
                        </button>
                        <span class="global-search-shortcut" id="globalSearchShortcut">
                            <span>/</span>
                        </span>
                    </div>
                    <div class="global-search-results" id="globalSearchResults"></div>
                </div>

                <div class="world-toolbar-actions">
                    <input type="file" id="worldJsonInput" accept="application/json" style="display:none" />
                    <button id="headerImportBtn" class="btn btn-primary btn-sm" onclick="triggerFileImport()" title="Import file (CSV, JSON, Excel)">
                        <i class="ph ph-upload-simple"></i>
                        Import
                    </button>
                    <div class="globe-menu">
                        <button id="globeMenuToggle" class="btn btn-secondary btn-sm globe-menu-toggle" title="World options">
                            <i class="ph ph-globe-hemisphere-west"></i>
                            <i class="ph ph-caret-down"></i>
                        </button>
                        <div class="globe-menu-panel" id="globeMenuPanel">
                            <button id="importWorldBtn" class="btn btn-secondary btn-sm globe-menu-item globe-menu-item-highlight">
                                <i class="ph ph-upload-simple"></i>
                                Import into view
                            </button>
                            <div class="globe-menu-divider"></div>
                            <button id="globalHistoryBtn" class="btn btn-secondary btn-sm globe-menu-item">
                                <i class="ph ph-clock-counter-clockwise"></i>
                                Global changes
                            </button>
                            <button id="viewWorldJsonBtn" class="btn btn-secondary btn-sm globe-menu-item">
                                <i class="ph ph-code"></i>
                                View JSON
                            </button>
                            <button id="exportWorldBtn" class="btn btn-secondary btn-sm globe-menu-item">
                                <i class="ph ph-download-simple"></i>
                                Download world
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Main Content -->
        <div class="app-main">
            <!-- Layout Container - supports flexible multi-pane layouts -->
            <div class="layout-container" id="layoutContainer">
                <!-- Layout will be rendered dynamically by renderLayout() -->
                <!-- Default single-pane fallback for initial load -->
                <div class="layout-pane focused" id="pane-main" data-pane-id="pane-main">
                    <div class="pane-tabs-bar">
                        <div class="pane-tabs" id="viewTabs"></div>
                        <button class="pane-tab-add" onclick="handleAddViewClick()" title="New view">
                            <i class="ph ph-plus"></i>
                        </button>
                        <div class="pane-actions">
                            <button class="pane-action-btn" onclick="splitActivePane('horizontal')" title="Split right">
                                <i class="ph ph-split-horizontal"></i>
                            </button>
                            <button class="pane-action-btn" onclick="splitActivePane('vertical')" title="Split down">
                                <i class="ph ph-split-vertical"></i>
                            </button>
                            <button class="pane-action-btn" onclick="popOutActiveTab()" title="Pop out">
                                <i class="ph ph-arrow-square-out"></i>
                            </button>
                        </div>
                    </div>
                    <div class="pane-content">
                        <div class="view-surface" id="viewSurface">
                            <div id="viewContainer"></div>
                        </div>
                    </div>
                    <!-- Drop zone indicators for drag and drop -->
                    <div class="drop-zone-indicator left" data-label="Split Left"></div>
                    <div class="drop-zone-indicator right" data-label="Split Right"></div>
                    <div class="drop-zone-indicator top" data-label="Split Above"></div>
                    <div class="drop-zone-indicator bottom" data-label="Split Below"></div>
                    <div class="drop-zone-indicator center" data-label="Add to Tabs"></div>
                </div>
            </div>
            <!-- Legacy wrapper for backward compatibility -->
            <div class="view-workspace hidden" id="legacyViewWorkspace">
                <div class="view-tabs-rail">
                    <div id="legacyViewTabs" class="view-tabs hidden"></div>
                    <button id="importTabBtn" class="import-tab-btn" onclick="triggerFileImport()" title="Import file (CSV, JSON, Excel)">
                        <i class="ph ph-upload-simple"></i>
                        <span>Import</span>
                    </button>
                </div>
                <div class="view-surface">
                    <div id="legacyViewContainer"></div>
                </div>
            </div>
        </div>

        <!-- Toss Pile Panel Container -->
        <div id="tossPilePanelContainer"></div>
    </div>

    <div class="mobile-bottom-bar" id="mobileBottomBar">
        <button class="mobile-bottom-action" data-mobile-nav="grid" onclick="switchViewType('grid')">
            <i class="ph ph-table"></i>
            <span>Grid</span>
        </button>
        <button class="mobile-bottom-action" data-mobile-nav="card" onclick="switchViewType('card')">
            <i class="ph ph-cards-three"></i>
            <span>Card</span>
        </button>
        <button class="mobile-bottom-action" data-mobile-nav="kanban" onclick="switchViewType('kanban')">
            <i class="ph ph-kanban"></i>
            <span>Kanban</span>
        </button>
        <button class="mobile-bottom-action" onclick="document.getElementById('filterBtn')?.click()">
            <i class="ph ph-funnel"></i>
            <span>Filter</span>
        </button>
        <button class="mobile-bottom-action" onclick="document.getElementById('sortBtn')?.click()">
            <i class="ph ph-arrows-down-up"></i>
            <span>Sort</span>
        </button>
        <button class="mobile-bottom-action" onclick="document.getElementById('visualizeBtn')?.click()">
            <i class="ph ph-chart-bar"></i>
            <span>Visualize</span>
        </button>
    </div>

    <button class="mobile-fab" id="mobileFab" onclick="triggerPrimaryAction()" aria-label="Quick add">
        <i class="ph ph-plus"></i>
    </button>

    <!-- All Modals from previous version -->
    <div id="confirmModal" class="hidden fixed inset-0 bg-black bg-opacity-20 modal-overlay flex items-center justify-center p-6 z-50">
        <div class="modal-container bg-white w-full max-w-md">
            <div class="modal-header">
                <h2 class="text-xl font-bold text-gray-900">Confirm Action</h2>
            </div>
            <div class="modal-body">
                <p class="text-gray-700" id="confirmMessage"></p>
            </div>
            <div class="modal-footer flex justify-end gap-2">
                <button id="confirmCancelBtn" class="btn btn-secondary">Cancel</button>
                <button id="confirmOkBtn" class="btn btn-danger">Confirm</button>
            </div>
        </div>
    </div>

    <div id="definitionModal" class="hidden fixed inset-0 bg-black bg-opacity-20 modal-overlay flex items-center justify-center p-6 z-50">
        <div class="modal-container bg-white w-full max-w-2xl">
            <div class="modal-header flex items-center justify-between">
                <div>
                    <h2 class="text-xl font-bold text-gray-900" id="definitionModalTitle">Add Definition</h2>
                    <p class="text-sm text-gray-500">Provide a definition for any entity type.</p>
                </div>
                <button class="text-gray-400 hover:text-gray-600 transition" onclick="closeDefinitionModal()" aria-label="Close">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>
            <div class="modal-body">
                <form id="definitionForm" class="grid grid-cols-1 md:grid-cols-2 gap-3">
                    <div>
                        <label class="form-label">Entity Type</label>
                        <select id="definitionEntityType" class="border rounded px-3 py-2 w-full">
                            <option value="">Select type</option>
                            <option value="Record">Record</option>
                            <option value="Field">Field</option>
                            <option value="Set">Set</option>
                            <option value="Connection">Connection</option>
                            <option value="ViewEntity">ViewEntity</option>
                        </select>
                    </div>
                    <div>
                        <label class="form-label">Entity ID</label>
                        <input id="definitionEntityId" type="text" class="border rounded px-3 py-2 w-full" placeholder="entity identifier" />
                    </div>
                    <div>
                        <label class="form-label">Term</label>
                        <input id="definitionTerm" type="text" class="border rounded px-3 py-2 w-full" placeholder="Human-readable term" />
                    </div>
                    <div>
                        <label class="form-label">Definition</label>
                        <input id="definitionDefinition" type="text" class="border rounded px-3 py-2 w-full" placeholder="What does this mean?" />
                    </div>
                    <div>
                        <label class="form-label">Notes</label>
                        <input id="definitionNotes" type="text" class="border rounded px-3 py-2 w-full" placeholder="Optional clarifications" />
                    </div>
                    <div>
                        <label class="form-label">Tags (comma separated)</label>
                        <input id="definitionTags" type="text" class="border rounded px-3 py-2 w-full" placeholder="demo, core" />
                    </div>
                </form>
            </div>
            <div class="modal-footer flex justify-end gap-2">
                <button class="btn btn-secondary" type="button" onclick="closeDefinitionModal()">Cancel</button>
                <button class="btn btn-primary" type="submit" form="definitionForm" id="definitionSubmit">Add Definition</button>
            </div>
        </div>
    </div>

    <div id="connectionRelationModal" class="hidden fixed inset-0 bg-black bg-opacity-20 modal-overlay flex items-center justify-center p-6 z-50">
        <div class="modal-container bg-white w-full max-w-lg max-h-[85vh] overflow-hidden flex flex-col">
            <div class="modal-header flex items-center justify-between">
                <div>
                    <h2 class="text-xl font-bold text-gray-900" id="connectionRelationModalTitle">Add Relation Type</h2>
                    <p class="text-sm text-gray-500">Define a reusable relation like "is linked to"</p>
                </div>
                <button class="text-gray-400 hover:text-gray-600 transition" onclick="closeModal('connectionRelationModal')" aria-label="Close">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>
            <div class="modal-body overflow-y-auto flex-1">
                <form id="connectionRelationForm" class="space-y-4">
                    <div>
                        <label class="form-label">Category</label>
                        <select id="connectionRelationOperator" class="border rounded px-3 py-2 w-full">
                            <option value="">Select category</option>
                        </select>
                        <p class="text-xs text-gray-500 mt-1">Type of relation (CON = connection, SEG = segmentation, etc.)</p>
                    </div>
                    <div>
                        <label class="form-label">Relation verb</label>
                        <select id="connectionRelationMode" class="border rounded px-3 py-2 w-full"></select>
                        <p class="text-xs text-gray-500 mt-1">How the subject relates to the object</p>
                    </div>
                    <div>
                        <label class="form-label">Description (optional)</label>
                        <input id="connectionRelationDescription" type="text" class="border rounded px-3 py-2 w-full" placeholder="When to use this relation" />
                    </div>

                    <!-- Parameter Schema Section -->
                    <div class="border-t border-gray-200 pt-4 mt-4">
                        <div class="flex items-center justify-between mb-3">
                            <label class="form-label mb-0">Parameter Fields</label>
                            <button type="button" class="text-sm text-blue-600 hover:text-blue-800 flex items-center gap-1" onclick="addRelationParamField()">
                                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path>
                                </svg>
                                Add field
                            </button>
                        </div>
                        <p class="text-xs text-gray-500 mb-3">Define what data connections of this type should capture</p>
                        <div id="relationParamFieldsList" class="space-y-3">
                            <!-- Dynamically populated parameter fields -->
                        </div>
                    </div>

                    <input id="connectionRelationName" type="hidden" value="" />
                </form>
            </div>
            <div class="modal-footer flex justify-end gap-2">
                <button class="btn btn-secondary" type="button" onclick="closeModal('connectionRelationModal')">Cancel</button>
                <button class="btn btn-primary" type="submit" form="connectionRelationForm" id="connectionRelationSubmit">Add</button>
            </div>
        </div>
    </div>

    <!-- Connection Parameter Editor Modal -->
    <div id="connectionParamEditorModal" class="hidden fixed inset-0 bg-black bg-opacity-30 modal-overlay flex items-center justify-center p-6 z-50">
        <div class="modal-container bg-white w-full max-w-lg max-h-[85vh] overflow-hidden flex flex-col">
            <div class="modal-header flex items-center justify-between border-b border-gray-200 pb-4">
                <div>
                    <h2 class="text-xl font-bold text-gray-900">Edit Connection Parameters</h2>
                    <p class="text-sm text-gray-500" id="connectionParamEditorSubtitle">Configure this connection's properties</p>
                </div>
                <button class="text-gray-400 hover:text-gray-600 transition p-1" onclick="closeConnectionParamEditor()" aria-label="Close">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>
            <div class="modal-body overflow-y-auto flex-1 py-4">
                <!-- Connection summary -->
                <div class="bg-gray-50 rounded-lg p-3 mb-4" id="connectionParamEditorSummary">
                    <!-- Filled dynamically -->
                </div>

                <!-- Parameter fields -->
                <form id="connectionParamEditorForm" class="space-y-4">
                    <div id="connectionParamEditorFields">
                        <!-- Dynamically generated parameter fields -->
                    </div>
                </form>

                <!-- Add custom parameter -->
                <div class="mt-4 pt-4 border-t border-gray-200">
                    <button type="button" class="text-sm text-blue-600 hover:text-blue-800 flex items-center gap-1" onclick="toggleAddCustomParam()">
                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path>
                        </svg>
                        Add custom parameter
                    </button>
                    <div id="addCustomParamSection" class="hidden mt-3 p-3 bg-gray-50 rounded-lg">
                        <div class="grid grid-cols-2 gap-2 mb-2">
                            <input type="text" id="customParamName" placeholder="Parameter name" class="border rounded px-3 py-2 text-sm" />
                            <select id="customParamType" class="border rounded px-3 py-2 text-sm">
                                <option value="text">Text</option>
                                <option value="number">Number</option>
                                <option value="select">Select</option>
                                <option value="checkbox">Checkbox</option>
                                <option value="date">Date</option>
                            </select>
                        </div>
                        <div class="flex gap-2">
                            <input type="text" id="customParamValue" placeholder="Value" class="border rounded px-3 py-2 text-sm flex-1" />
                            <button type="button" class="btn btn-sm btn-secondary" onclick="addCustomParamToEditor()">Add</button>
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer flex justify-end gap-2 border-t border-gray-200 pt-4">
                <button class="btn btn-secondary" type="button" onclick="closeConnectionParamEditor()">Cancel</button>
                <button class="btn btn-primary" type="button" onclick="saveConnectionParams()">Save Parameters</button>
            </div>
        </div>
    </div>

    <div id="connectionModal" class="hidden fixed inset-0 bg-black bg-opacity-30 modal-overlay flex items-center justify-center p-6 z-50">
        <div class="modal-container bg-white w-full max-w-2xl max-h-[85vh] overflow-hidden flex flex-col">
            <div class="modal-header flex items-center justify-between border-b border-gray-200 pb-4">
                <div>
                    <h2 class="text-xl font-bold text-gray-900" id="connectionModalTitle">Create Relationship</h2>
                    <p class="text-sm text-gray-500">Connect a subject to an operand through a relation</p>
                </div>
                <button class="text-gray-400 hover:text-gray-600 transition p-1" onclick="closeModal('connectionModal')" aria-label="Close">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>

            <!-- Step Progress Indicator -->
            <div class="connection-wizard-steps px-6 py-3 bg-gray-50 border-b border-gray-200">
                <div class="flex items-center justify-between max-w-md mx-auto">
                    <div class="wizard-step active" data-step="1">
                        <div class="step-circle">1</div>
                        <span class="step-label">Subject</span>
                    </div>
                    <div class="step-connector"></div>
                    <div class="wizard-step" data-step="2">
                        <div class="step-circle">2</div>
                        <span class="step-label">Relation</span>
                    </div>
                    <div class="step-connector"></div>
                    <div class="wizard-step" data-step="3">
                        <div class="step-circle">3</div>
                        <span class="step-label">Operand</span>
                    </div>
                    <div class="step-connector"></div>
                    <div class="wizard-step" data-step="4">
                        <div class="step-circle">4</div>
                        <span class="step-label">Review</span>
                    </div>
                </div>
            </div>

            <div class="modal-body flex-1 overflow-auto">
                <form id="connectionForm" class="h-full flex flex-col">
                    <!-- Hidden form fields -->
                    <input id="connectionSubjectId" type="hidden" />
                    <input id="connectionSubjectType" type="hidden" value="Entity" />
                    <input id="connectionOperandId" type="hidden" />
                    <input id="connectionOperandType" type="hidden" value="Entity" />
                    <input id="connectionRelationSelect" type="hidden" />

                    <!-- Step 1: Select Subject -->
                    <div id="connectionStep1" class="wizard-panel h-full flex flex-col">
                        <div class="p-4 border-b border-gray-100">
                            <h3 class="font-semibold text-gray-900">Select Subject Entity</h3>
                            <p class="text-sm text-gray-500 mt-1">Choose the entity that is the subject of this relationship</p>
                        </div>
                        <div class="p-4">
                            <input id="connectionSubjectSearch" type="text" class="border rounded-lg px-3 py-2 w-full" placeholder="Search entities by name..." autocomplete="off" />
                        </div>
                        <div id="connectionSubjectPanel" class="flex-1 overflow-y-auto px-4 pb-4"></div>
                        <div class="connection-selection-preview p-4 bg-blue-50 border-t border-blue-100 hidden" id="subjectPreview">
                            <div class="text-xs text-blue-600 font-medium mb-1">Selected Subject:</div>
                            <div class="font-semibold text-blue-900" id="subjectPreviewName"></div>
                            <div class="text-xs text-blue-600" id="subjectPreviewMeta"></div>
                        </div>
                    </div>

                    <!-- Step 2: Select Relation -->
                    <div id="connectionStep2" class="wizard-panel h-full flex flex-col hidden">
                        <div class="p-4 border-b border-gray-100">
                            <h3 class="font-semibold text-gray-900">Select Relation Type</h3>
                            <p class="text-sm text-gray-500 mt-1">How does the subject relate to the operand?</p>
                        </div>
                        <div class="p-4">
                            <input id="connectionRelationSearch" type="text" class="border rounded-lg px-3 py-2 w-full" placeholder="Search relations..." autocomplete="off" />
                        </div>
                        <div id="connectionRelationPanel" class="flex-1 overflow-y-auto px-4 pb-4"></div>
                        <div class="connection-selection-preview p-4 bg-green-50 border-t border-green-100 hidden" id="relationPreview">
                            <div class="text-xs text-green-600 font-medium mb-1">Selected Relation:</div>
                            <div class="font-semibold text-green-900" id="relationPreviewName"></div>
                            <div class="text-xs text-green-600" id="relationPreviewMeta"></div>
                        </div>
                    </div>

                    <!-- Step 3: Select Operand -->
                    <div id="connectionStep3" class="wizard-panel h-full flex flex-col hidden">
                        <div class="p-4 border-b border-gray-100">
                            <h3 class="font-semibold text-gray-900">Select Operand Entity</h3>
                            <p class="text-sm text-gray-500 mt-1">Choose the entity that is the target/operand of this relationship</p>
                        </div>
                        <div class="p-4">
                            <input id="connectionOperandSearch" type="text" class="border rounded-lg px-3 py-2 w-full" placeholder="Search entities by name..." autocomplete="off" />
                        </div>
                        <div id="connectionOperandPanel" class="flex-1 overflow-y-auto px-4 pb-4"></div>
                        <div class="connection-selection-preview p-4 bg-purple-50 border-t border-purple-100 hidden" id="operandPreview">
                            <div class="text-xs text-purple-600 font-medium mb-1">Selected Operand:</div>
                            <div class="font-semibold text-purple-900" id="operandPreviewName"></div>
                            <div class="text-xs text-purple-600" id="operandPreviewMeta"></div>
                        </div>
                    </div>

                    <!-- Step 4: Review & Create -->
                    <div id="connectionStep4" class="wizard-panel h-full flex flex-col hidden">
                        <div class="p-4 border-b border-gray-100">
                            <h3 class="font-semibold text-gray-900">Review Relationship</h3>
                            <p class="text-sm text-gray-500 mt-1">Confirm the relationship details before creating</p>
                        </div>
                        <div class="flex-1 overflow-y-auto p-4">
                            <!-- Relationship Summary -->
                            <div class="connection-review-card bg-gray-50 rounded-lg p-6 mb-4">
                                <div class="flex items-center justify-center gap-4 text-center flex-wrap">
                                    <div class="connection-review-entity bg-white rounded-lg p-4 shadow-sm border border-gray-200 min-w-[140px]">
                                        <div class="text-xs text-gray-500 mb-1">Subject</div>
                                        <div class="font-semibold text-gray-900" id="reviewSubjectName">-</div>
                                        <div class="text-xs text-gray-500" id="reviewSubjectType">-</div>
                                    </div>
                                    <div class="flex flex-col items-center px-4">
                                        <div class="text-2xl text-gray-400 mb-1">&#8594;</div>
                                        <div class="text-sm font-medium text-blue-600 bg-blue-50 px-3 py-1 rounded-full" id="reviewRelationName">-</div>
                                    </div>
                                    <div class="connection-review-entity bg-white rounded-lg p-4 shadow-sm border border-gray-200 min-w-[140px]">
                                        <div class="text-xs text-gray-500 mb-1">Operand</div>
                                        <div class="font-semibold text-gray-900" id="reviewOperandName">-</div>
                                        <div class="text-xs text-gray-500" id="reviewOperandType">-</div>
                                    </div>
                                </div>
                            </div>

                            <!-- Optional Description -->
                            <div class="mb-4">
                                <label class="form-label">Description (optional)</label>
                                <input id="connectionDescription" type="text" class="border rounded-lg px-3 py-2 w-full" placeholder="Add a note about this relationship..." />
                            </div>

                            <!-- Parameter Fields (shown if relation requires params) -->
                            <div id="connectionParamFields"></div>
                        </div>
                    </div>
                </form>
            </div>

            <div class="modal-footer flex justify-between gap-2 border-t border-gray-200 pt-4">
                <button class="btn btn-secondary" type="button" id="connectionBackBtn" onclick="connectionWizardBack()" disabled>Back</button>
                <div class="flex gap-2">
                    <button class="btn btn-secondary" type="button" onclick="closeModal('connectionModal')">Cancel</button>
                    <button class="btn btn-primary" type="button" id="connectionNextBtn" onclick="connectionWizardNext()">Next</button>
                    <button class="btn btn-primary hidden" type="submit" form="connectionForm" id="connectionSubmit">Create Relationship</button>
                </div>
            </div>
        </div>
    </div>

    <div id="expandedRecordModal" class="hidden fixed inset-0 bg-black bg-opacity-20 modal-overlay flex items-center justify-center p-6 z-50">
        <div class="modal-container bg-white w-full max-w-5xl max-h-[90vh] overflow-hidden flex flex-col">
            <div class="modal-header flex items-center justify-between flex-shrink-0">
                <div class="flex items-center gap-4 flex-1">
                    <h2 class="text-2xl font-bold text-gray-900" id="expandedRecordTitle">Record Details</h2>
                    <div class="profile-selector" id="recordProfileSelector"></div>
                </div>
                <div class="flex items-center gap-2">
                    <button id="toggleHistorySidebarBtn" class="btn btn-secondary btn-sm">Hide History</button>
                    <button id="closeExpandedRecordBtn" class="text-gray-400 hover:text-gray-600 transition p-2">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                        </svg>
                    </button>
                </div>
            </div>
            <div class="flex-1 overflow-hidden">
                <div class="grid grid-cols-1 md:grid-cols-3 h-full">
                    <div id="expandedRecordMainWrapper" class="md:col-span-2 p-6 overflow-y-auto border-r border-gray-200">
                        <div id="expandedRecordMain"></div>
                    </div>
                    <div id="expandedRecordHistoryColumn" class="overflow-hidden bg-gray-50 flex flex-col">
                        <div class="record-tabs">
                            <div class="record-tab active" data-tab="history" onclick="switchRecordTab('history')">History</div>
                            <div class="record-tab" data-tab="provenance" onclick="switchRecordTab('provenance')">Provenance</div>
                            <div class="record-tab" data-tab="connections" onclick="switchRecordTab('connections')">Relationships</div>
                        </div>
                        <div class="flex-1 overflow-y-auto p-6" id="expandedRecordSidebar"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="filterModal" class="hidden fixed inset-0 bg-black bg-opacity-20 modal-overlay flex items-center justify-center p-6 z-50">
        <div class="modal-container bg-white w-full max-w-xl max-h-[90vh] overflow-hidden flex flex-col">
            <div class="modal-header flex items-center justify-between">
                <div>
                    <h2 class="text-xl font-bold text-gray-900">Filter View</h2>
                    <p class="text-sm text-gray-500 mt-1">Create advanced filter conditions</p>
                </div>
                <button id="closeFilterBtn" class="text-gray-400 hover:text-gray-600 transition p-2">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>
            <div class="flex-1 overflow-y-auto modal-body">
                <div id="filterGroupsContainer"></div>
                <button id="addFilterGroupBtn" class="btn btn-secondary btn-sm mt-4">+ Add Filter Group</button>
            </div>
            <div class="modal-footer flex justify-end gap-2">
                <button id="clearFiltersBtn" class="btn btn-secondary">Clear All</button>
                <button id="applyFiltersBtn" class="btn btn-primary">Apply Filters</button>
            </div>
        </div>
    </div>

    <div id="sortModal" class="hidden fixed inset-0 bg-black bg-opacity-20 modal-overlay flex items-center justify-center p-6 z-50">
        <div class="modal-container bg-white w-full max-w-3xl max-h-[80vh] overflow-hidden flex flex-col">
            <div class="modal-header flex items-center justify-between">
                <div>
                    <h2 class="text-xl font-bold text-gray-900">Sort View</h2>
                    <p class="text-sm text-gray-500 mt-1">Create a sorting sequence for this view</p>
                </div>
                <button id="closeSortBtn" class="text-gray-400 hover:text-gray-600 transition p-2">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>
            <div class="flex-1 overflow-y-auto modal-body space-y-3">
                <div id="sortRulesContainer" class="space-y-3"></div>
                <button id="addSortRuleBtn" class="btn btn-secondary btn-sm">+ Add Sort</button>
            </div>
            <div class="modal-footer flex justify-between gap-2">
                <div class="flex items-center gap-2 text-sm text-gray-500">
                    <span class="sort-sequence-badge"><i class="ph ph-arrow-line-up"></i>Earlier sorts run first</span>
                </div>
                <div class="flex gap-2">
                    <button id="clearSortsBtn" class="btn btn-secondary">Clear All</button>
                    <button id="applySortsBtn" class="btn btn-primary">Apply Sorts</button>
                </div>
            </div>
        </div>
    </div>

    <div id="visualizationModal" class="hidden fixed inset-0 bg-black bg-opacity-20 modal-overlay flex items-center justify-center p-6 z-50">
        <div class="modal-container bg-white w-full max-w-4xl max-h-[90vh] overflow-hidden flex flex-col">
            <div class="modal-header flex items-center justify-between">
                <div>
                    <h2 class="text-xl font-bold text-gray-900">Visualize Data</h2>
                    <p class="text-sm text-gray-500 mt-1">Create interactive charts from your data</p>
                </div>
                <button id="closeVisualizationBtn" class="text-gray-400 hover:text-gray-600 transition p-2">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>
            <div class="flex-1 overflow-y-auto modal-body">
                <div class="space-y-4">
                    <div>
                        <label class="block text-sm font-semibold mb-2">Chart Type</label>
                        <div class="flex gap-2 flex-wrap">
                            <button class="btn btn-secondary btn-sm viz-chart-type-btn" data-chart-type="bar">
                                <i class="ph ph-chart-bar"></i>
                                Bar Chart
                            </button>
                            <button class="btn btn-secondary btn-sm viz-chart-type-btn" data-chart-type="line">
                                <i class="ph ph-chart-line"></i>
                                Line Chart
                            </button>
                            <button class="btn btn-secondary btn-sm viz-chart-type-btn" data-chart-type="pie">
                                <i class="ph ph-chart-pie-slice"></i>
                                Pie Chart
                            </button>
                            <button class="btn btn-secondary btn-sm viz-chart-type-btn" data-chart-type="area">
                                <i class="ph ph-chart-line-up"></i>
                                Area Chart
                            </button>
                        </div>
                    </div>
                    <div id="visualizationChartContainer" class="border border-gray-200 rounded-lg bg-white p-6 min-h-[400px]">
                        <div class="text-center text-gray-500 py-12">
                            Select a chart type to visualize your data
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer flex justify-end gap-2">
                <button id="closeVisualizationModalBtn" class="btn btn-secondary">Close</button>
            </div>
        </div>
    </div>

    <div id="popupSettingsModal" class="hidden fixed inset-0 bg-black bg-opacity-20 modal-overlay flex items-center justify-center p-6 z-50">
        <div class="modal-container bg-white popup-config-shell">
            <div class="popup-config-header">
                <div>
                    <h2 class="text-2xl font-bold text-gray-900">Modal Configuration</h2>
                    <p class="text-sm text-gray-600 mt-1">Curate which fields show in record modals, define conditional visibility, and preview layouts.</p>
                </div>
                <div class="flex items-center gap-2">
                    <button class="btn btn-secondary btn-sm" onclick="resetPopupLayout()">Reset</button>
                    <button id="closePopupSettingsBtn" class="btn btn-secondary btn-sm">Close</button>
                </div>
            </div>

            <div class="popup-config-tabs">
                <button class="popup-config-tab active" data-tab="popupFields" onclick="setPopupTab('popupFields')"> Fields <span class="popup-badge" id="popupFieldCountBadge">0</span></button>
                <button class="popup-config-tab" data-tab="popupLayout" onclick="setPopupTab('popupLayout')"> Layout</button>
                <button class="popup-config-tab" data-tab="popupConditions" onclick="setPopupTab('popupConditions')"> Conditions</button>
            </div>

            <div class="popup-config-body">
                <div class="popup-tab-panel active" id="popupFields">
                    <div class="popup-panel-scroll">
                        <div class="popup-quick-filters" id="popupFilters"></div>
                        <div class="popup-info"><span></span><span><strong>Drag to reorder</strong> and toggle visibility. Click the gear to set conditional rules per field.</span></div>
                        <div id="popupFieldList"></div>
                    </div>
                </div>

                <div class="popup-tab-panel" id="popupLayout">
                    <div class="popup-panel-scroll space-y-4">
                        <div class="popup-card">
                            <h4>Modal Size</h4>
                            <div class="popup-layout-options" id="popupSizeOptions"></div>
                        </div>
                        <div class="popup-card">
                            <h4>Column Layout</h4>
                            <div class="popup-layout-options" id="popupColumnOptions"></div>
                        </div>
                        <div class="popup-card">
                            <h4>Preview</h4>
                            <div id="popupPreview" class="popup-preview"></div>
                        </div>
                    </div>
                </div>

                <div class="popup-tab-panel" id="popupConditions">
                    <div class="popup-panel-scroll">
                        <div class="popup-info"><span></span><span><strong>Conditional visibility</strong> lets you keep modals focused and contextual.</span></div>
                        <div id="popupConditionsList" class="popup-conditions"></div>
                    </div>
                </div>

                <div class="popup-side">
                    <div class="popup-card">
                        <h4>Quick Stats</h4>
                        <div class="popup-stat-grid">
                            <div class="popup-stat">
                                <div class="value" id="popupVisibleCount">0</div>
                                <div class="label">Visible Fields</div>
                            </div>
                            <div class="popup-stat">
                                <div class="value" id="popupConditionalCount">0</div>
                                <div class="label">Conditional Rules</div>
                            </div>
                        </div>
                    </div>
                    <div class="popup-card">
                        <h4>Templates</h4>
                        <div class="popup-template-buttons">
                            <button class="btn btn-secondary btn-sm" onclick="applyPopupTemplate('minimal')"> Minimal View</button>
                            <button class="btn btn-secondary btn-sm" onclick="applyPopupTemplate('detailed')"> Detailed View</button>
                            <button class="btn btn-secondary btn-sm" onclick="applyPopupTemplate('compact')"> Compact View</button>
                        </div>
                    </div>
                    <div class="popup-card">
                        <h4>Recent Changes</h4>
                        <div id="popupRecentChanges" class="text-sm text-gray-600 space-y-1"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="addFieldModal" class="hidden fixed inset-0 bg-black bg-opacity-20 modal-overlay flex items-center justify-center p-6 z-50">
        <div class="modal-container bg-white w-full max-w-xl max-h-[90vh] overflow-hidden flex flex-col">
            <div class="modal-header flex items-center justify-between">
                <div>
                    <h2 class="text-xl font-bold text-gray-900">Add Field</h2>
                    <p class="text-sm text-gray-500 mt-1">Create a new field for your set</p>
                </div>
                <button id="closeAddFieldBtn" class="text-gray-400 hover:text-gray-600 transition p-2">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>
            <div class="flex-1 overflow-y-auto modal-body space-y-5">
                  <div>
                      <label class="form-label">Field Name</label>
                      <input type="text" id="newFieldName" placeholder="e.g., Status, Amount, Contact Person" autofocus aria-describedby="fieldNameError">
                      <p class="form-hint">A descriptive name for your field</p>
                      <p id="fieldNameError" class="form-error hidden" role="alert"></p>
                  </div>
                <div>
                    <label class="form-label">Field Type</label>
                    <div class="field-type-select">
                        <button type="button" id="fieldTypeTrigger" class="field-type-trigger">
                            <div class="field-type-trigger-content">
                                <span class="field-type-trigger-icon" aria-hidden="true"></span>
                                <div class="field-type-trigger-text">
                                    <div class="field-type-name" id="selectedFieldTypeName"></div>
                                    <div class="field-type-description" id="selectedFieldTypeDescription"></div>
                                </div>
                            </div>
                            <span class="field-type-trigger-arrow" aria-hidden="true"></span>
                        </button>
                        <div id="fieldTypeDropdown" class="field-type-dropdown hidden"></div>
                    </div>
                    <input type="hidden" id="newFieldType" value="TEXT">
                </div>
                <div id="selectConfig" class="config-section">
                    <div class="bg-orange-50 border border-orange-200 rounded-lg p-4">
                        <label class="form-label">Options</label>
                        <div id="selectOptionsList" class="space-y-2 mb-3"></div>
                        <button onclick="addSelectOption()" class="btn btn-secondary btn-sm">+ Add Option</button>
                        <div class="mt-4 flex items-center">
                            <input type="checkbox" id="acceptNewOptions" checked class="mr-2">
                            <label for="acceptNewOptions" class="text-sm text-gray-700">Accept new options</label>
                        </div>
                    </div>
                </div>
                <div id="linkToRecordConfig" class="config-section">
                    <div class="bg-blue-50 border border-blue-200 rounded-lg p-4">
                        <label class="form-label">Link to Set</label>
                        <div id="linkToSetContainer"></div>
                        <p class="form-hint">Select which set to link to</p>

                        <label class="form-label mt-4">Cardinality</label>
                        <div class="flex gap-2 mb-2">
                            <label class="flex items-center gap-2 px-3 py-2 border border-gray-200 rounded-lg cursor-pointer hover:border-blue-300 has-[:checked]:border-blue-500 has-[:checked]:bg-blue-50">
                                <input type="radio" name="linkCardinality" value="one" class="accent-blue-600">
                                <span class="text-sm font-medium">One</span>
                            </label>
                            <label class="flex items-center gap-2 px-3 py-2 border border-gray-200 rounded-lg cursor-pointer hover:border-blue-300 has-[:checked]:border-blue-500 has-[:checked]:bg-blue-50">
                                <input type="radio" name="linkCardinality" value="many" checked class="accent-blue-600">
                                <span class="text-sm font-medium">Many</span>
                            </label>
                            <label class="flex items-center gap-2 px-3 py-2 border border-gray-200 rounded-lg cursor-pointer hover:border-blue-300 has-[:checked]:border-blue-500 has-[:checked]:bg-blue-50">
                                <input type="radio" name="linkCardinality" value="limit" class="accent-blue-600">
                                <span class="text-sm font-medium">Limit</span>
                            </label>
                        </div>
                        <div id="linkLimitInput" class="hidden">
                            <label class="form-label text-sm">Maximum records</label>
                            <input type="number" id="linkLimit" min="1" max="100" value="3" class="w-20 px-2 py-1 border border-gray-300 rounded text-sm">
                        </div>
                        <p class="form-hint">How many records can be linked</p>
                    </div>
                </div>
                <div id="formulaConfig" class="config-section">
                    <div class="bg-purple-50 border border-purple-200 rounded-lg p-4">
                        <label class="form-label">Formula</label>
                        <div class="relative">
                            <textarea id="formulaInput" class="w-full px-3 py-2 border border-gray-300 rounded-lg font-mono text-sm" rows="4" placeholder="e.g., {Price} * {Quantity}"></textarea>
                            <div id="formulaAutocomplete" class="absolute z-10 hidden bg-white border border-gray-300 rounded-lg shadow-lg max-h-48 overflow-y-auto" style="width: calc(100% - 2rem);"></div>
                        </div>
                        <p class="form-hint mt-2">Use {Field Name} to reference other fields. Available functions: SUM, AVG, MIN, MAX, IF, CONCAT, ROUND, etc.</p>
                        <div id="formulaValidation" class="mt-2 text-sm"></div>
                        <div class="mt-3">
                            <label class="form-label">Display Format</label>
                            <div id="formulaFormatContainer"></div>
                        </div>
                        <div class="mt-3">
                            <label class="form-label">Decimal Places</label>
                            <input type="number" id="formulaDecimals" class="w-full px-3 py-2 border border-gray-300 rounded-lg" min="0" max="10" value="2">
                        </div>
                    </div>
                </div>
                <!-- Number Field Config -->
                <div id="numberConfig" class="config-section">
                    <div class="bg-emerald-50 border border-emerald-200 rounded-lg p-4">
                        <label class="form-label">Number Format</label>
                        <div class="grid grid-cols-3 gap-2 mb-3">
                            <label class="flex items-center gap-2 px-3 py-2 border border-gray-200 rounded-lg cursor-pointer hover:border-emerald-300 has-[:checked]:border-emerald-500 has-[:checked]:bg-emerald-50">
                                <input type="radio" name="numberFormat" value="integer" class="accent-emerald-600">
                                <span class="text-sm font-medium">Integer</span>
                            </label>
                            <label class="flex items-center gap-2 px-3 py-2 border border-gray-200 rounded-lg cursor-pointer hover:border-emerald-300 has-[:checked]:border-emerald-500 has-[:checked]:bg-emerald-50">
                                <input type="radio" name="numberFormat" value="decimal" checked class="accent-emerald-600">
                                <span class="text-sm font-medium">Decimal</span>
                            </label>
                            <label class="flex items-center gap-2 px-3 py-2 border border-gray-200 rounded-lg cursor-pointer hover:border-emerald-300 has-[:checked]:border-emerald-500 has-[:checked]:bg-emerald-50">
                                <input type="radio" name="numberFormat" value="percentage" class="accent-emerald-600">
                                <span class="text-sm font-medium">Percent</span>
                            </label>
                            <label class="flex items-center gap-2 px-3 py-2 border border-gray-200 rounded-lg cursor-pointer hover:border-emerald-300 has-[:checked]:border-emerald-500 has-[:checked]:bg-emerald-50">
                                <input type="radio" name="numberFormat" value="currency" class="accent-emerald-600">
                                <span class="text-sm font-medium">Currency</span>
                            </label>
                            <label class="flex items-center gap-2 px-3 py-2 border border-gray-200 rounded-lg cursor-pointer hover:border-emerald-300 has-[:checked]:border-emerald-500 has-[:checked]:bg-emerald-50">
                                <input type="radio" name="numberFormat" value="scientific" class="accent-emerald-600">
                                <span class="text-sm font-medium">Scientific</span>
                            </label>
                            <label class="flex items-center gap-2 px-3 py-2 border border-gray-200 rounded-lg cursor-pointer hover:border-emerald-300 has-[:checked]:border-emerald-500 has-[:checked]:bg-emerald-50">
                                <input type="radio" name="numberFormat" value="fraction" class="accent-emerald-600">
                                <span class="text-sm font-medium">Fraction</span>
                            </label>
                        </div>
                        <div class="grid grid-cols-2 gap-3 mt-3">
                            <div>
                                <label class="form-label text-sm">Decimal Places</label>
                                <input type="number" id="numberDecimals" min="0" max="10" value="2" class="w-full px-2 py-1 border border-gray-300 rounded text-sm">
                            </div>
                            <div>
                                <label class="form-label text-sm">Rounding</label>
                                <select id="numberRounding" class="w-full px-2 py-1 border border-gray-300 rounded text-sm">
                                    <option value="round">Round</option>
                                    <option value="floor">Floor</option>
                                    <option value="ceil">Ceiling</option>
                                    <option value="truncate">Truncate</option>
                                </select>
                            </div>
                        </div>
                        <div id="currencyOptions" class="mt-3 hidden">
                            <label class="form-label text-sm">Currency</label>
                            <select id="currencyCode" class="w-full px-2 py-1 border border-gray-300 rounded text-sm">
                                <option value="USD">$ USD - US Dollar</option>
                                <option value="EUR"> EUR - Euro</option>
                                <option value="GBP"> GBP - British Pound</option>
                                <option value="JPY"> JPY - Japanese Yen</option>
                                <option value="CNY"> CNY - Chinese Yuan</option>
                                <option value="CAD">$ CAD - Canadian Dollar</option>
                                <option value="AUD">$ AUD - Australian Dollar</option>
                                <option value="CHF">Fr CHF - Swiss Franc</option>
                                <option value="INR"> INR - Indian Rupee</option>
                                <option value="MXN">$ MXN - Mexican Peso</option>
                                <option value="BRL">R$ BRL - Brazilian Real</option>
                                <option value="KRW"> KRW - South Korean Won</option>
                            </select>
                        </div>
                        <div class="mt-3 flex items-center gap-4">
                            <label class="flex items-center gap-2 text-sm">
                                <input type="checkbox" id="thousandSep" checked class="accent-emerald-600">
                                <span>Thousands separator</span>
                            </label>
                            <label class="flex items-center gap-2 text-sm">
                                <input type="checkbox" id="allowNegative" checked class="accent-emerald-600">
                                <span>Allow negative</span>
                            </label>
                        </div>
                        <div class="grid grid-cols-2 gap-3 mt-3">
                            <div>
                                <label class="form-label text-sm">Min Value (optional)</label>
                                <input type="number" id="numberMin" class="w-full px-2 py-1 border border-gray-300 rounded text-sm" placeholder="No limit">
                            </div>
                            <div>
                                <label class="form-label text-sm">Max Value (optional)</label>
                                <input type="number" id="numberMax" class="w-full px-2 py-1 border border-gray-300 rounded text-sm" placeholder="No limit">
                            </div>
                        </div>
                    </div>
                </div>
                <!-- Date Field Config -->
                <div id="dateConfig" class="config-section">
                    <div class="bg-sky-50 border border-sky-200 rounded-lg p-4">
                        <label class="form-label">Date/Time Type</label>
                        <div class="flex gap-2 mb-3">
                            <label class="flex items-center gap-2 px-3 py-2 border border-gray-200 rounded-lg cursor-pointer hover:border-sky-300 has-[:checked]:border-sky-500 has-[:checked]:bg-sky-50">
                                <input type="radio" name="dateMode" value="date" checked class="accent-sky-600">
                                <span class="text-sm font-medium"><i class="ph ph-calendar"></i> Date</span>
                            </label>
                            <label class="flex items-center gap-2 px-3 py-2 border border-gray-200 rounded-lg cursor-pointer hover:border-sky-300 has-[:checked]:border-sky-500 has-[:checked]:bg-sky-50">
                                <input type="radio" name="dateMode" value="datetime" class="accent-sky-600">
                                <span class="text-sm font-medium"><i class="ph ph-calendar-plus"></i> Date & Time</span>
                            </label>
                            <label class="flex items-center gap-2 px-3 py-2 border border-gray-200 rounded-lg cursor-pointer hover:border-sky-300 has-[:checked]:border-sky-500 has-[:checked]:bg-sky-50">
                                <input type="radio" name="dateMode" value="time" class="accent-sky-600">
                                <span class="text-sm font-medium"><i class="ph ph-clock"></i> Time</span>
                            </label>
                        </div>
                        <div id="dateFormatSection">
                            <label class="form-label text-sm">Date Format</label>
                            <select id="dateFormat" class="w-full px-2 py-1 border border-gray-300 rounded text-sm mb-3">
                                <option value="MM/DD/YYYY">MM/DD/YYYY (US)</option>
                                <option value="DD/MM/YYYY">DD/MM/YYYY (European)</option>
                                <option value="YYYY-MM-DD">YYYY-MM-DD (ISO)</option>
                                <option value="DD.MM.YYYY">DD.MM.YYYY (German)</option>
                                <option value="MMM D, YYYY">MMM D, YYYY (Jan 1, 2024)</option>
                                <option value="D MMM YYYY">D MMM YYYY (1 Jan 2024)</option>
                            </select>
                        </div>
                        <div id="timeFormatSection" class="hidden">
                            <label class="form-label text-sm">Time Format</label>
                            <div class="flex gap-2 mb-3">
                                <label class="flex items-center gap-2 px-3 py-2 border border-gray-200 rounded-lg cursor-pointer hover:border-sky-300 has-[:checked]:border-sky-500 has-[:checked]:bg-sky-50">
                                    <input type="radio" name="timeFormat" value="24h" class="accent-sky-600">
                                    <span class="text-sm">24h (14:30)</span>
                                </label>
                                <label class="flex items-center gap-2 px-3 py-2 border border-gray-200 rounded-lg cursor-pointer hover:border-sky-300 has-[:checked]:border-sky-500 has-[:checked]:bg-sky-50">
                                    <input type="radio" name="timeFormat" value="12h" class="accent-sky-600">
                                    <span class="text-sm">12h (2:30)</span>
                                </label>
                                <label class="flex items-center gap-2 px-3 py-2 border border-gray-200 rounded-lg cursor-pointer hover:border-sky-300 has-[:checked]:border-sky-500 has-[:checked]:bg-sky-50">
                                    <input type="radio" name="timeFormat" value="12h_ampm" checked class="accent-sky-600">
                                    <span class="text-sm">12h AM/PM</span>
                                </label>
                            </div>
                            <label class="flex items-center gap-2 text-sm mb-3">
                                <input type="checkbox" id="includeSeconds" class="accent-sky-600">
                                <span>Include seconds</span>
                            </label>
                        </div>
                        <div class="border-t border-sky-200 pt-3 mt-2">
                            <label class="flex items-center gap-2 text-sm">
                                <input type="checkbox" id="showTimezone" class="accent-sky-600">
                                <span>Show timezone</span>
                            </label>
                            <select id="timezone" class="w-full px-2 py-1 border border-gray-300 rounded text-sm mt-2 hidden">
                                <option value="">Local timezone</option>
                                <option value="America/New_York">America/New_York (EST/EDT)</option>
                                <option value="America/Chicago">America/Chicago (CST/CDT)</option>
                                <option value="America/Denver">America/Denver (MST/MDT)</option>
                                <option value="America/Los_Angeles">America/Los_Angeles (PST/PDT)</option>
                                <option value="Europe/London">Europe/London (GMT/BST)</option>
                                <option value="Europe/Paris">Europe/Paris (CET/CEST)</option>
                                <option value="Europe/Berlin">Europe/Berlin (CET/CEST)</option>
                                <option value="Asia/Tokyo">Asia/Tokyo (JST)</option>
                                <option value="Asia/Shanghai">Asia/Shanghai (CST)</option>
                                <option value="Asia/Dubai">Asia/Dubai (GST)</option>
                                <option value="Australia/Sydney">Australia/Sydney (AEST/AEDT)</option>
                                <option value="UTC">UTC</option>
                            </select>
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer flex justify-end gap-2">
                <button id="cancelAddFieldBtn" class="btn btn-secondary">Cancel</button>
                <button id="saveAddFieldBtn" class="btn btn-primary">Add Field</button>
            </div>
        </div>
    </div>

    <div id="changeFieldTypeModal" class="hidden fixed inset-0 bg-black bg-opacity-20 modal-overlay flex items-center justify-center p-6 z-50">
        <div class="modal-container bg-white w-full max-w-xl max-h-[90vh] flex flex-col">
            <div class="modal-header flex items-center justify-between">
                <div>
                    <h2 class="text-xl font-bold text-gray-900">Change Field Type</h2>
                    <p class="text-sm text-gray-500 mt-1">Update the type for <span id="changeFieldName" class="font-medium text-gray-900"></span></p>
                    <p id="changeFieldTypeSummary" class="text-xs text-gray-500 mt-1"></p>
                </div>
                <button id="closeChangeFieldTypeBtn" class="text-gray-400 hover:text-gray-600 transition p-2">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>
            <div class="flex-1 overflow-y-auto modal-body space-y-5">
                <div>
                    <label class="form-label">Field Type</label>
                    <div class="field-type-select">
                        <button type="button" id="changeFieldTypeTrigger" class="field-type-trigger">
                            <div class="field-type-trigger-content">
                                <span class="field-type-trigger-icon" aria-hidden="true"></span>
                                <div class="field-type-trigger-text">
                                    <div class="field-type-name" id="changeSelectedFieldTypeName"></div>
                                    <div class="field-type-description" id="changeSelectedFieldTypeDescription"></div>
                                </div>
                            </div>
                            <span class="field-type-trigger-arrow" aria-hidden="true"></span>
                        </button>
                        <div id="changeFieldTypeDropdown" class="field-type-dropdown hidden"></div>
                    </div>
                    <input type="hidden" id="changeFieldTypeInput" value="TEXT">
                </div>
                <div id="changeFieldSubtypeConfig" class="config-section"></div>
                <div id="changeSelectConfig" class="config-section">
                    <div class="bg-orange-50 border border-orange-200 rounded-lg p-4">
                        <label class="form-label">Options</label>
                        <div id="changeSelectOptionsList" class="space-y-2 mb-3"></div>
                        <button onclick="changeAddSelectOption()" class="btn btn-secondary btn-sm">+ Add Option</button>
                        <div class="mt-4 flex items-center">
                            <input type="checkbox" id="changeAcceptNewOptions" checked class="mr-2">
                            <label for="changeAcceptNewOptions" class="text-sm text-gray-700">Accept new options</label>
                        </div>
                    </div>
                </div>
                <div id="changeLinkToRecordConfig" class="config-section">
                    <div class="bg-blue-50 border border-blue-200 rounded-lg p-4">
                        <label class="form-label">Link to Set</label>
                        <div id="changeLinkToSetContainer"></div>
                        <p class="form-hint">Select which set to link to</p>
                    </div>
                </div>
                <div id="changeFormulaConfig" class="config-section">
                    <div class="bg-purple-50 border border-purple-200 rounded-lg p-4">
                        <label class="form-label">Formula</label>
                        <div class="relative">
                            <textarea id="changeFormulaInput" class="w-full px-3 py-2 border border-gray-300 rounded-lg font-mono text-sm" rows="4" placeholder="e.g., {Price} * {Quantity}"></textarea>
                            <div id="changeFormulaAutocomplete" class="absolute z-10 hidden bg-white border border-gray-300 rounded-lg shadow-lg max-h-48 overflow-y-auto" style="width: calc(100% - 2rem);"></div>
                        </div>
                        <p class="form-hint mt-2">Use {Field Name} to reference other fields. Available functions: SUM, AVG, MIN, MAX, IF, CONCAT, ROUND, etc.</p>
                        <div id="changeFormulaValidation" class="mt-2 text-sm"></div>
                        <div class="mt-3">
                            <label class="form-label">Display Format</label>
                            <div id="changeFormulaFormatContainer"></div>
                        </div>
                        <div class="mt-3">
                            <label class="form-label">Decimal Places</label>
                            <input type="number" id="changeFormulaDecimals" class="w-full px-3 py-2 border border-gray-300 rounded-lg" min="0" max="10" value="2">
                        </div>
                        <div id="convertToEditableSection" class="mt-4 pt-4 border-t border-purple-200 hidden">
                            <p class="text-sm text-gray-600 mb-2">Convert this formula field to a regular editable field. Current calculated values will be preserved.</p>
                            <button type="button" onclick="convertFormulaToEditable()" class="btn btn-secondary w-full">
                                <span class="flex items-center justify-center gap-2">
                                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"></path>
                                    </svg>
                                    Convert to Editable Field
                                </span>
                            </button>
                        </div>
                    </div>
                </div>
                <!-- Change Number Field Config -->
                <div id="changeNumberConfig" class="config-section">
                    <div class="bg-emerald-50 border border-emerald-200 rounded-lg p-4">
                        <label class="form-label">Number Format</label>
                        <div class="grid grid-cols-3 gap-2 mb-3">
                            <label class="flex items-center gap-2 px-3 py-2 border border-gray-200 rounded-lg cursor-pointer hover:border-emerald-300 has-[:checked]:border-emerald-500 has-[:checked]:bg-emerald-50">
                                <input type="radio" name="changeNumberFormat" value="integer" class="accent-emerald-600">
                                <span class="text-sm font-medium">Integer</span>
                            </label>
                            <label class="flex items-center gap-2 px-3 py-2 border border-gray-200 rounded-lg cursor-pointer hover:border-emerald-300 has-[:checked]:border-emerald-500 has-[:checked]:bg-emerald-50">
                                <input type="radio" name="changeNumberFormat" value="decimal" checked class="accent-emerald-600">
                                <span class="text-sm font-medium">Decimal</span>
                            </label>
                            <label class="flex items-center gap-2 px-3 py-2 border border-gray-200 rounded-lg cursor-pointer hover:border-emerald-300 has-[:checked]:border-emerald-500 has-[:checked]:bg-emerald-50">
                                <input type="radio" name="changeNumberFormat" value="percentage" class="accent-emerald-600">
                                <span class="text-sm font-medium">Percent</span>
                            </label>
                            <label class="flex items-center gap-2 px-3 py-2 border border-gray-200 rounded-lg cursor-pointer hover:border-emerald-300 has-[:checked]:border-emerald-500 has-[:checked]:bg-emerald-50">
                                <input type="radio" name="changeNumberFormat" value="currency" class="accent-emerald-600">
                                <span class="text-sm font-medium">Currency</span>
                            </label>
                            <label class="flex items-center gap-2 px-3 py-2 border border-gray-200 rounded-lg cursor-pointer hover:border-emerald-300 has-[:checked]:border-emerald-500 has-[:checked]:bg-emerald-50">
                                <input type="radio" name="changeNumberFormat" value="scientific" class="accent-emerald-600">
                                <span class="text-sm font-medium">Scientific</span>
                            </label>
                            <label class="flex items-center gap-2 px-3 py-2 border border-gray-200 rounded-lg cursor-pointer hover:border-emerald-300 has-[:checked]:border-emerald-500 has-[:checked]:bg-emerald-50">
                                <input type="radio" name="changeNumberFormat" value="fraction" class="accent-emerald-600">
                                <span class="text-sm font-medium">Fraction</span>
                            </label>
                        </div>
                        <div class="grid grid-cols-2 gap-3 mt-3">
                            <div>
                                <label class="form-label text-sm">Decimal Places</label>
                                <input type="number" id="changeNumberDecimals" min="0" max="10" value="2" class="w-full px-2 py-1 border border-gray-300 rounded text-sm">
                            </div>
                            <div>
                                <label class="form-label text-sm">Rounding</label>
                                <select id="changeNumberRounding" class="w-full px-2 py-1 border border-gray-300 rounded text-sm">
                                    <option value="round">Round</option>
                                    <option value="floor">Floor</option>
                                    <option value="ceil">Ceiling</option>
                                    <option value="truncate">Truncate</option>
                                </select>
                            </div>
                        </div>
                        <div id="changeCurrencyOptions" class="mt-3 hidden">
                            <label class="form-label text-sm">Currency</label>
                            <select id="changeCurrencyCode" class="w-full px-2 py-1 border border-gray-300 rounded text-sm">
                                <option value="USD">$ USD - US Dollar</option>
                                <option value="EUR"> EUR - Euro</option>
                                <option value="GBP"> GBP - British Pound</option>
                                <option value="JPY"> JPY - Japanese Yen</option>
                                <option value="CNY"> CNY - Chinese Yuan</option>
                                <option value="CAD">$ CAD - Canadian Dollar</option>
                                <option value="AUD">$ AUD - Australian Dollar</option>
                                <option value="CHF">Fr CHF - Swiss Franc</option>
                                <option value="INR"> INR - Indian Rupee</option>
                                <option value="MXN">$ MXN - Mexican Peso</option>
                                <option value="BRL">R$ BRL - Brazilian Real</option>
                                <option value="KRW"> KRW - South Korean Won</option>
                            </select>
                        </div>
                        <div class="mt-3 flex items-center gap-4">
                            <label class="flex items-center gap-2 text-sm">
                                <input type="checkbox" id="changeThousandSep" checked class="accent-emerald-600">
                                <span>Thousands separator</span>
                            </label>
                            <label class="flex items-center gap-2 text-sm">
                                <input type="checkbox" id="changeAllowNegative" checked class="accent-emerald-600">
                                <span>Allow negative</span>
                            </label>
                        </div>
                        <div class="grid grid-cols-2 gap-3 mt-3">
                            <div>
                                <label class="form-label text-sm">Min Value (optional)</label>
                                <input type="number" id="changeNumberMin" class="w-full px-2 py-1 border border-gray-300 rounded text-sm" placeholder="No limit">
                            </div>
                            <div>
                                <label class="form-label text-sm">Max Value (optional)</label>
                                <input type="number" id="changeNumberMax" class="w-full px-2 py-1 border border-gray-300 rounded text-sm" placeholder="No limit">
                            </div>
                        </div>
                    </div>
                </div>
                <!-- Change Date Field Config -->
                <div id="changeDateConfig" class="config-section">
                    <div class="bg-sky-50 border border-sky-200 rounded-lg p-4">
                        <label class="form-label">Date/Time Type</label>
                        <div class="flex gap-2 mb-3">
                            <label class="flex items-center gap-2 px-3 py-2 border border-gray-200 rounded-lg cursor-pointer hover:border-sky-300 has-[:checked]:border-sky-500 has-[:checked]:bg-sky-50">
                                <input type="radio" name="changeDateMode" value="date" checked class="accent-sky-600">
                                <span class="text-sm font-medium"><i class="ph ph-calendar"></i> Date</span>
                            </label>
                            <label class="flex items-center gap-2 px-3 py-2 border border-gray-200 rounded-lg cursor-pointer hover:border-sky-300 has-[:checked]:border-sky-500 has-[:checked]:bg-sky-50">
                                <input type="radio" name="changeDateMode" value="datetime" class="accent-sky-600">
                                <span class="text-sm font-medium"><i class="ph ph-calendar-plus"></i> Date & Time</span>
                            </label>
                            <label class="flex items-center gap-2 px-3 py-2 border border-gray-200 rounded-lg cursor-pointer hover:border-sky-300 has-[:checked]:border-sky-500 has-[:checked]:bg-sky-50">
                                <input type="radio" name="changeDateMode" value="time" class="accent-sky-600">
                                <span class="text-sm font-medium"><i class="ph ph-clock"></i> Time</span>
                            </label>
                        </div>
                        <div id="changeDateFormatSection">
                            <label class="form-label text-sm">Date Format</label>
                            <select id="changeDateFormat" class="w-full px-2 py-1 border border-gray-300 rounded text-sm mb-3">
                                <option value="MM/DD/YYYY">MM/DD/YYYY (US)</option>
                                <option value="DD/MM/YYYY">DD/MM/YYYY (European)</option>
                                <option value="YYYY-MM-DD">YYYY-MM-DD (ISO)</option>
                                <option value="DD.MM.YYYY">DD.MM.YYYY (German)</option>
                                <option value="MMM D, YYYY">MMM D, YYYY (Jan 1, 2024)</option>
                                <option value="D MMM YYYY">D MMM YYYY (1 Jan 2024)</option>
                            </select>
                        </div>
                        <div id="changeTimeFormatSection" class="hidden">
                            <label class="form-label text-sm">Time Format</label>
                            <div class="flex gap-2 mb-3">
                                <label class="flex items-center gap-2 px-3 py-2 border border-gray-200 rounded-lg cursor-pointer hover:border-sky-300 has-[:checked]:border-sky-500 has-[:checked]:bg-sky-50">
                                    <input type="radio" name="changeTimeFormat" value="24h" class="accent-sky-600">
                                    <span class="text-sm">24h (14:30)</span>
                                </label>
                                <label class="flex items-center gap-2 px-3 py-2 border border-gray-200 rounded-lg cursor-pointer hover:border-sky-300 has-[:checked]:border-sky-500 has-[:checked]:bg-sky-50">
                                    <input type="radio" name="changeTimeFormat" value="12h" class="accent-sky-600">
                                    <span class="text-sm">12h (2:30)</span>
                                </label>
                                <label class="flex items-center gap-2 px-3 py-2 border border-gray-200 rounded-lg cursor-pointer hover:border-sky-300 has-[:checked]:border-sky-500 has-[:checked]:bg-sky-50">
                                    <input type="radio" name="changeTimeFormat" value="12h_ampm" checked class="accent-sky-600">
                                    <span class="text-sm">12h AM/PM</span>
                                </label>
                            </div>
                            <label class="flex items-center gap-2 text-sm mb-3">
                                <input type="checkbox" id="changeIncludeSeconds" class="accent-sky-600">
                                <span>Include seconds</span>
                            </label>
                        </div>
                        <div class="border-t border-sky-200 pt-3 mt-2">
                            <label class="flex items-center gap-2 text-sm">
                                <input type="checkbox" id="changeShowTimezone" class="accent-sky-600">
                                <span>Show timezone</span>
                            </label>
                            <select id="changeTimezone" class="w-full px-2 py-1 border border-gray-300 rounded text-sm mt-2 hidden">
                                <option value="">Local timezone</option>
                                <option value="America/New_York">America/New_York (EST/EDT)</option>
                                <option value="America/Chicago">America/Chicago (CST/CDT)</option>
                                <option value="America/Denver">America/Denver (MST/MDT)</option>
                                <option value="America/Los_Angeles">America/Los_Angeles (PST/PDT)</option>
                                <option value="Europe/London">Europe/London (GMT/BST)</option>
                                <option value="Europe/Paris">Europe/Paris (CET/CEST)</option>
                                <option value="Europe/Berlin">Europe/Berlin (CET/CEST)</option>
                                <option value="Asia/Tokyo">Asia/Tokyo (JST)</option>
                                <option value="Asia/Shanghai">Asia/Shanghai (CST)</option>
                                <option value="Asia/Dubai">Asia/Dubai (GST)</option>
                                <option value="Australia/Sydney">Australia/Sydney (AEST/AEDT)</option>
                                <option value="UTC">UTC</option>
                            </select>
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer flex justify-end gap-2">
                <button id="cancelChangeFieldTypeBtn" class="btn btn-secondary">Cancel</button>
                <button id="saveChangeFieldTypeBtn" class="btn btn-primary">Update Type</button>
            </div>
        </div>
    </div>

    <div id="addWorldModal" class="hidden fixed inset-0 bg-black bg-opacity-20 modal-overlay flex items-center justify-center p-6 z-50">
        <div class="modal-container bg-white w-full max-w-md">
            <div class="modal-header">
                <h2 class="text-xl font-bold text-gray-900">Create World</h2>
            </div>
            <div class="modal-body space-y-4">
                <div>
                    <label class="form-label">World Name</label>
                    <input type="text" id="newWorldName" placeholder="e.g., Workspace Alpha">
                </div>
            </div>
            <div class="modal-footer flex justify-end gap-2">
                <button id="cancelAddWorldBtn" class="btn btn-secondary">Cancel</button>
                <button id="saveAddWorldBtn" class="btn btn-primary">Create</button>
            </div>
        </div>
    </div>

    <div id="addSetModal" class="hidden fixed inset-0 bg-black bg-opacity-20 modal-overlay flex items-center justify-center p-6 z-50">
        <div class="modal-container bg-white w-full max-w-md">
            <div class="modal-header">
                <h2 id="addSetModalTitle" class="text-xl font-bold text-gray-900">Create Set</h2>
            </div>
            <div class="modal-body space-y-4">
                <div>
                    <label class="form-label">World</label>
                    <select id="newSetWorld"></select>
                </div>
                <div>
                    <label class="form-label">Set Name</label>
                    <input type="text" id="newSetName" placeholder="e.g., Projects, Contacts">
                </div>
                <div>
                    <label class="form-label">Icon</label>
                    <div id="newSetIconSelector" class="icon-selector" role="button" tabindex="0">
                        <div id="newSetIconPreview" class="icon-selector-icon" aria-hidden="true"></div>
                        <div class="icon-selector-text">
                            <div class="icon-selector-label">Pick a visual icon</div>
                            <div id="newSetIconToken" class="icon-selector-token"></div>
                        </div>
                        <span class="icon-selector-chevron"></span>
                    </div>
                    <input type="hidden" id="newSetIcon" value="ph-squares-four">
                </div>
            </div>
            <div class="modal-footer flex justify-end gap-2">
                <button id="cancelAddSetBtn" class="btn btn-secondary">Cancel</button>
                <button id="saveAddSetBtn" class="btn btn-primary">Create</button>
            </div>
        </div>
    </div>

    <div id="addRecordModal" class="hidden fixed inset-0 bg-black bg-opacity-20 modal-overlay flex items-center justify-center p-6 z-50">
        <div class="modal-container bg-white w-full max-w-md">
            <div class="modal-header">
                <h2 class="text-xl font-bold text-gray-900">Add Record</h2>
            </div>
            <div class="modal-body space-y-4">
                <div>
                    <label class="form-label">Select View</label>
                    <select id="addRecordViewSelect" class="w-full"></select>
                    <p class="form-hint">Choose which view to add the record to. The record will be structured based on the view's fields.</p>
                </div>
            </div>
            <div class="modal-footer flex justify-end gap-2">
                <button id="cancelAddRecordBtn" class="btn btn-secondary">Cancel</button>
                <button id="saveAddRecordBtn" class="btn btn-primary">Create Record</button>
            </div>
        </div>
    </div>

    <div id="addViewModal" class="hidden modal-overlay add-view-modal-overlay">
        <div class="modal add-view-modal">
            <div class="modal-header">
                <div class="modal-title-group">
                    <div class="modal-icon">
                        <i class="ph ph-plus"></i>
                    </div>
                    <h2 id="addViewModalTitle">Create View</h2>
                </div>
                <button class="modal-close" id="closeAddViewModalBtn" aria-label="Close">
                    <i class="ph ph-x"></i>
                </button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label class="form-label">View Name</label>
                    <input type="text" id="newViewName" placeholder="e.g., Active Items">
                    <p id="newViewNameError" class="form-error hidden">Please enter a view name</p>
                </div>
                <div class="form-group">
                    <label class="form-label">View Icon</label>
                    <div id="newViewIconSelector" class="icon-selector" role="button" tabindex="0">
                        <div id="newViewIconPreview" class="icon-selector-icon" aria-hidden="true"></div>
                        <div class="icon-selector-text">
                            <div class="icon-selector-label">Choose an icon</div>
                            <div id="newViewIconToken" class="icon-selector-token"></div>
                        </div>
                        <i class="ph ph-caret-down icon-selector-chevron"></i>
                    </div>
                    <input type="hidden" id="newViewIcon" value="ph-table">
                </div>
                <div class="form-group">
                    <label class="form-label">View Type</label>
                    <div class="view-type-grid">
                        <label class="view-type-option">
                            <input type="radio" name="newViewType" value="grid" checked>
                            <div class="view-type-option-content">
                                <i class="ph ph-table"></i>
                                <span>Table</span>
                            </div>
                        </label>
                        <label class="view-type-option">
                            <input type="radio" name="newViewType" value="card">
                            <div class="view-type-option-content">
                                <i class="ph ph-cards-three"></i>
                                <span>Cards</span>
                            </div>
                        </label>
                        <label class="view-type-option">
                            <input type="radio" name="newViewType" value="kanban">
                            <div class="view-type-option-content">
                                <i class="ph ph-kanban"></i>
                                <span>Kanban</span>
                            </div>
                        </label>
                        <label class="view-type-option">
                            <input type="radio" name="newViewType" value="graph">
                            <div class="view-type-option-content">
                                <i class="ph ph-graph"></i>
                                <span>Graph</span>
                            </div>
                        </label>
                    </div>
                </div>
                <div class="form-group">
                    <label class="form-label">Nest Under</label>
                    <select id="newViewParent"></select>
                    <p class="form-hint">Optionally place this view under another view</p>
                </div>
                <div class="form-group">
                    <label class="form-label">How do you want to start?</label>
                    <div class="creation-mode-options">
                        <label class="creation-mode-option">
                            <input type="radio" name="viewCreationMode" value="blank" checked>
                            <span>Blank View</span>
                        </label>
                        <label class="creation-mode-option expanded">
                            <input type="radio" name="viewCreationMode" value="key">
                            <div class="creation-mode-content">
                                <span>Create From Key or Value</span>
                                <div class="creation-mode-fields">
                                    <div class="relative">
                                        <input type="text" id="keySearchInput" placeholder="Search for a field or value..." autocomplete="off">
                                        <div id="keySearchResults" class="key-search-dropdown hidden"></div>
                                    </div>
                                    <select id="keyCandidateSelect" disabled>
                                        <option value="">Scanning for fields</option>
                                    </select>
                                    <p class="form-hint">Select a field to pivot around, or search for a specific value.</p>
                                </div>
                            </div>
                        </label>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button id="cancelAddViewBtn" class="btn-secondary">Cancel</button>
                <button id="saveAddViewBtn" class="btn-primary">
                    <i class="ph ph-plus"></i>
                    Create View
                </button>
            </div>
        </div>
    </div>

    <div id="iconPickerModal" class="hidden fixed inset-0 bg-black bg-opacity-20 modal-overlay flex items-center justify-center p-6 z-50">
        <div class="modal-container bg-white w-full max-w-2xl icon-picker-shell">
            <div class="modal-header flex items-center justify-between">
                <h2 class="text-xl font-bold text-gray-900">Pick an icon</h2>
                <button id="closeIconPickerBtn" class="btn btn-secondary btn-sm">Close</button>
            </div>
            <div class="modal-body space-y-4 icon-picker-body">
                <div class="icon-picker-controls">
                    <input type="text" id="iconPickerSearch" placeholder="Search icons (e.g., table, folder)" class="w-full icon-picker-search">
                    <div id="iconPickerPagination" class="icon-pagination"></div>
                </div>
                <div id="iconPickerOptions" class="icon-picker-grid"></div>
            </div>
        </div>
    </div>

    <div id="kanbanConfigModal" class="hidden fixed inset-0 bg-black bg-opacity-20 modal-overlay flex items-center justify-center p-6 z-50">
        <div class="modal-container bg-white w-full max-w-md">
            <div class="modal-header">
                <h2 class="text-xl font-bold text-gray-900">Configure Kanban</h2>
            </div>
            <div class="modal-body space-y-4">
                <div>
                    <label class="form-label">Group By Field</label>
                    <select id="kanbanGroupField"></select>
                    <p class="form-hint">Select a single-select field to group records by</p>
                </div>
            </div>
            <div class="modal-footer flex justify-end gap-2">
                <button id="cancelKanbanConfigBtn" class="btn btn-secondary">Cancel</button>
                <button id="saveKanbanConfigBtn" class="btn btn-primary">Apply</button>
            </div>
        </div>
    </div>

    <div id="csvImportModal" class="hidden fixed inset-0 bg-black bg-opacity-20 modal-overlay flex items-center justify-center p-6 z-50">
        <div class="modal-container bg-white w-full max-w-4xl max-h-[90vh] overflow-hidden flex flex-col">
            <div class="modal-header flex items-center justify-between">
                <div>
                    <h2 class="text-xl font-bold text-gray-900">Import CSV</h2>
                    <p class="text-sm text-gray-500 mt-1">Choose a destination set before uploading, then map columns and preview fuzzy matches.</p>
                </div>
                <button id="closeCsvImportBtn" class="text-gray-400 hover:text-gray-600 transition p-2">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>
            <div class="flex-1 overflow-y-auto modal-body space-y-4">
                <div class="csv-helper-card">
                    <div class="flex items-center justify-between mb-2">
                        <div>
                            <h3 class="text-lg font-semibold">Destination</h3>
                            <p class="text-sm text-gray-500">Pick an existing set or create a new one before selecting a file.</p>
                        </div>
                    </div>
                    <div class="space-y-3">
                        <label class="flex items-center gap-2 font-medium">
                            <input type="radio" name="csvImportTargetMode" value="existing">
                            Import into existing set
                        </label>
                        <div id="csvExistingSetPicker" class="pl-7 space-y-2 hidden">
                            <select id="csvTargetSetSelect"></select>
                            <p class="text-xs text-gray-500">We'll map columns to the selected set's fields.</p>
                        </div>
                        <label class="flex items-center gap-2 font-medium">
                            <input type="radio" name="csvImportTargetMode" value="new" checked>
                            Create a new set from this CSV
                        </label>
                        <div id="csvNewSetFields" class="pl-7 space-y-2">
                            <input type="text" id="csvNewSetName" placeholder="e.g., Leads" class="w-full">
                            <p class="text-xs text-gray-500">We'll create fields from your headers automatically.</p>
                        </div>
                    </div>
                </div>

                <div class="csv-helper-grid">
                    <div class="csv-helper-card">
                        <label class="form-label">Upload CSV File</label>
                        <input type="file" id="csvFileInput" accept=".csv" />
                        <p class="form-hint">Headers are required. We will auto-map matching field names.</p>
                    </div>
                    <div class="csv-helper-card">
                        <label class="form-label">Or Paste CSV Text</label>
                        <textarea id="csvTextInput" rows="5" placeholder="name,industry\nAcme,Technology"></textarea>
                        <div class="mt-2 flex justify-end">
                            <button id="parseCsvTextBtn" class="btn btn-secondary btn-sm">Preview CSV</button>
                        </div>
                    </div>
                </div>

                <div class="csv-helper-card">
                    <div class="flex items-center justify-between mb-2">
                        <div>
                            <h3 class="text-lg font-semibold">Field Mapping</h3>
                            <p class="text-sm text-gray-500">Match CSV columns to fields in the current set.</p>
                        </div>
                        <span class="csv-match-pill" id="csvRowCountBadge">0 rows</span>
                    </div>
                    <div id="csvMappingContainer" class="space-y-2"></div>
                </div>

                <div class="csv-helper-card" id="typeAssessmentCard" style="display: none;">
                    <div class="flex items-center justify-between mb-2">
                        <div>
                            <h3 class="text-lg font-semibold flex items-center gap-2">
                                <i class="ph ph-detective" style="color: #6366f1;"></i>
                                Type Detection Assessment
                            </h3>
                            <p class="text-sm text-gray-500">Review detected field types. Click to change if needed.</p>
                        </div>
                        <div class="flex items-center gap-2">
                            <span id="typeAssessmentSummary" class="text-xs text-gray-500"></span>
                            <button id="acceptAllTypesBtn" class="btn btn-secondary btn-sm" style="font-size: 11px;">Accept All</button>
                        </div>
                    </div>
                    <div id="typeAssessmentContainer" class="space-y-2" style="max-height: 300px; overflow-y: auto;"></div>
                </div>

                <div class="csv-helper-card">
                    <div class="flex items-center justify-between mb-2">
                        <div>
                            <h3 class="text-lg font-semibold">Preview</h3>
                            <p class="text-sm text-gray-500">First few records with applied mapping.</p>
                        </div>
                        <button id="refreshCsvPreviewBtn" class="btn btn-secondary btn-sm">Refresh Preview</button>
                    </div>
                    <div id="csvPreviewContainer" class="overflow-auto"></div>
                </div>

                <div class="csv-helper-card">
                    <div class="flex items-center justify-between mb-2">
                        <div>
                            <h3 class="text-lg font-semibold">Fuzzy Match Suggestions</h3>
                            <p class="text-sm text-gray-500">We surface potential duplicates against existing records.</p>
                        </div>
                        <div class="text-xs text-gray-500">Score  0.6 shown</div>
                    </div>
                    <div id="csvMatchSuggestions" class="space-y-2"></div>
                </div>

                <div class="csv-helper-card border-blue-200 bg-blue-50/30">
                    <div class="flex items-center justify-between mb-3">
                        <div>
                            <h3 class="text-lg font-semibold flex items-center gap-2">
                                <span>Import Notes</span>
                                <span class="text-xs font-normal text-gray-500">(Optional)</span>
                            </h3>
                            <p class="text-sm text-gray-500">Add context about this data import for audit trail.</p>
                        </div>
                    </div>
                    <div class="space-y-3">
                        <div class="grid grid-cols-2 gap-3">
                            <div>
                                <label class="text-xs font-medium text-gray-700 block mb-1">Source System</label>
                                <input type="text" id="csvProvenanceSource" class="w-full px-3 py-2 border border-gray-300 rounded-md text-sm" placeholder="e.g., Salesforce, Excel">
                            </div>
                            <div>
                                <label class="text-xs font-medium text-gray-700 block mb-1">Data Type</label>
                                <input type="text" id="csvProvenanceDataType" class="w-full px-3 py-2 border border-gray-300 rounded-md text-sm" placeholder="e.g., Leads, Contacts">
                            </div>
                        </div>
                        <div>
                            <label class="text-xs font-medium text-gray-700 block mb-1">Notes</label>
                            <textarea id="csvProvenanceNotes" class="w-full px-3 py-2 border border-gray-300 rounded-md text-sm" rows="2" placeholder="Any additional context about this import..."></textarea>
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer flex justify-end gap-2">
                <button id="cancelCsvImportBtn" class="btn btn-secondary">Cancel</button>
                <button id="runCsvImportBtn" class="btn btn-primary">Import Records</button>
            </div>
        </div>
    </div>

    <!-- JSON Import Modal -->
    <div id="jsonImportModal" class="hidden fixed inset-0 bg-black bg-opacity-20 modal-overlay flex items-center justify-center p-6 z-50">
        <div class="modal-container bg-white w-full max-w-4xl max-h-[90vh] overflow-hidden flex flex-col">
            <div class="modal-header flex items-center justify-between">
                <div>
                    <h2 class="text-xl font-bold text-gray-900">Import JSON</h2>
                    <p class="text-sm text-gray-500 mt-1">Choose a destination set before uploading, then map fields and preview data.</p>
                </div>
                <button id="closeJsonImportBtn" class="text-gray-400 hover:text-gray-600 transition p-2">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>
            <div class="flex-1 overflow-y-auto modal-body space-y-4">
                <div class="csv-helper-card">
                    <div class="flex items-center justify-between mb-2">
                        <div>
                            <h3 class="text-lg font-semibold">Destination</h3>
                            <p class="text-sm text-gray-500">Pick an existing set or create a new one before selecting a file.</p>
                        </div>
                    </div>
                    <div class="space-y-3">
                        <label class="flex items-center gap-2 font-medium">
                            <input type="radio" name="jsonImportTargetMode" value="existing">
                            Import into existing set
                        </label>
                        <div id="jsonExistingSetPicker" class="pl-7 space-y-2 hidden">
                            <select id="jsonTargetSetSelect"></select>
                            <p class="text-xs text-gray-500">We'll map JSON keys to the selected set's fields.</p>
                        </div>
                        <label class="flex items-center gap-2 font-medium">
                            <input type="radio" name="jsonImportTargetMode" value="new" checked>
                            Create a new set from this JSON
                        </label>
                        <div id="jsonNewSetFields" class="pl-7 space-y-2">
                            <input type="text" id="jsonNewSetName" placeholder="e.g., Leads" class="w-full">
                            <p class="text-xs text-gray-500">We'll create fields from your JSON keys automatically.</p>
                        </div>
                    </div>
                </div>

                <div class="csv-helper-grid">
                    <div class="csv-helper-card">
                        <label class="form-label">Upload JSON File</label>
                        <input type="file" id="jsonFileInput" accept=".json,application/json" />
                        <p class="form-hint">Expects an array of objects or an object with a data array. We will auto-map matching field names.</p>
                    </div>
                    <div class="csv-helper-card">
                        <label class="form-label">Or Paste JSON Text</label>
                        <textarea id="jsonTextInput" rows="5" placeholder='[{"name": "Acme", "industry": "Technology"}]'></textarea>
                        <div class="mt-2 flex justify-end">
                            <button id="parseJsonTextBtn" class="btn btn-secondary btn-sm">Preview JSON</button>
                        </div>
                    </div>
                </div>

                <div class="csv-helper-card">
                    <div class="flex items-center justify-between mb-2">
                        <div>
                            <h3 class="text-lg font-semibold">Field Mapping</h3>
                            <p class="text-sm text-gray-500">Match JSON keys to fields in the current set.</p>
                        </div>
                        <span class="csv-match-pill" id="jsonRowCountBadge">0 rows</span>
                    </div>
                    <div id="jsonMappingContainer" class="space-y-2"></div>
                </div>

                <div class="csv-helper-card">
                    <div class="flex items-center justify-between mb-2">
                        <div>
                            <h3 class="text-lg font-semibold">Preview</h3>
                            <p class="text-sm text-gray-500">First few records with applied mapping.</p>
                        </div>
                        <button id="refreshJsonPreviewBtn" class="btn btn-secondary btn-sm">Refresh Preview</button>
                    </div>
                    <div id="jsonPreviewContainer" class="overflow-auto"></div>
                </div>

                <div class="csv-helper-card">
                    <div class="flex items-center justify-between mb-2">
                        <div>
                            <h3 class="text-lg font-semibold">Fuzzy Match Suggestions</h3>
                            <p class="text-sm text-gray-500">We surface potential duplicates against existing records.</p>
                        </div>
                        <div class="text-xs text-gray-500">Score  0.6 shown</div>
                    </div>
                    <div id="jsonMatchSuggestions" class="space-y-2"></div>
                </div>

                <div class="csv-helper-card border-blue-200 bg-blue-50/30">
                    <div class="flex items-center justify-between mb-3">
                        <div>
                            <h3 class="text-lg font-semibold flex items-center gap-2">
                                <span>Import Notes</span>
                                <span class="text-xs font-normal text-gray-500">(Optional)</span>
                            </h3>
                            <p class="text-sm text-gray-500">Add context about this data import for audit trail.</p>
                        </div>
                    </div>
                    <div class="space-y-3">
                        <div class="grid grid-cols-2 gap-3">
                            <div>
                                <label class="text-xs font-medium text-gray-700 block mb-1">Source System</label>
                                <input type="text" id="jsonProvenanceSource" class="w-full px-3 py-2 border border-gray-300 rounded-md text-sm" placeholder="e.g., API, Salesforce">
                            </div>
                            <div>
                                <label class="text-xs font-medium text-gray-700 block mb-1">Data Type</label>
                                <input type="text" id="jsonProvenanceDataType" class="w-full px-3 py-2 border border-gray-300 rounded-md text-sm" placeholder="e.g., Leads, Contacts">
                            </div>
                        </div>
                        <div>
                            <label class="text-xs font-medium text-gray-700 block mb-1">Notes</label>
                            <textarea id="jsonProvenanceNotes" class="w-full px-3 py-2 border border-gray-300 rounded-md text-sm" rows="2" placeholder="Any additional context about this import..."></textarea>
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer flex justify-end gap-2">
                <button id="cancelJsonImportBtn" class="btn btn-secondary">Cancel</button>
                <button id="runJsonImportBtn" class="btn btn-primary">Import Records</button>
            </div>
        </div>
    </div>

    <!-- Provenance Review Modal (Tier 2 & 3) -->
    <div id="provenanceReviewModal" class="hidden fixed inset-0 bg-black bg-opacity-20 modal-overlay flex items-center justify-center p-6 z-50">
        <div class="modal-container bg-white w-full max-w-3xl max-h-[90vh] overflow-hidden flex flex-col">
            <div class="modal-header flex items-center justify-between">
                <div>
                    <h2 class="text-xl font-bold text-gray-900">Review Import Details</h2>
                    <p class="text-sm text-gray-500 mt-1">We've automatically detected information about your file. Review and edit if needed.</p>
                </div>
                <button id="closeProvenanceReviewBtn" class="text-gray-400 hover:text-gray-600 transition p-2">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>
            <div class="flex-1 overflow-y-auto modal-body space-y-4">
                <!-- Filename Display -->
                <div class="bg-gray-50 border border-gray-200 rounded-lg p-3">
                    <div class="text-sm font-medium text-gray-700">File:</div>
                    <div class="text-base font-mono" id="provenanceFilename"></div>
                </div>

                <!-- Tier 2: High Confidence Inferences -->
                <div class="border border-green-200 rounded-lg bg-green-50/50 p-4">
                    <div class="flex items-center gap-2 mb-3">
                        <span class="w-2 h-2 rounded-full bg-green-500"></span>
                        <h3 class="text-base font-semibold text-gray-900">Auto-Detected Information</h3>
                        <span class="text-xs text-gray-500">(click to edit)</span>
                    </div>

                    <div class="space-y-3">
                        <div class="flex items-center gap-3">
                            <label class="w-36 text-sm font-medium text-gray-700">Source System:</label>
                            <input type="text" id="provenanceSourceSystem" class="flex-1 px-3 py-1.5 border border-gray-300 rounded-md text-sm" placeholder="Auto-detected">
                            <span class="text-xs text-gray-500" id="provenanceSourceSystemConfidence"></span>
                        </div>

                        <div class="flex items-center gap-3">
                            <label class="w-36 text-sm font-medium text-gray-700">Data Type:</label>
                            <input type="text" id="provenanceDataType" class="flex-1 px-3 py-1.5 border border-gray-300 rounded-md text-sm" placeholder="Auto-detected">
                        </div>

                        <div class="flex items-center gap-3">
                            <label class="w-36 text-sm font-medium text-gray-700">Method:</label>
                            <select id="provenanceMethod" class="flex-1 px-3 py-1.5 border border-gray-300 rounded-md text-sm">
                                <option value="measured">Measured (system)</option>
                                <option value="declared">Declared (manual)</option>
                                <option value="derived">Derived (calculated)</option>
                                <option value="aggregated">Aggregated</option>
                                <option value="inferred">Inferred</option>
                            </select>
                        </div>

                        <div class="flex items-center gap-3">
                            <label class="w-36 text-sm font-medium text-gray-700">Timeframe:</label>
                            <div class="flex-1 flex items-center gap-2">
                                <input type="text" id="provenanceTimeframeStart" class="flex-1 px-3 py-1.5 border border-gray-300 rounded-md text-sm" placeholder="Start date">
                                <span class="text-gray-400">to</span>
                                <input type="text" id="provenanceTimeframeEnd" class="flex-1 px-3 py-1.5 border border-gray-300 rounded-md text-sm" placeholder="End date">
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Tier 2: Medium Confidence (please verify) -->
                <div class="border border-amber-200 rounded-lg bg-amber-50/50 p-4">
                    <div class="flex items-center gap-2 mb-3">
                        <span class="w-2 h-2 rounded-full bg-amber-500"></span>
                        <h3 class="text-base font-semibold text-gray-900">Additional Settings</h3>
                        <span class="text-xs text-gray-500">(please verify)</span>
                    </div>

                    <div class="space-y-3">
                        <div>
                            <label class="text-sm font-medium text-gray-700 block mb-2">Compliance Standard:</label>
                            <div class="space-y-2 pl-3">
                                <label class="flex items-center gap-2">
                                    <input type="radio" name="provenanceJurisdiction" value="us_gaap">
                                    <span class="text-sm">US GAAP</span>
                                </label>
                                <label class="flex items-center gap-2">
                                    <input type="radio" name="provenanceJurisdiction" value="ifrs">
                                    <span class="text-sm">IFRS</span>
                                </label>
                                <label class="flex items-center gap-2">
                                    <input type="radio" name="provenanceJurisdiction" value="sox">
                                    <span class="text-sm">SOX</span>
                                </label>
                                <label class="flex items-center gap-2">
                                    <input type="radio" name="provenanceJurisdiction" value="internal">
                                    <span class="text-sm">Internal / Custom</span>
                                </label>
                                <label class="flex items-center gap-2">
                                    <input type="radio" name="provenanceJurisdiction" value="auto" checked>
                                    <span class="text-sm">Auto (use column hints)</span>
                                </label>
                            </div>
                        </div>

                        <div>
                            <label class="text-sm font-medium text-gray-700 block mb-2">Organizational Scale:</label>
                            <div class="space-y-2 pl-3">
                                <label class="flex items-center gap-2">
                                    <input type="radio" name="provenanceScale" value="individual">
                                    <span class="text-sm">Individual</span>
                                </label>
                                <label class="flex items-center gap-2">
                                    <input type="radio" name="provenanceScale" value="team" checked>
                                    <span class="text-sm">Team</span>
                                </label>
                                <label class="flex items-center gap-2">
                                    <input type="radio" name="provenanceScale" value="department">
                                    <span class="text-sm">Department</span>
                                </label>
                                <label class="flex items-center gap-2">
                                    <input type="radio" name="provenanceScale" value="organization">
                                    <span class="text-sm">Organization</span>
                                </label>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Tier 3: Epistemic Context (Optional but Recommended) -->
                <div class="border border-blue-200 rounded-lg bg-blue-50/50 p-4">
                    <div class="flex items-center gap-2 mb-3">
                        <span class="text-blue-600"></span>
                        <h3 class="text-base font-semibold text-gray-900">Data Quality & Classification</h3>
                        <span class="text-xs text-gray-500">(optional but recommended)</span>
                    </div>

                    <div class="space-y-3">
                        <div>
                            <label class="text-sm font-medium text-gray-700 block mb-2">Data Category:</label>
                            <div class="text-xs text-gray-500 mb-2">What type of data is this?</div>
                            <select id="provenanceFrame" class="w-full px-3 py-2 border border-gray-300 rounded-md text-sm">
                                <option value="">None specified</option>
                                <option value="financial_reporting">Financial Reporting (GAAP/IFRS)</option>
                                <option value="operational">Operational Metrics</option>
                                <option value="sales_metrics">Sales & Revenue</option>
                                <option value="product_analytics">Product Analytics</option>
                                <option value="scientific">Scientific/Research</option>
                                <option value="legal_compliance">Legal/Compliance</option>
                                <option value="hr">Human Resources</option>
                                <option value="custom">Custom (specify below)</option>
                            </select>
                            <input type="text" id="provenanceFrameCustom" class="w-full px-3 py-2 border border-gray-300 rounded-md text-sm mt-2 hidden" placeholder="Specify custom frame">
                        </div>

                        <div>
                            <label class="text-sm font-medium text-gray-700 block mb-2">Data Owner:</label>
                            <div class="text-xs text-gray-500 mb-2">Who is responsible for this data?</div>
                            <input type="text" id="provenanceAuthority" class="w-full px-3 py-2 border border-gray-300 rounded-md text-sm" placeholder="e.g., CFO - Finance Department">
                        </div>

                        <div>
                            <label class="text-sm font-medium text-gray-700 block mb-2">Trust Level:</label>
                            <div class="space-y-2 pl-3">
                                <label class="flex items-center gap-2">
                                    <input type="radio" name="provenanceTrustLevel" value="authoritative" checked>
                                    <span class="text-sm">Authoritative (official record)</span>
                                </label>
                                <label class="flex items-center gap-2">
                                    <input type="radio" name="provenanceTrustLevel" value="provisional">
                                    <span class="text-sm">Provisional (draft/estimate)</span>
                                </label>
                                <label class="flex items-center gap-2">
                                    <input type="radio" name="provenanceTrustLevel" value="exploratory">
                                    <span class="text-sm">Exploratory (analysis/sandbox)</span>
                                </label>
                            </div>
                        </div>

                        <!-- External System Linkage -->
                        <div id="provenanceExternalLinksContainer" class="hidden">
                            <label class="text-sm font-medium text-gray-700 block mb-2">External System Link:</label>
                            <div class="bg-white border border-blue-200 rounded-md p-3">
                                <div class="flex items-center gap-2 mb-2">
                                    <span class="text-blue-600"></span>
                                    <span class="text-sm font-medium" id="provenanceExternalLinkText">Detected ID column</span>
                                </div>
                                <label class="flex items-center gap-2 text-sm">
                                    <input type="checkbox" id="provenanceEnableExternalLink">
                                    <span>Link to external system</span>
                                </label>
                                <input type="text" id="provenanceExternalLinkUrl" class="w-full px-3 py-2 border border-gray-300 rounded-md text-sm mt-2 hidden" placeholder="Base URL (e.g., https://mycompany.salesforce.com)">
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Summary of Detections -->
                <div class="bg-gray-50 border border-gray-200 rounded-lg p-3">
                    <div class="text-xs font-medium text-gray-700 mb-2">Detection Summary:</div>
                    <div id="provenanceSummary" class="text-xs text-gray-600 space-y-1"></div>
                </div>
            </div>
            <div class="modal-footer flex justify-between items-center gap-2">
                <button id="skipProvenanceBtn" class="btn btn-secondary">Skip - Use Defaults</button>
                <button id="continueToMappingBtn" class="btn btn-primary">Continue to Column Mapping </button>
            </div>
        </div>
    </div>

    <div id="columnRulesModal" class="hidden fixed inset-0 bg-black bg-opacity-20 modal-overlay flex items-center justify-center p-6 z-50">
        <div class="modal-container bg-white w-full max-w-2xl max-h-[90vh] overflow-hidden flex flex-col">
            <div class="modal-header flex items-center justify-between">
                <div>
                    <h2 class="text-xl font-bold text-gray-900">Column Rules</h2>
                    <p class="text-sm text-gray-500 mt-1">Pick how we resolve multiple observations per property.</p>
                </div>
                <button id="closeColumnRulesBtn" class="text-gray-400 hover:text-gray-600 transition p-2 rounded-lg hover:bg-gray-50">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>
            <div class="flex-1 overflow-y-auto modal-body space-y-6">
                <!-- Columns Visibility Section -->
                <div class="border border-gray-200 rounded-xl bg-gradient-to-br from-white to-gray-50/50 p-4 hover:border-gray-300 transition-all">
                    <div class="flex items-start gap-3">
                        <div class="flex-shrink-0 w-10 h-10 rounded-lg bg-blue-50 border border-blue-100 flex items-center justify-center">
                            <i class="ph ph-columns text-blue-600 text-xl"></i>
                        </div>
                        <div class="flex-1 min-w-0">
                            <div class="text-sm font-semibold text-gray-900 mb-1">Columns</div>
                            <div class="text-xs text-gray-500 mb-3">Toggle view-only columns like Row Numbers and Record ID.</div>
                            <div class="flex flex-wrap gap-4">
                                <label class="flex items-center gap-2 cursor-pointer select-none group">
                                    <span class="text-sm text-gray-700 font-medium">Row #</span>
                                    <div id="rowNumbersToggle" class="popup-toggle">
                                        <input id="rowNumbersVisibilityToggle" type="checkbox" class="hidden">
                                    </div>
                                </label>
                                <label class="flex items-center gap-2 cursor-pointer select-none group">
                                    <span class="text-sm text-gray-700 font-medium">Record ID</span>
                                    <div id="recordIdToggle" class="popup-toggle">
                                        <input id="recordIdVisibilityToggle" type="checkbox" class="hidden">
                                    </div>
                                </label>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Property Selection Section -->
                <div>
                    <label class="form-label flex items-center gap-2">
                        <i class="ph ph-tag text-gray-400"></i>
                        Property
                    </label>
                    <select id="columnRulesFieldSelect" class="w-full"></select>
                </div>

                <!-- Rule Selection Section -->
                <div>
                    <label class="form-label flex items-center gap-2">
                        <i class="ph ph-funnel text-gray-400"></i>
                        Rule
                    </label>
                    <select id="columnRulesRuleSelect" class="w-full">
                        <option value="sup_all">Show all (Multiple Observations)</option>
                        <option value="prefer_newest">Prefer newest</option>
                        <option value="prefer_oldest">Prefer oldest</option>
                        <option value="prefer_set">Prefer value from set</option>
                        <option value="average_numeric">Average numeric</option>
                        <option value="median_numeric">Median numeric</option>
                        <option value="concat_text">Concatenate text</option>
                        <option value="first_non_null">First non-null</option>
                    </select>
                    <p class="text-xs text-gray-500 mt-2">Choose how to handle multiple values for the same property.</p>
                </div>

                <!-- Preferred Set Section (conditional) -->
                <div id="columnRulesSetPicker" class="hidden">
                    <label class="form-label flex items-center gap-2">
                        <i class="ph ph-stack text-gray-400"></i>
                        Preferred Set
                    </label>
                    <select id="columnRulesPreferredSet" class="w-full"></select>
                </div>

                <!-- Rule Summary -->
                <div class="rounded-xl border-2 border-blue-100 bg-blue-50/50 p-4 flex items-start gap-3" id="columnRulesSummaryContainer">
                    <div class="flex-shrink-0 w-8 h-8 rounded-lg bg-blue-100 border border-blue-200 flex items-center justify-center">
                        <i class="ph ph-check-circle text-blue-600"></i>
                    </div>
                    <div class="flex-1 min-w-0">
                        <div class="text-xs font-semibold text-blue-900 uppercase tracking-wide mb-1">Current Rule</div>
                        <div id="columnRulesSummary" class="text-sm font-medium text-gray-900"></div>
                    </div>
                </div>
            </div>
            <div class="modal-footer flex justify-between items-center gap-3">
                <button id="deleteColumnRuleBtn" class="btn btn-danger flex items-center gap-2">
                    <i class="ph ph-trash text-sm"></i>
                    Clear Rule
                </button>
                <button id="saveColumnRuleBtn" class="btn btn-primary flex items-center gap-2">
                    <i class="ph ph-check text-sm"></i>
                    Save Rule
                </button>
            </div>
        </div>
    </div>

    <!-- Field Manager Modal -->
    <div id="fieldManagerModal" class="hidden fixed inset-0 bg-black bg-opacity-20 modal-overlay flex items-center justify-center p-6 z-50">
        <div class="modal-container bg-white w-full max-w-3xl max-h-[90vh] overflow-hidden flex flex-col">
            <div class="modal-header flex items-center justify-between">
                <div>
                    <h2 class="text-xl font-bold text-gray-900">Field Manager</h2>
                    <p class="text-sm text-gray-500 mt-1">Manage schema fields: add, remove, rename, reorder, and change types</p>
                </div>
                <button id="closeFieldManagerBtn" class="text-gray-400 hover:text-gray-600 transition p-2 rounded-lg hover:bg-gray-50">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>
            <div class="flex-1 overflow-y-auto modal-body">
                <!-- Search and Add Section -->
                <div class="sticky top-0 bg-white z-10 pb-4 border-b border-gray-200 mb-4">
                    <!-- Search Field -->
                    <div class="mb-3">
                        <div class="relative">
                            <i class="ph ph-magnifying-glass absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400"></i>
                            <input type="text" id="fieldManagerSearch" class="w-full pl-10 pr-10 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500" placeholder="Search fields...">
                            <button id="clearFieldSearch" class="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-400 hover:text-gray-600 hidden">
                                <i class="ph ph-x"></i>
                            </button>
                        </div>
                    </div>

                    <!-- Add New Field Button -->
                    <button id="addFieldTriggerBtn" class="btn btn-primary w-full flex items-center justify-center gap-2">
                        <i class="ph ph-plus-circle"></i>
                        Add New Field
                    </button>

                    <!-- Add Field Form (initially hidden) -->
                    <div id="addFieldForm" class="hidden mt-4 p-4 bg-gray-50 rounded-lg border border-gray-200 space-y-4">
                        <div>
                            <label class="form-label">Field Name</label>
                            <input type="text" id="fieldManagerNewName" class="w-full" placeholder="e.g., Email Address">
                        </div>
                        <div>
                            <label class="form-label">Field Type</label>
                            <div class="field-type-select">
                                <button type="button" id="fieldManagerTypeTrigger" class="field-type-trigger">
                                    <div class="field-type-trigger-content">
                                        <span class="field-type-trigger-icon" aria-hidden="true"></span>
                                        <div class="field-type-trigger-text">
                                            <div class="field-type-name" id="fieldManagerSelectedTypeName"></div>
                                            <div class="field-type-description" id="fieldManagerSelectedTypeDescription"></div>
                                        </div>
                                    </div>
                                    <span class="field-type-trigger-arrow" aria-hidden="true"></span>
                                </button>
                                <div id="fieldManagerTypeDropdown" class="field-type-dropdown hidden"></div>
                            </div>
                            <input type="hidden" id="fieldManagerNewType" value="TEXT">
                        </div>
                        <!-- Type-specific config containers -->
                        <div id="fieldManagerSelectConfig" class="config-section">
                            <div class="bg-orange-50 border border-orange-200 rounded-lg p-4">
                                <label class="form-label">Options</label>
                                <div id="fieldManagerSelectOptionsList" class="space-y-2 mb-3"></div>
                                <button onclick="addFieldManagerSelectOption()" type="button" class="btn btn-secondary btn-sm">+ Add Option</button>
                                <div class="mt-4 flex items-center">
                                    <input type="checkbox" id="fieldManagerAcceptNewOptions" checked class="mr-2">
                                    <label for="fieldManagerAcceptNewOptions" class="text-sm text-gray-700">Accept new options</label>
                                </div>
                            </div>
                        </div>
                        <div id="fieldManagerLinkToRecordConfig" class="config-section">
                            <div class="bg-blue-50 border border-blue-200 rounded-lg p-4">
                                <label class="form-label">Link to Set</label>
                                <select id="fieldManagerLinkToSet"></select>
                                <p class="form-hint">Select which set to link to</p>

                                <label class="form-label mt-4">Cardinality</label>
                                <div class="flex gap-2 mb-2">
                                    <label class="flex items-center gap-2 px-3 py-2 border border-gray-200 rounded-lg cursor-pointer hover:border-blue-300 has-[:checked]:border-blue-500 has-[:checked]:bg-blue-50">
                                        <input type="radio" name="fieldManagerLinkCardinality" value="one" class="accent-blue-600">
                                        <span class="text-sm font-medium">One</span>
                                    </label>
                                    <label class="flex items-center gap-2 px-3 py-2 border border-gray-200 rounded-lg cursor-pointer hover:border-blue-300 has-[:checked]:border-blue-500 has-[:checked]:bg-blue-50">
                                        <input type="radio" name="fieldManagerLinkCardinality" value="many" checked class="accent-blue-600">
                                        <span class="text-sm font-medium">Many</span>
                                    </label>
                                    <label class="flex items-center gap-2 px-3 py-2 border border-gray-200 rounded-lg cursor-pointer hover:border-blue-300 has-[:checked]:border-blue-500 has-[:checked]:bg-blue-50">
                                        <input type="radio" name="fieldManagerLinkCardinality" value="limit" class="accent-blue-600">
                                        <span class="text-sm font-medium">Limit</span>
                                    </label>
                                </div>
                                <div id="fieldManagerLinkLimitInput" class="hidden">
                                    <label class="form-label text-sm">Maximum records</label>
                                    <input type="number" id="fieldManagerLinkLimit" min="1" max="100" value="3" class="w-20 px-2 py-1 border border-gray-300 rounded text-sm">
                                </div>
                                <p class="form-hint">How many records can be linked</p>
                            </div>
                        </div>
                        <div id="fieldManagerFormulaConfig" class="config-section">
                            <div class="bg-purple-50 border border-purple-200 rounded-lg p-4">
                                <label class="form-label">Formula</label>
                                <div class="relative">
                                    <textarea id="fieldManagerFormulaInput" class="w-full px-3 py-2 border border-gray-300 rounded-lg font-mono text-sm" rows="4" placeholder="e.g., {Price} * {Quantity}"></textarea>
                                    <div id="fieldManagerFormulaAutocomplete" class="absolute z-10 hidden bg-white border border-gray-300 rounded-lg shadow-lg max-h-48 overflow-y-auto" style="width: calc(100% - 2rem);"></div>
                                </div>
                                <p class="form-hint mt-2">Use {Field Name} to reference other fields. Available functions: SUM, AVG, MIN, MAX, IF, CONCAT, ROUND, etc.</p>
                                <div id="fieldManagerFormulaValidation" class="mt-2 text-sm"></div>
                                <div class="mt-3">
                                    <label class="form-label">Display Format</label>
                                    <select id="fieldManagerFormulaFormat" class="w-full px-3 py-2 border border-gray-300 rounded-lg">
                                        <option value="number">Number</option>
                                        <option value="currency">Currency</option>
                                        <option value="percentage">Percentage</option>
                                        <option value="text">Text</option>
                                    </select>
                                </div>
                                <div class="mt-3">
                                    <label class="form-label">Decimal Places</label>
                                    <input type="number" id="fieldManagerFormulaDecimals" class="w-full px-3 py-2 border border-gray-300 rounded-lg" min="0" max="10" value="2">
                                </div>
                            </div>
                        </div>
                        <!-- Number Field Config -->
                        <div id="fieldManagerNumberConfig" class="config-section">
                            <div class="bg-emerald-50 border border-emerald-200 rounded-lg p-4">
                                <label class="form-label">Number Format</label>
                                <div class="grid grid-cols-3 gap-2 mb-3">
                                    <label class="flex items-center gap-2 px-3 py-2 border border-gray-200 rounded-lg cursor-pointer hover:border-emerald-300 has-[:checked]:border-emerald-500 has-[:checked]:bg-emerald-50">
                                        <input type="radio" name="fieldManagerNumberFormat" value="integer" class="accent-emerald-600">
                                        <span class="text-sm font-medium">Integer</span>
                                    </label>
                                    <label class="flex items-center gap-2 px-3 py-2 border border-gray-200 rounded-lg cursor-pointer hover:border-emerald-300 has-[:checked]:border-emerald-500 has-[:checked]:bg-emerald-50">
                                        <input type="radio" name="fieldManagerNumberFormat" value="decimal" checked class="accent-emerald-600">
                                        <span class="text-sm font-medium">Decimal</span>
                                    </label>
                                    <label class="flex items-center gap-2 px-3 py-2 border border-gray-200 rounded-lg cursor-pointer hover:border-emerald-300 has-[:checked]:border-emerald-500 has-[:checked]:bg-emerald-50">
                                        <input type="radio" name="fieldManagerNumberFormat" value="percentage" class="accent-emerald-600">
                                        <span class="text-sm font-medium">Percent</span>
                                    </label>
                                    <label class="flex items-center gap-2 px-3 py-2 border border-gray-200 rounded-lg cursor-pointer hover:border-emerald-300 has-[:checked]:border-emerald-500 has-[:checked]:bg-emerald-50">
                                        <input type="radio" name="fieldManagerNumberFormat" value="currency" class="accent-emerald-600">
                                        <span class="text-sm font-medium">Currency</span>
                                    </label>
                                    <label class="flex items-center gap-2 px-3 py-2 border border-gray-200 rounded-lg cursor-pointer hover:border-emerald-300 has-[:checked]:border-emerald-500 has-[:checked]:bg-emerald-50">
                                        <input type="radio" name="fieldManagerNumberFormat" value="scientific" class="accent-emerald-600">
                                        <span class="text-sm font-medium">Scientific</span>
                                    </label>
                                    <label class="flex items-center gap-2 px-3 py-2 border border-gray-200 rounded-lg cursor-pointer hover:border-emerald-300 has-[:checked]:border-emerald-500 has-[:checked]:bg-emerald-50">
                                        <input type="radio" name="fieldManagerNumberFormat" value="fraction" class="accent-emerald-600">
                                        <span class="text-sm font-medium">Fraction</span>
                                    </label>
                                </div>
                                <div class="grid grid-cols-2 gap-3 mt-3">
                                    <div>
                                        <label class="form-label text-sm">Decimal Places</label>
                                        <input type="number" id="fieldManagerNumberDecimals" min="0" max="10" value="2" class="w-full px-2 py-1 border border-gray-300 rounded text-sm">
                                    </div>
                                    <div>
                                        <label class="form-label text-sm">Rounding</label>
                                        <select id="fieldManagerNumberRounding" class="w-full px-2 py-1 border border-gray-300 rounded text-sm">
                                            <option value="round">Round</option>
                                            <option value="floor">Floor</option>
                                            <option value="ceil">Ceiling</option>
                                            <option value="truncate">Truncate</option>
                                        </select>
                                    </div>
                                </div>
                                <div id="fieldManagerCurrencyOptions" class="mt-3 hidden">
                                    <label class="form-label text-sm">Currency</label>
                                    <select id="fieldManagerCurrencyCode" class="w-full px-2 py-1 border border-gray-300 rounded text-sm">
                                        <option value="USD">$ USD - US Dollar</option>
                                        <option value="EUR"> EUR - Euro</option>
                                        <option value="GBP"> GBP - British Pound</option>
                                        <option value="JPY"> JPY - Japanese Yen</option>
                                        <option value="CNY"> CNY - Chinese Yuan</option>
                                        <option value="CAD">$ CAD - Canadian Dollar</option>
                                        <option value="AUD">$ AUD - Australian Dollar</option>
                                        <option value="CHF">Fr CHF - Swiss Franc</option>
                                        <option value="INR"> INR - Indian Rupee</option>
                                        <option value="MXN">$ MXN - Mexican Peso</option>
                                        <option value="BRL">R$ BRL - Brazilian Real</option>
                                        <option value="KRW"> KRW - South Korean Won</option>
                                    </select>
                                </div>
                                <div class="mt-3 flex items-center gap-4">
                                    <label class="flex items-center gap-2 text-sm">
                                        <input type="checkbox" id="fieldManagerThousandSep" checked class="accent-emerald-600">
                                        <span>Thousands separator</span>
                                    </label>
                                    <label class="flex items-center gap-2 text-sm">
                                        <input type="checkbox" id="fieldManagerAllowNegative" checked class="accent-emerald-600">
                                        <span>Allow negative</span>
                                    </label>
                                </div>
                                <div class="grid grid-cols-2 gap-3 mt-3">
                                    <div>
                                        <label class="form-label text-sm">Min Value (optional)</label>
                                        <input type="number" id="fieldManagerNumberMin" class="w-full px-2 py-1 border border-gray-300 rounded text-sm" placeholder="No limit">
                                    </div>
                                    <div>
                                        <label class="form-label text-sm">Max Value (optional)</label>
                                        <input type="number" id="fieldManagerNumberMax" class="w-full px-2 py-1 border border-gray-300 rounded text-sm" placeholder="No limit">
                                    </div>
                                </div>
                            </div>
                        </div>
                        <!-- Date Field Config -->
                        <div id="fieldManagerDateConfig" class="config-section">
                            <div class="bg-sky-50 border border-sky-200 rounded-lg p-4">
                                <label class="form-label">Date/Time Type</label>
                                <div class="flex gap-2 mb-3">
                                    <label class="flex items-center gap-2 px-3 py-2 border border-gray-200 rounded-lg cursor-pointer hover:border-sky-300 has-[:checked]:border-sky-500 has-[:checked]:bg-sky-50">
                                        <input type="radio" name="fieldManagerDateMode" value="date" checked class="accent-sky-600">
                                        <span class="text-sm font-medium"><i class="ph ph-calendar"></i> Date</span>
                                    </label>
                                    <label class="flex items-center gap-2 px-3 py-2 border border-gray-200 rounded-lg cursor-pointer hover:border-sky-300 has-[:checked]:border-sky-500 has-[:checked]:bg-sky-50">
                                        <input type="radio" name="fieldManagerDateMode" value="datetime" class="accent-sky-600">
                                        <span class="text-sm font-medium"><i class="ph ph-calendar-plus"></i> Date & Time</span>
                                    </label>
                                    <label class="flex items-center gap-2 px-3 py-2 border border-gray-200 rounded-lg cursor-pointer hover:border-sky-300 has-[:checked]:border-sky-500 has-[:checked]:bg-sky-50">
                                        <input type="radio" name="fieldManagerDateMode" value="time" class="accent-sky-600">
                                        <span class="text-sm font-medium"><i class="ph ph-clock"></i> Time</span>
                                    </label>
                                </div>
                                <div id="fieldManagerDateFormatSection">
                                    <label class="form-label text-sm">Date Format</label>
                                    <select id="fieldManagerDateFormat" class="w-full px-2 py-1 border border-gray-300 rounded text-sm mb-3">
                                        <option value="MM/DD/YYYY">MM/DD/YYYY (US)</option>
                                        <option value="DD/MM/YYYY">DD/MM/YYYY (European)</option>
                                        <option value="YYYY-MM-DD">YYYY-MM-DD (ISO)</option>
                                        <option value="DD.MM.YYYY">DD.MM.YYYY (German)</option>
                                        <option value="MMM D, YYYY">MMM D, YYYY (Jan 1, 2024)</option>
                                        <option value="D MMM YYYY">D MMM YYYY (1 Jan 2024)</option>
                                    </select>
                                </div>
                                <div id="fieldManagerTimeFormatSection" class="hidden">
                                    <label class="form-label text-sm">Time Format</label>
                                    <div class="flex gap-2 mb-3">
                                        <label class="flex items-center gap-2 px-3 py-2 border border-gray-200 rounded-lg cursor-pointer hover:border-sky-300 has-[:checked]:border-sky-500 has-[:checked]:bg-sky-50">
                                            <input type="radio" name="fieldManagerTimeFormat" value="24h" class="accent-sky-600">
                                            <span class="text-sm">24h (14:30)</span>
                                        </label>
                                        <label class="flex items-center gap-2 px-3 py-2 border border-gray-200 rounded-lg cursor-pointer hover:border-sky-300 has-[:checked]:border-sky-500 has-[:checked]:bg-sky-50">
                                            <input type="radio" name="fieldManagerTimeFormat" value="12h" class="accent-sky-600">
                                            <span class="text-sm">12h (2:30)</span>
                                        </label>
                                        <label class="flex items-center gap-2 px-3 py-2 border border-gray-200 rounded-lg cursor-pointer hover:border-sky-300 has-[:checked]:border-sky-500 has-[:checked]:bg-sky-50">
                                            <input type="radio" name="fieldManagerTimeFormat" value="12h_ampm" checked class="accent-sky-600">
                                            <span class="text-sm">12h AM/PM</span>
                                        </label>
                                    </div>
                                    <label class="flex items-center gap-2 text-sm mb-3">
                                        <input type="checkbox" id="fieldManagerIncludeSeconds" class="accent-sky-600">
                                        <span>Include seconds</span>
                                    </label>
                                </div>
                                <div class="border-t border-sky-200 pt-3 mt-2">
                                    <label class="flex items-center gap-2 text-sm">
                                        <input type="checkbox" id="fieldManagerShowTimezone" class="accent-sky-600">
                                        <span>Show timezone</span>
                                    </label>
                                    <select id="fieldManagerTimezone" class="w-full px-2 py-1 border border-gray-300 rounded text-sm mt-2 hidden">
                                        <option value="">Local timezone</option>
                                        <option value="America/New_York">America/New_York (EST/EDT)</option>
                                        <option value="America/Chicago">America/Chicago (CST/CDT)</option>
                                        <option value="America/Denver">America/Denver (MST/MDT)</option>
                                        <option value="America/Los_Angeles">America/Los_Angeles (PST/PDT)</option>
                                        <option value="Europe/London">Europe/London (GMT/BST)</option>
                                        <option value="Europe/Paris">Europe/Paris (CET/CEST)</option>
                                        <option value="Europe/Berlin">Europe/Berlin (CET/CEST)</option>
                                        <option value="Asia/Tokyo">Asia/Tokyo (JST)</option>
                                        <option value="Asia/Shanghai">Asia/Shanghai (CST)</option>
                                        <option value="Asia/Dubai">Asia/Dubai (GST)</option>
                                        <option value="Australia/Sydney">Australia/Sydney (AEST/AEDT)</option>
                                        <option value="UTC">UTC</option>
                                    </select>
                                </div>
                            </div>
                        </div>

                        <div class="flex gap-2">
                            <button id="saveNewFieldBtn" class="btn btn-primary flex-1">
                                <i class="ph ph-check"></i>
                                Save Field
                            </button>
                            <button id="cancelNewFieldBtn" class="btn btn-secondary flex-1">
                                Cancel
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Field List -->
                <div class="space-y-2" id="fieldManagerList"></div>
            </div>
            <div class="modal-footer flex justify-end items-center gap-3">
                <button id="closeFieldManagerFooterBtn" class="btn btn-secondary">Close</button>
            </div>
        </div>
    </div>

    <div id="historyPanel" class="side-panel">
        <div class="bg-gradient-to-r from-indigo-600 to-purple-600 text-white p-6 flex-shrink-0">
            <div class="flex items-center justify-between mb-4">
                <div>
                    <h3 class="text-xl font-bold">Edit History</h3>
                    <p class="text-sm opacity-90 mt-1">Full audit trail</p>
                </div>
                <button id="closeHistoryBtn" class="text-white hover:bg-white hover:bg-opacity-20 p-2 rounded-lg transition">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>
            <input type="text" id="historySearch" class="w-full text-gray-900 rounded-lg" placeholder="Search history...">
        </div>
        <div class="flex-1 overflow-y-auto p-6" id="historyContent"></div>
    </div>

    <div id="fuzzyMatchPanel" class="side-panel">
        <div class="bg-gradient-to-r from-emerald-500 to-blue-600 text-white p-6 flex-shrink-0">
            <div class="flex items-center justify-between mb-4">
                <div>
                    <h3 class="text-xl font-bold">Fuzzy Matches</h3>
                    <p class="text-sm opacity-90 mt-1">Possible duplicate or related records</p>
                </div>
                <button id="closeFuzzyPanelBtn" class="text-white hover:bg-white hover:bg-opacity-20 p-2 rounded-lg transition">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>
            <div class="panel-controls">
                <label class="text-sm flex-1">Similarity threshold
                    <input id="fuzzyThresholdInput" type="range" min="0.4" max="0.95" step="0.01" value="0.65" class="w-full">
                </label>
                <button id="refreshFuzzyMatchesBtn" class="btn btn-secondary btn-sm">Recompute</button>
            </div>
        </div>
        <div class="flex-1 overflow-y-auto p-6" id="fuzzyMatchList"></div>
    </div>

    <!-- Cell History Modal -->
    <div id="cellHistoryModal" class="hidden fixed inset-0 bg-black bg-opacity-20 modal-overlay flex items-center justify-center p-6 z-50">
        <div class="modal-container bg-white w-full max-w-3xl max-h-[90vh] overflow-hidden flex flex-col">
            <div class="modal-header flex items-center justify-between">
                <div>
                    <h2 class="text-xl font-bold text-gray-900" id="cellHistoryTitle">Cell History</h2>
                    <p class="text-sm text-gray-500 mt-1" id="cellHistorySubtitle"></p>
                </div>
                <button class="text-gray-400 hover:text-gray-600 transition p-2" onclick="closeModal('cellHistoryModal')">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>
            <div class="record-tabs" id="cellHistoryTabs"></div>
            <div class="flex-1 overflow-y-auto p-6" id="cellHistoryContent"></div>
        </div>
    </div>

    <!-- Edit History Modal -->
    <div id="editHistoryModal" class="hidden fixed inset-0 bg-black bg-opacity-20 modal-overlay flex items-center justify-center p-6 z-50">
        <div class="modal-container bg-white w-full max-w-4xl max-h-[90vh] overflow-hidden flex flex-col">
            <div class="modal-header flex items-center justify-between">
                <div>
                    <h2 class="text-xl font-bold text-gray-900">Edit History</h2>
                    <p class="text-sm text-gray-500 mt-1" id="editHistorySubtitle">Full audit trail of all changes</p>
                </div>
                <button class="text-gray-400 hover:text-gray-600 transition p-2" onclick="closeModal('editHistoryModal')">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>
            <div class="border-b border-gray-200 px-6 py-3">
                <div class="flex items-center gap-3">
                    <input type="text" id="editHistorySearch" placeholder="Search history..." class="flex-1 text-sm border border-gray-300 rounded-lg px-3 py-2">
                    <select id="editHistoryFilter" class="text-sm border border-gray-300 rounded-lg px-3 py-2">
                        <option value="all">All Changes</option>
                        <option value="SEG">Field Changes</option>
                        <option value="INS">Record Created</option>
                        <option value="DES">Record Deleted</option>
                        <option value="SYN">Structural Changes</option>
                    </select>
                </div>
            </div>
            <div class="flex-1 overflow-y-auto p-6" id="editHistoryContent"></div>
        </div>
    </div>

    <!-- JSON Viewer Modal -->
    <div id="jsonViewerModal" class="hidden fixed inset-0 bg-black bg-opacity-20 modal-overlay flex items-center justify-center p-6 z-50">
        <div class="modal-container bg-white w-full max-w-6xl h-[90vh] max-h-[90vh] overflow-hidden flex flex-col">
            <div class="modal-header flex items-center justify-between">
                <div>
                    <h2 class="text-xl font-bold text-gray-900">JSON Data</h2>
                    <p class="text-sm text-gray-500 mt-1">View the complete data structure</p>
                </div>
                <button id="closeJsonViewerBtn" class="text-gray-400 hover:text-gray-600 transition p-2">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>
            <div class="flex border-b border-gray-200">
                <button class="json-tab active" data-tab="all" onclick="switchJsonTab('all')">All Data</button>
                <button class="json-tab" data-tab="sets" onclick="switchJsonTab('sets')">Sets</button>
                <button class="json-tab" data-tab="current" onclick="switchJsonTab('current')">Current Set</button>
                <button class="json-tab" data-tab="events" onclick="switchJsonTab('events')">Event Stream</button>
            </div>
            <div class="flex-1 overflow-hidden relative">
                <pre id="jsonContent" class="p-6 overflow-auto h-full text-sm bg-gray-50 font-mono"></pre>
                <button id="copyJsonBtn" class="absolute top-4 right-4 btn btn-secondary btn-sm">
                    <i class="ph ph-clipboard-text"></i>
                    Copy
                </button>
            </div>
        </div>
    </div>

    <!-- Search Data Modal -->
    <div id="searchDataModal" class="hidden fixed inset-0 bg-black bg-opacity-20 modal-overlay flex items-center justify-center p-6 z-50">
        <div class="modal-container bg-white w-full max-w-6xl max-h-[90vh] overflow-hidden flex flex-col">
            <div class="modal-header">
                <h2 class="text-xl font-bold text-gray-900">Search Data</h2>
                <p class="text-sm text-gray-500 mt-1">Find fields, records, and values. Focus on anything to explore its context.</p>
            </div>
            <div class="search-shell">
                <!-- LEFT: SEARCH + RESULTS -->
                <div class="search-surface">
                    <div class="search-input-row">
                        <input type="text" id="searchDataInput" placeholder="Type to search..." />
                        <div class="scope-pill" id="searchScopePill">Scope: Everything</div>
                    </div>
                    <div class="search-results-container" id="searchDataResults">
                        <p class="text-sm text-gray-400 px-5 pt-2">Type to search...</p>
                    </div>
                </div>

                <!-- RIGHT: FOCUS PANEL -->
                <aside class="focus-panel hidden" id="focusPanel">
                    <div class="focus-header">
                        <div class="focus-label">Focus</div>
                        <div class="focus-title-row">
                            <div style="flex: 1;">
                                <div class="focus-title" id="focusTitle">Select an item</div>
                                <div class="focus-subtitle" id="focusSubtitle"></div>
                            </div>
                            <span class="focus-tag" id="focusTag">-</span>
                        </div>
                        <button class="focus-clear" onclick="clearFocus()">Clear Focus</button>
                    </div>
                    <div class="focus-body" id="focusBody">
                        <p class="text-sm text-gray-500">Click "Focus" on any search result to see detailed information here.</p>
                    </div>
                    <div class="focus-actions" id="focusActions"></div>
                </aside>
            </div>
            <div class="modal-footer flex justify-between gap-2" style="border-top: 1px solid var(--border);">
                <div class="flex gap-2">
                    <label class="flex items-center gap-2 text-sm">
                        <input type="radio" name="searchScope" value="everything" checked onchange="updateSearchScope()">
                        <span>Everything</span>
                    </label>
                    <label class="flex items-center gap-2 text-sm">
                        <input type="radio" name="searchScope" value="fields" onchange="updateSearchScope()">
                        <span>Fields</span>
                    </label>
                    <label class="flex items-center gap-2 text-sm">
                        <input type="radio" name="searchScope" value="records" onchange="updateSearchScope()">
                        <span>Records</span>
                    </label>
                    <label class="flex items-center gap-2 text-sm">
                        <input type="radio" name="searchScope" value="values" onchange="updateSearchScope()">
                        <span>Values</span>
                    </label>
                </div>
                <button id="closeSearchDataBtn" class="btn btn-secondary">Close</button>
            </div>
        </div>
    </div>

    <script>
        const BRAND_ASSETS = {
            light: 'assets/eo-icons/eo-bracket-light.svg',
            dark: 'assets/eo-icons/eo-bracket-dark.svg'
        };

        function getTimeOfDayBrandMode() {
            const hour = new Date().getHours();
            return hour >= 6 && hour < 18 ? 'light' : 'dark';
        }

        function applyTimeBasedBranding() {
            const mode = getTimeOfDayBrandMode();
            const bracketAsset = BRAND_ASSETS[mode] || BRAND_ASSETS.light;

            const faviconLink = document.querySelector('link#dynamicFavicon');
            if (faviconLink) {
                faviconLink.href = bracketAsset;
            }

            const appleIcon = document.querySelector('link#dynamicAppleIcon');
            if (appleIcon) {
                appleIcon.href = bracketAsset;
            }

            const cornerLogo = document.getElementById('topCornerLogo');
            if (cornerLogo) {
                const darkAsset = BRAND_ASSETS.dark || bracketAsset;
                cornerLogo.src = darkAsset;
                cornerLogo.alt = 'EO bracket logo for dark mode';
                cornerLogo.dataset.brandMode = 'dark';
            }

            document.documentElement.dataset.brandMode = mode;
        }

        // STATE
        const state = {
            worlds: new Map(),
            entities: new Map(),
            views: new Map(),
            currentWorldId: null,
            sets: new Map(),
            currentSetId: null,
            currentViewId: null,
            currentProfileId: 'default',
            eventStream: [],
            eventIdCounter: 1,
            currentUser: { type: 'Person', id: 'user_1', name: 'User' },
            operatorSet: {},
            connectionModes: {},
            connectionRelations: new Map(),
            leanContext: null, // Will be initialized in initializeApp
            interpretationRules: [],
            definitions: new Map(),
            entityFormState: { activeFilter: 'all', editingId: null, selectedType: 'set', expandedEntities: new Set() },
            connections: new Map(),
            demoRefs: {},
            connectionBuilder: { targetSetId: null, targetRecordId: '', searchQuery: '', relationId: null, params: {} },
            currentSpecialView: null,
            definitionFormState: { editingId: null, activeFilter: 'all', showImportPanel: false },
            connectionFormState: { editingId: null, selectedRelationId: null },
            connectionRelationFormState: { editingId: null },
            sidebarCollapsed: false,
            sidebarOpenMobile: false,
            modalStack: [],
            currentRecordTab: 'history',
            recordHistoryVisible: true,
            expandedRecordSetId: null,
            openTabs: [],
            confirmCallback: null,
            selectOptions: [{ value: 'Option 1', color: 'blue' }],
            changeSelectOptions: [{ value: 'Option 1', color: 'blue' }],
            changeLinkedSetId: '',
            changeFieldOriginalType: null,
            fieldTypeDropdownOpen: false,
            changeFieldTypeDropdownOpen: false,
            changeFieldContext: null,
            expandedSets: new Set(),
            collapsedNavSections: new Set(['world', 'explore']), // Start with World/Explore collapsed, Sets expanded
            lastUsedSetId: null,
            lastUsedViewId: null,
            draggedRecord: null,
            cellHistoryContext: null,
            setEditorContext: null,
            viewEditorContext: null,
            iconPickerTarget: null,
            iconPickerQuery: '',
            popupUi: { filter: 'all', activeTab: 'popupFields' },
            popupEventStream: [],
            popupDraggedField: null,
            iconPickerPage: 1,
            selectedRecordIds: new Set(),
            lastSelectedRecordId: null,
            selectedCell: null,
            lastSelectedCell: null,
            editingCell: null,
            csvImportState: { headers: [], rows: [], mappings: {}, previewRows: [], matches: [], targetMode: 'new', targetSetId: null, newSetName: '' },
            jsonImportState: { keys: [], rows: [], mappings: {}, previewRows: [], matches: [], targetMode: 'new', targetSetId: null, newSetName: '', filename: '' },
            fuzzyPanelState: { threshold: 0.65, matches: [] },
            fieldTypeHistory: new Map(),
            connectionTypeUsage: new Map() // Track usage counts for operator+verb combos
        };

        // Make state globally accessible for external modules
        window.state = state;

        function registerEntity(entity) {
            if (!entity || !entity.id || !entity.type) {
                throw new Error('Entities require an id and type');
            }
            if (!state.entities) state.entities = new Map();
            const existing = state.entities.get(entity.id) || {};
            const worldId = entity.worldId || existing.worldId || deriveWorldIdForEntity(entity);
            const payload = {
                ...existing,
                ...entity,
                worldId,
                entityType: entity.entityType || existing.entityType || entity.type,
                origin: entity.origin || existing.origin || 'system'
            };
            state.entities.set(entity.id, payload);
            return payload;
        }

        function deleteEntity(entityId) {
            if (!state.entities?.has(entityId)) return null;
            const existing = state.entities.get(entityId);
            state.entities.delete(entityId);
            return existing;
        }

        function cleanupOrphanedEntities() {
            // Remove record entities that no longer exist in their sets
            if (!state.entities) return 0;
            let removedCount = 0;
            for (const [entityId, entity] of state.entities.entries()) {
                if ((entity.type || '').toLowerCase() === 'record') {
                    if (getRecordById(entityId) === null) {
                        state.entities.delete(entityId);
                        removedCount++;
                    }
                }
            }
            return removedCount;
        }

        function getEntityView(filterFn) {
            const entities = Array.from(state.entities.values()).filter(entity => !entity.worldId || entity.worldId === state.currentWorldId);
            return typeof filterFn === 'function' ? entities.filter(filterFn) : entities;
        }

        const columnDragState = {
            timer: null,
            holdTimer: null,
            holdReady: false,
            draggedFieldId: null,
            dropFieldId: null,
            dropPosition: null,
            ghost: null,
            offsetX: 0,
            offsetY: 0,
            sourceElement: null,
            preventClick: false
        };

        const tabDragState = {
            draggingKey: null,
            dropKey: null,
            dropPosition: null
        };

        const COLUMN_WIDTH_MIN = 50;
        const COLUMN_WIDTH_MAX = 800;

        function clampColumnWidth(width) {
            if (isNaN(width)) return 150;
            return Math.min(COLUMN_WIDTH_MAX, Math.max(COLUMN_WIDTH_MIN, width));
        }

        function getFieldWidth(field, view) {
            // Check view-level column widths first
            if (view?.columnWidths?.[field?.id]) {
                return clampColumnWidth(view.columnWidths[field.id]);
            }
            // Fall back to field-level width
            const numericWidth = parseInt(field?.width || '150', 10);
            return clampColumnWidth(numericWidth);
        }



        const FIELD_TYPES = {
            TEXT: {
                id: 'TEXT',
                name: 'Text',
                description: 'Text fields with formatting options',
                defaultValue: '',
                icon: 'ph-text-t',
                subtypes: {
                    STRING: { id: 'STRING', name: 'String', description: 'Plain text for simple values', icon: 'ph-text-t' },
                    RICH_TEXT: { id: 'RICH_TEXT', name: 'Rich Text', description: 'Formatted text with markdown support', icon: 'ph-text-aa' }
                },
                defaultSubtype: 'STRING'
            },
            NUMBER: {
                id: 'NUMBER',
                name: 'Number',
                description: 'Numeric values with formatting',
                defaultValue: 0,
                icon: 'ph-hash',
                subtypes: {
                    NUMBER: { id: 'NUMBER', name: 'Number', description: 'Plain numeric values with sorting and calculations', icon: 'ph-hash' },
                    CURRENCY: { id: 'CURRENCY', name: 'Currency', description: 'Financial amounts with currency formatting', icon: 'ph-currency-dollar' }
                },
                defaultSubtype: 'NUMBER'
            },
            DATE: {
                id: 'DATE',
                name: 'Date',
                description: 'Capture due dates, milestones, and schedules',
                defaultValue: '',
                icon: 'ph-calendar-blank'
            },
            CONTACT: {
                id: 'CONTACT',
                name: 'Contact',
                description: 'Contact information fields',
                defaultValue: '',
                icon: 'ph-address-book',
                subtypes: {
                    EMAIL: { id: 'EMAIL', name: 'Email', description: 'Email addresses with validation', icon: 'ph-envelope-simple' },
                    URL: { id: 'URL', name: 'URL', description: 'Links to webpages, docs, or media', icon: 'ph-link-simple' },
                    PHONE: { id: 'PHONE', name: 'Phone', description: 'Phone numbers for contacts', icon: 'ph-phone' }
                },
                defaultSubtype: 'EMAIL'
            },
            LINK_RECORD: {
                id: 'LINK_RECORD',
                name: 'Link to Record',
                description: 'Connect records across sets with relationships',
                defaultValue: '',
                icon: 'ph-link-simple-horizontal',
                needsConfig: true,
                cardinalityOptions: [
                    { id: 'one', name: 'One', description: 'Link to exactly one record' },
                    { id: 'many', name: 'Many', description: 'Link to unlimited records' },
                    { id: 'limit', name: 'Limit', description: 'Link to a specific number of records' }
                ],
                defaultCardinality: 'many'
            },
            LOOKUP: {
                id: 'LOOKUP',
                name: 'Lookup',
                description: 'Search and reference records from another set',
                defaultValue: '',
                icon: 'ph-magnifying-glass',
                needsConfig: true
            },
            SELECT: {
                id: 'SELECT',
                name: 'Select',
                description: 'Choose from a list of options',
                defaultValue: '',
                icon: 'ph-list-bullets',
                needsConfig: true,
                subtypes: {
                    SINGLE: { id: 'SINGLE', name: 'Single Select', description: 'Choose one option from a list', icon: 'ph-list-bullets' },
                    MULTIPLE: { id: 'MULTIPLE', name: 'Multiple Select', description: 'Choose multiple options from a list', icon: 'ph-list-checks' }
                },
                defaultSubtype: 'SINGLE'
            },
            CHECKBOX: {
                id: 'CHECKBOX',
                name: 'Checkbox',
                description: 'Quick yes/no or done/undone tracking',
                defaultValue: false,
                icon: 'ph-check-square'
            },
            FORMULA: {
                id: 'FORMULA',
                name: 'Formula',
                description: 'Calculate values using spreadsheet-style formulas',
                defaultValue: '',
                icon: 'ph-function',
                needsConfig: true
            },
            LINKED_LOOKUP: {
                id: 'LINKED_LOOKUP',
                name: 'Linked Lookup',
                description: 'Values pulled from linked records',
                defaultValue: '',
                icon: 'ph-magnifying-glass',
                isDerived: true
            },
            LINKED_ROLLUP: {
                id: 'LINKED_ROLLUP',
                name: 'Linked Rollup',
                description: 'Aggregated values from linked records',
                defaultValue: '',
                icon: 'ph-chart-line-up',
                isDerived: true
            },
            JSON: {
                id: 'JSON',
                name: 'JSON',
                description: 'Structured JSON data with visual rendering',
                defaultValue: null,
                icon: 'ph-brackets-curly',
                subtypes: {
                    DISPLAY: { id: 'DISPLAY', name: 'Show as JSON', description: 'Display syntax-highlighted JSON code', icon: 'ph-code' },
                    RENDER: { id: 'RENDER', name: 'Render', description: 'Visual tree with collapsible objects and arrays', icon: 'ph-tree-structure' }
                },
                defaultSubtype: 'DISPLAY'
            }
        };

        const VIEW_TYPE_ICONS = { grid: 'ph-table', card: 'ph-cards-three', kanban: 'ph-kanban', graph: 'ph-graph', KEY_DERIVED: 'ph-key' };

        // Formula Autocomplete
        function initFormulaAutocomplete() {
            const input = document.getElementById('formulaInput');
            const autocomplete = document.getElementById('formulaAutocomplete');
            const validation = document.getElementById('formulaValidation');

            if (!input || !autocomplete) return;

            let autocompleteState = {
                cursorPos: 0,
                searchText: '',
                isActive: false
            };

            function hideAutocomplete() {
                autocomplete.classList.add('hidden');
                autocompleteState.isActive = false;
            }

            function showAutocomplete(items, searchText) {
                if (items.length === 0) {
                    hideAutocomplete();
                    return;
                }

                autocomplete.innerHTML = items.map((item, index) => `
                    <div class="autocomplete-item px-3 py-2 hover:bg-purple-100 cursor-pointer ${index === 0 ? 'bg-purple-50' : ''}"
                         data-value="${item.value}"
                         data-index="${index}">
                        <div class="font-medium text-sm">${item.label}</div>
                        ${item.description ? `<div class="text-xs text-gray-500">${item.description}</div>` : ''}
                    </div>
                `).join('');

                // Add click handlers
                autocomplete.querySelectorAll('.autocomplete-item').forEach(el => {
                    el.onclick = () => {
                        insertAutocomplete(el.dataset.value, searchText);
                        hideAutocomplete();
                    };
                });

                autocomplete.classList.remove('hidden');
                autocompleteState.isActive = true;
            }

            function insertAutocomplete(value, searchText) {
                const text = input.value;
                const cursorPos = input.selectionStart;
                const beforeCursor = text.substring(0, cursorPos);
                const afterCursor = text.substring(cursorPos);

                let newText, newCursorPos;

                // Check if we're inserting a field (starts with {) or a function
                const lastBracePos = beforeCursor.lastIndexOf('{');
                const lastCloseBracePos = beforeCursor.lastIndexOf('}');

                if (lastBracePos > lastCloseBracePos && value.startsWith('{')) {
                    // Inserting a field reference
                    newText = text.substring(0, lastBracePos) + value + afterCursor;
                    newCursorPos = lastBracePos + value.length;
                } else {
                    // Inserting a function - replace the partial word
                    const wordMatch = beforeCursor.match(/[A-Z_]+$/i);
                    if (wordMatch) {
                        const startPos = cursorPos - wordMatch[0].length;
                        newText = text.substring(0, startPos) + value + afterCursor;
                        newCursorPos = startPos + value.length;
                    } else {
                        // Fallback: just insert at cursor
                        newText = beforeCursor + value + afterCursor;
                        newCursorPos = cursorPos + value.length;
                    }
                }

                input.value = newText;
                input.setSelectionRange(newCursorPos, newCursorPos);
                input.focus();

                validateFormula();
            }

            function validateFormula() {
                const formula = input.value.trim();
                if (!formula) {
                    validation.innerHTML = '';
                    return;
                }

                const set = getCurrentSet();
                const result = FormulaEngine.validateFormula(formula, set.schema);

                if (result.valid) {
                    validation.innerHTML = '<span class="text-green-600"> Valid formula</span>';
                    if (result.dependencies.length > 0) {
                        validation.innerHTML += `<div class="text-xs text-gray-600 mt-1">Uses: ${result.dependencies.join(', ')}</div>`;
                    }
                } else {
                    validation.innerHTML = `<span class="text-red-600"> ${result.error}</span>`;
                }
            }

            input.addEventListener('input', (e) => {
                const cursorPos = input.selectionStart;
                const text = input.value;
                const beforeCursor = text.substring(0, cursorPos);

                // Check if we're inside a field reference
                const lastBracePos = beforeCursor.lastIndexOf('{');
                const lastCloseBracePos = beforeCursor.lastIndexOf('}');

                if (lastBracePos > lastCloseBracePos) {
                    // We're inside a field reference
                    const searchText = beforeCursor.substring(lastBracePos + 1).toLowerCase();
                    const set = getCurrentSet();

                    // Get field suggestions
                    const fields = set.schema
                        .filter(f => f.name.toLowerCase().includes(searchText))
                        .map(f => ({
                            label: f.name,
                            value: `{${f.name}}`,
                            description: FIELD_TYPES[f.type]?.name || f.type
                        }));

                    showAutocomplete(fields, searchText);
                } else {
                    // Check if we're typing a function name
                    // Look for the last word before cursor (alphanumeric characters)
                    const wordMatch = beforeCursor.match(/[A-Z_]+$/i);
                    if (wordMatch && wordMatch[0].length > 0) {
                        const searchText = wordMatch[0].toUpperCase();

                        // Function descriptions
                        const functionDescriptions = {
                            SUM: 'Add numbers together',
                            AVG: 'Calculate average of numbers',
                            MIN: 'Find minimum value',
                            MAX: 'Find maximum value',
                            ROUND: 'Round number to decimals',
                            ABS: 'Absolute value',
                            SQRT: 'Square root',
                            POWER: 'Raise to power',
                            IF: 'Conditional logic',
                            AND: 'Logical AND',
                            OR: 'Logical OR',
                            NOT: 'Logical NOT',
                            CONCAT: 'Combine text',
                            UPPER: 'Convert to uppercase',
                            LOWER: 'Convert to lowercase',
                            TRIM: 'Remove whitespace',
                            LEN: 'Text length',
                            LEFT: 'Get left characters',
                            RIGHT: 'Get right characters',
                            COUNT: 'Count non-null values',
                            COUNTA: 'Count non-empty values',
                            ISBLANK: 'Check if blank',
                            ISNUMBER: 'Check if number'
                        };

                        // Get function suggestions
                        const functions = Object.keys(FormulaEngine.functions)
                            .filter(fn => fn.startsWith(searchText))
                            .map(fn => ({
                                label: fn,
                                value: fn + '(',
                                description: functionDescriptions[fn] || 'Function'
                            }));

                        if (functions.length > 0) {
                            showAutocomplete(functions, searchText);
                        } else {
                            hideAutocomplete();
                        }
                    } else {
                        hideAutocomplete();
                    }
                }

                validateFormula();
            });

            input.addEventListener('keydown', (e) => {
                if (autocompleteState.isActive) {
                    const items = autocomplete.querySelectorAll('.autocomplete-item');
                    const selected = autocomplete.querySelector('.bg-purple-50');

                    if (e.key === 'ArrowDown') {
                        e.preventDefault();
                        if (selected && selected.nextElementSibling) {
                            selected.classList.remove('bg-purple-50');
                            selected.nextElementSibling.classList.add('bg-purple-50');
                        }
                    } else if (e.key === 'ArrowUp') {
                        e.preventDefault();
                        if (selected && selected.previousElementSibling) {
                            selected.classList.remove('bg-purple-50');
                            selected.previousElementSibling.classList.add('bg-purple-50');
                        }
                    } else if (e.key === 'Enter' || e.key === 'Tab') {
                        e.preventDefault();
                        if (selected) {
                            const searchText = input.value.substring(0, input.selectionStart).split('{').pop();
                            insertAutocomplete(selected.dataset.value, searchText);
                            hideAutocomplete();
                        }
                    } else if (e.key === 'Escape') {
                        hideAutocomplete();
                    }
                }
            });

            input.addEventListener('blur', () => {
                // Delay hiding to allow click on autocomplete
                setTimeout(hideAutocomplete, 200);
            });

            validateFormula();
        }

        // Change Formula Autocomplete (for change field type modal)
        function initChangeFormulaAutocomplete() {
            const input = document.getElementById('changeFormulaInput');
            const autocomplete = document.getElementById('changeFormulaAutocomplete');
            const validation = document.getElementById('changeFormulaValidation');

            if (!input || !autocomplete) return;

            let autocompleteState = {
                cursorPos: 0,
                searchText: '',
                isActive: false
            };

            function hideAutocomplete() {
                autocomplete.classList.add('hidden');
                autocompleteState.isActive = false;
            }

            function showAutocomplete(items, searchText) {
                if (items.length === 0) {
                    hideAutocomplete();
                    return;
                }

                autocomplete.innerHTML = items.map((item, index) => `
                    <div class="autocomplete-item px-3 py-2 hover:bg-purple-100 cursor-pointer ${index === 0 ? 'bg-purple-50' : ''}"
                         data-value="${item.value}"
                         data-index="${index}">
                        <div class="font-medium text-sm">${item.label}</div>
                        ${item.description ? `<div class="text-xs text-gray-500">${item.description}</div>` : ''}
                    </div>
                `).join('');

                autocomplete.querySelectorAll('.autocomplete-item').forEach(el => {
                    el.onclick = () => {
                        insertAutocomplete(el.dataset.value, searchText);
                        hideAutocomplete();
                    };
                });

                autocomplete.classList.remove('hidden');
                autocompleteState.isActive = true;
            }

            function insertAutocomplete(value, searchText) {
                const text = input.value;
                const cursorPos = input.selectionStart;
                const beforeCursor = text.substring(0, cursorPos);
                const afterCursor = text.substring(cursorPos);

                let newText, newCursorPos;

                // Check if we're inserting a field (starts with {) or a function
                const lastBracePos = beforeCursor.lastIndexOf('{');
                const lastCloseBracePos = beforeCursor.lastIndexOf('}');

                if (lastBracePos > lastCloseBracePos && value.startsWith('{')) {
                    // Inserting a field reference
                    newText = text.substring(0, lastBracePos) + value + afterCursor;
                    newCursorPos = lastBracePos + value.length;
                } else {
                    // Inserting a function - replace the partial word
                    const wordMatch = beforeCursor.match(/[A-Z_]+$/i);
                    if (wordMatch) {
                        const startPos = cursorPos - wordMatch[0].length;
                        newText = text.substring(0, startPos) + value + afterCursor;
                        newCursorPos = startPos + value.length;
                    } else {
                        // Fallback: just insert at cursor
                        newText = beforeCursor + value + afterCursor;
                        newCursorPos = cursorPos + value.length;
                    }
                }

                input.value = newText;
                input.setSelectionRange(newCursorPos, newCursorPos);
                input.focus();

                validateFormula();
            }

            function validateFormula() {
                const formula = input.value.trim();
                if (!formula) {
                    validation.innerHTML = '';
                    return;
                }

                const set = getCurrentSet();
                const result = FormulaEngine.validateFormula(formula, set.schema);

                if (result.valid) {
                    validation.innerHTML = '<span class="text-green-600"> Valid formula</span>';
                    if (result.dependencies.length > 0) {
                        validation.innerHTML += `<div class="text-xs text-gray-600 mt-1">Uses: ${result.dependencies.join(', ')}</div>`;
                    }
                } else {
                    validation.innerHTML = `<span class="text-red-600"> ${result.error}</span>`;
                }
            }

            input.addEventListener('input', (e) => {
                const cursorPos = input.selectionStart;
                const text = input.value;
                const beforeCursor = text.substring(0, cursorPos);

                const lastBracePos = beforeCursor.lastIndexOf('{');
                const lastCloseBracePos = beforeCursor.lastIndexOf('}');

                if (lastBracePos > lastCloseBracePos) {
                    // We're inside a field reference
                    const searchText = beforeCursor.substring(lastBracePos + 1).toLowerCase();
                    const set = getCurrentSet();

                    const fields = set.schema
                        .filter(f => f.name.toLowerCase().includes(searchText))
                        .map(f => ({
                            label: f.name,
                            value: `{${f.name}}`,
                            description: FIELD_TYPES[f.type]?.name || f.type
                        }));

                    showAutocomplete(fields, searchText);
                } else {
                    // Check if we're typing a function name
                    const wordMatch = beforeCursor.match(/[A-Z_]+$/i);
                    if (wordMatch && wordMatch[0].length > 0) {
                        const searchText = wordMatch[0].toUpperCase();

                        // Function descriptions
                        const functionDescriptions = {
                            SUM: 'Add numbers together',
                            AVG: 'Calculate average of numbers',
                            MIN: 'Find minimum value',
                            MAX: 'Find maximum value',
                            ROUND: 'Round number to decimals',
                            ABS: 'Absolute value',
                            SQRT: 'Square root',
                            POWER: 'Raise to power',
                            IF: 'Conditional logic',
                            AND: 'Logical AND',
                            OR: 'Logical OR',
                            NOT: 'Logical NOT',
                            CONCAT: 'Combine text',
                            UPPER: 'Convert to uppercase',
                            LOWER: 'Convert to lowercase',
                            TRIM: 'Remove whitespace',
                            LEN: 'Text length',
                            LEFT: 'Get left characters',
                            RIGHT: 'Get right characters',
                            COUNT: 'Count non-null values',
                            COUNTA: 'Count non-empty values',
                            ISBLANK: 'Check if blank',
                            ISNUMBER: 'Check if number'
                        };

                        // Get function suggestions
                        const functions = Object.keys(FormulaEngine.functions)
                            .filter(fn => fn.startsWith(searchText))
                            .map(fn => ({
                                label: fn,
                                value: fn + '(',
                                description: functionDescriptions[fn] || 'Function'
                            }));

                        if (functions.length > 0) {
                            showAutocomplete(functions, searchText);
                        } else {
                            hideAutocomplete();
                        }
                    } else {
                        hideAutocomplete();
                    }
                }

                validateFormula();
            });

            input.addEventListener('keydown', (e) => {
                if (autocompleteState.isActive) {
                    const items = autocomplete.querySelectorAll('.autocomplete-item');
                    const selected = autocomplete.querySelector('.bg-purple-50');

                    if (e.key === 'ArrowDown') {
                        e.preventDefault();
                        if (selected && selected.nextElementSibling) {
                            selected.classList.remove('bg-purple-50');
                            selected.nextElementSibling.classList.add('bg-purple-50');
                        }
                    } else if (e.key === 'ArrowUp') {
                        e.preventDefault();
                        if (selected && selected.previousElementSibling) {
                            selected.classList.remove('bg-purple-50');
                            selected.previousElementSibling.classList.add('bg-purple-50');
                        }
                    } else if (e.key === 'Enter' || e.key === 'Tab') {
                        e.preventDefault();
                        if (selected) {
                            const searchText = input.value.substring(0, input.selectionStart).split('{').pop();
                            insertAutocomplete(selected.dataset.value, searchText);
                            hideAutocomplete();
                        }
                    } else if (e.key === 'Escape') {
                        hideAutocomplete();
                    }
                }
            });

            input.addEventListener('blur', () => {
                setTimeout(hideAutocomplete, 200);
            });

            validateFormula();
        }

        // Formula Engine
        const FormulaEngine = {
            functions: {
                // Math functions
                SUM: (...args) => args.reduce((sum, val) => sum + (Number(val) || 0), 0),
                AVG: (...args) => {
                    const nums = args.map(v => Number(v) || 0);
                    return nums.length ? nums.reduce((sum, val) => sum + val, 0) / nums.length : 0;
                },
                MIN: (...args) => Math.min(...args.map(v => Number(v) || 0)),
                MAX: (...args) => Math.max(...args.map(v => Number(v) || 0)),
                ROUND: (num, decimals = 0) => {
                    const n = Number(num) || 0;
                    const d = Number(decimals) || 0;
                    return Math.round(n * Math.pow(10, d)) / Math.pow(10, d);
                },
                ABS: (num) => Math.abs(Number(num) || 0),
                SQRT: (num) => Math.sqrt(Number(num) || 0),
                POWER: (base, exp) => Math.pow(Number(base) || 0, Number(exp) || 0),

                // Logical functions
                IF: (condition, trueVal, falseVal) => condition ? trueVal : falseVal,
                AND: (...args) => args.every(v => !!v),
                OR: (...args) => args.some(v => !!v),
                NOT: (val) => !val,

                // Text functions
                CONCAT: (...args) => args.map(v => String(v ?? '')).join(''),
                UPPER: (text) => String(text ?? '').toUpperCase(),
                LOWER: (text) => String(text ?? '').toLowerCase(),
                TRIM: (text) => String(text ?? '').trim(),
                LEN: (text) => String(text ?? '').length,
                LEFT: (text, count) => String(text ?? '').substring(0, Number(count) || 0),
                RIGHT: (text, count) => {
                    const str = String(text ?? '');
                    const n = Number(count) || 0;
                    return str.substring(Math.max(0, str.length - n));
                },

                // Counting functions
                COUNT: (...args) => args.filter(v => v != null).length,
                COUNTA: (...args) => args.filter(v => v !== null && v !== undefined && v !== '').length,

                // Value checks
                ISBLANK: (val) => val == null || val === '',
                ISNUMBER: (val) => typeof val === 'number' && !isNaN(val),
            },

            evaluate(formula, record, schema) {
                if (!formula) return '';

                try {
                    // Replace field references {FieldName} with their values
                    let processedFormula = formula;
                    const fieldRefs = formula.match(/\{([^}]+)\}/g);

                    if (fieldRefs) {
                        for (const ref of fieldRefs) {
                            const fieldName = ref.slice(1, -1); // Remove { and }
                            const field = schema.find(f => f.name === fieldName);
                            if (field) {
                                let value = record[field.id];
                                // Convert value to appropriate type for formula
                                if (value === undefined || value === null) value = '';
                                if (typeof value === 'string') {
                                    // If it's a number string, convert it for math operations
                                    const num = parseFloat(value);
                                    if (!isNaN(num) && value.trim() !== '') {
                                        value = num;
                                    } else {
                                        value = `"${value.replace(/"/g, '\\"')}"`;
                                    }
                                }
                                processedFormula = processedFormula.replace(ref, value);
                            } else {
                                processedFormula = processedFormula.replace(ref, '""');
                            }
                        }
                    }

                    // Replace concatenation operator & with JavaScript's +
                    // Must be done carefully to avoid replacing bitwise AND in conditions
                    processedFormula = processedFormula.replace(/&/g, '+');

                    // Replace function calls
                    for (const [funcName, funcImpl] of Object.entries(this.functions)) {
                        const regex = new RegExp(`\\b${funcName}\\s*\\(`, 'g');
                        processedFormula = processedFormula.replace(regex, `FormulaEngine.functions.${funcName}(`);
                    }

                    // Evaluate the formula
                    const result = eval(processedFormula);
                    return result;
                } catch (error) {
                    console.error('Formula evaluation error:', error, formula);
                    return '#ERROR';
                }
            },

            extractFieldReferences(formula) {
                if (!formula) return [];
                const matches = formula.match(/\{([^}]+)\}/g);
                if (!matches) return [];
                return matches.map(m => m.slice(1, -1));
            },

            validateFormula(formula, schema) {
                if (!formula) return { valid: false, error: 'Formula is empty' };

                try {
                    // Check for field references
                    const fieldRefs = this.extractFieldReferences(formula);
                    const invalidFields = [];

                    for (const fieldName of fieldRefs) {
                        const field = schema.find(f => f.name === fieldName);
                        if (!field) {
                            invalidFields.push(fieldName);
                        }
                    }

                    if (invalidFields.length > 0) {
                        return {
                            valid: false,
                            error: `Unknown fields: ${invalidFields.join(', ')}`,
                            dependencies: fieldRefs
                        };
                    }

                    return {
                        valid: true,
                        error: null,
                        dependencies: fieldRefs
                    };
                } catch (error) {
                    return {
                        valid: false,
                        error: error.message,
                        dependencies: []
                    };
                }
            },

            formatFormulaValue(value, format, decimals) {
                if (value === '#ERROR' || value === null || value === undefined) return value;

                decimals = decimals || 2;

                switch (format) {
                    case 'number':
                        if (typeof value === 'number') {
                            return value.toFixed(decimals);
                        }
                        return String(value);

                    case 'currency':
                        if (typeof value === 'number') {
                            return new Intl.NumberFormat('en-US', {
                                style: 'currency',
                                currency: 'USD',
                                minimumFractionDigits: decimals,
                                maximumFractionDigits: decimals
                            }).format(value);
                        }
                        return String(value);

                    case 'percentage':
                        if (typeof value === 'number') {
                            return (value * 100).toFixed(decimals) + '%';
                        }
                        return String(value);

                    case 'text':
                    default:
                        return String(value);
                }
            }
        };

        const ICON_OPTIONS = [
            // Organization & Layout
            { token: 'ph-squares-four', label: 'Grid', keywords: ['dashboard', 'board', 'overview', 'layout'] },
            { token: 'ph-table', label: 'Table', keywords: ['grid', 'sheet', 'records', 'spreadsheet'] },
            { token: 'ph-cards-three', label: 'Cards', keywords: ['gallery', 'kanban', 'tiles', 'card'] },
            { token: 'ph-kanban', label: 'Kanban', keywords: ['workflow', 'board', 'columns', 'agile'] },
            { token: 'ph-list', label: 'List', keywords: ['items', 'menu', 'rows'] },
            { token: 'ph-list-bullets', label: 'List Bullets', keywords: ['todo', 'tasks', 'rows', 'items'] },
            { token: 'ph-list-checks', label: 'List Checks', keywords: ['todo', 'tasks', 'checklist', 'complete'] },
            { token: 'ph-list-dashes', label: 'List Dashes', keywords: ['items', 'menu', 'rows'] },
            { token: 'ph-list-numbers', label: 'List Numbers', keywords: ['ordered', 'sequence', 'steps'] },
            { token: 'ph-rows', label: 'Rows', keywords: ['layout', 'horizontal', 'lines'] },
            { token: 'ph-columns', label: 'Columns', keywords: ['layout', 'vertical', 'split'] },
            { token: 'ph-sidebar', label: 'Sidebar', keywords: ['navigation', 'menu', 'panel'] },
            { token: 'ph-sidebar-simple', label: 'Sidebar Simple', keywords: ['navigation', 'menu', 'panel'] },
            { token: 'ph-layout', label: 'Layout', keywords: ['design', 'structure', 'template'] },
            { token: 'ph-app-window', label: 'App Window', keywords: ['browser', 'application', 'screen'] },

            // Files & Folders
            { token: 'ph-folder', label: 'Folder', keywords: ['directory', 'files', 'organize'] },
            { token: 'ph-folders', label: 'Folders', keywords: ['files', 'library', 'taxonomy', 'organize'] },
            { token: 'ph-folder-open', label: 'Folder Open', keywords: ['directory', 'files', 'browse'] },
            { token: 'ph-folder-plus', label: 'Folder Plus', keywords: ['create', 'new', 'add'] },
            { token: 'ph-file', label: 'File', keywords: ['document', 'page', 'content'] },
            { token: 'ph-file-text', label: 'File Text', keywords: ['document', 'page', 'text'] },
            { token: 'ph-file-plus', label: 'File Plus', keywords: ['create', 'new', 'add'] },
            { token: 'ph-files', label: 'Files', keywords: ['documents', 'pages', 'multiple'] },
            { token: 'ph-note', label: 'Note', keywords: ['memo', 'text', 'write'] },
            { token: 'ph-note-blank', label: 'Note Blank', keywords: ['new', 'empty', 'create'] },
            { token: 'ph-notebook', label: 'Notebook', keywords: ['notes', 'doc', 'wiki', 'journal'] },
            { token: 'ph-notepad', label: 'Notepad', keywords: ['notes', 'memo', 'write'] },
            { token: 'ph-article', label: 'Article', keywords: ['blog', 'post', 'content'] },
            { token: 'ph-newspaper', label: 'Newspaper', keywords: ['news', 'article', 'media'] },
            { token: 'ph-book', label: 'Book', keywords: ['library', 'reading', 'documentation'] },
            { token: 'ph-book-open', label: 'Book Open', keywords: ['reading', 'documentation', 'learn'] },
            { token: 'ph-books', label: 'Books', keywords: ['library', 'reading', 'education'] },

            // Documents & Text
            { token: 'ph-clipboard', label: 'Clipboard', keywords: ['copy', 'paste', 'temp'] },
            { token: 'ph-clipboard-text', label: 'Clipboard Text', keywords: ['notes', 'summary', 'doc', 'copy'] },
            { token: 'ph-article-medium', label: 'Article Medium', keywords: ['blog', 'post', 'medium'] },
            { token: 'ph-textbox', label: 'Textbox', keywords: ['input', 'field', 'form'] },
            { token: 'ph-text-aa', label: 'Text AA', keywords: ['font', 'typography', 'letters'] },
            { token: 'ph-text-t', label: 'Text T', keywords: ['font', 'type', 'letter'] },
            { token: 'ph-quotes', label: 'Quotes', keywords: ['citation', 'text', 'speech'] },
            { token: 'ph-signature', label: 'Signature', keywords: ['sign', 'approve', 'autograph'] },

            // Communication
            { token: 'ph-chat', label: 'Chat', keywords: ['message', 'conversation', 'talk'] },
            { token: 'ph-chat-circle', label: 'Chat Circle', keywords: ['message', 'bubble', 'talk'] },
            { token: 'ph-chat-dots', label: 'Chat Dots', keywords: ['message', 'typing', 'conversation'] },
            { token: 'ph-chats', label: 'Chats', keywords: ['messages', 'conversations', 'multiple'] },
            { token: 'ph-envelope', label: 'Envelope', keywords: ['email', 'mail', 'message'] },
            { token: 'ph-envelope-open', label: 'Envelope Open', keywords: ['email', 'read', 'mail'] },
            { token: 'ph-envelope-simple', label: 'Envelope Simple', keywords: ['email', 'mail', 'send'] },
            { token: 'ph-paper-plane-tilt', label: 'Paper Plane', keywords: ['send', 'message', 'mail'] },
            { token: 'ph-phone', label: 'Phone', keywords: ['contact', 'call', 'support', 'telephone'] },
            { token: 'ph-phone-call', label: 'Phone Call', keywords: ['calling', 'telephone', 'contact'] },
            { token: 'ph-megaphone', label: 'Megaphone', keywords: ['announcement', 'broadcast', 'marketing'] },
            { token: 'ph-speaker-high', label: 'Speaker High', keywords: ['volume', 'sound', 'audio'] },
            { token: 'ph-bell', label: 'Bell', keywords: ['alerts', 'reminders', 'updates', 'notifications'] },
            { token: 'ph-bell-ringing', label: 'Bell Ringing', keywords: ['alert', 'notification', 'alarm'] },

            // Users & People
            { token: 'ph-user', label: 'User', keywords: ['person', 'profile', 'account'] },
            { token: 'ph-user-circle', label: 'User Circle', keywords: ['profile', 'account', 'avatar'] },
            { token: 'ph-user-plus', label: 'User Plus', keywords: ['add', 'invite', 'new'] },
            { token: 'ph-users', label: 'Users', keywords: ['people', 'group', 'team'] },
            { token: 'ph-users-three', label: 'Users Three', keywords: ['people', 'collaboration', 'group', 'team'] },
            { token: 'ph-user-gear', label: 'User Gear', keywords: ['settings', 'profile', 'account'] },
            { token: 'ph-identification-card', label: 'ID Card', keywords: ['profile', 'identity', 'badge'] },
            { token: 'ph-address-book', label: 'Address Book', keywords: ['contacts', 'people', 'directory'] },

            // Time & Calendar
            { token: 'ph-calendar', label: 'Calendar', keywords: ['dates', 'schedule', 'events', 'day'] },
            { token: 'ph-calendar-blank', label: 'Calendar Blank', keywords: ['dates', 'schedule', 'events', 'empty'] },
            { token: 'ph-calendar-check', label: 'Calendar Check', keywords: ['event', 'confirmed', 'scheduled'] },
            { token: 'ph-calendar-plus', label: 'Calendar Plus', keywords: ['add', 'event', 'new'] },
            { token: 'ph-calendar-x', label: 'Calendar X', keywords: ['cancel', 'delete', 'remove'] },
            { token: 'ph-clock', label: 'Clock', keywords: ['time', 'schedule', 'hour'] },
            { token: 'ph-clock-countdown', label: 'Clock Countdown', keywords: ['timer', 'countdown', 'deadline'] },
            { token: 'ph-timer', label: 'Timer', keywords: ['stopwatch', 'time', 'clock'] },
            { token: 'ph-hourglass', label: 'Hourglass', keywords: ['time', 'waiting', 'pending'] },
            { token: 'ph-alarm', label: 'Alarm', keywords: ['clock', 'reminder', 'alert'] },

            // Actions & Controls
            { token: 'ph-plus', label: 'Plus', keywords: ['add', 'create', 'new'] },
            { token: 'ph-plus-circle', label: 'Plus Circle', keywords: ['add', 'create', 'new'] },
            { token: 'ph-minus', label: 'Minus', keywords: ['remove', 'subtract', 'delete'] },
            { token: 'ph-minus-circle', label: 'Minus Circle', keywords: ['remove', 'delete', 'subtract'] },
            { token: 'ph-x', label: 'X', keywords: ['close', 'cancel', 'delete'] },
            { token: 'ph-x-circle', label: 'X Circle', keywords: ['close', 'cancel', 'remove'] },
            { token: 'ph-check', label: 'Check', keywords: ['done', 'complete', 'confirm'] },
            { token: 'ph-check-circle', label: 'Check Circle', keywords: ['done', 'complete', 'success'] },
            { token: 'ph-trash', label: 'Trash', keywords: ['delete', 'remove', 'bin'] },
            { token: 'ph-pencil', label: 'Pencil', keywords: ['edit', 'write', 'modify'] },
            { token: 'ph-pencil-simple', label: 'Pencil Simple', keywords: ['edit', 'write', 'modify'] },
            { token: 'ph-pen', label: 'Pen', keywords: ['write', 'edit', 'signature'] },
            { token: 'ph-eraser', label: 'Eraser', keywords: ['delete', 'remove', 'clear'] },
            { token: 'ph-copy', label: 'Copy', keywords: ['duplicate', 'clone', 'paste'] },
            { token: 'ph-scissors', label: 'Scissors', keywords: ['cut', 'trim', 'clip'] },
            { token: 'ph-floppy-disk', label: 'Floppy Disk', keywords: ['save', 'store', 'disk'] },
            { token: 'ph-download', label: 'Download', keywords: ['save', 'export', 'get'] },
            { token: 'ph-upload', label: 'Upload', keywords: ['import', 'add', 'send'] },
            { token: 'ph-export', label: 'Export', keywords: ['download', 'save', 'output'] },
            { token: 'ph-share', label: 'Share', keywords: ['send', 'distribute', 'forward'] },
            { token: 'ph-share-network', label: 'Share Network', keywords: ['social', 'distribute', 'connect'] },

            // Navigation
            { token: 'ph-arrow-left', label: 'Arrow Left', keywords: ['back', 'previous', 'return'] },
            { token: 'ph-arrow-right', label: 'Arrow Right', keywords: ['forward', 'next', 'continue'] },
            { token: 'ph-arrow-up', label: 'Arrow Up', keywords: ['top', 'scroll', 'increase'] },
            { token: 'ph-arrow-down', label: 'Arrow Down', keywords: ['bottom', 'scroll', 'decrease'] },
            { token: 'ph-caret-left', label: 'Caret Left', keywords: ['previous', 'back', 'nav'] },
            { token: 'ph-caret-right', label: 'Caret Right', keywords: ['next', 'forward', 'nav'] },
            { token: 'ph-caret-up', label: 'Caret Up', keywords: ['expand', 'show', 'nav'] },
            { token: 'ph-caret-down', label: 'Caret Down', keywords: ['dropdown', 'expand', 'nav'] },
            { token: 'ph-house', label: 'House', keywords: ['home', 'main', 'start'] },
            { token: 'ph-house-line', label: 'House Line', keywords: ['overview', 'landing', 'summary', 'home'] },
            { token: 'ph-compass', label: 'Compass', keywords: ['navigation', 'explore', 'direction'] },
            { token: 'ph-map-pin', label: 'Map Pin', keywords: ['location', 'marker', 'place'] },
            { token: 'ph-map-trifold', label: 'Map Trifold', keywords: ['location', 'routes', 'navigation', 'geography'] },
            { token: 'ph-navigation-arrow', label: 'Navigation Arrow', keywords: ['direction', 'gps', 'location'] },

            // Search & View
            { token: 'ph-magnifying-glass', label: 'Search', keywords: ['find', 'search', 'look'] },
            { token: 'ph-magnifying-glass-plus', label: 'Zoom In', keywords: ['enlarge', 'magnify', 'expand'] },
            { token: 'ph-magnifying-glass-minus', label: 'Zoom Out', keywords: ['reduce', 'shrink', 'minimize'] },
            { token: 'ph-eye', label: 'Eye', keywords: ['view', 'see', 'preview'] },
            { token: 'ph-eye-closed', label: 'Eye Closed', keywords: ['hide', 'hidden', 'invisible'] },
            { token: 'ph-eye-slash', label: 'Eye Slash', keywords: ['hide', 'hidden', 'invisible'] },
            { token: 'ph-binoculars', label: 'Binoculars', keywords: ['search', 'find', 'explore'] },
            { token: 'ph-funnel', label: 'Funnel', keywords: ['filter', 'sort', 'refine'] },
            { token: 'ph-funnel-simple', label: 'Funnel Simple', keywords: ['filter', 'sort', 'refine'] },
            { token: 'ph-sliders', label: 'Sliders', keywords: ['settings', 'adjust', 'control'] },
            { token: 'ph-sliders-horizontal', label: 'Sliders Horizontal', keywords: ['settings', 'adjust', 'filter'] },
            { token: 'ph-adjustments', label: 'Adjustments', keywords: ['settings', 'controls', 'tune'] },

            // Business & Work
            { token: 'ph-briefcase', label: 'Briefcase', keywords: ['portfolio', 'business', 'clients', 'work'] },
            { token: 'ph-suitcase', label: 'Suitcase', keywords: ['travel', 'business', 'luggage'] },
            { token: 'ph-bank', label: 'Bank', keywords: ['finance', 'money', 'institution'] },
            { token: 'ph-buildings', label: 'Buildings', keywords: ['city', 'office', 'company'] },
            { token: 'ph-storefront', label: 'Storefront', keywords: ['shop', 'store', 'retail'] },
            { token: 'ph-shopping-bag', label: 'Shopping Bag', keywords: ['purchase', 'buy', 'retail'] },
            { token: 'ph-shopping-cart', label: 'Shopping Cart', keywords: ['sales', 'store', 'orders', 'ecommerce'] },
            { token: 'ph-shopping-cart-simple', label: 'Cart Simple', keywords: ['purchase', 'buy', 'shop'] },
            { token: 'ph-currency-dollar', label: 'Dollar', keywords: ['money', 'price', 'payment'] },
            { token: 'ph-money', label: 'Money', keywords: ['cash', 'payment', 'finance'] },
            { token: 'ph-credit-card', label: 'Credit Card', keywords: ['payment', 'transaction', 'purchase'] },
            { token: 'ph-coin', label: 'Coin', keywords: ['money', 'currency', 'payment'] },
            { token: 'ph-receipt', label: 'Receipt', keywords: ['invoice', 'payment', 'transaction'] },
            { token: 'ph-invoice', label: 'Invoice', keywords: ['bill', 'payment', 'receipt'] },
            { token: 'ph-wallet', label: 'Wallet', keywords: ['money', 'payment', 'finance'] },

            // Analytics & Data
            { token: 'ph-chart-line', label: 'Chart Line', keywords: ['metrics', 'reporting', 'dash', 'analytics', 'graph'] },
            { token: 'ph-chart-bar', label: 'Chart Bar', keywords: ['graph', 'statistics', 'data'] },
            { token: 'ph-chart-bar-horizontal', label: 'Chart Bar Horizontal', keywords: ['graph', 'statistics', 'data'] },
            { token: 'ph-chart-pie', label: 'Chart Pie', keywords: ['graph', 'statistics', 'distribution'] },
            { token: 'ph-chart-pie-slice', label: 'Chart Pie Slice', keywords: ['graph', 'statistics', 'portion'] },
            { token: 'ph-chart-line-up', label: 'Chart Line Up', keywords: ['growth', 'increase', 'trending'] },
            { token: 'ph-chart-line-down', label: 'Chart Line Down', keywords: ['decrease', 'decline', 'trending'] },
            { token: 'ph-trend-up', label: 'Trend Up', keywords: ['growth', 'increase', 'positive'] },
            { token: 'ph-trend-down', label: 'Trend Down', keywords: ['decrease', 'decline', 'negative'] },
            { token: 'ph-presentation', label: 'Presentation', keywords: ['slides', 'meeting', 'report'] },
            { token: 'ph-presentation-chart', label: 'Presentation Chart', keywords: ['slides', 'analytics', 'report'] },

            // Tech & Development
            { token: 'ph-code', label: 'Code', keywords: ['development', 'programming', 'developer'] },
            { token: 'ph-terminal', label: 'Terminal', keywords: ['console', 'command', 'cli'] },
            { token: 'ph-terminal-window', label: 'Terminal Window', keywords: ['console', 'command', 'shell'] },
            { token: 'ph-brackets-curly', label: 'Brackets Curly', keywords: ['code', 'json', 'programming'] },
            { token: 'ph-bug', label: 'Bug', keywords: ['error', 'issue', 'debug'] },
            { token: 'ph-cpu', label: 'CPU', keywords: ['processor', 'hardware', 'computing'] },
            { token: 'ph-hard-drive', label: 'Hard Drive', keywords: ['storage', 'disk', 'data'] },
            { token: 'ph-database', label: 'Database', keywords: ['storage', 'records', 'warehouse', 'data'] },
            { token: 'ph-server', label: 'Server', keywords: ['database', 'hosting', 'backend'] },
            { token: 'ph-cloud', label: 'Cloud', keywords: ['sync', 'storage', 'backup', 'online'] },
            { token: 'ph-cloud-arrow-up', label: 'Cloud Upload', keywords: ['sync', 'upload', 'backup'] },
            { token: 'ph-cloud-arrow-down', label: 'Cloud Download', keywords: ['sync', 'download', 'retrieve'] },
            { token: 'ph-git-branch', label: 'Git Branch', keywords: ['version', 'control', 'code'] },
            { token: 'ph-git-commit', label: 'Git Commit', keywords: ['version', 'control', 'save'] },
            { token: 'ph-git-merge', label: 'Git Merge', keywords: ['version', 'control', 'combine'] },
            { token: 'ph-github-logo', label: 'GitHub', keywords: ['code', 'repository', 'git'] },

            // Security
            { token: 'ph-lock', label: 'Lock', keywords: ['security', 'private', 'secure'] },
            { token: 'ph-lock-key', label: 'Lock Key', keywords: ['permissions', 'security', 'access', 'roles'] },
            { token: 'ph-lock-open', label: 'Lock Open', keywords: ['unlock', 'access', 'open'] },
            { token: 'ph-key', label: 'Key', keywords: ['password', 'access', 'security'] },
            { token: 'ph-shield', label: 'Shield', keywords: ['security', 'protection', 'safety'] },
            { token: 'ph-shield-check', label: 'Shield Check', keywords: ['security', 'verified', 'protected'] },
            { token: 'ph-fingerprint', label: 'Fingerprint', keywords: ['biometric', 'security', 'identity'] },
            { token: 'ph-password', label: 'Password', keywords: ['security', 'login', 'access'] },

            // Media & Design
            { token: 'ph-image', label: 'Image', keywords: ['photo', 'picture', 'media'] },
            { token: 'ph-images', label: 'Images', keywords: ['photos', 'gallery', 'media'] },
            { token: 'ph-camera', label: 'Camera', keywords: ['photo', 'picture', 'capture'] },
            { token: 'ph-video-camera', label: 'Video Camera', keywords: ['recording', 'film', 'media'] },
            { token: 'ph-play', label: 'Play', keywords: ['video', 'start', 'media'] },
            { token: 'ph-pause', label: 'Pause', keywords: ['stop', 'media', 'video'] },
            { token: 'ph-film-strip', label: 'Film Strip', keywords: ['video', 'movie', 'cinema'] },
            { token: 'ph-music-notes', label: 'Music Notes', keywords: ['audio', 'sound', 'song'] },
            { token: 'ph-palette', label: 'Palette', keywords: ['color', 'design', 'art'] },
            { token: 'ph-paint-brush', label: 'Paint Brush', keywords: ['design', 'art', 'draw'] },
            { token: 'ph-paint-roller', label: 'Paint Roller', keywords: ['design', 'theme', 'style'] },
            { token: 'ph-eyedropper', label: 'Eyedropper', keywords: ['color', 'picker', 'design'] },

            // Symbols & Shapes
            { token: 'ph-star', label: 'Star', keywords: ['favorite', 'rating', 'important'] },
            { token: 'ph-heart', label: 'Heart', keywords: ['like', 'favorite', 'love'] },
            { token: 'ph-flag', label: 'Flag', keywords: ['marker', 'important', 'report'] },
            { token: 'ph-bookmark', label: 'Bookmark', keywords: ['save', 'favorite', 'mark'] },
            { token: 'ph-bookmark-simple', label: 'Bookmark Simple', keywords: ['save', 'favorite', 'mark'] },
            { token: 'ph-tag', label: 'Tag', keywords: ['labels', 'categories', 'taxonomy', 'label'] },
            { token: 'ph-hash', label: 'Hash', keywords: ['hashtag', 'number', 'tag'] },
            { token: 'ph-at', label: 'At', keywords: ['mention', 'email', 'address'] },
            { token: 'ph-info', label: 'Info', keywords: ['information', 'help', 'about'] },
            { token: 'ph-question', label: 'Question', keywords: ['help', 'faq', 'support'] },
            { token: 'ph-warning', label: 'Warning', keywords: ['alert', 'caution', 'danger'] },
            { token: 'ph-warning-circle', label: 'Warning Circle', keywords: ['alert', 'caution', 'error'] },
            { token: 'ph-prohibit', label: 'Prohibit', keywords: ['blocked', 'forbidden', 'no'] },
            { token: 'ph-circle', label: 'Circle', keywords: ['shape', 'dot', 'round'] },
            { token: 'ph-square', label: 'Square', keywords: ['shape', 'box', 'rectangle'] },
            { token: 'ph-triangle', label: 'Triangle', keywords: ['shape', 'arrow', 'pointer'] },
            { token: 'ph-diamond', label: 'Diamond', keywords: ['shape', 'gem', 'special'] },

            // Actions & Ideas
            { token: 'ph-rocket', label: 'Rocket', keywords: ['project', 'ship', 'release', 'launch'] },
            { token: 'ph-rocket-launch', label: 'Rocket Launch', keywords: ['start', 'deploy', 'begin'] },
            { token: 'ph-lightbulb', label: 'Lightbulb', keywords: ['brainstorm', 'concepts', 'innovation', 'ideas'] },
            { token: 'ph-target', label: 'Target', keywords: ['goal', 'objective', 'aim'] },
            { token: 'ph-trophy', label: 'Trophy', keywords: ['achievement', 'success', 'award'] },
            { token: 'ph-medal', label: 'Medal', keywords: ['award', 'achievement', 'winner'] },
            { token: 'ph-gift', label: 'Gift', keywords: ['present', 'reward', 'bonus'] },
            { token: 'ph-crown', label: 'Crown', keywords: ['premium', 'vip', 'royal'] },
            { token: 'ph-magic-wand', label: 'Magic Wand', keywords: ['auto', 'ai', 'magic'] },
            { token: 'ph-sparkle', label: 'Sparkle', keywords: ['new', 'special', 'shine'] },
            { token: 'ph-lightning', label: 'Lightning', keywords: ['fast', 'quick', 'speed'] },
            { token: 'ph-fire', label: 'Fire', keywords: ['hot', 'trending', 'popular'] },

            // Connectivity & Links
            { token: 'ph-link', label: 'Link', keywords: ['url', 'connection', 'attach'] },
            { token: 'ph-link-simple', label: 'Link Simple', keywords: ['connection', 'attach', 'url', 'hyperlink'] },
            { token: 'ph-link-break', label: 'Link Break', keywords: ['unlink', 'disconnect', 'remove'] },
            { token: 'ph-paperclip', label: 'Paperclip', keywords: ['attach', 'file', 'attachment'] },
            { token: 'ph-anchor', label: 'Anchor', keywords: ['link', 'fixed', 'permanent'] },
            { token: 'ph-wireless', label: 'Wireless', keywords: ['wifi', 'connection', 'network'] },
            { token: 'ph-wifi-high', label: 'WiFi High', keywords: ['wireless', 'connection', 'network'] },
            { token: 'ph-globe', label: 'Globe', keywords: ['world', 'internet', 'global'] },
            { token: 'ph-globe-hemisphere-west', label: 'Globe West', keywords: ['world', 'map', 'earth'] },

            // Settings & Configuration
            { token: 'ph-gear', label: 'Gear', keywords: ['settings', 'configuration', 'options'] },
            { token: 'ph-gear-six', label: 'Gear Six', keywords: ['settings', 'config', 'preferences'] },
            { token: 'ph-wrench', label: 'Wrench', keywords: ['tools', 'fix', 'maintenance'] },
            { token: 'ph-nut', label: 'Nut', keywords: ['settings', 'configuration', 'hardware'] },
            { token: 'ph-faders', label: 'Faders', keywords: ['settings', 'adjust', 'mixer'] },
            { token: 'ph-toggle-left', label: 'Toggle Left', keywords: ['switch', 'off', 'disable'] },
            { token: 'ph-toggle-right', label: 'Toggle Right', keywords: ['switch', 'on', 'enable'] },

            // Miscellaneous
            { token: 'ph-smiley', label: 'Smiley', keywords: ['emoji', 'happy', 'face'] },
            { token: 'ph-package', label: 'Package', keywords: ['box', 'delivery', 'product'] },
            { token: 'ph-cube', label: 'Cube', keywords: ['3d', 'box', 'object'] },
            { token: 'ph-puzzle-piece', label: 'Puzzle Piece', keywords: ['plugin', 'extension', 'addon'] },
            { token: 'ph-tree', label: 'Tree', keywords: ['nature', 'hierarchy', 'branch'] },
            { token: 'ph-plant', label: 'Plant', keywords: ['nature', 'growing', 'organic'] }
        ];

        const ICONS_PER_PAGE = 60;

        function renderIcon(icon) {
            if (!icon) return '';
            const trimmed = icon.toString().trim();
            if (trimmed.startsWith('<')) return trimmed;
            if (trimmed.startsWith('ph ')) return `<i class="${trimmed}"></i>`;
            if (trimmed.startsWith('ph-')) return `<i class="ph ${trimmed}"></i>`;
            return trimmed;
        }

        function cloneConfig(config) {
            if (typeof structuredClone === 'function') return structuredClone(config || null);
            return JSON.parse(JSON.stringify(config || null));
        }

        function extractIconToken(icon) {
            if (!icon) return '';
            const trimmed = icon.toString().trim();
            const match = trimmed.match(/ph-[\w-]+/);
            if (match) return match[0];
            return trimmed;
        }

        function buildIconSearchText(option) {
            const keywords = (option.keywords || []).join(' ');
            return `${option.label} ${option.token} ${keywords}`.toLowerCase();
        }

        function fuzzyScore(query, text) {
            const normalizedQuery = (query || '').trim().toLowerCase();
            if (!normalizedQuery) return 1;
            const normalizedText = text.toLowerCase();
            const parts = normalizedQuery.split(/\s+/).filter(Boolean);

            let score = 0;
            parts.forEach(part => {
                if (normalizedText.includes(part)) {
                    score += 2;
                    return;
                }

                let lastIndex = -1;
                let subsequenceScore = 0;
                for (const char of part) {
                    const idx = normalizedText.indexOf(char, lastIndex + 1);
                    if (idx === -1) { subsequenceScore = 0; break; }
                    const distance = lastIndex === -1 ? 0 : idx - lastIndex - 1;
                    subsequenceScore += Math.max(0.1, 1 - distance * 0.08);
                    lastIndex = idx;
                }
                if (subsequenceScore > 0) {
                    const proximityBoost = Math.min(0.5, part.length / 12);
                    score += (subsequenceScore / part.length) + proximityBoost;
                }
            });

            return score / parts.length;
        }

        function findIconMeta(token) {
            const clean = extractIconToken(token);
            return ICON_OPTIONS.find(opt => opt.token === clean);
        }

        const ICON_SELECTOR_TARGETS = {
            newSetIcon: { selectorId: 'newSetIconSelector', previewId: 'newSetIconPreview', tokenId: 'newSetIconToken' },
            newViewIcon: { selectorId: 'newViewIconSelector', previewId: 'newViewIconPreview', tokenId: 'newViewIconToken' }
        };

        function syncIconSelector(inputId) {
            const config = ICON_SELECTOR_TARGETS[inputId];
            const input = document.getElementById(inputId);
            if (!config || !input) return;
            const token = extractIconToken(input.value || '');
            const meta = findIconMeta(token);
            const preview = document.getElementById(config.previewId);
            if (preview) preview.innerHTML = renderIcon(token || 'ph-squares-four');
            const tokenLabel = document.getElementById(config.tokenId);
            if (tokenLabel) tokenLabel.textContent = meta ? `${meta.label}  ${meta.token}` : (token || 'Select an icon');
        }

        function bindIconSelector(inputId) {
            const config = ICON_SELECTOR_TARGETS[inputId];
            if (!config) return;
            const selector = document.getElementById(config.selectorId);
            if (selector) {
                const trigger = () => openIconPicker(inputId);
                selector.onclick = trigger;
                selector.onkeydown = (event) => {
                    if (event.key === 'Enter' || event.key === ' ' || event.key === 'Spacebar') {
                        event.preventDefault();
                        trigger();
                    }
                };
            }
            const input = document.getElementById(inputId);
            if (input) input.addEventListener('change', () => syncIconSelector(inputId));
            syncIconSelector(inputId);
        }

        function openIconPicker(targetInputId) {
            state.iconPickerTarget = targetInputId;
            state.iconPickerQuery = '';
            state.iconPickerPage = 1;
            const searchInput = document.getElementById('iconPickerSearch');
            if (searchInput) {
                searchInput.value = '';
                setTimeout(() => searchInput.focus(), 50);
            }
            renderIconPickerOptions();
            openModal('iconPickerModal');
        }

        function renderIconPickerOptions() {
            const container = document.getElementById('iconPickerOptions');
            const pagination = document.getElementById('iconPickerPagination');
            if (!container) return;
            const search = (state.iconPickerQuery || '').toLowerCase();
            const currentValue = state.iconPickerTarget ? extractIconToken(document.getElementById(state.iconPickerTarget)?.value || '') : '';

            container.innerHTML = '';
            if (pagination) pagination.innerHTML = '';

            const scored = ICON_OPTIONS
                .map(opt => ({ ...opt, score: fuzzyScore(search, buildIconSearchText(opt)) }))
                .filter(entry => entry.score > 0)
                .sort((a, b) => b.score - a.score);

            if (scored.length === 0) {
                container.innerHTML = '<p class="text-sm text-gray-500">No icons match your search. Try a related term like table or board.</p>';
                return;
            }

            const totalPages = Math.max(1, Math.ceil(scored.length / ICONS_PER_PAGE));
            state.iconPickerPage = Math.min(Math.max(state.iconPickerPage, 1), totalPages);
            const startIndex = (state.iconPickerPage - 1) * ICONS_PER_PAGE;
            const pagedIcons = scored.slice(startIndex, startIndex + ICONS_PER_PAGE);

            if (pagination) {
                pagination.innerHTML = `
                    <span class="icon-pagination-count">${scored.length} icons</span>
                    <div class="icon-pagination-buttons">
                        <button type="button" class="icon-page-btn" data-direction="prev" ${state.iconPickerPage === 1 ? 'disabled' : ''}>Prev</button>
                        <span class="text-sm text-gray-600">Page ${state.iconPickerPage} / ${totalPages}</span>
                        <button type="button" class="icon-page-btn" data-direction="next" ${state.iconPickerPage === totalPages ? 'disabled' : ''}>Next</button>
                    </div>
                `;

                pagination.querySelectorAll('.icon-page-btn').forEach(btn => {
                    btn.onclick = () => {
                        const direction = btn.getAttribute('data-direction');
                        if (direction === 'prev' && state.iconPickerPage > 1) {
                            state.iconPickerPage -= 1;
                        } else if (direction === 'next' && state.iconPickerPage < totalPages) {
                            state.iconPickerPage += 1;
                        }
                        renderIconPickerOptions();
                    };
                });
            }

            pagedIcons.forEach(opt => {
                const btn = document.createElement('button');
                btn.type = 'button';
                btn.className = `icon-option${opt.token === currentValue ? ' active' : ''}`;
                btn.setAttribute('aria-label', opt.label);
                btn.innerHTML = `
                    <span class="icon-chip">${renderIcon(opt.token)}</span>
                    <span class="sr-only">${opt.label}</span>
                `;
                btn.onclick = () => selectIconFromPicker(opt.token);
                container.appendChild(btn);
            });
        }

        function selectIconFromPicker(token) {
            if (state.iconPickerTarget) {
                const input = document.getElementById(state.iconPickerTarget);
                if (input) {
                    input.value = token;
                    input.dispatchEvent(new Event('change'));
                }
            }
            closeModal('iconPickerModal');
        }

        const EO_OPERATOR_SET = {
            INS: { id: 'INS', name: 'Instantiate', description: 'Create a new object that did not exist before.' },
            DES: { id: 'DES', name: 'Designate', description: 'Assign a name, ID, label, alias, or classification.' },
            SEG: { id: 'SEG', name: 'Segment', description: 'Change boundaries, structure, or partition membership.' },
            CON: { id: 'CON', name: 'Connect', description: 'Create or remove a connection between objects.' },
            ALT: { id: 'ALT', name: 'Alternate', description: 'Toggle or switch between mutually exclusive states.' },
            SYN: { id: 'SYN', name: 'Synthesize', description: 'Combine two or more objects into a new unified whole.' },
            SUP: { id: 'SUP', name: 'Superposition', description: 'Hold contradictory states as simultaneously true without resolving them.' },
            REC: { id: 'REC', name: 'Recurse', description: 'Introduce a new layer of logic, rules, or self-reference.' },
            NUL: { id: 'NUL', name: 'Nullify', description: 'Declare absence, deletion, or erasure.' }
        };

        function getModesForOperator(operator) {
            return state.connectionModes?.[operator] || [];
        }

        function getAllVerbs() {
            // Returns all verbs across all operators with their operator mappings
            const allVerbs = [];
            const operatorCodes = Object.keys(state.connectionModes || {}).filter(k => k !== 'operators' && k !== 'meta');
            operatorCodes.forEach(op => {
                const verbs = state.connectionModes[op] || [];
                verbs.forEach(verb => {
                    allVerbs.push({ verb, operator: op });
                });
            });
            return allVerbs;
        }

        function getOperatorForVerb(verb) {
            // Find which operator a verb belongs to
            const operatorCodes = Object.keys(state.connectionModes || {}).filter(k => k !== 'operators' && k !== 'meta');
            for (const op of operatorCodes) {
                const verbs = state.connectionModes[op] || [];
                if (verbs.includes(verb)) {
                    return op;
                }
            }
            return null;
        }

        // Connection type usage tracking
        function getConnectionTypeKey(operator, verb) {
            return `${operator}::${verb}`;
        }

        function trackConnectionTypeUsage(operator, verb) {
            if (!operator || !verb) return;
            const key = getConnectionTypeKey(operator, verb);
            const current = state.connectionTypeUsage.get(key) || { count: 0, lastUsed: null };
            state.connectionTypeUsage.set(key, {
                count: current.count + 1,
                lastUsed: Date.now(),
                operator,
                verb
            });
            // Persist to localStorage
            try {
                const usageData = {};
                state.connectionTypeUsage.forEach((val, k) => { usageData[k] = val; });
                localStorage.setItem('eo_connection_type_usage', JSON.stringify(usageData));
            } catch (e) { /* ignore storage errors */ }
        }

        function loadConnectionTypeUsage() {
            try {
                const stored = localStorage.getItem('eo_connection_type_usage');
                if (stored) {
                    const usageData = JSON.parse(stored);
                    Object.entries(usageData).forEach(([key, val]) => {
                        state.connectionTypeUsage.set(key, val);
                    });
                }
            } catch (e) { /* ignore storage errors */ }
        }

        function getConnectionTypeUsageCount(operator, verb) {
            const key = getConnectionTypeKey(operator, verb);
            return state.connectionTypeUsage.get(key)?.count || 0;
        }

        // Get connection types sorted by priority: CON first, then by usage
        function getSortedConnectionTypes() {
            const operators = state.connectionModes?.operators || {};
            const operatorCodes = Object.keys(state.connectionModes || {}).filter(k => k !== 'operators' && k !== 'meta');

            // Define base priority - CON is most likely, then common relationship operators
            const operatorPriority = {
                'CON': 0,  // Connect - most common
                'SEG': 1,  // Segment - part-of relationships
                'INS': 2,  // Instantiate - creates/produces
                'DES': 3,  // Designate - labels/names
                'ALT': 4,  // Alternate - either/or
                'SYN': 5,  // Synthesize - combines
                'SUP': 6,  // Superpose - overlays
                'REC': 7,  // Recurse - references self
                'NUL': 8   // Null - absence
            };

            // Collect all verb+operator combinations
            const allTypes = [];
            operatorCodes.forEach(op => {
                const verbs = state.connectionModes[op] || [];
                const opInfo = operators[op] || {};
                verbs.forEach(verb => {
                    const usageCount = getConnectionTypeUsageCount(op, verb);
                    allTypes.push({
                        operator: op,
                        verb,
                        operatorName: opInfo.name || op,
                        operatorSymbol: opInfo.symbol || '',
                        operatorColor: opInfo.style?.color || '#6B7280',
                        usageCount,
                        basePriority: operatorPriority[op] ?? 99
                    });
                });
            });

            // Sort: first by usage count (desc), then by base priority (asc), then alphabetically
            allTypes.sort((a, b) => {
                // Items with usage always come first
                if (a.usageCount > 0 && b.usageCount === 0) return -1;
                if (b.usageCount > 0 && a.usageCount === 0) return 1;

                // Among used items, sort by usage count
                if (a.usageCount !== b.usageCount) return b.usageCount - a.usageCount;

                // Among unused items, sort by base priority
                if (a.basePriority !== b.basePriority) return a.basePriority - b.basePriority;

                // Finally, alphabetically by verb
                return a.verb.localeCompare(b.verb);
            });

            return allTypes;
        }

        // Get quick pick connection types (most useful defaults + most used)
        function getQuickPickConnectionTypes(limit = 6) {
            const sorted = getSortedConnectionTypes();
            const quickPicks = [];
            const seen = new Set();

            // Always include these default quick picks if they exist (CON verbs first - most common)
            const defaultQuickPicks = [
                { operator: 'CON', verb: 'depends on' },
                { operator: 'CON', verb: 'relates to' },
                { operator: 'CON', verb: 'references' },
                { operator: 'CON', verb: 'is linked to' },
                { operator: 'SEG', verb: 'includes' },
                { operator: 'INS', verb: 'creates' }
            ];

            // First, add any frequently used types (used 2+ times)
            sorted.filter(t => t.usageCount >= 2).slice(0, limit).forEach(type => {
                const key = `${type.operator}::${type.verb}`;
                if (!seen.has(key)) {
                    seen.add(key);
                    quickPicks.push(type);
                }
            });

            // Fill remaining slots with defaults
            for (const def of defaultQuickPicks) {
                if (quickPicks.length >= limit) break;
                const key = `${def.operator}::${def.verb}`;
                if (!seen.has(key)) {
                    const typeInfo = sorted.find(t => t.operator === def.operator && t.verb === def.verb);
                    if (typeInfo) {
                        seen.add(key);
                        quickPicks.push(typeInfo);
                    }
                }
            }

            return quickPicks;
        }

        function normalizeParamList(params = []) {
            if (params === undefined || params === null) return [];
            if (!Array.isArray(params)) throw new Error('Parameter lists must be arrays');

            return Array.from(
                new Set(
                    params
                        .map(param => typeof param === 'string' ? param.trim() : String(param || '').trim())
                        .filter(Boolean)
                )
            );
        }

        function validateConnectionRelationPayload(relation) {
            const operator = relation?.operator;
            const mode = relation?.mode;

            // Validate operator exists
            if (!operator || typeof operator !== 'string') {
                throw new Error('Operator is required');
            }

            // Validate mode exists
            if (!mode || typeof mode !== 'string') {
                throw new Error('Mode is required');
            }

            // Check if connection modes are loaded - if not, allow any valid operator/mode combination
            const connectionModesLoaded = Object.keys(state.connectionModes || {}).some(k => k !== 'operators' && k !== 'meta');

            if (connectionModesLoaded) {
                const modes = getModesForOperator(operator);
                // Only validate against known modes if the operator has defined modes
                if (modes.length && !modes.includes(mode)) {
                    console.warn(`Mode "${mode}" not in predefined modes for operator "${operator}". Allowing custom mode.`);
                }
            }

            const requiredParams = normalizeParamList(relation.requiredParams || []);
            const optionalParams = normalizeParamList(relation.optionalParams || []);
            const worldId = relation.worldId || state.currentWorldId;

            // Process parameterSchema - the new typed parameter definitions
            // Schema format: { paramName: { type, label, required, default, options, min, max, description } }
            const parameterSchema = relation.parameterSchema || {};

            // Auto-generate schema from requiredParams/optionalParams if not provided
            const mergedSchema = { ...parameterSchema };
            requiredParams.forEach(name => {
                if (!mergedSchema[name]) {
                    mergedSchema[name] = { type: 'text', label: name, required: true };
                } else {
                    mergedSchema[name].required = true;
                }
            });
            optionalParams.forEach(name => {
                if (!mergedSchema[name]) {
                    mergedSchema[name] = { type: 'text', label: name, required: false };
                }
            });

            return {
                ...relation,
                id: relation.id || `REL_${relation.operator}_${Date.now()}_${Math.random().toString(36).slice(2, 6)}`,
                operator: relation.operator,
                mode: relation.mode,
                name: relation.name || '',
                description: relation.description || '',
                requiredParams,
                optionalParams,
                parameterSchema: mergedSchema,
                createdAt: relation.createdAt || new Date().toISOString(),
                worldId
            };
        }

        function addConnectionRelation(relation) {
            let payload;
            try {
                payload = validateConnectionRelationPayload(relation);
            } catch (error) {
                showToast(` ${error.message || 'Unable to create connection relation'}`);
                return null;
            }

            state.connectionRelations.set(payload.id, payload);
            return payload.id;
        }

        function updateConnectionRelation(relationId, updates = {}) {
            // All relation types are immutable EO operators
            throw new Error('Relation types are immutable and cannot be modified');
        }

        function deleteConnectionRelation(relationId) {
            // All relation types are immutable EO operators
            throw new Error('Relation types are immutable and cannot be deleted');
        }

        function getConnectionRelationView(filterFn) {
            const relations = Array.from(state.connectionRelations.values()).filter(rel => !rel.worldId || rel.worldId === state.currentWorldId);
            return typeof filterFn === 'function' ? relations.filter(filterFn) : relations;
        }

        function findConnectionRelation(relationId) {
            return state.connectionRelations.get(relationId) || null;
        }

        function getDefaultConnectionRelationId(preferredOperator = null) {
            const relations = getConnectionRelationView(rel => !preferredOperator || rel.operator === preferredOperator);
            return relations.length ? relations[0].id : null;
        }

        function suggestFormatsForView(view) {
            const suggestions = [];

            if (view?.filters?.length) {
                suggestions.push('SEG');
            }

            if (view?.aggregationRules?.length) {
                suggestions.push('SYN');
            }

            if (view?.pivotField) {
                suggestions.push('SUP');
            }

            return suggestions;
        }

        // DEFINITIONS & CONNECTIONS
        function deriveWorldIdForEntity(entity) {
            if (!entity) return state.currentWorldId;
            if (entity.type === 'Record') {
                const ref = getRecordById(entity.id);
                if (ref?.set?.worldId) return ref.set.worldId;
            }
            if (entity.type === 'Set') {
                const set = state.sets.get(entity.id);
                if (set?.worldId) return set.worldId;
            }
            if (entity.type === 'Connection') {
                const existing = state.connections.get(entity.id);
                if (existing?.worldId) return existing.worldId;
            }
            return state.currentWorldId;
        }

        function findDefinitionByEntity(entity, worldId = state.currentWorldId) {
            if (!entity) return null;
            return Array.from(state.definitions.values()).find(def =>
                def.entity?.type === entity.type &&
                def.entity?.id === entity.id &&
                (!worldId || !def.worldId || def.worldId === worldId)
            ) || null;
        }

        function renderEntityLabel(entity) {
            if (!entity) return '';
            const def = findDefinitionByEntity(entity);
            if (def?.term) return def.term;

            if (entity.type === 'Record') {
                const displayName = getRecordDisplayName(entity.id);
                if (displayName) return displayName;
                // Fall back to set name if available
                const ref = getRecordById(entity.id);
                if (ref?.set?.name) return ref.set.name;
                return 'Record';
            }
            if (entity.type === 'Set') {
                return state.sets.get(entity.id)?.name || 'Set';
            }
            if (entity.type === 'Connection') {
                const conn = state.connections.get(entity.id);
                if (conn) return `${renderEntityLabel(conn.subject)} ${conn.mode || ''} ${renderEntityLabel(conn.operand)}`;
            }
            return entity.type || 'Entity';
        }

        function addDefinition(def) {
            if (!def?.entity || !def?.entity?.type || !def?.entity?.id) {
                throw new Error('Definitions require an entity with type and id');
            }
            if (!def.term || !def.definition) {
                throw new Error('Definitions require both term and definition text');
            }

            const id = def.id || `def_${Date.now()}_${Math.random().toString(36).substr(2, 6)}`;
            const worldId = def.worldId || deriveWorldIdForEntity(def.entity);
            const payload = {
                ...def,
                id,
                worldId,
                tags: def.tags || [],
                createdAt: def.createdAt || new Date().toISOString()
            };

            state.definitions.set(id, payload);

            // Register definition as an entity for tracking
            registerEntity({
                id: payload.id,
                type: 'Definition',
                entityType: 'Definition',
                name: payload.term,
                worldId: payload.worldId,
                createdAt: payload.createdAt,
                origin: 'manual'
            });

            return payload;
        }

        function updateDefinition(id, updates = {}) {
            const existing = state.definitions.get(id);
            if (!existing) throw new Error(`Definition ${id} not found`);

            const next = {
                ...existing,
                ...updates,
                id,
                updatedAt: new Date().toISOString()
            };

            state.definitions.set(id, next);
            return next;
        }

        function deleteDefinition(id) {
            const existing = state.definitions.get(id);
            if (!existing) throw new Error(`Definition ${id} not found`);
            state.definitions.delete(id);
            return existing;
        }

        function getDefinitionView(filterFn) {
            const defs = Array.from(state.definitions.values()).filter(def => !def.worldId || def.worldId === state.currentWorldId);
            return typeof filterFn === 'function' ? defs.filter(filterFn) : defs;
        }

        function getConnectionView(filterFn) {
            const conns = Array.from(state.connections.values()).filter(conn => !conn.worldId || conn.worldId === state.currentWorldId);
            return typeof filterFn === 'function' ? conns.filter(filterFn) : conns;
        }

        function seedWorldDefaults(worldId = state.currentWorldId) {
            const locationsId = createSet('Locations', 'ph-map-pin', worldId);
            const locationsSet = state.sets.get(locationsId);
            if (locationsSet) {
                locationsSet.schema = [
                    { id: 'name', name: 'Location', type: 'TEXT', width: '220px' },
                    { id: 'area', name: 'Area', type: 'TEXT', width: '180px' },
                    { id: 'notes', name: 'Notes', type: 'LONG_TEXT', width: '260px' }
                ];
            }

            const observationsId = createSet('Observations', 'ph-binoculars', worldId);
            const observationsSet = state.sets.get(observationsId);
            if (observationsSet) {
                observationsSet.schema = [
                    { id: 'date', name: 'Date', type: 'DATE', width: '140px' },
                    { id: 'observer', name: 'Observer', type: 'TEXT', width: '180px' },
                    { id: 'observation', name: 'Observation', type: 'LONG_TEXT', width: '260px' }
                ];
            }

            if (locationsSet) {
                createView(locationsId, 'Locations', { type: 'grid', sorts: [{ fieldId: 'name', direction: 'asc' }] });
            }
            if (observationsSet) {
                createView(observationsId, 'Observations', { type: 'grid', sorts: [{ fieldId: 'date', direction: 'desc' }] });
            }

            return { locationsId, observationsId };
        }

        // INITIALIZATION
        async function initializeApp() {
            state.operatorSet = EO_OPERATOR_SET;

            // Initialize lean context system
            if (typeof EOLeanContext !== 'undefined') {
                state.leanContext = new EOLeanContext();
                console.log(' Lean Context System initialized');
            }

            // Initialize Import Manager and Integration
            if (typeof EOImportManager !== 'undefined') {
                state.importManager = new EOImportManager();
                console.log(' Import Manager initialized');

                if (typeof EOImportIntegration !== 'undefined') {
                    state.importIntegration = new EOImportIntegration({
                        importManager: state.importManager,
                        state: state,
                        onSetCreated: (setId) => {
                            state.expandedSets.add(setId);
                            renderSidebar();
                        },
                        onRecordsAdded: (setId, records) => {
                            // Only render if records were added to the currently viewed set
                            // switchSet will handle the render when switching to a new set
                            if (setId === state.currentSetId) {
                                renderCurrentView();
                            }
                        },
                        showToast: showToast,
                        createEvent: createEvent,
                        switchSet: switchSet
                    });
                    console.log(' Import Integration initialized');
                }

                // Listen for import changes to update sidebar
                state.importManager.addListener((event, data) => {
                    renderImportsInSidebar();
                });
            }

            // Initialize Layout System for flexible tab layouts
            if (typeof EOLayout !== 'undefined') {
                initializeLayoutSystem();
                console.log(' Layout System initialized');
            }

            initializeOperatorRules();
            await loadConnectionModes();
            loadConnectionTypeUsage(); // Load usage stats from localStorage
            await loadRelationshipTypes();
            createSampleData();
            applyRouteParams();
            renderWorldSelector();
            renderSidebar();
            initializeNavSections();
            initializeImportDropZone();

            // Navigate to first available view (data-first approach)
            // Users start IN their data, not looking at an abstract dashboard
            const firstView = findFirstAvailableView();
            if (firstView) {
                // Expand the set in sidebar so user sees context
                state.expandedSets.add(firstView.setId);
                switchSet(firstView.setId, firstView.viewId);
            } else {
                // No data yet - show import-focused dashboard
                navigateTo('dashboard');
            }

            setupEventListeners();
            setupKeyboardShortcuts();
            applyResponsiveLayout();
            GlobalSearch.init();
            window.addEventListener('resize', applyResponsiveLayout);
            // syncUrlState(); // Commented out to prevent URL manipulation
        }

        function findFirstAvailableView() {
            // Find the first set with views in the current world
            const setsForWorld = getSetsForWorld();
            for (const set of setsForWorld) {
                if (set.views && set.views.size > 0) {
                    const firstViewId = Array.from(set.views.keys())[0];
                    return { setId: set.id, viewId: firstViewId };
                }
            }
            return null;
        }

        function normalizeOperatorModeDictionary(data) {
            if (!data || typeof data !== 'object' || Array.isArray(data)) return {};

            const normalized = { operators: {} };

            // Handle new nested structure with operators.CON.verbs
            if (data.operators) {
                Object.entries(data.operators).forEach(([op, opData]) => {
                    // Store full operator data for display
                    normalized.operators[op] = opData;

                    // Extract verbs/modes for backward compatibility
                    const verbs = opData.verbs || [];
                    const cleaned = verbs.map(mode => typeof mode === 'string' ? mode.trim() : '').filter(Boolean);
                    if (cleaned.length) normalized[op] = cleaned;
                });
            } else {
                // Legacy flat format: { "CON": ["mode1", "mode2", ...] }
                Object.entries(data).forEach(([op, modes]) => {
                    if (!Array.isArray(modes)) return;
                    const cleaned = modes.map(mode => typeof mode === 'string' ? mode.trim() : '').filter(Boolean);
                    if (cleaned.length) normalized[op] = cleaned;
                });
            }

            // Merge legacyVerbs as fallback for any operators without verbs
            if (data.legacyVerbs && typeof data.legacyVerbs === 'object') {
                Object.entries(data.legacyVerbs).forEach(([op, verbs]) => {
                    if (!normalized[op] && Array.isArray(verbs)) {
                        const cleaned = verbs.map(mode => typeof mode === 'string' ? mode.trim() : '').filter(Boolean);
                        if (cleaned.length) normalized[op] = cleaned;
                    }
                });
            }

            return normalized;
        }

        async function loadConnectionModes() {
            try {
                const response = await fetch('data/connection_modes.json');
                if (!response.ok) throw new Error('Unable to load operator dictionary');

                const rawModes = await response.json();
                state.connectionModes = normalizeOperatorModeDictionary(rawModes);
            } catch (error) {
                console.warn('Unable to load connection modes', error);
                state.connectionModes = {};
            }
        }

        async function loadRelationshipTypes() {
            try {
                const response = await fetch('data/relationship_types.json');
                if (!response.ok) throw new Error('Unable to load relationship types');

                const data = await response.json();
                state.relationshipTypes = data.relationships || [];
                state.relationshipDomains = data.domains || {};
                console.log(` Loaded ${state.relationshipTypes.length} relationship types`);
            } catch (error) {
                console.warn('Unable to load relationship types', error);
                state.relationshipTypes = [];
                state.relationshipDomains = {};
            }
        }

        function searchRelationshipTypes(query) {
            if (!query || query.length < 1) return state.relationshipTypes.slice(0, 20);
            const lowerQuery = query.toLowerCase();
            return state.relationshipTypes.filter(rel =>
                rel.name.toLowerCase().includes(lowerQuery) ||
                rel.operator.toLowerCase().includes(lowerQuery) ||
                rel.domain.toLowerCase().includes(lowerQuery)
            ).slice(0, 30);
        }

        function searchEntities(query) {
            const entities = getEntityView();
            if (!query || query.length < 1) return entities.slice(0, 20);
            const lowerQuery = query.toLowerCase();
            return entities.filter(entity => {
                const name = getEntityDisplayName(entity).toLowerCase();
                const type = (entity.entityType || entity.type || '').toLowerCase();
                const id = (entity.id || '').toLowerCase();
                return name.includes(lowerQuery) || type.includes(lowerQuery) || id.includes(lowerQuery);
            }).slice(0, 30);
        }

        function getEntityDisplayName(entity) {
            if (!entity) return 'Unknown';

            // For records, use the comprehensive display name function
            if (entity.type === 'Record' && entity.id) {
                const displayName = getRecordDisplayName(entity.id);
                if (displayName) return displayName;
            }

            // Try various name fields for other entity types
            if (entity.viewRef?.viewName) return entity.viewRef.viewName;
            if (entity.entityType && entity.entityType !== entity.type) return entity.entityType;
            if (entity.name) return entity.name;

            return entity.id || 'Unknown';
        }

        function getOperatorInfo(operatorCode) {
            const operators = state.connectionModes?.operators || {};
            return operators[operatorCode] || { name: operatorCode, symbol: operatorCode };
        }

        function readRouteParams() {
            const params = new URLSearchParams(window.location.search);
            return {
                worldId: params.get('world'),
                setId: params.get('set'),
                viewId: params.get('view'),
                special: params.get('special')
            };
        }

        function applyRouteParams() {
            const route = readRouteParams();
            if (route.worldId && state.worlds.has(route.worldId)) {
                state.currentWorldId = route.worldId;
            }

            if (route.special) {
                state.currentSpecialView = route.special;
                state.currentSetId = null;
                state.currentViewId = null;
                return;
            }

            if (route.setId && state.sets.has(route.setId)) {
                state.currentSetId = route.setId;
                const set = state.sets.get(route.setId);
                if (route.viewId && set.views.has(route.viewId)) {
                    state.currentViewId = route.viewId;
                } else if (set.views.size > 0) {
                    state.currentViewId = Array.from(set.views.keys())[0];
                }
            }
        }

        function syncUrlState() {
            const params = new URLSearchParams();
            if (state.currentWorldId) params.set('world', state.currentWorldId);

            if (state.currentSpecialView) {
                params.set('special', state.currentSpecialView);
            } else {
                if (state.currentSetId) params.set('set', state.currentSetId);
                if (state.currentViewId) params.set('view', state.currentViewId);
            }

            const query = params.toString();
            const nextUrl = query ? `${window.location.pathname}?${query}` : window.location.pathname;
            window.history.replaceState({}, '', nextUrl);
        }

        function applyResponsiveLayout() {
            const appContainer = document.getElementById('appContainer');
            const isMobile = window.matchMedia('(max-width: 1024px)').matches;
            const bottomBar = document.getElementById('mobileBottomBar');
            const fab = document.getElementById('mobileFab');
            const topbar = document.getElementById('mobileTopbar');

            if (isMobile) {
                appContainer.classList.add('mobile-layout');
                appContainer.classList.toggle('sidebar-open-mobile', state.sidebarOpenMobile);
                appContainer.classList.remove('sidebar-collapsed');
                bottomBar?.classList.remove('hidden');
                fab?.classList.remove('hidden');
                topbar?.classList.remove('hidden');
            } else {
                appContainer.classList.remove('mobile-layout');
                appContainer.classList.remove('sidebar-open-mobile');
                appContainer.classList.toggle('sidebar-collapsed', state.sidebarCollapsed);
                bottomBar?.classList.add('hidden');
                fab?.classList.add('hidden');
                topbar?.classList.add('hidden');
            }

            updateMobileChrome();
        }

        function updateMobileChrome() {
            const titleEl = document.getElementById('mobileTopbarTitle');
            const set = getCurrentSet();
            const view = getCurrentView();
            const special = state.currentSpecialView === 'definitions'
                ? 'Definitions'
                : state.currentSpecialView === 'relations'
                    ? 'Relations'
                    : state.currentSpecialView === 'entities'
                        ? 'Entities'
                        : null;

            if (titleEl) titleEl.textContent = special || set?.name || 'EO';

            document.querySelectorAll('.mobile-bottom-action').forEach(btn => {
                const type = btn.dataset.mobileNav;
                if (!type) return;
                btn.classList.toggle('active', !special && view?.type === type);
            });
        }

        let toolbarMenuCleanup = null;
        function setupToolbarMenu() {
            if (typeof toolbarMenuCleanup === 'function') {
                toolbarMenuCleanup();
                toolbarMenuCleanup = null;
            }

            const menu = document.querySelector('.toolbar-menu');
            const toggle = document.getElementById('toolbarMenuToggle');
            const panel = document.getElementById('toolbarMenuPanel');
            if (!menu || !toggle || !panel) return;

            const closeMenu = () => menu.classList.remove('open');

            const toggleHandler = (event) => {
                event.stopPropagation();
                menu.classList.toggle('open');
            };

            const panelHandler = (event) => {
                event.stopPropagation();
                if (event.target.closest('button')) closeMenu();
            };

            const clickHandler = (event) => {
                if (!menu.contains(event.target)) closeMenu();
            };

            const keydownHandler = (event) => {
                if (event.key === 'Escape') closeMenu();
            };

            toggle.addEventListener('click', toggleHandler);
            panel.addEventListener('click', panelHandler);
            document.addEventListener('click', clickHandler);
            document.addEventListener('keydown', keydownHandler);

            toolbarMenuCleanup = () => {
                toggle.removeEventListener('click', toggleHandler);
                panel.removeEventListener('click', panelHandler);
                document.removeEventListener('click', clickHandler);
                document.removeEventListener('keydown', keydownHandler);
            };
        }

        let globeMenuCleanup = null;
        function setupGlobeMenu() {
            if (typeof globeMenuCleanup === 'function') {
                globeMenuCleanup();
                globeMenuCleanup = null;
            }

            const menu = document.querySelector('.globe-menu');
            const toggle = document.getElementById('globeMenuToggle');
            const panel = document.getElementById('globeMenuPanel');
            if (!menu || !toggle || !panel) return;

            const closeMenu = () => menu.classList.remove('open');

            const toggleHandler = (event) => {
                event.stopPropagation();
                menu.classList.toggle('open');
            };

            const panelHandler = (event) => {
                event.stopPropagation();
                if (event.target.closest('button')) closeMenu();
            };

            const clickHandler = (event) => {
                if (!menu.contains(event.target)) closeMenu();
            };

            const keydownHandler = (event) => {
                if (event.key === 'Escape') closeMenu();
            };

            toggle.addEventListener('click', toggleHandler);
            panel.addEventListener('click', panelHandler);
            document.addEventListener('click', clickHandler);
            document.addEventListener('keydown', keydownHandler);

            globeMenuCleanup = () => {
                toggle.removeEventListener('click', toggleHandler);
                panel.removeEventListener('click', panelHandler);
                document.removeEventListener('click', clickHandler);
                document.removeEventListener('keydown', keydownHandler);
            };
        }

        function handleAddRecord() {
            const set = getCurrentSet();
            if (!set) {
                showToast(' No set selected');
                return;
            }

            // Clear selection state to prevent restoration
            state.selectedCell = null;
            state.lastSelectedCell = null;
            state.editingCell = null;

            const record = { id: `rec_${Date.now()}` };
            set.schema.forEach(f => {
                const fieldType = FIELD_TYPES[f.type];
                record[f.id] = fieldType ? fieldType.defaultValue : '';
            });

            // If on a filtered view, pre-populate the record with filter values
            // so it's immediately visible after creation
            const view = getCurrentView();
            if (view && view.filters && view.filters.length > 0) {
                // Use the first filter group to populate values
                const firstGroup = view.filters[0];
                const rules = firstGroup.filter(r => r.field);
                rules.forEach(rule => {
                    if (rule.field && rule.value !== undefined) {
                        record[rule.field] = rule.value;
                    }
                });
            }

            set.records.set(record.id, record);

            // Track the new record for auto-focus after render
            state.newlyAddedRecordId = record.id;

            renderCurrentView();
            showToast(' Record added');
        }

        function wireViewStageActions() {
            const addRecordBtn = document.getElementById('addRecordBtn');
            if (addRecordBtn) addRecordBtn.onclick = handleAddRecord;

            const addFieldBtn = document.getElementById('addFieldBtn');
            if (addFieldBtn) addFieldBtn.onclick = openAddFieldModal;

            const filterBtn = document.getElementById('filterBtn');
            if (filterBtn) filterBtn.onclick = openFilterModal;

            const sortBtn = document.getElementById('sortBtn');
            if (sortBtn) sortBtn.onclick = openSortModal;

            const visualizeBtn = document.getElementById('visualizeBtn');
            if (visualizeBtn) visualizeBtn.onclick = openVisualizationModal;

            const columnWidthBtn = document.getElementById('columnWidthBtn');
            if (columnWidthBtn) columnWidthBtn.onclick = showColumnWidthMenu;

            const tossSelectedBtn = document.getElementById('tossSelectedBtn');
            if (tossSelectedBtn) tossSelectedBtn.onclick = handleTossSelectedRecords;

            const tossSelectedBtnVisible = document.getElementById('tossSelectedBtnVisible');
            if (tossSelectedBtnVisible) tossSelectedBtnVisible.onclick = handleTossSelectedRecords;

            const reifyBtn = document.getElementById('reifyViewBtn');
            if (reifyBtn) reifyBtn.onclick = reifyCurrentView;

            const reifyRecordsBtn = document.getElementById('reifyRecordsBtn');
            if (reifyRecordsBtn) reifyRecordsBtn.onclick = reifyImportView;

            const toolbarActions = [
                ['popupSettingsBtn', openPopupSettingsModal],
                ['importCsvBtn', openCsvImportModal],
                ['importJsonBtn', openJsonImportModal],
                ['fuzzyPanelBtn', openFuzzyPanel]
            ];

            toolbarActions.forEach(([id, handler]) => {
                const el = document.getElementById(id);
                if (el) el.onclick = handler;
            });
        }

        function renderViewBreadcrumb() {
            const world = getWorld();
            const set = getCurrentSet();
            const view = getCurrentView();
            if (!world || !set) return '';

            return `
                <div class="view-breadcrumb">
                    <span class="view-breadcrumb-item clickable" onclick="navigateTo('dashboard')" title="Go to World overview">
                        <i class="ph ph-globe-hemisphere-west" style="font-size: 14px;"></i>
                        ${world.name}
                    </span>
                    <span class="view-breadcrumb-sep"></span>
                    <span class="view-breadcrumb-item">
                        <i class="ph ph-stack" style="font-size: 14px;"></i>
                        ${set.name}
                    </span>
                    ${view ? `
                        <span class="view-breadcrumb-sep"></span>
                        <span class="view-breadcrumb-item">
                            <i class="ph ph-table" style="font-size: 14px;"></i>
                            ${view.name}
                        </span>
                    ` : ''}
                </div>
            `;
        }

        function hasActiveFiltersOrSorts(view) {
            if (!view) return false;
            const hasFilters = view.filters && view.filters.length > 0 &&
                view.filters.some(group => group.some(f => f.field && f.operator));
            const hasSorts = view.sorts && view.sorts.length > 0 &&
                view.sorts.some(s => s.fieldId);
            return hasFilters || hasSorts;
        }

        function saveCurrentViewAs() {
            const view = getCurrentView();
            const set = getCurrentSet();
            if (!view || !set) return;

            const viewName = prompt('Name for this view:', `${view.name} (filtered)`);
            if (!viewName || !viewName.trim()) return;

            const newViewId = createView(set.id, viewName.trim(), {
                type: view.type,
                filters: JSON.parse(JSON.stringify(view.filters || [])),
                sorts: JSON.parse(JSON.stringify(view.sorts || [])),
                hiddenFields: [...(view.hiddenFields || [])],
                kanbanGroupField: view.kanbanGroupField,
                parentId: view.id // Link to parent view
            });

            state.expandedSets.add(set.id);
            switchSet(set.id, newViewId);
            showToast(` Created view "${viewName.trim()}"`);
        }

        /**
         * Render the view mode badge (Sandbox vs Live)
         * Sandbox: exploratory, temporary, dashed styling
         * Live: curated, intentional, solid styling
         */
        function renderViewModeBadge(viewMode) {
            if (viewMode === 'sandbox') {
                return `<span class="view-mode-header-badge sandbox" title="Sandbox view - exploratory, not yet promoted to live data">
                    <i class="ph ph-flask"></i>
                    Sandbox
                </span>`;
            } else if (viewMode === 'live') {
                // Live views don't need a badge - they're the default/expected state
                return '';
            }
            return '';
        }

        /**
         * Promote a sandbox view to live status
         * This changes the view from exploratory/temporary to curated/intentional
         */
        function promoteViewToLive() {
            const view = getCurrentView();
            if (!view) return;

            if (view.viewMode !== 'sandbox') {
                showToast('This view is already live');
                return;
            }

            // Update the view mode
            view.viewMode = 'live';

            // Also update in global state.views if present
            if (state.views.has(view.id)) {
                state.views.get(view.id).viewMode = 'live';
            }

            // Re-render to show the updated state
            renderCurrentView();
            renderSidebar();

            showToast(' View promoted to live data');
        }

        /**
         * Demote a live view back to sandbox status
         * Useful if user wants to mark something as exploratory again
         */
        function demoteViewToSandbox() {
            const view = getCurrentView();
            if (!view) return;

            if (view.viewMode === 'sandbox') {
                showToast('This view is already in sandbox mode');
                return;
            }

            view.viewMode = 'sandbox';

            if (state.views.has(view.id)) {
                state.views.get(view.id).viewMode = 'sandbox';
            }

            renderCurrentView();
            renderSidebar();

            showToast(' View moved to sandbox');
        }

        function renderViewActions(extraControls = '') {
            const view = getCurrentView();
            const isImportView = view && view.isTemporary && view.importMetadata;
            const isSandbox = view && view.viewMode === 'sandbox';

            // Add save/reify buttons for import views
            const saveViewButton = isImportView ? `
                <button id="saveImportViewBtn" class="btn btn-success btn-sm" style="background: #10b981; border-color: #10b981;" onclick="showSaveImportAsViewDialog()">
                    <i class="ph ph-floppy-disk"></i>
                    Save as View
                </button>
            ` : '';

            // Add promote button for sandbox views
            const promoteButton = isSandbox ? `
                <button id="promoteToLiveBtn" class="btn btn-sm" style="background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%); color: white; border: none;" onclick="promoteViewToLive()">
                    <i class="ph ph-arrow-circle-up"></i>
                    Promote to Live
                </button>
            ` : '';

            return `
                <div class="view-stage-actions">
                    <div class="toolbar-row">
                        <div class="toolbar-group">
                            <div class="selection-group">
                                <div id="selectionIndicator" class="selection-indicator hidden">
                                    <i class="ph ph-check-square-offset"></i>
                                    <span><span id="selectedCount">0</span> selected</span>
                                </div>
                                <button id="tossSelectedBtnVisible" class="btn btn-secondary btn-sm toss-selected-btn hidden" title="Toss selected records">
                                    <i class="ph ph-hand-fist"></i>
                                    Toss
                                </button>
                            </div>
                            <div class="view-stage-inline-actions">
                                ${promoteButton}
                                ${saveViewButton}
                                <button id="filterBtn" class="btn btn-secondary btn-sm">
                                    <i class="ph ph-funnel-simple"></i>
                                    Filter
                                </button>
                                <button id="sortBtn" class="btn btn-secondary btn-sm">
                                    <i class="ph ph-arrows-down-up"></i>
                                    Sort
                                </button>
                                <button id="visualizeBtn" class="btn btn-secondary btn-sm">
                                    <i class="ph ph-chart-bar"></i>
                                    Visualize
                                </button>
                                <div class="column-width-dropdown-container" style="position: relative;">
                                    <button id="columnWidthBtn" class="btn btn-secondary btn-sm column-width-btn">
                                        <i class="ph ph-columns"></i>
                                        Columns
                                    </button>
                                </div>
                                <button id="tossPileBtnVisible" class="btn btn-secondary btn-sm toss-pile-toggle" onclick="TossPileUI.togglePanel()" title="Open Toss Pile">
                                    <i class="ph ph-recycle"></i>
                                    Toss Pile${getTossPileBadgeHtml()}
                                </button>
                            </div>
                            ${extraControls ? `<div class="toolbar-group">${extraControls}</div>` : ''}
                        </div>
                        <div class="toolbar-group">
                            <button id="addRecordBtn" class="btn btn-primary btn-sm" onclick="handleAddRecord()">+ Add Record</button>
                            <button id="addFieldBtn" class="btn btn-secondary btn-sm">+ Add Field</button>
                            <button class="btn btn-secondary btn-sm" onclick="openFieldManager()">
                                <i class="ph ph-gear-six text-sm"></i>
                                <span class="ml-1">Fields</span>
                            </button>
                            <div class="toolbar-menu">
                                <button id="toolbarMenuToggle" class="btn btn-secondary btn-sm toolbar-menu-toggle">
                                    <i class="ph ph-dots-three"></i>
                                </button>
                                <div class="toolbar-menu-panel" id="toolbarMenuPanel">
                                    <button id="tossSelectedBtn" class="btn btn-secondary btn-sm toolbar-menu-item" disabled>
                                        <i class="ph ph-hand-fist"></i>
                                        Toss Selected
                                    </button>
                                    <button id="tossPileBtn" class="btn btn-secondary btn-sm toolbar-menu-item toss-pile-toggle" onclick="TossPileUI.togglePanel()">
                                        <i class="ph ph-recycle"></i>
                                        Toss Pile ${getTossPileBadgeHtml()}
                                    </button>
                                    <button id="ghostToggleBtn" class="btn btn-secondary btn-sm toolbar-menu-item ${getGhostToggleClass()}" onclick="toggleGhostVisibility()">
                                        <i class="ph ph-eye${getGhostToggleIcon()}"></i>
                                        ${isGhostVisible() ? 'Hide Ghosts' : 'Show Ghosts'}
                                    </button>
                                    <div class="toolbar-menu-divider"></div>
                                    <button id="popupSettingsBtn" class="btn btn-secondary btn-sm toolbar-menu-item">
                                        <i class="ph ph-gear-six"></i>
                                        Details
                                    </button>
                                    <button id="importCsvBtn" class="btn btn-secondary btn-sm toolbar-menu-item">
                                        <i class="ph ph-upload-simple"></i>
                                        Import CSV
                                    </button>
                                    <button id="importJsonBtn" class="btn btn-secondary btn-sm toolbar-menu-item">
                                        <i class="ph ph-brackets-curly"></i>
                                        Import JSON
                                    </button>
                                    <div class="toolbar-menu-divider"></div>
                                    <button id="fuzzyPanelBtn" class="btn btn-secondary btn-sm toolbar-menu-item">
                                        <i class="ph ph-graph"></i>
                                        Fuzzy Matches
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        function getTossPileBadgeHtml() {
            if (typeof TossPile === 'undefined') return '';
            const stats = TossPile.getTossPileStats(state, state.currentSetId);
            if (stats.totalEntries === 0) return '';
            return `<span class="toggle-badge">${stats.totalEntries}</span>`;
        }

        function isGhostVisible() {
            if (typeof TossPile === 'undefined') return false;
            const pile = TossPile.init(state);
            return pile.settings.showGhosts;
        }

        function getGhostToggleClass() {
            return isGhostVisible() ? 'ghost-visible' : 'ghost-hidden';
        }

        function getGhostToggleIcon() {
            return isGhostVisible() ? '' : '-slash';
        }

        function getGhostToggleTitle() {
            return isGhostVisible() ? 'Hide ghost data' : 'Show ghost data';
        }

        function toggleGhostVisibility() {
            if (typeof TossPile === 'undefined' || typeof TossPileUI === 'undefined') return;
            const newState = !isGhostVisible();
            TossPile.setGhostVisibility(state, newState);
            renderCurrentView();
            updateGhostToggleButton();
        }

        function updateGhostToggleButton() {
            const btn = document.getElementById('ghostToggleBtn');
            if (!btn) return;
            const visible = isGhostVisible();
            btn.className = `btn btn-secondary btn-sm toolbar-menu-item ${visible ? 'ghost-visible' : 'ghost-hidden'}`;
            const icon = btn.querySelector('i');
            if (icon) {
                icon.className = `ph ph-eye${visible ? '' : '-slash'}`;
            }
            // Update text content (keep icon, update label)
            const textNode = Array.from(btn.childNodes).find(n => n.nodeType === Node.TEXT_NODE);
            if (textNode) {
                textNode.textContent = visible ? 'Hide Ghosts' : 'Show Ghosts';
            }
        }

        function finalizeViewStage() {
            wireViewStageActions();
            setupToolbarMenu();
        }

        function triggerPrimaryAction() {
            const addRecordBtn = document.getElementById('addRecordBtn');
            if (addRecordBtn) { addRecordBtn.click(); return; }

            document.getElementById('addFieldBtn')?.click();
        }

        function initializeOperatorRules() {
            const defaultRules = [
                {
                    rule_id: 'rule_ins_requires_object',
                    applies_to_op: 'INS',
                    description: 'Instantiation must target an identifiable object.',
                    effect: 'require_object_id'
                },
                {
                    rule_id: 'rule_events_require_actor',
                    description: 'All events must be attributable to an actor.',
                    effect: 'require_actor'
                },
                {
                    rule_id: 'rule_con_requires_object',
                    applies_to_op: 'CON',
                    description: 'Connections must reference a concrete edge object.',
                    effect: 'require_object_id'
                },
                {
                    rule_id: 'rule_con_requires_endpoints',
                    applies_to_op: 'CON',
                    description: 'Connections must include both source and target references.',
                    effect: 'require_connection_endpoints'
                },
                {
                    rule_id: 'rule_nullify_marks_deleted',
                    applies_to_op: 'NUL',
                    description: 'Nullify operations explicitly mark the object as deleted in the payload.',
                    effect: 'mark_deleted'
                }
            ];

            defaultRules.forEach(rule => registerInterpretationRule(rule, { skipEvent: true }));
        }

        function createSampleData() {
            const defaultWorldId = createWorld('Example World', 'world_example');
            state.currentWorldId = defaultWorldId;
            const worldDefaults = state.worlds.get(defaultWorldId)?.defaults || {};

            const locationsId = worldDefaults.locationsId || createSet('Locations', 'ph-map-pin', defaultWorldId);
            const observationsId = worldDefaults.observationsId || createSet('Observations', 'ph-binoculars', defaultWorldId);

            const locationsSet = state.sets.get(locationsId);
            if (!locationsSet) {
                console.error('Failed to create Locations set');
                return;
            }
            locationsSet.schema = [
                { id: 'name', name: 'Location', type: 'TEXT', width: '220px' },
                { id: 'area', name: 'Area', type: 'TEXT', width: '180px' },
                { id: 'notes', name: 'Notes', type: 'LONG_TEXT', width: '260px' }
            ];

            locationsSet.records.clear();
            if (!locationsSet.views) locationsSet.views = new Map();
            locationsSet.views.clear();
            const ridgeId = addRecord(locationsId, { name: 'Summit Ridge', area: 'Highlands', notes: 'Windy lookout with clean sight lines.' });
            const marshId = addRecord(locationsId, { name: 'Quiet Marsh', area: 'Wetlands', notes: 'Shallow water and dense reeds.' });
            const groveId = addRecord(locationsId, { name: 'North Grove', area: 'Forest Edge', notes: 'Shaded trail with frequent wildlife activity.' });

            createView(locationsId, 'Locations', { type: 'grid', sorts: [{ fieldId: 'name', direction: 'asc' }] });
            createView(locationsId, 'By Area', {
                type: 'KEY_DERIVED',
                key: { setId: locationsId, fieldId: 'area' },
                schema: [
                    { id: 'locationNames', name: 'Locations', type: 'TEXT', sourceFieldId: 'name' },
                    { id: 'notesSummary', name: 'Notes', type: 'LONG_TEXT', sourceFieldId: 'notes' }
                ],
                columnRules: {
                    locationNames: { rule: 'sup_all' },
                    notesSummary: { rule: 'sup_all' }
                }
            });

            const observationsSet = state.sets.get(observationsId);
            if (!observationsSet) {
                console.error('Failed to create Observations set');
                return;
            }
            observationsSet.schema = [
                { id: 'date', name: 'Date', type: 'DATE', width: '140px' },
                { id: 'location', name: 'Location', type: 'TEXT', width: '200px' },
                { id: 'observer', name: 'Observer', type: 'TEXT', width: '180px' },
                { id: 'observation', name: 'Observation', type: 'LONG_TEXT', width: '260px' }
            ];

            observationsSet.records.clear();
            if (!observationsSet.views) observationsSet.views = new Map();
            observationsSet.views.clear();
            const obs1Id = addRecord(observationsId, { date: '2024-04-12', location: 'Summit Ridge', observer: 'M. Ellis', observation: 'Found fresh tracks along the ridge path.' });
            const obs2Id = addRecord(observationsId, { date: '2024-04-13', location: 'Quiet Marsh', observer: 'S. Kaur', observation: 'Low mist over the marsh; water depth at 0.4m.' });
            const obs3Id = addRecord(observationsId, { date: '2024-04-14', location: 'North Grove', observer: 'J. Rivera', observation: 'Pair of hawks circling above the grove at noon.' });
            const obs4Id = addRecord(observationsId, { date: '2024-04-15', location: 'Summit Ridge', observer: 'M. Ellis', observation: 'Clear skies; ridge visibility extends 10km.' });

            createView(observationsId, 'Observations', {
                type: 'grid',
                sorts: [{ fieldId: 'date', direction: 'desc' }]
            });

            createView(observationsId, 'By Location', {
                type: 'KEY_DERIVED',
                key: { setId: observationsId, fieldId: 'location' },
                schema: [
                    { id: 'notes', name: 'Observations', type: 'LONG_TEXT', sourceFieldId: 'observation' },
                    { id: 'observers', name: 'Observers', type: 'TEXT', sourceFieldId: 'observer' },
                    { id: 'latestDate', name: 'Most Recent', type: 'DATE', sourceFieldId: 'date' }
                ],
                columnRules: {
                    notes: { rule: 'sup_all' },
                    observers: { rule: 'sup_all' },
                    latestDate: { rule: 'prefer_newest' }
                }
            });

            createView(observationsId, 'By Observer', {
                type: 'KEY_DERIVED',
                key: { setId: observationsId, fieldId: 'observer' },
                schema: [
                    { id: 'locations', name: 'Locations', type: 'TEXT', sourceFieldId: 'location' },
                    { id: 'notes', name: 'Observations', type: 'LONG_TEXT', sourceFieldId: 'observation' },
                    { id: 'latestDate', name: 'Most Recent', type: 'DATE', sourceFieldId: 'date' }
                ],
                columnRules: {
                    locations: { rule: 'sup_all' },
                    notes: { rule: 'sup_all' },
                    latestDate: { rule: 'prefer_newest' }
                }
            });

            Array.from(state.definitions.values())
                .filter(def => def.worldId === defaultWorldId)
                .forEach(def => state.definitions.delete(def.id));

            Array.from(state.connectionRelations.values())
                .filter(fmt => fmt.worldId === defaultWorldId)
                .forEach(fmt => state.connectionRelations.delete(fmt.id));

            const observationLinkRelationId = addConnectionRelation({
                id: `${defaultWorldId}_format_observation_link`,
                operator: 'CON',
                mode: 'is linked to',
                description: 'Links an observation to its location',
                requiredParams: ['context'],
                optionalParams: ['notes'],
                worldId: defaultWorldId
            });

            if (!observationLinkRelationId) return;

            addDefinition({
                id: `${defaultWorldId}_def_location`,
                entity: { type: 'Record', id: ridgeId },
                term: 'Field Location',
                definition: 'A place where observations are collected in the example world.',
                notes: 'Locations anchor the observation network.',
                tags: ['example', 'location'],
                worldId: defaultWorldId
            });
            addDefinition({
                id: `${defaultWorldId}_def_observation`,
                entity: { type: 'Record', id: obs1Id },
                term: 'Observation Entry',
                definition: 'A single sighting or measurement recorded by an observer.',
                notes: 'Use date and observer to track context.',
                tags: ['example', 'observation'],
                worldId: defaultWorldId
            });
            addDefinition({
                id: `${defaultWorldId}_def_link`,
                entity: { type: 'Connection', id: `${defaultWorldId}_example_conn_1` },
                term: 'Observed At',
                definition: 'Connects each observation to the location where it was made.',
                notes: 'Maintains spatial context for notes.',
                tags: ['example', 'connection'],
                worldId: defaultWorldId
            });

            Array.from(state.connections.values())
                .filter(conn => conn.worldId === defaultWorldId)
                .forEach(conn => state.connections.delete(conn.id));

            addConnection({
                id: `${defaultWorldId}_example_conn_1`,
                subject: { type: 'Record', id: obs1Id },
                relationId: observationLinkRelationId,
                operand: { type: 'Record', id: ridgeId },
                description: 'Tracks where the ridge observation was made.',
                params: { context: 'location' },
                worldId: defaultWorldId
            });

            addConnection({
                id: `${defaultWorldId}_example_conn_2`,
                subject: { type: 'Record', id: obs2Id },
                relationId: observationLinkRelationId,
                operand: { type: 'Record', id: marshId },
                description: 'Links marsh observation to its site.',
                params: { context: 'location' },
                worldId: defaultWorldId
            });

            addConnection({
                id: `${defaultWorldId}_example_conn_3`,
                subject: { type: 'Record', id: obs3Id },
                relationId: observationLinkRelationId,
                operand: { type: 'Record', id: groveId },
                description: 'Associates grove observation with location.',
                params: { context: 'location' },
                worldId: defaultWorldId
            });

            addConnection({
                id: `${defaultWorldId}_example_conn_4`,
                subject: { type: 'Record', id: obs4Id },
                relationId: observationLinkRelationId,
                operand: { type: 'Record', id: ridgeId },
                description: 'Links the second ridge observation to its site.',
                params: { context: 'location' },
                worldId: defaultWorldId
            });

            // Add more relation types demonstrating all 9 EO operators
            const nullRelationId = addConnectionRelation({
                id: `${defaultWorldId}_format_null`,
                operator: 'NUL',
                mode: 'detects absence of',
                description: 'Recognizes absence or missing data',
                requiredParams: [],
                optionalParams: ['notes'],
                worldId: defaultWorldId
            });

            const designateRelationId = addConnectionRelation({
                id: `${defaultWorldId}_format_designate`,
                operator: 'DES',
                mode: 'labels',
                description: 'Designates or labels an entity',
                requiredParams: [],
                optionalParams: ['notes'],
                worldId: defaultWorldId
            });

            const instantiateRelationId = addConnectionRelation({
                id: `${defaultWorldId}_format_instantiate`,
                operator: 'INS',
                mode: 'creates',
                description: 'Creates or generates a new entity',
                requiredParams: [],
                optionalParams: ['notes'],
                worldId: defaultWorldId
            });

            const segmentRelationId = addConnectionRelation({
                id: `${defaultWorldId}_format_segment`,
                operator: 'SEG',
                mode: 'filters by',
                description: 'Segments or filters entities',
                requiredParams: [],
                optionalParams: ['notes'],
                worldId: defaultWorldId
            });

            const alternateRelationId = addConnectionRelation({
                id: `${defaultWorldId}_format_alternate`,
                operator: 'ALT',
                mode: 'alternates with',
                description: 'Alternates between states or entities',
                requiredParams: [],
                optionalParams: ['notes'],
                worldId: defaultWorldId
            });

            const synthesizeRelationId = addConnectionRelation({
                id: `${defaultWorldId}_format_synthesize`,
                operator: 'SYN',
                mode: 'combines with',
                description: 'Synthesizes or integrates entities',
                requiredParams: [],
                optionalParams: ['notes'],
                worldId: defaultWorldId
            });

            const superposeRelationId = addConnectionRelation({
                id: `${defaultWorldId}_format_superpose`,
                operator: 'SUP',
                mode: 'overlays',
                description: 'Superimposes or overlays entities',
                requiredParams: [],
                optionalParams: ['notes'],
                worldId: defaultWorldId
            });

            const recurseRelationId = addConnectionRelation({
                id: `${defaultWorldId}_format_recurse`,
                operator: 'REC',
                mode: 'references',
                description: 'Creates recursive or self-referential relationships',
                requiredParams: [],
                optionalParams: ['notes'],
                worldId: defaultWorldId
            });

            // Add demo connections with different operators
            if (nullRelationId) {
                addConnection({
                    id: `${defaultWorldId}_demo_nul_1`,
                    subject: { type: 'Record', id: marshId },
                    relationId: nullRelationId,
                    operand: { type: 'Record', id: obs2Id },
                    description: 'Marsh observation is missing water quality data.',
                    params: {},
                    worldId: defaultWorldId
                });
            }

            if (designateRelationId) {
                addConnection({
                    id: `${defaultWorldId}_demo_des_1`,
                    subject: { type: 'Record', id: ridgeId },
                    relationId: designateRelationId,
                    operand: { type: 'Set', id: locationsId },
                    description: 'Summit Ridge is designated as a primary field site.',
                    params: {},
                    worldId: defaultWorldId
                });
            }

            if (instantiateRelationId) {
                addConnection({
                    id: `${defaultWorldId}_demo_ins_1`,
                    subject: { type: 'Record', id: obs1Id },
                    relationId: instantiateRelationId,
                    operand: { type: 'Record', id: obs2Id },
                    description: 'The ridge observation led to the marsh observation.',
                    params: {},
                    worldId: defaultWorldId
                });
            }

            if (segmentRelationId) {
                addConnection({
                    id: `${defaultWorldId}_demo_seg_1`,
                    subject: { type: 'Set', id: observationsId },
                    relationId: segmentRelationId,
                    operand: { type: 'Set', id: locationsId },
                    description: 'Observations are filtered by location.',
                    params: {},
                    worldId: defaultWorldId
                });
            }

            if (alternateRelationId) {
                addConnection({
                    id: `${defaultWorldId}_demo_alt_1`,
                    subject: { type: 'Record', id: obs1Id },
                    relationId: alternateRelationId,
                    operand: { type: 'Record', id: obs4Id },
                    description: 'Observers alternate shifts at the ridge.',
                    params: {},
                    worldId: defaultWorldId
                });
            }

            if (synthesizeRelationId) {
                addConnection({
                    id: `${defaultWorldId}_demo_syn_1`,
                    subject: { type: 'Record', id: obs2Id },
                    relationId: synthesizeRelationId,
                    operand: { type: 'Record', id: obs3Id },
                    description: 'Marsh and grove data combine for ecosystem analysis.',
                    params: {},
                    worldId: defaultWorldId
                });
            }

            if (superposeRelationId) {
                addConnection({
                    id: `${defaultWorldId}_demo_sup_1`,
                    subject: { type: 'Record', id: marshId },
                    relationId: superposeRelationId,
                    operand: { type: 'Record', id: groveId },
                    description: 'Wetlands and forest monitoring overlay in the same region.',
                    params: {},
                    worldId: defaultWorldId
                });
            }

            if (recurseRelationId) {
                addConnection({
                    id: `${defaultWorldId}_demo_rec_1`,
                    subject: { type: 'Record', id: obs3Id },
                    relationId: recurseRelationId,
                    operand: { type: 'Record', id: obs3Id },
                    description: 'This observation references itself as a follow-up note.',
                    params: {},
                    worldId: defaultWorldId
                });
            }

            state.currentSetId = observationsId;
            state.currentViewId = Array.from(observationsSet.views.keys())[0];
            state.expandedSets.add(observationsId);
            state.expandedSets.add(locationsId);
        }

        function createGraphDemo() {
            const demoWorldId = createWorld('Graph Demo', 'world_graph_demo');
            state.currentWorldId = demoWorldId;
            const worldDefaults = state.worlds.get(demoWorldId)?.defaults || {};

            // Create sets for different entity types
            const projectsId = createSet('Projects', 'ph-folder', demoWorldId);
            const peopleId = createSet('People', 'ph-users', demoWorldId);
            const tasksId = createSet('Tasks', 'ph-list-checks', demoWorldId);
            const conceptsId = createSet('Concepts', 'ph-lightbulb', demoWorldId);

            // Schema for Projects - demonstrates TEXT, LONG_TEXT, NUMBER, DATE, CHECKBOX, SELECT
            const projectsSet = state.sets.get(projectsId);
            projectsSet.schema = [
                { id: 'name', name: 'Project', type: 'TEXT', width: '200px' },
                { id: 'status', name: 'Status', type: 'SELECT', subtype: 'SINGLE', width: '120px', options: ['Planning', 'Active', 'On Hold', 'Completed'] },
                { id: 'description', name: 'Description', type: 'LONG_TEXT', width: '300px' },
                { id: 'budget', name: 'Budget', type: 'NUMBER', subtype: 'CURRENCY', width: '120px' },
                { id: 'startDate', name: 'Start Date', type: 'DATE', width: '140px' },
                { id: 'active', name: 'Active', type: 'CHECKBOX', width: '80px' }
            ];

            // Schema for People - demonstrates TEXT, CONTACT (EMAIL, URL), CHECKBOX
            const peopleSet = state.sets.get(peopleId);
            peopleSet.schema = [
                { id: 'name', name: 'Name', type: 'TEXT', width: '180px' },
                { id: 'role', name: 'Role', type: 'SELECT', subtype: 'SINGLE', width: '150px', options: ['Technical Lead', 'Engineer', 'Researcher', 'Designer', 'Manager'] },
                { id: 'expertise', name: 'Expertise', type: 'TEXT', width: '200px' },
                { id: 'email', name: 'Email', type: 'CONTACT', subtype: 'EMAIL', width: '200px' },
                { id: 'website', name: 'Website', type: 'CONTACT', subtype: 'URL', width: '180px' },
                { id: 'available', name: 'Available', type: 'CHECKBOX', width: '80px' }
            ];

            // Schema for Tasks - demonstrates TEXT, LONG_TEXT, DATE, NUMBER, CHECKBOX, SELECT (MULTIPLE)
            const tasksSet = state.sets.get(tasksId);
            tasksSet.schema = [
                { id: 'title', name: 'Task', type: 'TEXT', width: '220px' },
                { id: 'priority', name: 'Priority', type: 'SELECT', subtype: 'SINGLE', width: '100px', options: ['Low', 'Medium', 'High', 'Critical'] },
                { id: 'description', name: 'Description', type: 'LONG_TEXT', width: '280px' },
                { id: 'dueDate', name: 'Due Date', type: 'DATE', width: '140px' },
                { id: 'estimatedHours', name: 'Est. Hours', type: 'NUMBER', width: '100px' },
                { id: 'completed', name: 'Done', type: 'CHECKBOX', width: '70px' },
                { id: 'tags', name: 'Tags', type: 'SELECT', subtype: 'MULTIPLE', width: '150px', options: ['frontend', 'backend', 'design', 'research', 'urgent'] }
            ];

            // Schema for Concepts - demonstrates TEXT, LONG_TEXT, DATE, CHECKBOX, CONTACT (URL)
            const conceptsSet = state.sets.get(conceptsId);
            conceptsSet.schema = [
                { id: 'concept', name: 'Concept', type: 'TEXT', width: '200px' },
                { id: 'category', name: 'Category', type: 'SELECT', subtype: 'SINGLE', width: '150px', options: ['Core Concept', 'Data Pattern', 'Computation', 'Data Structure', 'Framework'] },
                { id: 'definition', name: 'Definition', type: 'LONG_TEXT', width: '320px' },
                { id: 'createdDate', name: 'Created', type: 'DATE', width: '140px' },
                { id: 'validated', name: 'Validated', type: 'CHECKBOX', width: '80px' },
                { id: 'reference', name: 'Reference URL', type: 'CONTACT', subtype: 'URL', width: '180px' }
            ];

            // Add project records with all field types populated
            projectsSet.records.clear();
            const proj1 = addRecord(projectsId, {
                name: 'Knowledge Graph',
                status: 'Active',
                description: 'Build interactive knowledge graph visualization system',
                budget: 150000,
                startDate: '2024-01-15',
                active: true
            });
            const proj2 = addRecord(projectsId, {
                name: 'Context Engine',
                status: 'Active',
                description: 'Develop epistemic observability context tracking',
                budget: 120000,
                startDate: '2024-02-01',
                active: true
            });
            const proj3 = addRecord(projectsId, {
                name: 'Formula System',
                status: 'Planning',
                description: 'Implement reactive formula field calculations',
                budget: 80000,
                startDate: '2024-06-01',
                active: false
            });

            // Add people records with CONTACT and CHECKBOX fields
            peopleSet.records.clear();
            const person1 = addRecord(peopleId, {
                name: 'Dr. Sarah Chen',
                role: 'Technical Lead',
                expertise: 'Graph Theory, Distributed Systems',
                email: 'sarah.chen@example.com',
                website: 'https://sarahchen.dev',
                available: true
            });
            const person2 = addRecord(peopleId, {
                name: 'Alex Morgan',
                role: 'Engineer',
                expertise: 'Frontend, Data Visualization',
                email: 'alex.morgan@example.com',
                website: 'https://alexmorgan.io',
                available: true
            });
            const person3 = addRecord(peopleId, {
                name: 'Jordan Kim',
                role: 'Researcher',
                expertise: 'Knowledge Management, Ontologies',
                email: 'jordan.kim@example.com',
                website: 'https://jkim-research.org',
                available: false
            });

            // Add task records with DATE, NUMBER, CHECKBOX, and MULTIPLE SELECT
            tasksSet.records.clear();
            const task1 = addRecord(tasksId, {
                title: 'Design node layout algorithm',
                priority: 'High',
                description: 'Create force-directed graph layout with clustering',
                dueDate: '2024-03-01',
                estimatedHours: 40,
                completed: true,
                tags: ['frontend', 'design']
            });
            const task2 = addRecord(tasksId, {
                title: 'Implement edge rendering',
                priority: 'High',
                description: 'Add support for curved edges and directional arrows',
                dueDate: '2024-03-15',
                estimatedHours: 32,
                completed: false,
                tags: ['frontend', 'urgent']
            });
            const task3 = addRecord(tasksId, {
                title: 'Build context tracker',
                priority: 'Medium',
                description: 'Track provenance and lineage of data values',
                dueDate: '2024-04-01',
                estimatedHours: 24,
                completed: false,
                tags: ['backend']
            });
            const task4 = addRecord(tasksId, {
                title: 'Add formula parser',
                priority: 'Medium',
                description: 'Parse and evaluate spreadsheet-like formulas',
                dueDate: '2024-07-01',
                estimatedHours: 48,
                completed: false,
                tags: ['backend', 'frontend']
            });
            const task5 = addRecord(tasksId, {
                title: 'Research graph databases',
                priority: 'Low',
                description: 'Evaluate Neo4j and other graph database options',
                dueDate: '2024-05-15',
                estimatedHours: 16,
                completed: false,
                tags: ['research', 'backend']
            });

            // Add concept records with DATE, CHECKBOX, and URL fields
            conceptsSet.records.clear();
            const concept1 = addRecord(conceptsId, {
                concept: 'Epistemic Observability',
                category: 'Core Concept',
                definition: 'The ability to trace the origin and context of every data value',
                createdDate: '2023-11-01',
                validated: true,
                reference: 'https://eleganceofobjects.org/epistemic'
            });
            const concept2 = addRecord(conceptsId, {
                concept: 'Superposition',
                category: 'Data Pattern',
                definition: 'Multiple simultaneous values with different contexts',
                createdDate: '2023-12-15',
                validated: true,
                reference: 'https://eleganceofobjects.org/superposition'
            });
            const concept3 = addRecord(conceptsId, {
                concept: 'Reactive Formula',
                category: 'Computation',
                definition: 'Formula that automatically recalculates when dependencies change',
                createdDate: '2024-01-10',
                validated: false,
                reference: 'https://eleganceofobjects.org/formulas'
            });
            const concept4 = addRecord(conceptsId, {
                concept: 'Knowledge Graph',
                category: 'Data Structure',
                definition: 'Network of entities and relationships forming a semantic model',
                createdDate: '2023-10-20',
                validated: true,
                reference: 'https://eleganceofobjects.org/graphs'
            });

            // Create views - demonstrating all view types
            // Grid views (default table view)
            createView(projectsId, 'Projects', { type: 'grid' });
            createView(peopleId, 'People', { type: 'grid' });
            createView(tasksId, 'Tasks', { type: 'grid' });
            createView(conceptsId, 'Concepts', { type: 'grid' });

            // Card views (visual card layout)
            createView(projectsId, 'Project Cards', { type: 'card' });
            createView(peopleId, 'Team Cards', { type: 'card' });

            // Kanban views (board layout grouped by status/priority)
            createView(projectsId, 'Project Board', {
                type: 'kanban',
                groupByField: 'status',
                sortField: 'startDate'
            });
            createView(tasksId, 'Task Board', {
                type: 'kanban',
                groupByField: 'priority',
                sortField: 'dueDate'
            });

            // KEY_DERIVED views (aggregated/summarized views)
            createView(tasksId, 'Tasks by Priority', {
                type: 'KEY_DERIVED',
                key: { setId: tasksId, fieldId: 'priority' },
                schema: [
                    { id: 'taskTitles', name: 'Tasks', type: 'TEXT', sourceFieldId: 'title' },
                    { id: 'totalHours', name: 'Total Est. Hours', type: 'NUMBER', sourceFieldId: 'estimatedHours' }
                ],
                columnRules: {
                    taskTitles: { rule: 'sup_all' },
                    totalHours: { rule: 'sum' }
                }
            });

            createView(conceptsId, 'Concepts by Category', {
                type: 'KEY_DERIVED',
                key: { setId: conceptsId, fieldId: 'category' },
                schema: [
                    { id: 'conceptNames', name: 'Concepts', type: 'TEXT', sourceFieldId: 'concept' },
                    { id: 'definitions', name: 'Definitions', type: 'LONG_TEXT', sourceFieldId: 'definition' }
                ],
                columnRules: {
                    conceptNames: { rule: 'sup_all' },
                    definitions: { rule: 'sup_all' }
                }
            });

            // Clear existing definitions and connections for this world
            Array.from(state.definitions.values())
                .filter(def => def.worldId === demoWorldId)
                .forEach(def => state.definitions.delete(def.id));
            Array.from(state.connectionRelations.values())
                .filter(fmt => fmt.worldId === demoWorldId)
                .forEach(fmt => state.connectionRelations.delete(fmt.id));

            // Create connection relations using valid EO operators
            // CON (Connect) - for linking/relating entities
            const ownsRelationId = addConnectionRelation({
                id: `${demoWorldId}_format_owns`,
                operator: 'CON',
                mode: 'is linked to',
                description: 'Person leads/owns a project',
                worldId: demoWorldId
            });

            // CON (Connect) - for task assignments
            const assignedRelationId = addConnectionRelation({
                id: `${demoWorldId}_format_assigned`,
                operator: 'CON',
                mode: 'relates to',
                description: 'Task assigned to person',
                worldId: demoWorldId
            });

            // SEG (Segment) - for containment/partitioning
            const partOfRelationId = addConnectionRelation({
                id: `${demoWorldId}_format_part_of`,
                operator: 'SEG',
                mode: 'constrains',
                description: 'Task is part of project scope',
                worldId: demoWorldId
            });

            // SYN (Synthesize) - for integration/combining
            const implementsRelationId = addConnectionRelation({
                id: `${demoWorldId}_format_implements`,
                operator: 'SYN',
                mode: 'integrates',
                description: 'Project implements concept',
                worldId: demoWorldId
            });

            // CON (Connect) - for dependencies
            const dependsRelationId = addConnectionRelation({
                id: `${demoWorldId}_format_depends`,
                operator: 'CON',
                mode: 'depends on',
                description: 'Task depends on another task',
                worldId: demoWorldId
            });

            // CON (Connect) - for concept relationships
            const relatesRelationId = addConnectionRelation({
                id: `${demoWorldId}_format_relates`,
                operator: 'CON',
                mode: 'relates to',
                description: 'Concept relates to concept',
                worldId: demoWorldId
            });

            // DES (Designate) - for labeling/naming
            const designatesRelationId = addConnectionRelation({
                id: `${demoWorldId}_format_designates`,
                operator: 'DES',
                mode: 'labels',
                description: 'Entity designates/labels another',
                worldId: demoWorldId
            });

            // INS (Instantiate) - for creation relationships
            const createsRelationId = addConnectionRelation({
                id: `${demoWorldId}_format_creates`,
                operator: 'INS',
                mode: 'creates',
                description: 'Entity creates/generates another',
                worldId: demoWorldId
            });

            // ALT (Alternate) - for state transitions
            const alternatesRelationId = addConnectionRelation({
                id: `${demoWorldId}_format_alternates`,
                operator: 'ALT',
                mode: 'toggles with',
                description: 'Entity alternates states with another',
                worldId: demoWorldId
            });

            // SUP (Superpose) - for parallel/layered values
            const superposesRelationId = addConnectionRelation({
                id: `${demoWorldId}_format_superposes`,
                operator: 'SUP',
                mode: 'overlays',
                description: 'Entity maintains parallel values with another',
                worldId: demoWorldId
            });

            // REC (Recurse) - for feedback loops
            const recursesRelationId = addConnectionRelation({
                id: `${demoWorldId}_format_recurses`,
                operator: 'REC',
                mode: 'feeds back into',
                description: 'Entity iterates/feeds back into another',
                worldId: demoWorldId
            });

            // NUL (Null/Absence) - for detecting missing/void relationships
            const nullRelationId = addConnectionRelation({
                id: `${demoWorldId}_format_null`,
                operator: 'NUL',
                mode: 'detects absence of',
                description: 'Entity detects absence or void in another',
                worldId: demoWorldId
            });

            // Add definitions for key entities
            addDefinition({
                id: `${demoWorldId}_def_proj1`,
                entity: { type: 'Record', id: proj1 },
                term: 'Knowledge Graph Project',
                definition: 'Primary project for building interactive visualization of entity relationships',
                tags: ['demo', 'project'],
                worldId: demoWorldId
            });

            addDefinition({
                id: `${demoWorldId}_def_proj2`,
                entity: { type: 'Record', id: proj2 },
                term: 'Context Engine',
                definition: 'Core infrastructure for tracking data provenance and lineage',
                tags: ['demo', 'project'],
                worldId: demoWorldId
            });

            addDefinition({
                id: `${demoWorldId}_def_proj3`,
                entity: { type: 'Record', id: proj3 },
                term: 'Formula System',
                definition: 'Reactive computation system for derived values',
                tags: ['demo', 'project'],
                worldId: demoWorldId
            });

            addDefinition({
                id: `${demoWorldId}_def_person1`,
                entity: { type: 'Record', id: person1 },
                term: 'Dr. Sarah Chen',
                definition: 'Technical lead with expertise in graph algorithms and distributed systems',
                tags: ['demo', 'person'],
                worldId: demoWorldId
            });

            addDefinition({
                id: `${demoWorldId}_def_person2`,
                entity: { type: 'Record', id: person2 },
                term: 'Alex Morgan',
                definition: 'Engineer focused on frontend development and data visualization',
                tags: ['demo', 'person'],
                worldId: demoWorldId
            });

            addDefinition({
                id: `${demoWorldId}_def_person3`,
                entity: { type: 'Record', id: person3 },
                term: 'Jordan Kim',
                definition: 'Researcher specializing in knowledge management and ontology design',
                tags: ['demo', 'person'],
                worldId: demoWorldId
            });

            addDefinition({
                id: `${demoWorldId}_def_concept1`,
                entity: { type: 'Record', id: concept1 },
                term: 'Epistemic Observability',
                definition: 'Core principle: every data value should be traceable to its source and context',
                tags: ['demo', 'concept'],
                worldId: demoWorldId
            });

            addDefinition({
                id: `${demoWorldId}_def_concept4`,
                entity: { type: 'Record', id: concept4 },
                term: 'Knowledge Graph',
                definition: 'Semantic network representing entities and their relationships',
                tags: ['demo', 'concept'],
                worldId: demoWorldId
            });

            // Clear existing connections
            Array.from(state.connections.values())
                .filter(conn => conn.worldId === demoWorldId)
                .forEach(conn => state.connections.delete(conn.id));

            // Add connections: People own projects
            addConnection({
                id: `${demoWorldId}_conn_1`,
                subject: { type: 'Record', id: person1 },
                relationId: ownsRelationId,
                operand: { type: 'Record', id: proj1 },
                description: 'Sarah leads the Knowledge Graph project',
                worldId: demoWorldId
            });

            addConnection({
                id: `${demoWorldId}_conn_2`,
                subject: { type: 'Record', id: person1 },
                relationId: ownsRelationId,
                operand: { type: 'Record', id: proj2 },
                description: 'Sarah oversees Context Engine development',
                worldId: demoWorldId
            });

            addConnection({
                id: `${demoWorldId}_conn_3`,
                subject: { type: 'Record', id: person3 },
                relationId: ownsRelationId,
                operand: { type: 'Record', id: proj3 },
                description: 'Jordan leads Formula System research',
                worldId: demoWorldId
            });

            // Add connections: Tasks assigned to people
            addConnection({
                id: `${demoWorldId}_conn_4`,
                subject: { type: 'Record', id: task1 },
                relationId: assignedRelationId,
                operand: { type: 'Record', id: person1 },
                description: 'Node layout assigned to Sarah',
                worldId: demoWorldId
            });

            addConnection({
                id: `${demoWorldId}_conn_5`,
                subject: { type: 'Record', id: task2 },
                relationId: assignedRelationId,
                operand: { type: 'Record', id: person2 },
                description: 'Edge rendering assigned to Alex',
                worldId: demoWorldId
            });

            addConnection({
                id: `${demoWorldId}_conn_6`,
                subject: { type: 'Record', id: task3 },
                relationId: assignedRelationId,
                operand: { type: 'Record', id: person2 },
                description: 'Context tracker assigned to Alex',
                worldId: demoWorldId
            });

            addConnection({
                id: `${demoWorldId}_conn_7`,
                subject: { type: 'Record', id: task4 },
                relationId: assignedRelationId,
                operand: { type: 'Record', id: person3 },
                description: 'Formula parser assigned to Jordan',
                worldId: demoWorldId
            });

            addConnection({
                id: `${demoWorldId}_conn_8`,
                subject: { type: 'Record', id: task5 },
                relationId: assignedRelationId,
                operand: { type: 'Record', id: person3 },
                description: 'Database research assigned to Jordan',
                worldId: demoWorldId
            });

            // Add connections: Tasks part of projects
            addConnection({
                id: `${demoWorldId}_conn_9`,
                subject: { type: 'Record', id: task1 },
                relationId: partOfRelationId,
                operand: { type: 'Record', id: proj1 },
                description: 'Layout algorithm is part of Knowledge Graph',
                worldId: demoWorldId
            });

            addConnection({
                id: `${demoWorldId}_conn_10`,
                subject: { type: 'Record', id: task2 },
                relationId: partOfRelationId,
                operand: { type: 'Record', id: proj1 },
                description: 'Edge rendering is part of Knowledge Graph',
                worldId: demoWorldId
            });

            addConnection({
                id: `${demoWorldId}_conn_11`,
                subject: { type: 'Record', id: task3 },
                relationId: partOfRelationId,
                operand: { type: 'Record', id: proj2 },
                description: 'Context tracker is part of Context Engine',
                worldId: demoWorldId
            });

            addConnection({
                id: `${demoWorldId}_conn_12`,
                subject: { type: 'Record', id: task4 },
                relationId: partOfRelationId,
                operand: { type: 'Record', id: proj3 },
                description: 'Formula parser is part of Formula System',
                worldId: demoWorldId
            });

            addConnection({
                id: `${demoWorldId}_conn_13`,
                subject: { type: 'Record', id: task5 },
                relationId: partOfRelationId,
                operand: { type: 'Record', id: proj1 },
                description: 'Graph database research supports Knowledge Graph',
                worldId: demoWorldId
            });

            // Add connections: Projects implement concepts
            addConnection({
                id: `${demoWorldId}_conn_14`,
                subject: { type: 'Record', id: proj1 },
                relationId: implementsRelationId,
                operand: { type: 'Record', id: concept4 },
                description: 'Knowledge Graph project implements graph concepts',
                worldId: demoWorldId
            });

            addConnection({
                id: `${demoWorldId}_conn_15`,
                subject: { type: 'Record', id: proj2 },
                relationId: implementsRelationId,
                operand: { type: 'Record', id: concept1 },
                description: 'Context Engine implements epistemic observability',
                worldId: demoWorldId
            });

            addConnection({
                id: `${demoWorldId}_conn_16`,
                subject: { type: 'Record', id: proj3 },
                relationId: implementsRelationId,
                operand: { type: 'Record', id: concept3 },
                description: 'Formula System implements reactive formulas',
                worldId: demoWorldId
            });

            // Add connections: Task dependencies
            addConnection({
                id: `${demoWorldId}_conn_17`,
                subject: { type: 'Record', id: task2 },
                relationId: dependsRelationId,
                operand: { type: 'Record', id: task1 },
                description: 'Edge rendering depends on layout algorithm',
                worldId: demoWorldId
            });

            addConnection({
                id: `${demoWorldId}_conn_18`,
                subject: { type: 'Record', id: task5 },
                relationId: dependsRelationId,
                operand: { type: 'Record', id: task1 },
                description: 'Database research depends on layout design',
                worldId: demoWorldId
            });

            // Add connections: Concept relationships
            addConnection({
                id: `${demoWorldId}_conn_19`,
                subject: { type: 'Record', id: concept2 },
                relationId: relatesRelationId,
                operand: { type: 'Record', id: concept1 },
                description: 'Superposition requires epistemic observability',
                worldId: demoWorldId
            });

            addConnection({
                id: `${demoWorldId}_conn_20`,
                subject: { type: 'Record', id: concept4 },
                relationId: relatesRelationId,
                operand: { type: 'Record', id: concept1 },
                description: 'Knowledge graphs benefit from context tracking',
                worldId: demoWorldId
            });

            // DES (Designate) - Labeling/naming relationships
            addConnection({
                id: `${demoWorldId}_conn_21`,
                subject: { type: 'Record', id: concept1 },
                relationId: designatesRelationId,
                operand: { type: 'Record', id: proj2 },
                description: 'Epistemic Observability concept labels Context Engine project',
                worldId: demoWorldId
            });

            addConnection({
                id: `${demoWorldId}_conn_22`,
                subject: { type: 'Record', id: person1 },
                relationId: designatesRelationId,
                operand: { type: 'Record', id: task1 },
                description: 'Sarah labels design approach for node layout',
                worldId: demoWorldId
            });

            // INS (Instantiate) - Creation relationships
            addConnection({
                id: `${demoWorldId}_conn_23`,
                subject: { type: 'Record', id: proj1 },
                relationId: createsRelationId,
                operand: { type: 'Record', id: task1 },
                description: 'Knowledge Graph project creates layout algorithm task',
                worldId: demoWorldId
            });

            addConnection({
                id: `${demoWorldId}_conn_24`,
                subject: { type: 'Record', id: person3 },
                relationId: createsRelationId,
                operand: { type: 'Record', id: concept2 },
                description: 'Jordan creates superposition concept definition',
                worldId: demoWorldId
            });

            // ALT (Alternate) - State transition relationships
            addConnection({
                id: `${demoWorldId}_conn_25`,
                subject: { type: 'Record', id: proj1 },
                relationId: alternatesRelationId,
                operand: { type: 'Record', id: proj2 },
                description: 'Knowledge Graph and Context Engine alternate focus during development cycles',
                worldId: demoWorldId
            });

            addConnection({
                id: `${demoWorldId}_conn_26`,
                subject: { type: 'Record', id: task1 },
                relationId: alternatesRelationId,
                operand: { type: 'Record', id: task2 },
                description: 'Layout and rendering tasks toggle in priority',
                worldId: demoWorldId
            });

            // SUP (Superpose) - Parallel/layered value relationships
            addConnection({
                id: `${demoWorldId}_conn_27`,
                subject: { type: 'Record', id: concept2 },
                relationId: superposesRelationId,
                operand: { type: 'Record', id: concept3 },
                description: 'Superposition overlays with reactive formula pattern',
                worldId: demoWorldId
            });

            addConnection({
                id: `${demoWorldId}_conn_28`,
                subject: { type: 'Record', id: proj2 },
                relationId: superposesRelationId,
                operand: { type: 'Record', id: proj3 },
                description: 'Context Engine and Formula System maintain parallel development tracks',
                worldId: demoWorldId
            });

            // REC (Recurse) - Feedback loop relationships
            addConnection({
                id: `${demoWorldId}_conn_29`,
                subject: { type: 'Record', id: task3 },
                relationId: recursesRelationId,
                operand: { type: 'Record', id: concept1 },
                description: 'Context tracker feeds back into epistemic observability understanding',
                worldId: demoWorldId
            });

            addConnection({
                id: `${demoWorldId}_conn_30`,
                subject: { type: 'Record', id: proj1 },
                relationId: recursesRelationId,
                operand: { type: 'Record', id: concept4 },
                description: 'Knowledge Graph project iterates with knowledge graph concept',
                worldId: demoWorldId
            });

            // NUL (Null/Absence) - Detecting missing relationships
            addConnection({
                id: `${demoWorldId}_conn_31`,
                subject: { type: 'Record', id: task5 },
                relationId: nullRelationId,
                operand: { type: 'Record', id: proj3 },
                description: 'Database research detects absence of backend in Formula System',
                worldId: demoWorldId
            });

            addConnection({
                id: `${demoWorldId}_conn_32`,
                subject: { type: 'Record', id: concept3 },
                relationId: nullRelationId,
                operand: { type: 'Record', id: task5 },
                description: 'Reactive Formula concept flags missing implementation in database research',
                worldId: demoWorldId
            });

            // Create a graph view for this demo
            const graphViewId = createView(projectsId, 'Graph Demo', { type: 'graph' });

            state.currentSetId = projectsId;
            state.currentViewId = graphViewId;
            state.expandedSets.add(projectsId);
            state.expandedSets.add(peopleId);
            state.expandedSets.add(tasksId);
            state.expandedSets.add(conceptsId);
        }

        // WORLD & SET MANAGEMENT
        function createWorld(name, worldId = null) {
            const resolvedWorldId = worldId || ('world_' + Date.now());
            const defaults = seedWorldDefaults(resolvedWorldId);

            state.worlds.set(resolvedWorldId, {
                id: resolvedWorldId,
                name,
                setIds: new Set([defaults.locationsId, defaults.observationsId].filter(Boolean)),
                createdAt: new Date().toISOString(),
                defaults
            });
            return resolvedWorldId;
        }

        function getWorld(worldId = state.currentWorldId) {
            return worldId ? state.worlds.get(worldId) : null;
        }

        function getSetsForWorld(worldId = state.currentWorldId) {
            return Array.from(state.sets.values()).filter(set => set.worldId === worldId);
        }

        function createSet(name, icon = 'ph-squares-four', worldId = state.currentWorldId) {
            const resolvedWorldId = worldId || state.currentWorldId;
            const setId = 'set_' + Date.now();
            state.sets.set(setId, {
                id: setId,
                name: name,
                icon: icon,
                worldId: resolvedWorldId,
                schema: [],
                records: new Map(),
                views: new Map(),
                profiles: new Map([['default', { id: 'default', name: 'All Fields', visibleFields: [] }]])
            });
            registerEntity({ id: setId, type: 'Set', name, worldId: resolvedWorldId });
            const world = getWorld(resolvedWorldId);
            world?.setIds?.add(setId);
            createEvent(
                'Create Set',
                'INS',
                { type: 'Set', id: setId },
                { name, worldId: resolvedWorldId },
                { summary: `Created set "${name}"`, scale: 'collection' }
            );
            return setId;
        }

        function inferIdentifierFieldId(set) {
            if (!set?.schema) return null;

            const explicitName = set.schema.find(f => f.id === 'name' || (f.name || '').toLowerCase() === 'name');
            if (explicitName) return explicitName.id;

            const textLike = set.schema.find(f => ['TEXT', 'LONG_TEXT'].includes(f.type));
            if (textLike) return textLike.id;

            return set.schema[0]?.id || null;
        }

        function ensureViewColumnOrder(view, schema, includeRecordId = false) {
            if (!view || !schema) return [];

            const existingOrder = Array.isArray(view.columnOrder) ? view.columnOrder : [];
            const baseOrder = schema.map(f => f.id);
            const shouldTrackRecordId = includeRecordId || existingOrder.includes('__recordId');
            if (shouldTrackRecordId && !baseOrder.includes('__recordId')) baseOrder.unshift('__recordId');

            const mergedOrder = [
                ...existingOrder.filter(id => baseOrder.includes(id)),
                ...baseOrder.filter(id => !existingOrder.includes(id))
            ];

            view.columnOrder = mergedOrder;
            return mergedOrder;
        }

        function buildTableSchema(view, schema) {
            const columnOrder = ensureViewColumnOrder(view, schema, view?.showRecordId);
            const visibilitySet = new Set(view?.hiddenFields || []);

            const baseFields = columnOrder
                .filter(id => id !== '__recordId' || view?.showRecordId)
                .map(id => id === '__recordId' ? getRecordIdFieldDefinition() : schema.find(f => f.id === id))
                .filter(Boolean)
                .filter(field => !visibilitySet.has(field.id))
                .map(field => ({
                    ...field,
                    // Use view-specific display name if available, otherwise fall back to field name
                    name: view?.columnDisplayNames?.[field.id] || field.name
                }));

            // Add linked fields (lookups with optional rollup formulas) from view
            const linkedFields = [];

            // All lookups are in view.relationships - they may optionally have a rollupFormula
            // Filter out hidden lookups using the same visibilitySet
            if (view?.relationships && Array.isArray(view.relationships)) {
                view.relationships.forEach(rel => {
                    if (rel.type === 'lookup') {
                        // Skip if this lookup is hidden
                        if (visibilitySet.has(rel.id)) return;

                        // Determine field type based on whether rollupFormula is set
                        const fieldType = rel.rollupFormula ? 'LINKED_ROLLUP' : 'LINKED_LOOKUP';
                        linkedFields.push({
                            id: rel.id,
                            name: view?.columnDisplayNames?.[rel.id] || rel.displayName || `Linked: ${rel.targetFieldId}`,
                            type: fieldType,
                            _linkedConfig: {
                                ...rel,
                                // Map rollupFormula to aggregation for compatibility with rollup engine
                                aggregation: rel.rollupFormula || null
                            },
                            width: '150px'
                        });
                    }
                });
            }

            // Legacy support: Also check view.rollups for backward compatibility
            // Filter out hidden rollups using the same visibilitySet
            if (view?.rollups && Array.isArray(view.rollups)) {
                view.rollups.forEach(rollup => {
                    // Skip if this rollup is hidden
                    if (visibilitySet.has(rollup.id)) return;

                    linkedFields.push({
                        id: rollup.id,
                        name: view?.columnDisplayNames?.[rollup.id] || rollup.displayName || `Rollup: ${rollup.targetFieldId}`,
                        type: 'LINKED_ROLLUP',
                        _linkedConfig: rollup,
                        width: '150px'
                    });
                });
            }

            return [...baseFields, ...linkedFields];
        }

        function createView(setId, name, config = {}) {
            const viewId = 'view_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            const set = state.sets.get(setId);
            if (!set) {
                console.error(`createView: Set ${setId} not found`);
                return null;
            }
            // Ensure set.views is initialized (defensive check)
            if (!set.views) {
                set.views = new Map();
            }
            const defaultIdentifier = config.identifierField || inferIdentifierFieldId(set);
            const viewPayload = {
                id: viewId,
                setId,
                name: name,
                type: config.type || 'grid',
                icon: config.icon || VIEW_TYPE_ICONS[config.type || 'grid'] || '',
                filters: config.filters || [],
                sorts: config.sorts || [],
                hiddenFields: config.hiddenFields || [],
                popupVisibilityRules: config.popupVisibilityRules || [],
                popupLayout: config.popupLayout || { size: 'medium', columns: 4, rows: 4 },
                kanbanGroupField: config.kanbanGroupField || null,
                cardFields: config.cardFields || [],
                parentId: config.parentId || null,
                key: config.key || null,
                schema: config.schema || null,
                relationships: config.relationships || [],
                rollups: config.rollups || [],
                showRecordId: config.showRecordId || false,
                showRowNumbers: config.showRowNumbers !== undefined ? config.showRowNumbers : true,
                identifierField: defaultIdentifier,
                columnRules: config.columnRules || {},
                columnDisplayNames: config.columnDisplayNames || {},
                columnOrder: config.columnOrder || null,
                createdAt: Date.now(),
                createdBy: state.currentUser.id,
                isTemporary: config.isTemporary || false,
                importMetadata: config.importMetadata || null,
                // View mode: 'sandbox' for exploratory views, 'live' for curated/export-ready views
                viewMode: config.viewMode || 'live',
                // Pivot metadata for lineage tracking
                pivotMetadata: config.pivotMetadata || null
            };
            set.views.set(viewId, viewPayload);
            // Also add to global state.views for recent imports tracking
            if (!state.views) {
                state.views = new Map();
            }
            state.views.set(viewId, viewPayload);

            if (config.type === 'KEY_DERIVED') {
                createEvent(
                    'Create Key View',
                    'SYN',
                    { type: 'View', id: viewId, setId },
                    { view: viewPayload, summary: `Generated view "${name}" from identity property` },
                    { scale: 'collection' }
                );
            }

            return viewId;
        }

        /**
         * Add a new field to the current view's columnOrder
         * This ensures the field appears in the view immediately after creation
         */
        function addFieldToCurrentView(fieldId) {
            const view = getCurrentView();
            if (!view) return;

            // Initialize columnOrder if not present
            if (!Array.isArray(view.columnOrder)) {
                view.columnOrder = [];
            }

            // Add field to columnOrder if not already present
            if (!view.columnOrder.includes(fieldId)) {
                view.columnOrder.push(fieldId);
            }

            // Remove from hiddenFields if it was hidden
            if (Array.isArray(view.hiddenFields)) {
                const hiddenIndex = view.hiddenFields.indexOf(fieldId);
                if (hiddenIndex !== -1) {
                    view.hiddenFields.splice(hiddenIndex, 1);
                }
            }
        }

        /**
         * Add a new field to all views of a set
         * This ensures the field appears in all views of the set
         */
        function addFieldToAllViews(set, fieldId) {
            if (!set || !set.views) return;

            set.views.forEach((viewRef, viewId) => {
                // Get the full view object
                const view = typeof viewRef === 'object' && viewRef.id === viewId ? viewRef : set.views.get(viewId);
                if (!view) return;

                // Initialize columnOrder if not present
                if (!Array.isArray(view.columnOrder)) {
                    view.columnOrder = [];
                }

                // Add field to columnOrder if not already present
                if (!view.columnOrder.includes(fieldId)) {
                    view.columnOrder.push(fieldId);
                }

                // Remove from hiddenFields if it was hidden
                if (Array.isArray(view.hiddenFields)) {
                    const hiddenIndex = view.hiddenFields.indexOf(fieldId);
                    if (hiddenIndex !== -1) {
                        view.hiddenFields.splice(hiddenIndex, 1);
                    }
                }
            });
        }

        function reifyCurrentView() {
            const view = getCurrentView();
            if (!view) {
                showToast(' No active view to reify');
                return null;
            }
            const setId = state.currentSetId;
            return reifyView({ ...view, setId: view.setId || setId });
        }

        function reifyView(view) {
            if (!view) return null;

            const randomId = crypto.randomUUID ? crypto.randomUUID() : `${Date.now()}_${Math.random().toString(36).substr(2, 6)}`;
            const id = `entity_view_${randomId}`;
            const viewRef = {
                setId: view.setId || view.sourceSet || view.sourceSetId || null,
                viewId: view.id || view.key || view.name,
                viewName: view.name
            };
            const memberRefs = collectViewMembers(view);
            const viewWorldId = viewRef.setId ? state.sets.get(viewRef.setId)?.worldId : state.currentWorldId;
            const viewEntity = {
                id,
                type: 'ViewEntity',
                entityType: view.name || 'Reified View',
                viewRef,
                sourceSet: view.setId || view.sourceSet || null,
                memberRefs,
                origin: 'reified',
                worldId: viewWorldId,
                createdAt: Date.now()
            };

            registerEntity(viewEntity);

            addDefinition({
                id: `def_${id}`,
                entity: { type: 'ViewEntity', id },
                term: view.name || 'Reified View',
                definition: 'A view created from filters, groups, or aggregates.',
                notes: `Reified from view ${viewRef.viewName || viewRef.viewId || ''}`.trim(),
                tags: ['reified', 'view'],
                worldId: viewWorldId
            });

            const lineage = extractViewLineage(view, id);
            lineage.forEach(conn => addConnection(conn));

            showToast(` View reified as entity: ${id}`);
            return id;
        }

        function collectViewMembers(view) {
            if (!view) return [];
            const setId = view.setId || view.sourceSet || view.sourceSetId || null;
            const set = setId ? state.sets.get(setId) : null;
            if (!set) return [];

            let records = Array.from(set.records.values());
            if (Array.isArray(view.filters) && view.filters.length > 0) records = applyFilterGroups(records, view.filters, set.schema);
            if (Array.isArray(view.sorts) && view.sorts.length > 0) records = applySorts(records, view.sorts, set.schema);

            return records.map(record => ({ type: 'Record', id: record.id, setId: set.id }));
        }

        function extractViewLineage(view, newEntityId) {
            const list = [];
            const sourceSetId = view.setId || view.sourceSet || view.sourceSetId || null;
            const idFactory = () => `conn_${crypto.randomUUID ? crypto.randomUUID() : `${Date.now()}_${Math.random().toString(36).substr(2, 6)}`}`;

            if (Array.isArray(view.filters)) {
                view.filters.forEach(filter => {
                    if (!filter?.fieldId) return;
                    list.push({
                        id: idFactory(),
                        subject: { type: 'Field', id: filter.fieldId },
                        operator: 'SEG',
                        mode: 'filters by',
                        operand: { type: 'ViewEntity', id: newEntityId },
                        description: 'View generated by filtering',
                        params: filter
                    });
                });
            }

            if (Array.isArray(view.groupBy)) {
                view.groupBy.forEach(group => {
                    if (!group?.fieldId) return;
                    list.push({
                        id: idFactory(),
                        subject: { type: 'Field', id: group.fieldId },
                        operator: 'SEG',
                        mode: 'groups by',
                        operand: { type: 'ViewEntity', id: newEntityId },
                        description: 'View grouped by field',
                        params: group
                    });
                });
            }

            if (Array.isArray(view.aggregationRules)) {
                view.aggregationRules.forEach(rule => {
                    list.push({
                        id: idFactory(),
                        subject: { type: 'Set', id: sourceSetId },
                        operator: 'SYN',
                        mode: 'aggregates into',
                        operand: { type: 'ViewEntity', id: newEntityId },
                        description: 'Aggregated fields/materialized view',
                        params: rule
                    });
                });
            }

            if (view.pivotField) {
                list.push({
                    id: idFactory(),
                    subject: { type: 'Field', id: view.pivotField },
                    operator: 'SUP',
                    mode: 'superposes over',
                    operand: { type: 'ViewEntity', id: newEntityId },
                    description: 'View pivoted on field',
                    params: {}
                });
            }

            return list;
        }

        function scoreKeyCandidate(set, fieldId, fieldName, fieldType = 'TEXT') {
            let score = 0;
            if (fieldType === 'LINK_RECORD') score += 0.35;

            const values = Array.from(set.records.values()).map(r => r[fieldId]).filter(v => v !== undefined && v !== null);
            if (values.length > 0) {
                const unique = new Set(values.map(v => JSON.stringify(v))).size;
                const reuseRatio = 1 - unique / values.length;
                score += reuseRatio * 0.4;
            }

            for (const otherSet of getSetsForWorld(set.worldId)) {
                if (otherSet.id === set.id) continue;
                const overlap = otherSet.schema.some(f => f.id === fieldId || f.name === fieldName || f.name === fieldId);
                const dataOverlap = Array.from(otherSet.records.values()).some(r => r[fieldId] !== undefined);
                if (overlap || dataOverlap) score += 0.15;
            }

            score = Math.min(1, score);
            return { score };
        }

        function scoreFieldAsKey(set, field) {
            return scoreKeyCandidate(set, field.id, field.name, field.type);
        }

        function findLooseKeyCandidates(set) {
            const schemaFieldIds = new Set(set.schema.map(f => f.id));
            const counts = new Map();

            set.records.forEach(record => {
                Object.keys(record || {}).forEach(fieldId => {
                    if (fieldId === 'id' || schemaFieldIds.has(fieldId)) return;
                    counts.set(fieldId, (counts.get(fieldId) || 0) + 1);
                });
            });

            const totalRecords = Math.max(set.records.size, 1);
            return [...counts.entries()]
                .map(([fieldId, count]) => ({
                    fieldId,
                    fieldName: fieldId,
                    score: Math.min(1, count / totalRecords)
                }))
                .filter(candidate => candidate.score > 0.6);
        }

        function findKeyCandidates() {
            const candidates = new Map();

            const isValueField = (field) => (field.id?.toLowerCase() === 'value' || field.name?.toLowerCase() === 'value');

            const addCandidate = (setId, fieldId, fieldName, score) => {
                if (!fieldId) return;
                const key = `${setId}:${fieldId}`;
                const existing = candidates.get(key);
                if (!existing || score > existing.score) {
                    candidates.set(key, { setId, fieldId, fieldName, score });
                }
            };

            getSetsForWorld().forEach(set => {
                const setId = set.id;
                set.schema.forEach(field => {
                    const usage = scoreFieldAsKey(set, field);
                    if (usage.score > 0.6) {
                        addCandidate(setId, field.id, field.name, usage.score);
                    }
                });

                const valueField = set.schema.find(isValueField);
                if (valueField) {
                    const values = Array.from(set.records.values())
                        .map(r => r[valueField.id])
                        .filter(v => v !== undefined && v !== null && v !== '');
                    if (values.length > 0) {
                        const unique = new Set(values.map(v => JSON.stringify(v))).size;
                        const reuseRatio = 1 - unique / values.length;
                        const score = Math.min(1, Math.max(0.65, reuseRatio * 0.8 + 0.2));
                        addCandidate(setId, valueField.id, valueField.name || valueField.id, score);
                    }
                }

                set.views.forEach(view => {
                    if (!Array.isArray(view.schema)) return;
                    view.schema.forEach(field => {
                        const sourceFieldId = field.sourceFieldId || field.id;
                        const usage = scoreKeyCandidate(set, sourceFieldId, field.name || sourceFieldId, field.type);
                        if (usage.score > 0.6) {
                            addCandidate(setId, sourceFieldId, field.name || sourceFieldId, usage.score);
                        }
                    });
                });

                findLooseKeyCandidates(set).forEach(candidate => {
                    addCandidate(setId, candidate.fieldId, candidate.fieldName, candidate.score);
                });
            });

            return [...candidates.values()].sort((a, b) => b.score - a.score);
        }

        function getAllFieldsForPivot() {
            const fields = [];
            const seen = new Set();
            const recommendedKeys = new Set(findKeyCandidates().map(c => `${c.setId}:${c.fieldId}`));

            getSetsForWorld().forEach(set => {
                if (!set || !set.schema) return;
                const setId = set.id;
                const setName = set.name || 'Untitled Set';

                set.schema.forEach(field => {
                    if (!field || !field.id) return;
                    const key = `${setId}:${field.id}`;
                    if (seen.has(key)) return;
                    seen.add(key);

                    const isRecommended = recommendedKeys.has(key);
                    const { score } = scoreFieldAsKey(set, field);

                    fields.push({
                        setId,
                        setName,
                        fieldId: field.id,
                        fieldName: field.name || field.id,
                        fieldType: field.type,
                        score,
                        isRecommended
                    });
                });
            });

            // Sort: recommended first, then by score, then alphabetically
            fields.sort((a, b) => {
                if (a.isRecommended !== b.isRecommended) return b.isRecommended ? 1 : -1;
                if (Math.abs(a.score - b.score) > 0.1) return b.score - a.score;
                return a.fieldName.localeCompare(b.fieldName);
            });

            return fields;
        }

        function findFieldAcrossSets(fieldId) {
            for (const set of getSetsForWorld()) {
                const setId = set.id;
                const schemaField = set.schema.find(f => f.id === fieldId);
                if (schemaField) return { setId, field: schemaField };

                for (const view of set.views.values()) {
                    if (!Array.isArray(view.schema)) continue;
                    const viewField = view.schema.find(f => f.id === fieldId || f.sourceFieldId === fieldId);
                    if (viewField) return { setId, field: viewField };
                }
            }
            return null;
        }

        function findAllItemsForKey(setId, fieldId) {
            const results = [];

            const worldId = state.sets.get(setId)?.worldId || state.currentWorldId;
            getSetsForWorld(worldId).forEach(set => {
                set.records.forEach((record, id) => {
                    if (record[fieldId] !== null && record[fieldId] !== undefined) {
                        results.push({ setId: set.id, recordId: id, record });
                    }
                });
            });

            return results;
        }

        function buildPropertyInventory(items, keyFieldId) {
            const propertyCount = new Map();

            items.forEach(({ record }) => {
                Object.keys(record).forEach(fieldId => {
                    if (fieldId === keyFieldId) return;
                    propertyCount.set(fieldId, (propertyCount.get(fieldId) || 0) + 1);
                });
            });

            return [...propertyCount.entries()]
                .filter(([_, count]) => count / Math.max(items.length, 1) > 0.2)
                .map(([f]) => f);
        }

        function detectRelationships(propertyIds) {
            return propertyIds
                .map(fieldId => {
                    const hit = findFieldAcrossSets(fieldId);
                    if (!hit) return null;
                    if (hit.field.type === 'LINK_RECORD') {
                        return { fieldId, setId: hit.setId, type: 'link' };
                    }
                    if (Array.isArray(hit.field.defaultValue)) {
                        return { fieldId, setId: hit.setId, type: 'array' };
                    }
                    return null;
                })
                .filter(Boolean);
        }

        function detectRollups(keyRef) {
            const rollups = [];
            const worldId = state.sets.get(keyRef.setId)?.worldId || state.currentWorldId;
            getSetsForWorld(worldId).forEach(set => {
                const setId = set.id;
                const hasReference = set.schema.some(f => f.id === keyRef.fieldId || f.name === keyRef.fieldId || f.config?.linkedSetId === keyRef.setId);
                if (hasReference) {
                    rollups.push({
                        type: 'count',
                        fromSetId: setId,
                        fieldId: keyRef.fieldId,
                        label: `Count of ${set.name} where ${keyRef.fieldId} matches`
                    });
                }
            });
            return rollups;
        }

        function autoDetectSchemaFromKey(keyRef) {
            const allItems = findAllItemsForKey(keyRef.setId, keyRef.fieldId);
            const propertyIds = buildPropertyInventory(allItems, keyRef.fieldId);
            const relationships = detectRelationships(propertyIds);
            const rollups = detectRollups(keyRef);

            const schema = propertyIds.map(propId => {
                const match = findFieldAcrossSets(propId);
                return {
                    id: `derived_${propId}`,
                    sourceFieldId: propId,
                    sourceSetId: match?.setId || null,
                    name: match?.field?.name || propId,
                    type: match?.field?.type || 'TEXT'
                };
            });

            return { schema, relationships, rollups };
        }

        function groupByKeyValue(items, keyFieldId) {
            const grouped = new Map();
            items.forEach(item => {
                const key = item.record[keyFieldId];
                if (key === undefined || key === null) return;
                if (!grouped.has(key)) grouped.set(key, []);
                grouped.get(key).push(item);
            });
            return grouped;
        }

        function applyColumnRule(values, ruleConfig = {}) {
            if (!values || values.length === 0) return null;
            const uniqueValues = values.filter(v => v !== undefined && v !== null);
            if (uniqueValues.length === 0) return null;
            const rule = ruleConfig.rule || 'sup_all';

            switch (rule) {
                case 'prefer_newest':
                    return uniqueValues[uniqueValues.length - 1];
                case 'prefer_oldest':
                    return uniqueValues[0];
                case 'prefer_set':
                    if (ruleConfig.setId) {
                        const found = uniqueValues.find(v => v && v.__sourceSetId === ruleConfig.setId);
                        if (found !== undefined) return found;
                    }
                    return uniqueValues[0];
                case 'average_numeric':
                    const nums = uniqueValues.map(Number).filter(n => !Number.isNaN(n));
                    return nums.length ? nums.reduce((a, b) => a + b, 0) / nums.length : null;
                case 'median_numeric':
                    const sorted = uniqueValues.map(Number).filter(n => !Number.isNaN(n)).sort((a, b) => a - b);
                    if (!sorted.length) return null;
                    const mid = Math.floor(sorted.length / 2);
                    return sorted.length % 2 ? sorted[mid] : (sorted[mid - 1] + sorted[mid]) / 2;
                case 'concat_text':
                    return uniqueValues.join(', ');
                case 'first_non_null':
                    return uniqueValues.find(v => v !== null && v !== undefined);
                case 'sup_all':
                default:
                    return {
                        value: uniqueValues.map(val => {
                            const rawVal = typeof val === 'object' && val !== null && !Array.isArray(val) ? val : { val };
                            const actualValue = rawVal.val !== undefined ? rawVal.val : val;
                            const sourceSetId = rawVal.__sourceSetId;
                            const sourceSet = sourceSetId ? state.sets.get(sourceSetId) : null;
                            return {
                                val: actualValue,
                                context: {
                                    method: 'aggregated',
                                    scale: 'individual',
                                    source: sourceSet?.name || sourceSetId || 'unknown'
                                }
                            };
                        }),
                        _sup: true
                    };
            }
        }

        function buildRowsFromGroups(grouped, view) {
            const rows = [];
            grouped.forEach((items, keyValue) => {
                const row = { id: `key_${keyValue}`, keyValue, __sourceItems: items };
                (view.schema || []).forEach(field => {
                    const values = items.map(item => {
                        const raw = item.record[field.sourceFieldId || field.id];
                        if (raw && typeof raw === 'object' && !raw.__sourceSetId) {
                            return { ...raw, __sourceSetId: item.setId };
                        }
                        if (raw !== undefined && raw !== null) {
                            return typeof raw === 'object' ? { ...raw, __sourceSetId: item.setId } : raw;
                        }
                        return undefined;
                    }).filter(v => v !== undefined);
                    row[field.id] = applyColumnRule(values, view.columnRules?.[field.id]);
                });
                rows.push(row);
            });
            return rows;
        }

        function addRecord(setId, data) {
            const set = state.sets.get(setId);
            const recordId = 'rec_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            const record = { id: recordId, ...data };
            set.records.set(recordId, record);
            registerEntity({ id: recordId, type: 'Record', setId, data, createdAt: new Date().toISOString() });
            createEvent(
                'Create Record',
                'INS',
                { type: 'Record', id: recordId, setId },
                { setId, recordId, data, summary: 'Created record' }
            );
            return recordId;
        }

        function getRecordById(recordId) {
            // First check current world's sets
            for (const set of getSetsForWorld()) {
                if (set.records.has(recordId)) {
                    return { setId: set.id, set, record: set.records.get(recordId) };
                }
            }
            // Fall back to searching all sets across all worlds
            for (const set of state.sets.values()) {
                if (set.records.has(recordId)) {
                    return { setId: set.id, set, record: set.records.get(recordId) };
                }
            }
            return null;
        }

        function getLinkedSet(field) {
            const linkedSetId = field?.config?.linkedSetId;
            if (!linkedSetId) return null;
            return state.sets.get(linkedSetId) || null;
        }

        function getLinkedRecordOptions(field) {
            const linkedSet = getLinkedSet(field);
            return linkedSet ? Array.from(linkedSet.records.values()) : [];
        }

        function createLinkedRecordOptionList(field) {
            const options = getLinkedRecordOptions(field);
            const linkedSet = getLinkedSet(field);
            return options.map(opt => ({
                id: opt.id,
                label: opt.name || getRecordDisplayName(opt.id) || linkedSet?.name || 'Record'
            }));
        }

        // CSV IMPORT & FUZZY MATCHING
        const CREATE_FIELD_PREFIX = '__create__';
        const CSV_FIELD_MATCH_THRESHOLD = 0.75;

        function slugifyFieldId(name) {
            return (name || '').toLowerCase()
                .replace(/[^a-z0-9]/g, '_')
                .replace(/_+/g, '_')
                .replace(/^_+|_+$/g, '') || 'field';
        }

        function isCreateFieldValue(value) {
            return typeof value === 'string' && value.startsWith(CREATE_FIELD_PREFIX);
        }

        function buildCreateFieldValue(header) {
            return `${CREATE_FIELD_PREFIX}${slugifyFieldId(header)}`;
        }

        function findBestFieldMatch(header, schema) {
            const target = (header || '').trim();
            let best = null;
            schema.forEach(field => {
                const score = Math.max(
                    similarityScore(target, field.name),
                    similarityScore(target, field.id)
                );
                if (!best || score > best.score) {
                    best = { field, score };
                }
            });
            return best;
        }

        function resetCsvImportState() {
            const defaultSetId = state.currentSetId || Array.from(state.sets.keys())[0] || null;
            state.csvImportState = {
                headers: [],
                rows: [],
                mappings: {},
                previewRows: [],
                matches: [],
                targetMode: defaultSetId ? 'existing' : 'new',
                targetSetId: defaultSetId,
                newSetName: ''
            };
            const badge = document.getElementById('csvRowCountBadge');
            if (badge) badge.textContent = '0 rows';
            const mappingEl = document.getElementById('csvMappingContainer');
            if (mappingEl) mappingEl.innerHTML = '<p class="text-sm text-gray-500">Load a CSV file or paste CSV text to start mapping.</p>';
            const previewEl = document.getElementById('csvPreviewContainer');
            if (previewEl) previewEl.innerHTML = '<p class="text-sm text-gray-500">Preview will appear after parsing.</p>';
            const matchesEl = document.getElementById('csvMatchSuggestions');
            if (matchesEl) matchesEl.innerHTML = '<p class="text-sm text-gray-500">No suggestions yet.</p>';
            const textInput = document.getElementById('csvTextInput');
            if (textInput) textInput.value = '';
            const fileInput = document.getElementById('csvFileInput');
            if (fileInput) fileInput.value = '';
            populateCsvTargetSetOptions();
            syncCsvImportTargetUi();
        }

        function populateCsvTargetSetOptions() {
            const select = document.getElementById('csvTargetSetSelect');
            if (!select) return;
            const options = getSetsForWorld().map(set => `<option value="${set.id}">${set.name}</option>`);
            if (!options.length) {
                select.innerHTML = '<option value="" disabled>No sets available</option>';
                select.value = '';
                state.csvImportState.targetSetId = null;
                return;
            }
            select.innerHTML = options.join('');
            const desired = state.csvImportState.targetSetId || state.currentSetId || select.options[0]?.value || '';
            select.value = desired;
            state.csvImportState.targetSetId = select.value || null;
        }

        function syncCsvImportTargetUi() {
            const mode = state.csvImportState.targetMode;
            document.querySelectorAll('input[name="csvImportTargetMode"]').forEach(input => {
                input.checked = input.value === mode;
            });
            document.getElementById('csvExistingSetPicker')?.classList.toggle('hidden', mode !== 'existing');
            document.getElementById('csvNewSetFields')?.classList.toggle('hidden', mode !== 'new');
            const select = document.getElementById('csvTargetSetSelect');
            if (select && mode === 'existing') select.value = state.csvImportState.targetSetId || '';
            const nameInput = document.getElementById('csvNewSetName');
            if (nameInput && mode === 'new') nameInput.value = state.csvImportState.newSetName || '';
        }

        function getCsvTargetSet() {
            if (state.csvImportState.targetMode === 'existing') {
                const setId = state.csvImportState.targetSetId || state.currentSetId;
                return setId ? state.sets.get(setId) : null;
            }
            return {
                id: null,
                name: state.csvImportState.newSetName?.trim() || 'New Set',
                schema: [],
                records: new Map()
            };
        }

        function handleCsvTargetChange() {
            populateCsvTargetSetOptions();
            syncCsvImportTargetUi();
            if (state.csvImportState.headers.length) {
                const set = getCsvTargetSet();
                state.csvImportState.mappings = autoMapColumns(state.csvImportState.headers, set);
                renderCsvMapping();
                renderCsvPreview();
                renderCsvMatches();
            }
        }

        function openCsvImportModal(targetSetId = null) {
            resetCsvImportState();
            if (targetSetId) {
                state.csvImportState.targetMode = 'existing';
                state.csvImportState.targetSetId = targetSetId;
                populateCsvTargetSetOptions();
                syncCsvImportTargetUi();
            }
            openModal('csvImportModal');
        }

        function handleCsvFileSelected(event) {
            const file = event.target.files?.[0];
            if (!file) return;
            const targetSet = getCsvTargetSet();
            if (!targetSet) {
                showToast(' Choose a destination set first');
                event.target.value = '';
                return;
            }
            const reader = new FileReader();
            reader.onload = (e) => {
                const csvText = e.target.result || '';
                const { headers, rows } = parseCsvContent(csvText);

                // Extract provenance in background but don't show modal
                if (window.EOProvenanceExtractor) {
                    const extractor = new EOProvenanceExtractor();
                    const provenance = extractor.extractFullProvenance(file, csvText, headers, rows);

                    // Store provenance for optional review in import modal
                    state.csvImportState.provenance = provenance;
                    state.csvImportState.filename = file.name;
                    state.csvImportState.file = file;
                }

                // Go directly to field mapping
                handleCsvData(headers, rows);
            };
            reader.readAsText(file);
        }

        // PROVENANCE REVIEW MODAL FUNCTIONS

        function showProvenanceReviewModal(provenance, onContinue) {
            // Store the continuation callback
            state.csvImportState.provenanceContinueCallback = onContinue;

            // Populate modal fields with extracted provenance
            populateProvenanceModal(provenance);

            // Show the modal
            openModal('provenanceReviewModal');
        }

        function populateProvenanceModal(provenance) {
            const { file, filename, inferred, confidence, embedded, schema } = provenance;

            // Set filename
            document.getElementById('provenanceFilename').textContent = file.filename || '';

            // High confidence inferences
            if (inferred.sourceSystem) {
                document.getElementById('provenanceSourceSystem').value = inferred.sourceSystem.name || '';
                const confPercent = Math.round((confidence.sourceSystem || 0) * 100);
                document.getElementById('provenanceSourceSystemConfidence').textContent = `${confPercent}% confidence`;
            } else {
                document.getElementById('provenanceSourceSystem').value = '';
                document.getElementById('provenanceSourceSystemConfidence').textContent = '';
            }

            document.getElementById('provenanceDataType').value = inferred.dataType || '';

            // Method
            const methodSelect = document.getElementById('provenanceMethod');
            if (inferred.method && inferred.method.name) {
                methodSelect.value = inferred.method.name;
            }

            // Timeframe
            if (inferred.timeframe) {
                document.getElementById('provenanceTimeframeStart').value = inferred.timeframe.start || '';
                document.getElementById('provenanceTimeframeEnd').value = inferred.timeframe.end || '';
            } else {
                document.getElementById('provenanceTimeframeStart').value = '';
                document.getElementById('provenanceTimeframeEnd').value = '';
            }

            // Medium confidence: Jurisdiction
            if (inferred.jurisdiction && inferred.jurisdiction.name) {
                const jurisdictionValue = inferred.jurisdiction.name.toLowerCase().replace(/\s+/g, '_');
                const jurisdictionRadio = document.querySelector(`input[name="provenanceJurisdiction"][value="${jurisdictionValue}"]`);
                if (jurisdictionRadio) {
                    jurisdictionRadio.checked = true;
                } else {
                    document.querySelector('input[name="provenanceJurisdiction"][value="auto"]').checked = true;
                }
            } else {
                document.querySelector('input[name="provenanceJurisdiction"][value="auto"]').checked = true;
            }

            // Scale
            if (inferred.scale && inferred.scale.name) {
                const scaleRadio = document.querySelector(`input[name="provenanceScale"][value="${inferred.scale.name}"]`);
                if (scaleRadio) {
                    scaleRadio.checked = true;
                }
            }

            // Frame
            const frameSelect = document.getElementById('provenanceFrame');
            if (inferred.frame && inferred.frame.name) {
                frameSelect.value = inferred.frame.name;
            } else {
                frameSelect.value = '';
            }

            // External links
            if (inferred.externalLinks && inferred.externalLinks.length > 0) {
                const link = inferred.externalLinks[0];
                document.getElementById('provenanceExternalLinksContainer').classList.remove('hidden');
                document.getElementById('provenanceExternalLinkText').textContent =
                    `Detected ID column: "${link.idColumn}" (${link.system})`;
            } else {
                document.getElementById('provenanceExternalLinksContainer').classList.add('hidden');
            }

            // Build summary
            const summaryEl = document.getElementById('provenanceSummary');
            const summaryItems = [];

            if (schema.externalIds && schema.externalIds.length > 0) {
                summaryItems.push(` Found ${schema.externalIds.length} external ID column(s)`);
            }
            if (schema.timestamps && schema.timestamps.length > 0) {
                summaryItems.push(` Found ${schema.timestamps.length} timestamp column(s)`);
            }
            if (schema.definitionColumns && schema.definitionColumns.length > 0) {
                summaryItems.push(` Found ${schema.definitionColumns.length} definition column(s)`);
            }
            if (embedded && Object.keys(embedded).length > 0) {
                summaryItems.push(` Extracted ${Object.keys(embedded).length} embedded metadata field(s)`);
            }

            summaryEl.innerHTML = summaryItems.length > 0
                ? summaryItems.join('<br>')
                : ' No special markers detected';
        }

        function captureProvenanceEdits() {
            // Capture user edits from the modal
            const edits = {
                sourceSystem: document.getElementById('provenanceSourceSystem').value.trim() || null,
                dataType: document.getElementById('provenanceDataType').value.trim() || null,
                method: document.getElementById('provenanceMethod').value || null,
                timeframe: {
                    start: document.getElementById('provenanceTimeframeStart').value || null,
                    end: document.getElementById('provenanceTimeframeEnd').value || null
                },
                jurisdiction: document.querySelector('input[name="provenanceJurisdiction"]:checked')?.value || 'auto',
                scale: document.querySelector('input[name="provenanceScale"]:checked')?.value || 'individual',
                frame: document.getElementById('provenanceFrame').value || null,
                authority: document.getElementById('provenanceAuthority').value.trim() || null,
                trustLevel: document.querySelector('input[name="provenanceTrustLevel"]:checked')?.value || 'authoritative',
                externalLink: {
                    enabled: document.getElementById('provenanceEnableExternalLink')?.checked || false,
                    url: document.getElementById('provenanceExternalLinkUrl')?.value.trim() || null
                }
            };

            // Handle custom frame
            if (edits.frame === 'custom') {
                edits.frame = document.getElementById('provenanceFrameCustom').value.trim() || null;
            }

            return edits;
        }

        function closeProvenanceReviewModal() {
            closeModal('provenanceReviewModal');
            // Clear the callback
            state.csvImportState.provenanceContinueCallback = null;
        }

        function continueToColumnMapping() {
            // Capture edits
            const edits = captureProvenanceEdits();
            state.csvImportState.provenanceEdits = edits;

            // Close provenance modal
            closeModal('provenanceReviewModal');

            // Execute the continuation callback
            if (state.csvImportState.provenanceContinueCallback) {
                state.csvImportState.provenanceContinueCallback();
            }
        }

        function skipProvenanceReview() {
            // Use default/auto-detected values
            state.csvImportState.provenanceEdits = {};

            // Close provenance modal
            closeModal('provenanceReviewModal');

            // Execute the continuation callback
            if (state.csvImportState.provenanceContinueCallback) {
                state.csvImportState.provenanceContinueCallback();
            }
        }

        function previewCsvFromText() {
            const text = document.getElementById('csvTextInput')?.value || '';
            const targetSet = getCsvTargetSet();
            if (!targetSet) {
                showToast(' Choose a destination set first');
                return;
            }
            const { headers, rows } = parseCsvContent(text);
            handleCsvData(headers, rows);
        }

        function parseCsvContent(text) {
            if (!text || !text.trim()) return { headers: [], rows: [] };
            const rows = [];
            let current = '';
            let inQuotes = false;
            const result = [];
            for (let i = 0; i < text.length; i++) {
                const char = text[i];
                const nextChar = text[i + 1];
                if (char === '"') {
                    if (inQuotes && nextChar === '"') {
                        current += '"';
                        i++;
                    } else {
                        inQuotes = !inQuotes;
                    }
                } else if (char === ',' && !inQuotes) {
                    rowPush(current);
                } else if ((char === '\n' || char === '\r') && !inQuotes) {
                    rowPush(current);
                    if (result.length) rows.push(result.splice(0));
                } else {
                    current += char;
                }
            }
            rowPush(current);
            if (result.length) rows.push(result);

            function rowPush(value) {
                result.push(value.trim());
                current = '';
            }

            const headers = rows.shift() || [];
            const normalizedRows = rows.filter(r => r.length && r.some(cell => cell !== '')).map(r => {
                const obj = {};
                headers.forEach((h, idx) => obj[h] = r[idx] || '');
                return obj;
            });
            return { headers, rows: normalizedRows };
        }

        function autoMapColumns(headers, set) {
            const mappings = {};
            const schema = set?.schema || [];
            headers.forEach(h => {
                const match = findBestFieldMatch(h, schema);
                if (match && match.score >= CSV_FIELD_MATCH_THRESHOLD) {
                    mappings[h] = match.field.id;
                } else {
                    mappings[h] = buildCreateFieldValue(h);
                }
            });
            return mappings;
        }

        function handleCsvData(headers, rows) {
            const set = getCsvTargetSet();
            if (state.csvImportState.targetMode === 'existing' && !set) {
                showToast(' Choose a destination set first');
                return;
            }
            state.csvImportState.headers = headers;
            state.csvImportState.rows = rows;
            state.csvImportState.mappings = autoMapColumns(headers, set);
            const badge = document.getElementById('csvRowCountBadge');
            if (badge) badge.textContent = `${rows.length} rows`;

            // Run robust type detection
            runTypeDetection(headers, rows);

            renderCsvMapping();
            renderCsvPreview();
            renderCsvMatches();
            renderTypeAssessment();
            populateSimplifiedProvenance();
        }

        /**
         * Run type detection on CSV data
         */
        function runTypeDetection(headers, rows) {
            if (!window.EOTypeDetector) {
                console.warn('EOTypeDetector not available');
                state.csvImportState.typeAssessment = null;
                return;
            }

            try {
                const detector = new EOTypeDetector({
                    confidenceThreshold: 0.7
                });

                // Convert rows to the format expected by the detector
                const rowObjects = rows.map(row => {
                    const obj = {};
                    headers.forEach((h, i) => {
                        obj[h] = Array.isArray(row) ? row[i] : row[h];
                    });
                    return obj;
                });

                // Run detection
                const detectionResults = detector.analyzeDataset(rowObjects, headers);
                const assessment = detector.createTypeAssessment(detectionResults);

                // Store in state
                state.csvImportState.typeAssessment = assessment;
                state.csvImportState.typeDetectionResults = detectionResults;

            } catch (err) {
                console.error('Type detection error:', err);
                state.csvImportState.typeAssessment = null;
            }
        }

        /**
         * Render type assessment UI
         */
        function renderTypeAssessment() {
            const card = document.getElementById('typeAssessmentCard');
            const container = document.getElementById('typeAssessmentContainer');
            const summaryEl = document.getElementById('typeAssessmentSummary');
            const assessment = state.csvImportState.typeAssessment;

            if (!card || !container) return;

            // Hide card if no assessment or importing to existing set with schema
            if (!assessment || state.csvImportState.targetMode === 'existing') {
                card.style.display = 'none';
                return;
            }

            card.style.display = 'block';

            // Update summary
            if (summaryEl) {
                const s = assessment.summary;
                summaryEl.innerHTML = `
                    <span class="text-green-600">${s.highConfidence} high</span> 
                    <span class="text-amber-600">${s.mediumConfidence} medium</span> 
                    <span class="text-red-600">${s.lowConfidence} low</span>
                `;
            }

            // Render each field
            const html = state.csvImportState.headers.map(header => {
                const field = assessment.fields[header];
                if (!field) return '';

                const confidenceClass = field.confidenceLevel === 'high' ? 'confidence-high' :
                                         field.confidenceLevel === 'medium' ? 'confidence-medium' : 'confidence-low';
                const confidencePercent = Math.round(field.confidence * 100);

                // Get type color and icon
                const typeInfo = getTypeDisplayInfo(field.detectedType);

                // Get sample values
                const results = state.csvImportState.typeDetectionResults?.[header];
                const samples = results?.samples || [];
                const sampleText = samples.slice(0, 2).join(', ');

                // Build alternatives chips
                const altsHtml = (field.alternatives || []).slice(0, 2).map(alt =>
                    `<span class="type-alternative-chip" onclick="applyTypeOverride('${header}', '${alt.type}')" title="${alt.reason || ''}">${alt.type}</span>`
                ).join('');

                return `
                    <div class="type-assessment-row ${field.needsReview ? 'needs-review' : ''}" data-field="${header}">
                        <div class="type-assessment-field-name">${header}</div>
                        <div class="type-assessment-confidence ${confidenceClass}">
                            <div class="confidence-bar"><div class="confidence-bar-fill" style="width: ${confidencePercent}%"></div></div>
                            <span>${confidencePercent}%</span>
                        </div>
                        <div class="type-assessment-samples" title="${sampleText}">${sampleText || ''}</div>
                        <div style="position: relative;">
                            <div class="type-assessment-type" style="background: ${typeInfo.bgColor}; color: ${typeInfo.textColor};" onclick="toggleTypeDropdown('${header}')">
                                <i class="ph ${typeInfo.icon}"></i>
                                ${field.detectedType}${field.detectedSubtype ? ` (${field.detectedSubtype})` : ''}
                            </div>
                            <div id="typeDropdown_${header}" class="type-dropdown" style="display: none;"></div>
                        </div>
                        ${altsHtml ? `<div class="type-alternatives">${altsHtml}</div>` : ''}
                    </div>
                `;
            }).join('');

            container.innerHTML = html || '<p class="text-sm text-gray-500">No fields to assess.</p>';
        }

        /**
         * Get display info for a field type
         */
        function getTypeDisplayInfo(type) {
            const typeMap = {
                'TEXT': { icon: 'ph-text-t', bgColor: '#f1f5f9', textColor: '#475569' },
                'NUMBER': { icon: 'ph-hash', bgColor: '#dbeafe', textColor: '#1d4ed8' },
                'CURRENCY': { icon: 'ph-currency-dollar', bgColor: '#dcfce7', textColor: '#15803d' },
                'DATE': { icon: 'ph-calendar', bgColor: '#fef3c7', textColor: '#b45309' },
                'DATETIME': { icon: 'ph-calendar-blank', bgColor: '#fef3c7', textColor: '#b45309' },
                'TIME': { icon: 'ph-clock', bgColor: '#fef3c7', textColor: '#b45309' },
                'CHECKBOX': { icon: 'ph-check-square', bgColor: '#e0e7ff', textColor: '#4338ca' },
                'EMAIL': { icon: 'ph-envelope', bgColor: '#ede9fe', textColor: '#7c3aed' },
                'URL': { icon: 'ph-link', bgColor: '#cffafe', textColor: '#0891b2' },
                'SELECT': { icon: 'ph-list-bullets', bgColor: '#fce7f3', textColor: '#be185d' },
                'MULTI_SELECT': { icon: 'ph-list-checks', bgColor: '#fce7f3', textColor: '#be185d' },
                'LONG_TEXT': { icon: 'ph-text-aa', bgColor: '#f1f5f9', textColor: '#475569' },
                'JSON': { icon: 'ph-code', bgColor: '#fef9c3', textColor: '#a16207' }
            };
            return typeMap[type] || { icon: 'ph-question', bgColor: '#f1f5f9', textColor: '#475569' };
        }

        /**
         * Toggle type dropdown for a field
         */
        function toggleTypeDropdown(fieldName) {
            const dropdown = document.getElementById(`typeDropdown_${fieldName}`);
            if (!dropdown) return;

            const isVisible = dropdown.style.display !== 'none';

            // Hide all other dropdowns first
            document.querySelectorAll('.type-dropdown').forEach(d => d.style.display = 'none');

            if (!isVisible) {
                // Populate and show dropdown
                const validTypes = ['TEXT', 'NUMBER', 'CURRENCY', 'DATE', 'DATETIME', 'TIME', 'CHECKBOX', 'EMAIL', 'URL', 'SELECT', 'LONG_TEXT', 'JSON'];
                const currentType = state.csvImportState.typeAssessment?.fields[fieldName]?.detectedType || 'TEXT';

                dropdown.innerHTML = validTypes.map(type => {
                    const info = getTypeDisplayInfo(type);
                    const isSelected = type === currentType;
                    return `
                        <div class="type-dropdown-item ${isSelected ? 'selected' : ''}" onclick="applyTypeOverride('${fieldName}', '${type}')">
                            <i class="ph ${info.icon}" style="color: ${info.textColor};"></i>
                            ${type}
                        </div>
                    `;
                }).join('');

                dropdown.style.display = 'block';
            }

            // Close dropdown on outside click
            const closeHandler = (e) => {
                if (!dropdown.contains(e.target) && !e.target.closest('.type-assessment-type')) {
                    dropdown.style.display = 'none';
                    document.removeEventListener('click', closeHandler);
                }
            };
            setTimeout(() => document.addEventListener('click', closeHandler), 0);
        }

        /**
         * Apply a type override for a field
         */
        function applyTypeOverride(fieldName, newType) {
            const assessment = state.csvImportState.typeAssessment;
            if (!assessment || !assessment.fields[fieldName]) return;

            // Update the assessment
            assessment.fields[fieldName].detectedType = newType;
            assessment.fields[fieldName].userOverride = {
                type: newType,
                overriddenAt: new Date().toISOString()
            };
            assessment.fields[fieldName].needsReview = false;

            // Remove from needs review list
            const idx = assessment.summary.needsReview.indexOf(fieldName);
            if (idx > -1) {
                assessment.summary.needsReview.splice(idx, 1);
            }

            // Hide dropdown
            document.querySelectorAll('.type-dropdown').forEach(d => d.style.display = 'none');

            // Re-render
            renderTypeAssessment();
            showToast(`Changed ${fieldName} to ${newType}`);
        }

        /**
         * Accept all detected types
         */
        function acceptAllTypes() {
            const assessment = state.csvImportState.typeAssessment;
            if (!assessment) return;

            for (const fieldName of Object.keys(assessment.fields)) {
                assessment.fields[fieldName].needsReview = false;
                assessment.fields[fieldName].acceptedAt = new Date().toISOString();
            }
            assessment.summary.needsReview = [];

            renderTypeAssessment();
            showToast('All types accepted');
        }

        function populateSimplifiedProvenance() {
            // Populate simplified provenance fields with auto-detected values
            const provenance = state.csvImportState.provenance;
            if (!provenance) return;

            const sourceInput = document.getElementById('csvProvenanceSource');
            const dataTypeInput = document.getElementById('csvProvenanceDataType');

            if (sourceInput && provenance.inferred?.sourceSystem) {
                sourceInput.value = provenance.inferred.sourceSystem.name || '';
                sourceInput.placeholder = `Auto-detected: ${provenance.inferred.sourceSystem.name || 'Unknown'}`;
            }

            if (dataTypeInput && provenance.inferred?.dataType) {
                dataTypeInput.value = provenance.inferred.dataType || '';
                dataTypeInput.placeholder = `Auto-detected: ${provenance.inferred.dataType || 'Unknown'}`;
            }
        }

        function renderCsvMapping() {
            const container = document.getElementById('csvMappingContainer');
            const set = getCsvTargetSet();
            if (!container || !set) return;
            if (!state.csvImportState.headers.length) {
                container.innerHTML = '<p class="text-sm text-gray-500">No headers detected yet.</p>';
                return;
            }

            const typeAssessment = state.csvImportState.typeAssessment;

            container.innerHTML = state.csvImportState.headers.map(header => {
                const mappedField = state.csvImportState.mappings[header] || '';
                const createValue = buildCreateFieldValue(header);
                const options = ['<option value="">Skip</option>']
                    .concat(`<option value="${createValue}" ${mappedField === createValue ? 'selected' : ''}> Create new field: "${header}"</option>`)
                    .concat(set.schema.map(f => `<option value="${f.id}" ${mappedField === f.id ? 'selected' : ''}>${f.name}</option>`))
                    .join('');

                // Get detected type for display
                let typeHint = '';
                if (isCreateFieldValue(mappedField) && typeAssessment && typeAssessment.fields[header]) {
                    const assessment = typeAssessment.fields[header];
                    const detectedType = assessment.detectedType || 'TEXT';
                    const typeInfo = getTypeDisplayInfo(detectedType);
                    const confidencePercent = Math.round((assessment.confidence || 0) * 100);
                    typeHint = `
                        <p class="text-xs mt-1 flex items-center gap-1">
                            <span style="color: #6b7280;">Will create</span>
                            <span style="background: ${typeInfo.bgColor}; color: ${typeInfo.textColor}; padding: 1px 6px; border-radius: 4px; font-weight: 600;">
                                <i class="ph ${typeInfo.icon}" style="font-size: 10px;"></i> ${detectedType}
                            </span>
                            <span style="color: #9ca3af;">(${confidencePercent}% confidence)</span>
                        </p>
                    `;
                } else if (isCreateFieldValue(mappedField)) {
                    typeHint = `<p class="text-xs text-amber-600 mt-1">Will create a new TEXT field</p>`;
                }

                return `
                    <div class="flex items-center gap-3">
                        <div class="w-1/3 font-medium">${header}</div>
                        <div class="flex-1">
                            <select data-csv-header="${header}" class="flex-1">${options}</select>
                            ${typeHint}
                        </div>
                    </div>
                `;
            }).join('');

            container.querySelectorAll('select').forEach(select => {
                select.onchange = (event) => {
                    const header = event.target.dataset.csvHeader;
                    state.csvImportState.mappings[header] = event.target.value;
                    renderCsvPreview();
                    renderCsvMatches();
                };
            });
        }

        function buildCsvPreviewRows(limit = 5) {
            const set = getCsvTargetSet();
            if (!set) return [];
            const mappedHeaders = state.csvImportState.headers
                .map(header => [header, state.csvImportState.mappings[header]])
                .filter(([, fieldId]) => fieldId);
            return state.csvImportState.rows.slice(0, limit).map(row => {
                const preview = { __original: row };
                mappedHeaders.forEach(([header, fieldId]) => {
                    const field = set.schema.find(f => f.id === fieldId);
                    let value = row[header] || '';
                    if (['NUMBER', 'CURRENCY'].includes(field?.type)) {
                        const numeric = parseFloat(value);
                        value = isNaN(numeric) ? '' : numeric;
                    }
                    preview[fieldId] = value;
                });
                return preview;
            });
        }

        function renderCsvPreview() {
            const container = document.getElementById('csvPreviewContainer');
            const set = getCsvTargetSet();
            if (!container || !set) return;
            const mappedEntries = state.csvImportState.headers
                .map(header => [header, state.csvImportState.mappings[header]])
                .filter(([, fieldId]) => fieldId);
            if (!mappedEntries.length || !state.csvImportState.rows.length) {
                container.innerHTML = '<p class="text-sm text-gray-500">Map at least one column to preview records.</p>';
                return;
            }

            const previewRows = buildCsvPreviewRows();
            state.csvImportState.previewRows = previewRows;
            const headerCells = mappedEntries.map(([header, fieldId]) => {
                const field = set.schema.find(f => f.id === fieldId);
                const label = field?.name || header;
                const badge = field ? '' : '<span class="ml-2 text-xs font-semibold text-amber-600">(creates field)</span>';
                return `<th>${label}${badge}</th>`;
            }).join('');

            const bodyRows = previewRows.map(row => {
                const cells = mappedEntries.map(([, fieldId]) => `<td>${row[fieldId] ?? ''}</td>`).join('');
                return `<tr>${cells}</tr>`;
            }).join('');

            container.innerHTML = `
                <table class="csv-preview-table">
                    <thead><tr>${headerCells}</tr></thead>
                    <tbody>${bodyRows}</tbody>
                </table>
            `;
        }

        function similarityScore(a, b) {
            const s1 = (a || '').toString().trim().toLowerCase();
            const s2 = (b || '').toString().trim().toLowerCase();
            if (!s1 || !s2) return 0;
            const distance = levenshteinDistance(s1, s2);
            return 1 - (distance / Math.max(s1.length, s2.length));
        }

        function levenshteinDistance(a, b) {
            const matrix = Array.from({ length: b.length + 1 }, () => []);
            for (let i = 0; i <= b.length; i++) matrix[i][0] = i;
            for (let j = 0; j <= a.length; j++) matrix[0][j] = j;
            for (let i = 1; i <= b.length; i++) {
                for (let j = 1; j <= a.length; j++) {
                    if (b.charAt(i - 1) === a.charAt(j - 1)) {
                        matrix[i][j] = matrix[i - 1][j - 1];
                    } else {
                        matrix[i][j] = Math.min(
                            matrix[i - 1][j - 1] + 1,
                            matrix[i][j - 1] + 1,
                            matrix[i - 1][j] + 1
                        );
                    }
                }
            }
            return matrix[b.length][a.length];
        }

        function resolvePrimaryFieldFromMappings(set) {
            const nameField = Object.entries(state.csvImportState.mappings).find(([, fieldId]) => fieldId === 'name');
            if (nameField) return nameField[1];
            const textFields = set.schema.filter(f => ['TEXT', 'LONG_TEXT'].includes(f.type));
            const mappedTextField = Object.entries(state.csvImportState.mappings)
                .map(([, fieldId]) => set.schema.find(f => f.id === fieldId))
                .find(f => f && ['TEXT', 'LONG_TEXT'].includes(f.type));
            return mappedTextField?.id || textFields[0]?.id || set.schema[0]?.id;
        }

        function renderCsvMatches() {
            const container = document.getElementById('csvMatchSuggestions');
            const set = getCsvTargetSet();
            if (!container || !set) return;
            if (!state.csvImportState.rows.length) {
                container.innerHTML = '<p class="text-sm text-gray-500">Load rows to see suggestions.</p>';
                return;
            }

            const keyFieldId = resolvePrimaryFieldFromMappings(set);
            if (!keyFieldId) {
                container.innerHTML = '<p class="text-sm text-gray-500">Map at least one text column to find duplicates.</p>';
                return;
            }

            const existing = Array.from(set.records.values());
            const matches = [];
            state.csvImportState.rows.forEach(row => {
                const mappedValue = Object.entries(state.csvImportState.mappings).find(([, fieldId]) => fieldId === keyFieldId);
                const candidateValue = mappedValue ? row[mappedValue[0]] : '';
                let bestMatch = null;
                existing.forEach(rec => {
                    const score = similarityScore(candidateValue, rec[keyFieldId]);
                    if (score >= 0.6 && (!bestMatch || score > bestMatch.score)) {
                        bestMatch = { csvValue: candidateValue, record: rec, score };
                    }
                });
                if (bestMatch) matches.push(bestMatch);
            });

            state.csvImportState.matches = matches;
            if (!matches.length) {
                container.innerHTML = '<p class="text-sm text-gray-500">No close matches detected.</p>';
                return;
            }

            container.innerHTML = matches.slice(0, 10).map(match => `
                <div class="fuzzy-match-row">
                    <div class="flex-1">
                        <div class="text-sm text-gray-500">CSV Value</div>
                        <strong>${match.csvValue || '(blank)'}</strong>
                    </div>
                    <div class="flex-1">
                        <div class="text-sm text-gray-500">Existing Record</div>
                        <strong>${match.record.name || match.record.id}</strong>
                        <div class="text-xs text-gray-500">Score: <span class="fuzzy-score">${match.score.toFixed(2)}</span></div>
                    </div>
                </div>
            `).join('');
        }

        function importCsvRecords() {
            let set = null;
            if (state.csvImportState.targetMode === 'existing') {
                const setId = state.csvImportState.targetSetId || state.currentSetId;
                if (!setId) {
                    showToast(' Choose a destination set first');
                    return;
                }
                set = state.sets.get(setId);
            } else {
                const name = (state.csvImportState.newSetName || '').trim();
                if (!name) {
                    showToast(' Name your new set before importing');
                    return;
                }
                const setId = createSet(name, 'ph-squares-four', state.currentWorldId);
                createView(setId, 'All ' + name, { type: 'grid' });
                state.expandedSets.add(setId);
                renderSidebar();
                switchSet(setId, null);
                set = state.sets.get(setId);
                state.csvImportState.targetMode = 'existing';
                state.csvImportState.targetSetId = setId;
            }
            if (!set) return;
            const mappedHeaders = Object.entries(state.csvImportState.mappings).filter(([, fieldId]) => fieldId);
            if (!mappedHeaders.length) {
                showToast(' Map at least one column');
                return;
            }
            if (!state.csvImportState.rows.length) {
                showToast(' No rows to import');
                return;
            }

            const existingFieldIds = new Set(set.schema.map(f => f.id));
            const typeAssessment = state.csvImportState.typeAssessment;

            mappedHeaders
                .filter(([, fieldId]) => isCreateFieldValue(fieldId))
                .forEach(([header, fieldId]) => {
                    const suggestedId = fieldId.replace(CREATE_FIELD_PREFIX, '') || slugifyFieldId(header);
                    const fieldName = header?.trim() || 'New Field';
                    let uniqueId = suggestedId;
                    let counter = 1;
                    while (existingFieldIds.has(uniqueId)) {
                        uniqueId = `${suggestedId}_${counter++}`;
                    }

                    // Use detected type from type assessment if available
                    let detectedType = 'TEXT';
                    let fieldConfig = {};

                    if (typeAssessment && typeAssessment.fields[header]) {
                        const assessment = typeAssessment.fields[header];
                        detectedType = assessment.detectedType || 'TEXT';

                        // Use suggested config from assessment
                        if (assessment.suggestedConfig) {
                            fieldConfig = { ...assessment.suggestedConfig };
                            delete fieldConfig.type; // type is separate
                        }

                        // Handle subtype for TEXT fields
                        if (detectedType === 'TEXT' && assessment.detectedSubtype) {
                            fieldConfig.subtype = assessment.detectedSubtype;
                        }
                    }

                    const newField = {
                        id: uniqueId,
                        name: fieldName,
                        type: detectedType,
                        width: '150px',
                        config: fieldConfig
                    };
                    set.schema.push(newField);

                    // Add field to all existing views of the set
                    addFieldToAllViews(set, uniqueId);

                    const defaultValue = FIELD_TYPES[detectedType]?.defaultValue ?? '';
                    set.records.forEach(r => r[uniqueId] = defaultValue);
                    existingFieldIds.add(uniqueId);
                    state.csvImportState.mappings[header] = uniqueId;
                });

            const finalizedMappings = Object.entries(state.csvImportState.mappings).filter(([, fieldId]) => fieldId);

            // Create ONE context template for the entire import (lean approach)
            // Enhanced with rich provenance from extraction
            let importTemplateId = null;
            if (state.leanContext) {
                const importFilename = state.csvImportState.filename || 'import.csv';
                const provenance = state.csvImportState.provenance || {};
                const provenanceEdits = state.csvImportState.provenanceEdits || {};
                const inferred = provenance.inferred || {};

                // Build rich context template
                const templateContext = {
                    // Basic context (with provenance enhancements)
                    method: provenanceEdits.method || inferred.method?.name || 'declared',
                    source: provenanceEdits.sourceSystem || inferred.sourceSystem?.name || 'csv_import',
                    agent: state.currentUser.id,
                    timeframe: provenanceEdits.timeframe?.start ? provenanceEdits.timeframe : (inferred.timeframe || {
                        start: new Date().toISOString().split('T')[0]
                    }),
                    scale: provenanceEdits.scale || inferred.scale?.name || 'individual',

                    // NEW: Rich provenance fields
                    frame: provenanceEdits.frame || inferred.frame?.name || null,
                    jurisdiction: provenanceEdits.jurisdiction !== 'auto' ? provenanceEdits.jurisdiction : (inferred.jurisdiction?.name || null),
                    ground: provenanceEdits.authority || null,
                    trustLevel: provenanceEdits.trustLevel || 'authoritative',

                    // File metadata
                    fileMetadata: provenance.file || {},
                    embeddedMetadata: provenance.embedded || {},

                    // External system linkage
                    externalLinks: inferred.externalLinks || [],

                    // Confidence scores (for transparency)
                    confidence: provenance.confidence || {}
                };

                // If external link is enabled, add connection info
                if (provenanceEdits.externalLink?.enabled && provenanceEdits.externalLink?.url) {
                    templateContext.externalSystemUrl = provenanceEdits.externalLink.url;
                }

                importTemplateId = state.leanContext.registerContextTemplate(templateContext);

                // Column-level definition detection and capture
                if (provenance.schema && provenance.schema.definitionColumns) {
                    state.csvImportState.fieldDefinitions = state.csvImportState.fieldDefinitions || {};

                    provenance.schema.definitionColumns.forEach(defColumn => {
                        // Find the base field name (e.g., "revenue" from "revenue_definition")
                        const baseFieldName = defColumn.replace(/_definition$|_definition_id$|_def$|_type$|_category$/i, '');

                        // Extract unique definitions from the data
                        const definitions = new Set();
                        state.csvImportState.rows.forEach(row => {
                            const defValue = row[defColumn];
                            if (defValue) definitions.add(defValue);
                        });

                        // Record as definitional events
                        definitions.forEach(defValue => {
                            state.csvImportState.fieldDefinitions[baseFieldName] = {
                                operator: 'DES',
                                definer: {
                                    type: 'system',
                                    source: templateContext.source,
                                    id: templateContext.agent
                                },
                                definition: defValue,
                                frame: templateContext.frame,
                                jurisdiction: templateContext.jurisdiction,
                                definitionColumn: defColumn,
                                timestamp: new Date().toISOString()
                            };
                        });
                    });
                }
            }

            state.csvImportState.rows.forEach(row => {
                const recordData = {};
                finalizedMappings.forEach(([header, fieldId]) => {
                    const field = set.schema.find(f => f.id === fieldId);
                    let value = row[header];
                    if (['NUMBER', 'CURRENCY'].includes(field?.type)) {
                        const numeric = parseFloat(value);
                        value = isNaN(numeric) ? 0 : numeric;
                    }
                    recordData[fieldId] = value;
                });

                // Use lean record creation if available
                if (state.leanContext && importTemplateId) {
                    const leanRecord = state.leanContext.createLeanRecord(set.id, recordData, importTemplateId);

                    // Apply field-level definition overrides if available
                    if (state.csvImportState.fieldDefinitions) {
                        Object.entries(state.csvImportState.fieldDefinitions).forEach(([baseFieldName, defInfo]) => {
                            // Find matching field in mappings
                            const matchingMapping = finalizedMappings.find(([header, fieldId]) => {
                                const normalized = header.toLowerCase().replace(/[^a-z0-9]/g, '_');
                                return normalized.includes(baseFieldName.toLowerCase());
                            });

                            if (matchingMapping) {
                                const [header, fieldId] = matchingMapping;
                                const definitionColumn = defInfo.definitionColumn;
                                const recordDefinition = row[definitionColumn];

                                // If this record has a specific definition value, apply field-level context
                                if (recordDefinition && state.leanContext.setFieldContext) {
                                    state.leanContext.setFieldContext(leanRecord, fieldId, {
                                        definition: recordDefinition,
                                        frame: defInfo.frame,
                                        jurisdiction: defInfo.jurisdiction
                                    });
                                }
                            }
                        });
                    }

                    set.records.set(leanRecord.id, leanRecord);
                    createEvent(
                        'Create Record',
                        'INS',
                        { type: 'Record', id: leanRecord.id, setId: set.id },
                        { setId: set.id, recordId: leanRecord.id, data: recordData, summary: 'Created record via import' }
                    );
                } else {
                    addRecord(set.id, recordData);
                }
            });

            // Create batch import event (compact)
            const importTimestamp = Date.now();
            if (state.leanContext && importTemplateId) {
                createEvent(
                    'Batch Import',
                    'INS',
                    { type: 'Set', id: set.id },
                    {
                        count: state.csvImportState.rows.length,
                        templateId: importTemplateId,
                        summary: `Imported ${state.csvImportState.rows.length} records`,
                        timestamp: importTimestamp
                    }
                );
            }

            // Auto-create a temporary view for this import
            const importFileName = state.csvImportState.filename || 'import.csv';
            const baseViewName = importFileName.replace(/\.[^/.]+$/, ''); // Remove extension
            const viewName = `Import: ${baseViewName}`;

            const importViewId = createView(set.id, viewName, {
                type: 'grid',
                icon: '',
                isTemporary: true,
                filters: [{
                    field: '_provenance.importId',
                    value: importTemplateId,
                    operator: 'equals'
                }],
                importMetadata: {
                    filename: importFileName,
                    timestamp: importTimestamp,
                    recordCount: state.csvImportState.rows.length,
                    templateId: importTemplateId
                }
            });

            // Track this as an import view in event stream
            createEvent(
                'Import View Created',
                'INS',
                { type: 'View', id: importViewId },
                {
                    setId: set.id,
                    viewName: viewName,
                    filename: importFileName,
                    recordCount: state.csvImportState.rows.length,
                    isTemporary: true
                }
            );

            switchSet(set.id, importViewId);
            showToast(` Imported ${state.csvImportState.rows.length} records`);
            closeModal('csvImportModal');
        }

        // JSON IMPORT FUNCTIONS
        const JSON_FIELD_MATCH_THRESHOLD = 0.75;

        function resetJsonImportState() {
            const defaultSetId = state.currentSetId || Array.from(state.sets.keys())[0] || null;
            state.jsonImportState = {
                keys: [],
                rows: [],
                mappings: {},
                previewRows: [],
                matches: [],
                targetMode: defaultSetId ? 'existing' : 'new',
                targetSetId: defaultSetId,
                newSetName: '',
                filename: ''
            };
            const badge = document.getElementById('jsonRowCountBadge');
            if (badge) badge.textContent = '0 rows';
            const mappingEl = document.getElementById('jsonMappingContainer');
            if (mappingEl) mappingEl.innerHTML = '<p class="text-sm text-gray-500">Load a JSON file or paste JSON text to start mapping.</p>';
            const previewEl = document.getElementById('jsonPreviewContainer');
            if (previewEl) previewEl.innerHTML = '<p class="text-sm text-gray-500">Preview will appear after parsing.</p>';
            const matchesEl = document.getElementById('jsonMatchSuggestions');
            if (matchesEl) matchesEl.innerHTML = '<p class="text-sm text-gray-500">No suggestions yet.</p>';
            const textInput = document.getElementById('jsonTextInput');
            if (textInput) textInput.value = '';
            const fileInput = document.getElementById('jsonFileInput');
            if (fileInput) fileInput.value = '';
            populateJsonTargetSetOptions();
            syncJsonImportTargetUi();
        }

        function populateJsonTargetSetOptions() {
            const select = document.getElementById('jsonTargetSetSelect');
            if (!select) return;
            const options = getSetsForWorld().map(set => `<option value="${set.id}">${set.name}</option>`);
            if (!options.length) {
                select.innerHTML = '<option value="" disabled>No sets available</option>';
                select.value = '';
                state.jsonImportState.targetSetId = null;
                return;
            }
            select.innerHTML = options.join('');
            const desired = state.jsonImportState.targetSetId || state.currentSetId || select.options[0]?.value || '';
            select.value = desired;
            state.jsonImportState.targetSetId = select.value || null;
        }

        function syncJsonImportTargetUi() {
            const mode = state.jsonImportState.targetMode;
            document.querySelectorAll('input[name="jsonImportTargetMode"]').forEach(input => {
                input.checked = input.value === mode;
            });
            document.getElementById('jsonExistingSetPicker')?.classList.toggle('hidden', mode !== 'existing');
            document.getElementById('jsonNewSetFields')?.classList.toggle('hidden', mode !== 'new');
            const select = document.getElementById('jsonTargetSetSelect');
            if (select && mode === 'existing') select.value = state.jsonImportState.targetSetId || '';
            const nameInput = document.getElementById('jsonNewSetName');
            if (nameInput && mode === 'new') nameInput.value = state.jsonImportState.newSetName || '';
        }

        function getJsonTargetSet() {
            if (state.jsonImportState.targetMode === 'existing') {
                const setId = state.jsonImportState.targetSetId || state.currentSetId;
                return setId ? state.sets.get(setId) : null;
            }
            return {
                id: null,
                name: state.jsonImportState.newSetName?.trim() || 'New Set',
                schema: [],
                records: new Map()
            };
        }

        function handleJsonTargetChange() {
            populateJsonTargetSetOptions();
            syncJsonImportTargetUi();
            if (state.jsonImportState.keys.length) {
                const set = getJsonTargetSet();
                state.jsonImportState.mappings = autoMapJsonKeys(state.jsonImportState.keys, set);
                renderJsonMapping();
                renderJsonPreview();
                renderJsonMatches();
            }
        }

        function openJsonImportModal(targetSetId = null) {
            resetJsonImportState();
            if (targetSetId) {
                state.jsonImportState.targetMode = 'existing';
                state.jsonImportState.targetSetId = targetSetId;
                populateJsonTargetSetOptions();
                syncJsonImportTargetUi();
            }
            openModal('jsonImportModal');
        }

        function handleJsonFileSelected(event) {
            const file = event.target.files?.[0];
            if (!file) return;
            const targetSet = getJsonTargetSet();
            if (!targetSet) {
                showToast(' Choose a destination set first');
                event.target.value = '';
                return;
            }
            const reader = new FileReader();
            reader.onload = (e) => {
                const jsonText = e.target.result || '';
                state.jsonImportState.filename = file.name;
                try {
                    const { keys, rows } = parseJsonContent(jsonText);
                    handleJsonData(keys, rows);
                } catch (err) {
                    showToast(' Invalid JSON: ' + err.message);
                }
            };
            reader.readAsText(file);
        }

        function previewJsonFromText() {
            const text = document.getElementById('jsonTextInput')?.value || '';
            const targetSet = getJsonTargetSet();
            if (!targetSet) {
                showToast(' Choose a destination set first');
                return;
            }
            try {
                const { keys, rows } = parseJsonContent(text);
                handleJsonData(keys, rows);
            } catch (err) {
                showToast(' Invalid JSON: ' + err.message);
            }
        }

        function parseJsonContent(text) {
            if (!text || !text.trim()) return { keys: [], rows: [] };

            let parsed;
            try {
                parsed = JSON.parse(text);
            } catch (e) {
                throw new Error('Could not parse JSON');
            }

            // Handle different JSON structures
            let rows = [];
            if (Array.isArray(parsed)) {
                // Direct array of objects
                rows = parsed;
            } else if (parsed && typeof parsed === 'object') {
                // Look for common data array properties
                const dataKeys = ['data', 'items', 'records', 'results', 'rows', 'entries', 'list'];
                for (const key of dataKeys) {
                    if (Array.isArray(parsed[key])) {
                        rows = parsed[key];
                        break;
                    }
                }
                // If no data array found, treat the object itself as a single row
                if (rows.length === 0 && Object.keys(parsed).length > 0) {
                    // Check if it looks like metadata wrapper vs actual data
                    const hasNestedArrays = Object.values(parsed).some(v => Array.isArray(v));
                    if (!hasNestedArrays) {
                        rows = [parsed];
                    }
                }
            }

            if (!rows.length) {
                throw new Error('No data found. Expected an array of objects or an object with a data array.');
            }

            // Filter to only objects
            rows = rows.filter(row => row && typeof row === 'object' && !Array.isArray(row));

            if (!rows.length) {
                throw new Error('No valid objects found in the data.');
            }

            // Extract all unique keys from all rows
            const keySet = new Set();
            rows.forEach(row => {
                Object.keys(row).forEach(key => {
                    // Skip nested objects/arrays for simplicity, but include primitive values
                    const value = row[key];
                    if (value === null || value === undefined || typeof value !== 'object' || value instanceof Date) {
                        keySet.add(key);
                    } else if (Array.isArray(value)) {
                        // Include arrays as they can be converted to strings
                        keySet.add(key);
                    }
                });
            });

            const keys = Array.from(keySet);

            // Normalize rows to have consistent keys with stringified values
            const normalizedRows = rows.map(row => {
                const obj = {};
                keys.forEach(key => {
                    let value = row[key];
                    // Convert non-primitive values to strings
                    if (value === null || value === undefined) {
                        obj[key] = '';
                    } else if (Array.isArray(value)) {
                        obj[key] = value.join(', ');
                    } else if (typeof value === 'object') {
                        obj[key] = JSON.stringify(value);
                    } else {
                        obj[key] = String(value);
                    }
                });
                return obj;
            });

            return { keys, rows: normalizedRows };
        }

        function autoMapJsonKeys(keys, set) {
            const mappings = {};
            const schema = set?.schema || [];
            keys.forEach(key => {
                const match = findBestFieldMatch(key, schema);
                if (match && match.score >= JSON_FIELD_MATCH_THRESHOLD) {
                    mappings[key] = match.field.id;
                } else {
                    mappings[key] = buildCreateFieldValue(key);
                }
            });
            return mappings;
        }

        function handleJsonData(keys, rows) {
            const set = getJsonTargetSet();
            if (state.jsonImportState.targetMode === 'existing' && !set) {
                showToast(' Choose a destination set first');
                return;
            }
            state.jsonImportState.keys = keys;
            state.jsonImportState.rows = rows;
            state.jsonImportState.mappings = autoMapJsonKeys(keys, set);
            const badge = document.getElementById('jsonRowCountBadge');
            if (badge) badge.textContent = `${rows.length} rows`;
            renderJsonMapping();
            renderJsonPreview();
            renderJsonMatches();
        }

        function renderJsonMapping() {
            const container = document.getElementById('jsonMappingContainer');
            const set = getJsonTargetSet();
            if (!container || !set) return;
            if (!state.jsonImportState.keys.length) {
                container.innerHTML = '<p class="text-sm text-gray-500">No keys detected yet.</p>';
                return;
            }

            container.innerHTML = state.jsonImportState.keys.map(key => {
                const mappedField = state.jsonImportState.mappings[key] || '';
                const createValue = buildCreateFieldValue(key);
                const options = ['<option value="">Skip</option>']
                    .concat(`<option value="${createValue}" ${mappedField === createValue ? 'selected' : ''}> Create new field: "${key}"</option>`)
                    .concat(set.schema.map(f => `<option value="${f.id}" ${mappedField === f.id ? 'selected' : ''}>${f.name}</option>`))
                    .join('');
                return `
                    <div class="flex items-center gap-3">
                        <div class="w-1/3 font-medium">${key}</div>
                        <div class="flex-1">
                            <select data-json-key="${key}" class="flex-1">${options}</select>
                            ${isCreateFieldValue(mappedField) ? `<p class="text-xs text-amber-600 mt-1">Will create a new text field named "${key}"</p>` : ''}
                        </div>
                    </div>
                `;
            }).join('');

            container.querySelectorAll('select').forEach(select => {
                select.onchange = (event) => {
                    const key = event.target.dataset.jsonKey;
                    state.jsonImportState.mappings[key] = event.target.value;
                    renderJsonPreview();
                    renderJsonMatches();
                };
            });
        }

        function buildJsonPreviewRows(limit = 5) {
            const set = getJsonTargetSet();
            if (!set) return [];
            const mappedKeys = state.jsonImportState.keys
                .map(key => [key, state.jsonImportState.mappings[key]])
                .filter(([, fieldId]) => fieldId);
            return state.jsonImportState.rows.slice(0, limit).map(row => {
                const preview = { __original: row };
                mappedKeys.forEach(([key, fieldId]) => {
                    const field = set.schema.find(f => f.id === fieldId);
                    let value = row[key] || '';
                    if (['NUMBER', 'CURRENCY'].includes(field?.type)) {
                        const numeric = parseFloat(value);
                        value = isNaN(numeric) ? '' : numeric;
                    }
                    preview[fieldId] = value;
                });
                return preview;
            });
        }

        function renderJsonPreview() {
            const container = document.getElementById('jsonPreviewContainer');
            const set = getJsonTargetSet();
            if (!container || !set) return;
            const mappedEntries = state.jsonImportState.keys
                .map(key => [key, state.jsonImportState.mappings[key]])
                .filter(([, fieldId]) => fieldId);
            if (!mappedEntries.length || !state.jsonImportState.rows.length) {
                container.innerHTML = '<p class="text-sm text-gray-500">Map at least one key to preview records.</p>';
                return;
            }

            const previewRows = buildJsonPreviewRows();
            state.jsonImportState.previewRows = previewRows;
            const headerCells = mappedEntries.map(([key, fieldId]) => {
                const field = set.schema.find(f => f.id === fieldId);
                const label = field?.name || key;
                const badge = field ? '' : '<span class="ml-2 text-xs font-semibold text-amber-600">(creates field)</span>';
                return `<th>${label}${badge}</th>`;
            }).join('');

            const bodyRows = previewRows.map(row => {
                const cells = mappedEntries.map(([, fieldId]) => `<td>${row[fieldId] ?? ''}</td>`).join('');
                return `<tr>${cells}</tr>`;
            }).join('');

            container.innerHTML = `
                <table class="csv-preview-table">
                    <thead><tr>${headerCells}</tr></thead>
                    <tbody>${bodyRows}</tbody>
                </table>
            `;
        }

        function resolveJsonPrimaryFieldFromMappings(set) {
            const nameField = Object.entries(state.jsonImportState.mappings).find(([, fieldId]) => fieldId === 'name');
            if (nameField) return nameField[1];
            const textFields = set.schema.filter(f => ['TEXT', 'LONG_TEXT'].includes(f.type));
            const mappedTextField = Object.entries(state.jsonImportState.mappings)
                .map(([, fieldId]) => set.schema.find(f => f.id === fieldId))
                .find(f => f && ['TEXT', 'LONG_TEXT'].includes(f.type));
            return mappedTextField?.id || textFields[0]?.id || set.schema[0]?.id;
        }

        function renderJsonMatches() {
            const container = document.getElementById('jsonMatchSuggestions');
            const set = getJsonTargetSet();
            if (!container || !set) return;
            if (!state.jsonImportState.rows.length) {
                container.innerHTML = '<p class="text-sm text-gray-500">Load rows to see suggestions.</p>';
                return;
            }

            const keyFieldId = resolveJsonPrimaryFieldFromMappings(set);
            if (!keyFieldId) {
                container.innerHTML = '<p class="text-sm text-gray-500">Map at least one text key to find duplicates.</p>';
                return;
            }

            const existing = Array.from(set.records.values());
            const matches = [];
            state.jsonImportState.rows.forEach(row => {
                const mappedValue = Object.entries(state.jsonImportState.mappings).find(([, fieldId]) => fieldId === keyFieldId);
                const candidateValue = mappedValue ? row[mappedValue[0]] : '';
                let bestMatch = null;
                existing.forEach(rec => {
                    const score = similarityScore(candidateValue, rec[keyFieldId]);
                    if (score >= 0.6 && (!bestMatch || score > bestMatch.score)) {
                        bestMatch = { jsonValue: candidateValue, record: rec, score };
                    }
                });
                if (bestMatch) matches.push(bestMatch);
            });

            state.jsonImportState.matches = matches;
            if (!matches.length) {
                container.innerHTML = '<p class="text-sm text-gray-500">No close matches detected.</p>';
                return;
            }

            container.innerHTML = matches.slice(0, 10).map(match => `
                <div class="fuzzy-match-row">
                    <div class="flex-1">
                        <div class="text-sm text-gray-500">JSON Value</div>
                        <strong>${match.jsonValue || '(blank)'}</strong>
                    </div>
                    <div class="flex-1">
                        <div class="text-sm text-gray-500">Existing Record</div>
                        <strong>${match.record.name || match.record.id}</strong>
                        <div class="text-xs text-gray-500">Score: <span class="fuzzy-score">${match.score.toFixed(2)}</span></div>
                    </div>
                </div>
            `).join('');
        }

        function importJsonRecords() {
            let set = null;
            if (state.jsonImportState.targetMode === 'existing') {
                const setId = state.jsonImportState.targetSetId || state.currentSetId;
                if (!setId) {
                    showToast(' Choose a destination set first');
                    return;
                }
                set = state.sets.get(setId);
            } else {
                const name = (state.jsonImportState.newSetName || '').trim();
                if (!name) {
                    showToast(' Name your new set before importing');
                    return;
                }
                const setId = createSet(name, 'ph-squares-four', state.currentWorldId);
                createView(setId, 'All ' + name, { type: 'grid' });
                state.expandedSets.add(setId);
                renderSidebar();
                switchSet(setId, null);
                set = state.sets.get(setId);
                state.jsonImportState.targetMode = 'existing';
                state.jsonImportState.targetSetId = setId;
            }
            if (!set) return;
            const mappedKeys = Object.entries(state.jsonImportState.mappings).filter(([, fieldId]) => fieldId);
            if (!mappedKeys.length) {
                showToast(' Map at least one key');
                return;
            }
            if (!state.jsonImportState.rows.length) {
                showToast(' No rows to import');
                return;
            }

            const existingFieldIds = new Set(set.schema.map(f => f.id));
            mappedKeys
                .filter(([, fieldId]) => isCreateFieldValue(fieldId))
                .forEach(([key, fieldId]) => {
                    const suggestedId = fieldId.replace(CREATE_FIELD_PREFIX, '') || slugifyFieldId(key);
                    const fieldName = key?.trim() || 'New Field';
                    let uniqueId = suggestedId;
                    let counter = 1;
                    while (existingFieldIds.has(uniqueId)) {
                        uniqueId = `${suggestedId}_${counter++}`;
                    }

                    const newField = { id: uniqueId, name: fieldName, type: 'TEXT', width: '150px', config: {} };
                    set.schema.push(newField);

                    // Add field to all existing views of the set
                    addFieldToAllViews(set, uniqueId);

                    set.records.forEach(r => r[uniqueId] = FIELD_TYPES.TEXT.defaultValue);
                    existingFieldIds.add(uniqueId);
                    state.jsonImportState.mappings[key] = uniqueId;
                });

            const finalizedMappings = Object.entries(state.jsonImportState.mappings).filter(([, fieldId]) => fieldId);

            // Create ONE context template for the entire import (lean approach)
            let importTemplateId = null;
            if (state.leanContext) {
                const importFilename = state.jsonImportState.filename || 'import.json';

                // Get provenance notes from the form
                const sourceInput = document.getElementById('jsonProvenanceSource');
                const dataTypeInput = document.getElementById('jsonProvenanceDataType');
                const notesInput = document.getElementById('jsonProvenanceNotes');

                const templateContext = {
                    method: 'declared',
                    source: sourceInput?.value?.trim() || 'json_import',
                    agent: state.currentUser.id,
                    timeframe: {
                        start: new Date().toISOString().split('T')[0]
                    },
                    scale: 'individual',
                    dataType: dataTypeInput?.value?.trim() || null,
                    notes: notesInput?.value?.trim() || null,
                    fileMetadata: {
                        filename: importFilename,
                        type: 'application/json'
                    }
                };

                importTemplateId = state.leanContext.registerContextTemplate(templateContext);
            }

            state.jsonImportState.rows.forEach(row => {
                const recordData = {};
                finalizedMappings.forEach(([key, fieldId]) => {
                    const field = set.schema.find(f => f.id === fieldId);
                    let value = row[key];
                    if (['NUMBER', 'CURRENCY'].includes(field?.type)) {
                        const numeric = parseFloat(value);
                        value = isNaN(numeric) ? 0 : numeric;
                    }
                    recordData[fieldId] = value;
                });

                // Use lean record creation if available
                if (state.leanContext && importTemplateId) {
                    const leanRecord = state.leanContext.createLeanRecord(set.id, recordData, importTemplateId);
                    set.records.set(leanRecord.id, leanRecord);
                    createEvent(
                        'Create Record',
                        'INS',
                        { type: 'Record', id: leanRecord.id, setId: set.id },
                        { setId: set.id, recordId: leanRecord.id, data: recordData, summary: 'Created record via JSON import' }
                    );
                } else {
                    addRecord(set.id, recordData);
                }
            });

            // Create batch import event (compact)
            const importTimestamp = Date.now();
            if (state.leanContext && importTemplateId) {
                createEvent(
                    'Batch Import',
                    'INS',
                    { type: 'Set', id: set.id },
                    {
                        count: state.jsonImportState.rows.length,
                        templateId: importTemplateId,
                        summary: `Imported ${state.jsonImportState.rows.length} records from JSON`,
                        timestamp: importTimestamp
                    }
                );
            }

            // Auto-create a temporary view for this import
            const importFileName = state.jsonImportState.filename || 'import.json';
            const baseViewName = importFileName.replace(/\.[^/.]+$/, ''); // Remove extension
            const viewName = `Import: ${baseViewName}`;

            const importViewId = createView(set.id, viewName, {
                type: 'grid',
                icon: '',
                isTemporary: true,
                filters: [{
                    field: '_provenance.importId',
                    value: importTemplateId,
                    operator: 'equals'
                }],
                importMetadata: {
                    filename: importFileName,
                    timestamp: importTimestamp,
                    recordCount: state.jsonImportState.rows.length,
                    templateId: importTemplateId
                }
            });

            // Track this as an import view in event stream
            createEvent(
                'Import View Created',
                'INS',
                { type: 'View', id: importViewId },
                {
                    setId: set.id,
                    viewName: viewName,
                    filename: importFileName,
                    recordCount: state.jsonImportState.rows.length,
                    isTemporary: true
                }
            );

            switchSet(set.id, importViewId);
            showToast(` Imported ${state.jsonImportState.rows.length} records from JSON`);
            closeModal('jsonImportModal');
        }

        function computeFuzzyMatchesForSet(set, threshold = state.fuzzyPanelState.threshold) {
            if (!set) return [];
            const candidates = Array.from(set.records.values());
            const textFields = set.schema.filter(f => ['TEXT', 'LONG_TEXT'].includes(f.type));
            const fieldId = textFields[0]?.id || set.schema[0]?.id;
            const matches = [];
            for (let i = 0; i < candidates.length; i++) {
                for (let j = i + 1; j < candidates.length; j++) {
                    const a = candidates[i];
                    const b = candidates[j];
                    const score = similarityScore(a[fieldId], b[fieldId]);
                    if (score >= threshold) {
                        matches.push({ a, b, score, fieldId });
                    }
                }
            }
            return matches.sort((x, y) => y.score - x.score).slice(0, 50);
        }

        function renderFuzzyPanel() {
            const container = document.getElementById('fuzzyMatchList');
            const thresholdInput = document.getElementById('fuzzyThresholdInput');
            if (!container || !thresholdInput) return;
            const set = getCurrentSet();
            if (!set) return;
            const threshold = parseFloat(thresholdInput.value) || state.fuzzyPanelState.threshold;
            state.fuzzyPanelState.threshold = threshold;
            const matches = computeFuzzyMatchesForSet(set, threshold);
            state.fuzzyPanelState.matches = matches;

            if (!matches.length) {
                container.innerHTML = '<p class="text-sm text-gray-500">No matches at this threshold.</p>';
                return;
            }

            container.innerHTML = matches.map(match => `
                <div class="fuzzy-match-row">
                    <div class="flex-1">
                        <div class="text-sm text-gray-500">Record A</div>
                        <strong>${match.a.name || match.a.id}</strong>
                    </div>
                    <div class="flex-1">
                        <div class="text-sm text-gray-500">Record B</div>
                        <strong>${match.b.name || match.b.id}</strong>
                        <div class="text-xs text-gray-500">Score: <span class="fuzzy-score">${match.score.toFixed(2)}</span></div>
                    </div>
                    <div class="flex items-center gap-2">
                        <button class="btn btn-secondary btn-sm" data-link="${match.a.id}|${match.b.id}" data-score="${match.score}">Link</button>
                        <button class="btn btn-secondary btn-sm" data-dismiss="${match.a.id}|${match.b.id}">Dismiss</button>
                    </div>
                </div>
            `).join('');

            container.querySelectorAll('[data-link]').forEach(btn => {
                btn.onclick = () => {
                    const [sourceId, targetId] = btn.dataset.link.split('|');
                    const score = parseFloat(btn.dataset.score || '0');
                    createConnection(sourceId, targetId, { reason: 'fuzzy-match', score });
                    showToast(' Linked records');
                };
            });

            container.querySelectorAll('[data-dismiss]').forEach(btn => {
                btn.onclick = () => {
                    btn.closest('.fuzzy-match-row').remove();
                };
            });
        }

        function openFuzzyPanel() {
            renderFuzzyPanel();
            document.getElementById('fuzzyMatchPanel').classList.add('open');
        }

        function closeFuzzyPanel() {
            document.getElementById('fuzzyMatchPanel').classList.remove('open');
        }

        function validateConnectionPayload(connection) {
            if (!connection?.relationId) {
                throw new Error('Connections must reference a connection relation');
            }

            const relation = findConnectionRelation(connection.relationId);
            if (!relation) {
                throw new Error('Referenced connection relation not found');
            }

            if (!connection?.subject || !connection?.operand) {
                throw new Error('Connections require both subject and operand');
            }
            const { subject, operand } = connection;
            if (!subject.type || !subject.id || !operand.type || !operand.id) {
                throw new Error('Connections require typed entity references');
            }

            const subjectWorld = deriveWorldIdForEntity(subject);
            const operandWorld = deriveWorldIdForEntity(operand);
            const worldMismatch = subjectWorld && operandWorld && subjectWorld !== operandWorld;
            if (worldMismatch) {
                throw new Error('Connections must stay within the same world');
            }

            const params = connection.params || {};
            if (params === null || typeof params !== 'object' || Array.isArray(params)) {
                throw new Error('Connection params must be an object');
            }

            relation.requiredParams.forEach(param => {
                if (!(param in params)) {
                    throw new Error(`Missing required param: ${param}`);
                }
            });

            const worldId = connection.worldId || subjectWorld || operandWorld || state.currentWorldId;
            if (relation.worldId && worldId && relation.worldId !== worldId) {
                throw new Error('Connection must use a relation from the same world');
            }

            return {
                ...connection,
                params,
                worldId,
                relationId: relation.id,
                operator: relation.operator,
                mode: relation.mode
            };
        }

        function addConnection(conn) {
            let normalized;
            try {
                normalized = validateConnectionPayload(conn);
            } catch (error) {
                console.error(error);
                showToast(` ${error.message || 'Unable to create connection'}`);
                return null;
            }

            const connectionId = conn.id || `conn_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            const payload = {
                ...normalized,
                id: connectionId,
                createdAt: normalized.createdAt || new Date().toISOString()
            };

            state.connections.set(connectionId, payload);
            registerEntity({ id: connectionId, type: 'Connection', worldId: payload.worldId, subject: payload.subject, operand: payload.operand });

            const summary = `Connected ${renderEntityLabel(payload.subject)} ${payload.mode || ''} ${renderEntityLabel(payload.operand)}`.trim();
            createEvent(
                'Create Connection',
                'CON',
                { type: 'Connection', id: connectionId },
                {
                    edge: payload,
                    summary
                },
                { frame: 'graph', scale: 'relationship' }
            );

            return connectionId;
        }

        function updateConnection(connectionId, updates = {}) {
            const existing = state.connections.get(connectionId);
            if (!existing) throw new Error(`Connection ${connectionId} not found`);

            const merged = validateConnectionPayload({
                ...existing,
                ...updates,
                id: connectionId
            });

            const updated = {
                ...existing,
                ...merged,
                updatedAt: new Date().toISOString()
            };

            state.connections.set(connectionId, updated);

            const summary = `Updated connection ${connectionId} (${renderEntityLabel(updated.subject)} ${updated.mode || ''} ${renderEntityLabel(updated.operand)})`;
            createEvent(
                'Update Connection',
                'CON',
                { type: 'Connection', id: connectionId },
                {
                    edge: updated,
                    summary
                },
                { frame: 'graph', scale: 'relationship' }
            );

            return updated;
        }

        function deleteConnection(connectionId) {
            const existing = state.connections.get(connectionId);
            if (!existing) throw new Error(`Connection ${connectionId} not found`);

            state.connections.delete(connectionId);

            const summary = `Removed connection ${renderEntityLabel(existing.subject)} ${existing.mode || ''} ${renderEntityLabel(existing.operand)}`;
            createEvent(
                'Delete Connection',
                'CON',
                { type: 'Connection', id: connectionId },
                {
                    edge: existing,
                    summary,
                    deleted: true
                },
                { frame: 'graph', scale: 'relationship' }
            );

            return existing;
        }

        function createConnection(sourceId, targetId, relationId = null, params = {}) {
            const resolvedRelationId = relationId || getDefaultConnectionRelationId('CON') || getDefaultConnectionRelationId();
            if (!resolvedRelationId) {
                showToast(' Add a connection relation before creating connections');
                return null;
            }

            return addConnection({
                subject: { type: 'Record', id: sourceId },
                operand: { type: 'Record', id: targetId },
                relationId: resolvedRelationId,
                params
            });
        }

        // SIDEBAR
        function toggleSidebar() {
            const isMobile = window.matchMedia('(max-width: 1024px)').matches;
            if (isMobile) {
                state.sidebarOpenMobile = !state.sidebarOpenMobile;
            } else {
                state.sidebarCollapsed = !state.sidebarCollapsed;
            }
            applyResponsiveLayout();
        }

        function closeMobileSidebar() {
            if (!state.sidebarOpenMobile) return;
            state.sidebarOpenMobile = false;
            applyResponsiveLayout();
        }

        function toggleSetExpansion(setId) {
            if (state.expandedSets.has(setId)) {
                state.expandedSets.delete(setId);
            } else {
                state.expandedSets.add(setId);
            }
            renderSidebar();
        }

        function toggleNavSection(sectionName) {
            const contentId = sectionName + 'NavContent';
            const chevronId = sectionName + 'SectionChevron';
            const content = document.getElementById(contentId);
            const chevron = document.getElementById(chevronId);

            if (!content || !chevron) return;

            if (state.collapsedNavSections.has(sectionName)) {
                state.collapsedNavSections.delete(sectionName);
                content.style.display = 'block';
                chevron.className = 'ph ph-caret-down';
            } else {
                state.collapsedNavSections.add(sectionName);
                content.style.display = 'none';
                chevron.className = 'ph ph-caret-right';
            }
        }

        function initializeNavSections() {
            // Initialize all nav sections based on the collapsedNavSections state
            const sections = ['world', 'explore', 'dataImports', 'actions', 'sets'];
            sections.forEach(sectionName => {
                const contentId = sectionName + 'NavContent';
                const chevronId = sectionName + 'SectionChevron';
                const content = document.getElementById(contentId);
                const chevron = document.getElementById(chevronId);

                if (!content || !chevron) return;

                const isCollapsed = state.collapsedNavSections.has(sectionName);
                if (isCollapsed) {
                    content.style.display = 'none';
                    chevron.className = 'ph ph-caret-right';
                } else {
                    content.style.display = 'block';
                    chevron.className = 'ph ph-caret-down';
                }
            });
        }

        function filterSets(searchTerm) {
            const setsContainer = document.getElementById('navSetsContainer');
            if (!setsContainer) return;

            const normalizedSearch = searchTerm.toLowerCase().trim();

            // If search is empty, re-render normally
            if (!normalizedSearch) {
                renderSidebar();
                return;
            }

            // Get all sets for the current world
            const setsForWorld = getSetsForWorld();
            setsContainer.innerHTML = '';

            let hasResults = false;

            setsForWorld.forEach(set => {
                const setMatches = set.name.toLowerCase().includes(normalizedSearch);
                const matchingViews = [];

                // Check if any views match
                if (set.views && set.views.size > 0) {
                    set.views.forEach((view, viewId) => {
                        if (view.name.toLowerCase().includes(normalizedSearch)) {
                            matchingViews.push([viewId, view]);
                        }
                    });
                }

                // Show set if it matches or has matching views
                if (setMatches || matchingViews.length > 0) {
                    hasResults = true;

                    // Create set header
                    const setHeader = document.createElement('div');
                    setHeader.className = 'nav-item';
                    setHeader.style.display = 'flex';
                    setHeader.style.alignItems = 'center';
                    setHeader.style.justifyContent = 'space-between';

                    const setLabel = document.createElement('span');
                    setLabel.textContent = set.name;
                    setLabel.style.flex = '1';

                    if (set.id === state.currentSetId && !state.currentSpecialView && !state.currentViewId) {
                        setHeader.classList.add('active');
                    }

                    setHeader.appendChild(setLabel);

                    setHeader.onclick = (e) => {
                        e.stopPropagation();
                        // Save any pending cell edits before navigating
                        if (state.editingCell) {
                            exitEditMode(true);
                        }
                        // Open the set in a tab (will use first view if available)
                        switchSet(set.id, null);
                    };

                    setsContainer.appendChild(setHeader);

                    // Show matching views (or all views if set matched)
                    const viewsToShow = setMatches ? Array.from(set.views.entries()) : matchingViews;
                    if (viewsToShow.length > 0) {
                        const viewsContainer = document.createElement('div');
                        viewsContainer.style.paddingLeft = '0.5rem';
                        viewsContainer.style.marginTop = '0.25rem';
                        viewsContainer.style.marginBottom = '0.5rem';

                        viewsToShow.forEach(([viewId, view]) => {
                            const viewMode = view.viewMode || 'live';
                            const viewModeClass = viewMode === 'sandbox' ? 'sandbox' : 'live';
                            const viewModeBadge = viewMode === 'sandbox'
                                ? '<span class="view-mode-badge">SB</span>'
                                : '';

                            const viewItem = document.createElement('div');
                            viewItem.className = `view-item ${viewModeClass} ${viewId === state.currentViewId ? 'active' : ''}`;
                            viewItem.style.paddingLeft = '12px';
                            viewItem.innerHTML = `
                                <span class="view-item-icon">${renderIcon(view.icon || VIEW_TYPE_ICONS[view.type])}</span>
                                <span style="flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${view.name}</span>
                                ${viewModeBadge}
                            `;
                            viewItem.onclick = (e) => {
                                e.stopPropagation();
                                switchSet(set.id, viewId);
                            };
                            viewsContainer.appendChild(viewItem);
                        });

                        setsContainer.appendChild(viewsContainer);
                    }
                }
            });

            if (!hasResults) {
                setsContainer.innerHTML = '<div style="color: #9ca3af; font-size: 0.875rem; padding: 0.5rem 0;">No matching sets or views</div>';
            }
        }

        function renderWorldSelector() {
            const select = document.getElementById('worldSelect');
            const label = document.getElementById('currentWorldLabel');
            const headerLabel = document.getElementById('currentWorldHeaderLabel');

            // Update the select dropdown if it exists
            if (select) {
                select.innerHTML = '';
                state.worlds.forEach((world, id) => {
                    const opt = document.createElement('option');
                    opt.value = id;
                    opt.textContent = world.name;
                    select.appendChild(opt);
                });

                if (!state.currentWorldId && select.options.length > 0) {
                    state.currentWorldId = select.options[0].value;
                }

                if (state.currentWorldId) {
                    select.value = state.currentWorldId;
                }
            } else {
                // If select doesn't exist, ensure we have a current world
                if (!state.currentWorldId && state.worlds.size > 0) {
                    state.currentWorldId = Array.from(state.worlds.keys())[0];
                }
            }

            // Always update labels
            if (label) {
                const world = getWorld();
                label.textContent = world?.name || 'No world selected';
            }

            if (headerLabel) {
                const world = getWorld();
                headerLabel.textContent = world?.name || 'No world selected';
            }
        }

        function pruneTabsForWorld(worldId) {
            if (!worldId) return;

            state.openTabs = state.openTabs.filter(tab => {
                const set = state.sets.get(tab.setId);
                return set?.worldId === worldId;
            });
        }

        function switchWorld(worldId) {
            if (!worldId || !state.worlds.has(worldId)) return;
            state.currentWorldId = worldId;
            pruneTabsForWorld(worldId);
            const sets = getSetsForWorld(worldId);
            if (!sets.some(set => set.id === state.currentSetId)) {
                state.currentSetId = sets[0]?.id || null;
                state.currentViewId = null;
            }
            renderWorldSelector();
            renderSidebar();
            renderViewTabs();
            if (state.currentSetId) {
                switchSet(state.currentSetId, state.currentViewId);
            } else {
                // No sets in this world - navigate to dashboard
                state.currentSpecialView = 'dashboard';
                renderCurrentView();
            }
            // syncUrlState(); // Commented out to prevent URL manipulation
        }

        function loadGraphDemo() {
            createGraphDemo();
            renderWorldSelector();
            renderSidebar();
            renderViewTabs();
            if (state.currentSetId && state.currentViewId) {
                switchSet(state.currentSetId, state.currentViewId);
            }
            // syncUrlState(); // Commented out to prevent URL manipulation
            showToast('Graph demo loaded! Explore the visualization of projects, people, tasks, and concepts.');
        }

        function openAddWorldModal() {
            const input = document.getElementById('newWorldName');
            if (input) input.value = '';
            openModal('addWorldModal');
        }

        function openEntitiesPage() {
            state.currentSpecialView = 'entities';
            state.currentSetId = null;
            state.currentViewId = null;
            closeMobileSidebar();
            renderSidebar();
            renderCurrentView();
            updateMobileChrome();
            // syncUrlState(); // Commented out to prevent URL manipulation
        }

        function saveWorldFromModal() {
            const input = document.getElementById('newWorldName');
            const name = input?.value.trim();
            if (!name) { showConfirm('Please enter a world name', () => {}); return; }
            const worldId = createWorld(name);
            switchWorld(worldId);
            closeModal('addWorldModal');
            showToast(' World created');
        }

        function openDefinitionsPage() {
            state.currentSpecialView = 'definitions';
            state.currentSetId = null;
            state.currentViewId = null;
            closeMobileSidebar();
            renderSidebar();
            renderCurrentView();
            updateMobileChrome();
            // syncUrlState(); // Commented out to prevent URL manipulation
        }

        function openRelationsPage() {
            state.currentSpecialView = 'relations';
            state.currentSetId = null;
            state.currentViewId = null;
            closeMobileSidebar();
            renderSidebar();
            renderCurrentView();
            updateMobileChrome();
            // syncUrlState(); // Commented out to prevent URL manipulation
        }

        // Alias for backwards compatibility
        function openConnectionsPage() { openRelationsPage(); }

        function openVisualizationsPage() {
            state.currentSpecialView = 'visualizations';
            state.currentSetId = null;
            state.currentViewId = null;
            closeMobileSidebar();
            renderSidebar();
            renderCurrentView();
            updateMobileChrome();
            // syncUrlState(); // Commented out to prevent URL manipulation
        }

        // NEW NAVIGATION HELPER FUNCTION
        function navigateTo(page, filterType = null) {
            // Save any pending cell edits before navigating
            if (state.editingCell) {
                exitEditMode(true);
            }

            closeMobileSidebar();

            switch(page) {
                case 'dashboard':
                case 'relations':
                case 'definitions':
                case 'views':
                case 'explore':
                case 'sandbox':
                    switchToSpecialTab(page);
                    return;
                case 'entities':
                    if (filterType) {
                        state.entityFormState = state.entityFormState || {};
                        state.entityFormState.selectedType = filterType;
                    }
                    switchToSpecialTab('entities');
                    return;
                case 'search':
                    // Legacy support - redirect to explore
                    navigateTo('explore');
                    return;
                default:
                    console.warn('Unknown navigation target:', page);
                    return;
            }
        }

        // Helper functions for navigation actions
        function openAddRecordModal() {
            const setsForWorld = getSetsForWorld();
            if (setsForWorld.length === 0) {
                showToast('Please create a set first');
                return;
            }

            const viewSelect = document.getElementById('addRecordViewSelect');
            if (!viewSelect) return;

            viewSelect.innerHTML = '';

            // Populate with all views from all sets
            setsForWorld.forEach(set => {
                if (set.views && set.views.size > 0) {
                    const optgroup = document.createElement('optgroup');
                    optgroup.label = set.name;

                    Array.from(set.views.entries()).forEach(([viewId, viewRef]) => {
                        const fullView = state.views?.get(viewId) || viewRef;
                        const option = document.createElement('option');
                        option.value = JSON.stringify({ setId: set.id, viewId });
                        option.textContent = fullView.name || 'Untitled View';
                        optgroup.appendChild(option);
                    });

                    viewSelect.appendChild(optgroup);
                }
            });

            if (viewSelect.options.length === 0) {
                showToast('Please create a view first');
                return;
            }

            // Pre-select current view if available
            if (state.currentSetId && state.currentViewId) {
                const currentValue = JSON.stringify({ setId: state.currentSetId, viewId: state.currentViewId });
                for (let i = 0; i < viewSelect.options.length; i++) {
                    if (viewSelect.options[i].value === currentValue) {
                        viewSelect.selectedIndex = i;
                        break;
                    }
                }
            }

            openModal('addRecordModal');
        }

        function importWorld() {
            document.getElementById('worldJsonInput')?.click();
        }

        function exportWorld() {
            exportJSON();
        }

        function handleAddViewClick() {
            // If a set is currently selected, use that
            if (state.currentSetId) {
                openAddViewModal(state.currentSetId);
                return;
            }

            // Otherwise, try to use the first available set
            const setsForWorld = getSetsForWorld();
            if (setsForWorld.length > 0) {
                openAddViewModal(setsForWorld[0].id);
            } else {
                showToast('Please create a set first');
            }
        }

        function toggleKnowledgeSection() {
            const titleEl = document.querySelector('.sidebar-section-title.collapsible');
            const contentEl = document.getElementById('knowledgeContent');
            if (titleEl && contentEl) {
                titleEl.classList.toggle('collapsed');
                contentEl.classList.toggle('collapsed');
            }
        }

        function pinImportToViews(viewId) {
            const view = state.views?.get(viewId);
            if (!view) return;

            // Remove temporary flag and import metadata
            view.isTemporary = false;
            delete view.importMetadata;

            // Update the view name to remove "Import: " prefix if present
            if (view.name.startsWith('Import: ')) {
                view.name = view.name.replace('Import: ', '');
            }

            // Log the pin event
            createEvent(
                'Import View Pinned',
                'UPD',
                { type: 'View', id: viewId },
                {
                    setId: view.setId,
                    viewName: view.name,
                    wasPinned: true
                }
            );

            showToast(' Import pinned to views');
            renderSidebar();
            renderCurrentView();
        }

        function removeImportView(viewId) {
            const view = state.views?.get(viewId);
            if (!view) return;

            if (!confirm(`Remove import "${view.name}"? The imported records will remain in the set.`)) {
                return;
            }

            // Remove the view
            const set = state.sets.get(view.setId);
            if (set && set.views) {
                set.views.delete(viewId);
            }
            state.views.delete(viewId);

            // Log the removal event
            createEvent(
                'Import View Removed',
                'DEL',
                { type: 'View', id: viewId },
                {
                    setId: view.setId,
                    viewName: view.name
                }
            );

            // If this was the current view, switch to the set default view
            if (state.currentViewId === viewId) {
                switchSet(view.setId, null);
            }

            showToast(' Import removed');
            renderSidebar();
        }

        // Floating import banner management
        let floatingBannerDismissed = new Set(); // Track dismissed banners by view ID

        function updateFloatingImportBanner() {
            const existingBanner = document.querySelector('.floating-import-banner');
            const view = getCurrentView();
            const isImportView = view && view.isTemporary && view.importMetadata;

            // Remove existing banner if not an import view or if dismissed
            if (!isImportView || floatingBannerDismissed.has(view?.id)) {
                if (existingBanner) {
                    existingBanner.classList.add('hiding');
                    setTimeout(() => existingBanner.remove(), 200);
                }
                return;
            }

            // Don't re-create if already showing for this view
            if (existingBanner && existingBanner.dataset.viewId === view.id) {
                return;
            }

            // Remove any existing banner first
            if (existingBanner) {
                existingBanner.remove();
            }

            // Create and show the floating banner
            const banner = document.createElement('div');
            banner.className = 'floating-import-banner';
            banner.dataset.viewId = view.id;

            // Get deduplication stats if available
            let dedupInfo = '';
            if (typeof EOContentStore !== 'undefined' && view.importMetadata?.importId) {
                const dedupStats = EOContentStore.getImportStats(view.importMetadata.importId);
                if (dedupStats && parseFloat(dedupStats.compressionRatio) > 0) {
                    dedupInfo = `
                        <div style="display: flex; align-items: center; gap: 8px; margin-top: 8px; padding: 8px 10px; background: rgba(34, 197, 94, 0.1); border-radius: 6px; font-size: 11px;">
                            <i class="ph ph-hard-drives" style="color: #22c55e;"></i>
                            <span><strong>${dedupStats.compressionRatio}%</strong> storage optimized</span>
                            <span style="color: rgba(255,255,255,0.5);">|</span>
                            <span>${dedupStats.duplicateRecords} duplicates</span>
                            ${dedupStats.deltaRecords > 0 ? `<span style="color: rgba(255,255,255,0.5);">|</span><span>${dedupStats.deltaRecords} deltas</span>` : ''}
                            <button onclick="showImportStorageDetails('${view.importMetadata.importId}')" style="margin-left: auto; background: transparent; border: 1px solid rgba(255,255,255,0.3); color: white; padding: 2px 8px; border-radius: 4px; cursor: pointer; font-size: 10px;">
                                Details
                            </button>
                        </div>
                    `;
                }
            }

            banner.innerHTML = `
                <button class="floating-import-banner-close" onclick="dismissFloatingImportBanner('${view.id}')" title="Dismiss">
                    <i class="ph ph-x"></i>
                </button>
                <i class="ph ph-cloud-slash floating-import-banner-icon"></i>
                <div class="floating-import-banner-content">
                    <div class="floating-import-banner-title">Saved Locally Only</div>
                    <div class="floating-import-banner-text">
                        This data is stored in your browser. Hit "Save" to sync to cloud. If you export your world now, this data will be included.
                    </div>
                    ${dedupInfo}
                    <div class="floating-import-banner-actions">
                        <button class="floating-import-banner-btn primary" onclick="showSaveImportAsViewDialog()">
                            <i class="ph ph-cloud-arrow-up"></i> Save to Cloud
                        </button>
                    </div>
                </div>
            `;
            document.body.appendChild(banner);
        }

        function dismissFloatingImportBanner(viewId) {
            floatingBannerDismissed.add(viewId);
            const banner = document.querySelector('.floating-import-banner');
            if (banner) {
                banner.classList.add('hiding');
                setTimeout(() => banner.remove(), 200);
            }
        }

        /**
         * Show detailed storage/deduplication info for an import
         */
        function showImportStorageDetails(importId) {
            if (typeof EODeduplicationUI === 'undefined') {
                showToast('Storage details module not available', 'error');
                return;
            }

            const modal = document.createElement('div');
            modal.className = 'modal-overlay';
            modal.id = 'storageDetailsModal';
            modal.style.display = 'flex';

            const imp = state.importManager?.getImport(importId);
            const impName = imp?.name || 'Import';

            modal.innerHTML = `
                <div class="modal" style="width: 90%; max-width: 800px; max-height: 85vh; display: flex; flex-direction: column;">
                    <div class="modal-header">
                        <h3 style="display: flex; align-items: center; gap: 10px;">
                            <i class="ph ph-hard-drives" style="color: #6366f1;"></i>
                            Storage Details: ${impName}
                        </h3>
                        <button class="modal-close" onclick="closeModal('storageDetailsModal')"></button>
                    </div>
                    <div class="modal-body" style="flex: 1; overflow: auto; padding: 0;">
                        ${EODeduplicationUI.renderImportStorageTab(importId)}
                    </div>
                    <div class="modal-footer">
                        <button class="btn btn-secondary" onclick="closeModal('storageDetailsModal')">Close</button>
                    </div>
                </div>
            `;

            document.body.appendChild(modal);
        }

        // Expose to global scope for onclick handlers
        window.showImportStorageDetails = showImportStorageDetails;

        function reifyImportView() {
            const view = getCurrentView();
            if (!view || !view.isTemporary || !view.importMetadata) return;

            const set = getCurrentSet();
            if (!set) return;

            // Mark all imported records as "reified" (permanent entities)
            const recordIds = Array.from(set.records.keys());
            let reifiedCount = 0;

            recordIds.forEach(recordId => {
                const record = set.records.get(recordId);
                if (record) {
                    // Add reified metadata to record
                    if (!record._metadata) {
                        record._metadata = {};
                    }
                    record._metadata.reified = true;
                    record._metadata.reifiedAt = Date.now();
                    record._metadata.reifiedBy = state.currentUser.id;
                    record._metadata.importSource = view.importMetadata.filename;
                    reifiedCount++;
                }
            });

            // Remove temporary flag and import metadata from view
            view.isTemporary = false;
            const importMetadata = view.importMetadata;
            delete view.importMetadata;

            // Update the view name to remove "Import: " prefix if present
            if (view.name.startsWith('Import: ')) {
                view.name = view.name.replace('Import: ', '');
            }

            // Log the reification event
            createEvent(
                'Import Reified',
                'UPD',
                { type: 'View', id: view.id },
                {
                    setId: view.setId,
                    viewName: view.name,
                    recordCount: reifiedCount,
                    originalFilename: importMetadata.filename,
                    wasReified: true
                }
            );

            showToast(` Import made permanent (${reifiedCount} records reified)`);
            renderSidebar();
            renderCurrentView();
        }

        function renderSidebar() {
            // Update world name in nav
            const worldNavName = document.getElementById('worldNavName');
            const world = getWorld();
            if (worldNavName && world) {
                worldNavName.textContent = world.name;
            }

            // Update active states for nav items
            const navItems = {
                'navDashboard': state.currentSpecialView === 'dashboard',
                'navEntities': state.currentSpecialView === 'entities',
                'navRelations': state.currentSpecialView === 'relations',
                'navDefinitions': state.currentSpecialView === 'definitions',
                'navViews': state.currentSpecialView === 'views',
                'navExplore': state.currentSpecialView === 'explore',
                'navSandbox': state.currentSpecialView === 'sandbox',
                'navSuggestedViews': state.currentSpecialView === 'suggestedViews',
                'navSuggestedConcepts': state.currentSpecialView === 'suggestedConcepts'
            };

            Object.entries(navItems).forEach(([id, isActive]) => {
                const el = document.getElementById(id);
                if (el) {
                    el.classList.toggle('active', isActive);
                }
            });

            // Render imports in sidebar
            renderImportsInSidebar();

            // Populate sets in nav
            const setsContainer = document.getElementById('navSetsContainer');
            if (!setsContainer) return;

            setsContainer.innerHTML = '';
            const setsForWorld = getSetsForWorld();

            if (setsForWorld.length === 0) {
                setsContainer.innerHTML = '<div style="color: #9ca3af; font-size: 0.875rem; padding: 0.5rem 0;">No sets yet</div>';
            } else {
                setsForWorld.forEach(set => {
                    const isExpanded = state.expandedSets.has(set.id);
                    const hasViews = set.views && set.views.size > 0;

                    // Create set header with chevron
                    const setHeader = document.createElement('div');
                    setHeader.className = 'nav-item';
                    setHeader.style.display = 'flex';
                    setHeader.style.alignItems = 'center';
                    setHeader.style.justifyContent = 'space-between';

                    const setLabel = document.createElement('span');
                    setLabel.textContent = set.name;
                    setLabel.style.flex = '1';

                    const chevron = document.createElement('i');
                    chevron.className = `ph ${isExpanded ? 'ph-caret-down' : 'ph-caret-right'}`;
                    chevron.style.fontSize = '12px';
                    chevron.style.opacity = '0.7';
                    chevron.style.transition = 'transform 0.15s';

                    if (set.id === state.currentSetId && !state.currentSpecialView && !state.currentViewId) {
                        setHeader.classList.add('active');
                    }

                    setHeader.appendChild(setLabel);
                    if (hasViews) {
                        setHeader.appendChild(chevron);
                    }

                    setHeader.onclick = (e) => {
                        e.stopPropagation();
                        // Save any pending cell edits before navigating
                        if (state.editingCell) {
                            exitEditMode(true);
                        }
                        // Open the set in a tab (will use first view if available)
                        switchSet(set.id, null);
                    };

                    setHeader.oncontextmenu = (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        showSetContextMenu(e, set.id);
                    };

                    setsContainer.appendChild(setHeader);

                    // Render views under this set if expanded
                    if (isExpanded && hasViews) {
                        const viewsContainer = document.createElement('div');
                        viewsContainer.style.paddingLeft = '0.5rem';
                        viewsContainer.style.marginTop = '0.25rem';
                        viewsContainer.style.marginBottom = '0.5rem';

                        const orderedViews = Array.from(set.views.entries())
                            .sort(([, a], [, b]) => (a.order || 0) - (b.order || 0));

                        renderViewTree(orderedViews, set.id, viewsContainer);
                        setsContainer.appendChild(viewsContainer);
                    }
                });
            }

            renderViewTabs();
        }

        function renderViewTree(orderedViews, setId, container, parentId = null, depth = 0) {
            const normalizedParent = parentId || null;
            const childViews = orderedViews.filter(([_, view]) => (view.parentId || null) === normalizedParent);

            childViews.forEach(([viewId, view]) => {
                const viewMode = view.viewMode || 'live';
                const viewModeClass = viewMode === 'sandbox' ? 'sandbox' : 'live';
                const viewModeBadge = viewMode === 'sandbox'
                    ? '<span class="view-mode-badge">SB</span>'
                    : '';

                const viewItem = document.createElement('div');
                viewItem.className = `view-item ${viewModeClass} ${viewId === state.currentViewId ? 'active' : ''}`;
                viewItem.style.paddingLeft = `${12 + depth * 16}px`;
                viewItem.innerHTML = `
                    <span class="view-item-icon">${renderIcon(view.icon || VIEW_TYPE_ICONS[view.type])}</span>
                    <span style="flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${view.name}</span>
                    ${viewModeBadge}
                `;
                viewItem.onclick = (e) => {
                    e.stopPropagation();
                    switchSet(setId, viewId);
                };
                viewItem.ondblclick = (e) => { e.stopPropagation(); openAddViewModal(setId, viewId); };
                viewItem.oncontextmenu = (e) => { e.preventDefault(); e.stopPropagation(); openAddViewModal(setId, viewId); };

                container.appendChild(viewItem);
                renderViewTree(orderedViews, setId, container, viewId, depth + 1);
            });
        }

        function isViewDescendant(set, startId, potentialAncestorId) {
            let currentParent = set.views.get(startId)?.parentId || null;
            while (currentParent) {
                if (currentParent === potentialAncestorId) return true;
                currentParent = set.views.get(currentParent)?.parentId || null;
            }
            return false;
        }

        function populateViewParentOptions(setId, excludeViewId = null, selectedParentId = null) {
            const select = document.getElementById('newViewParent');
            if (!select) return;

            select.innerHTML = '';
            const defaultOption = document.createElement('option');
            defaultOption.value = '';
            defaultOption.textContent = 'No parent';
            select.appendChild(defaultOption);

            const set = state.sets.get(setId);
            if (!set) return;

            const orderedViews = Array.from(set.views.entries());
            const renderOptions = (parentId = null, depth = 0) => {
                const children = orderedViews.filter(([id, view]) => (view.parentId || null) === (parentId || null));
                children.forEach(([id, view]) => {
                    if (excludeViewId && id === excludeViewId) return;
                    const option = document.createElement('option');
                    option.value = id;
                    option.innerHTML = `${' '.repeat(depth)}${renderIcon(view.icon || VIEW_TYPE_ICONS[view.type])} ${view.name}`;
                    select.appendChild(option);
                    renderOptions(id, depth + 1);
                });
            };

            renderOptions();
            select.value = selectedParentId || '';
        }

        function openAddViewModal(setId, viewId = null) {
            const set = state.sets.get(setId);
            if (!set) {
                showToast(' Please select a set first to add a view');
                return;
            }

            const titleEl = document.getElementById('addViewModalTitle');
            const saveBtn = document.getElementById('saveAddViewBtn');
            const nameInput = document.getElementById('newViewName');
            const iconInput = document.getElementById('newViewIcon');
            const keySelect = document.getElementById('keyCandidateSelect');
            const radioBlank = document.querySelector('input[name="viewCreationMode"][value="blank"]');
            const radioKey = document.querySelector('input[name="viewCreationMode"][value="key"]');

            state.currentSetId = setId;
            if (viewId) {
                const view = set.views.get(viewId);
                state.viewEditorContext = { setId, viewId };
                if (titleEl) titleEl.textContent = 'Edit View';
                if (saveBtn) saveBtn.textContent = 'Save';
                if (nameInput) nameInput.value = view?.name || '';
                if (iconInput) iconInput.value = extractIconToken(view?.icon || VIEW_TYPE_ICONS[view?.type]);
                populateViewParentOptions(setId, viewId, view?.parentId || null);
                if (radioBlank && radioKey) {
                    radioBlank.checked = view?.type !== 'KEY_DERIVED';
                    radioKey.checked = view?.type === 'KEY_DERIVED';
                }
                if (keySelect && view?.type === 'KEY_DERIVED' && view.key) {
                    const optionValue = `${view.key.setId}:${view.key.fieldId}`;
                    keySelect.innerHTML = `<option value="${optionValue}">${view.key.fieldId}</option>`;
                    keySelect.disabled = true;
                }
            } else {
                state.viewEditorContext = { setId, viewId: null };
                if (titleEl) titleEl.textContent = 'Create View';
                if (saveBtn) saveBtn.textContent = 'Create';
                if (nameInput) nameInput.value = '';
                if (iconInput) iconInput.value = 'ph-table';
                populateViewParentOptions(setId);

                // Show modal immediately with loading state for key candidates
                if (keySelect) {
                    keySelect.disabled = true;
                    keySelect.innerHTML = '<option value="">Scanning for identity properties</option>';
                }
                if (radioBlank && radioKey) {
                    radioBlank.checked = true;
                    radioKey.checked = false;
                }

                // Find all fields for pivot asynchronously to avoid blocking UI
                setTimeout(() => {
                    const allFields = getAllFieldsForPivot();
                    if (keySelect) {
                        keySelect.disabled = allFields.length === 0;
                        if (allFields.length === 0) {
                            keySelect.innerHTML = '<option value="">No fields available</option>';
                        } else {
                            const recommended = allFields.filter(f => f.isRecommended);
                            const others = allFields.filter(f => !f.isRecommended);

                            let html = '<option value="">Select a field to pivot on...</option>';

                            if (recommended.length > 0) {
                                html += '<optgroup label="Recommended">';
                                html += recommended.map(f =>
                                    `<option value="${f.setId}:${f.fieldId}">${f.fieldName} (${f.setName})</option>`
                                ).join('');
                                html += '</optgroup>';
                            }

                            if (others.length > 0) {
                                html += '<optgroup label="All Fields">';
                                html += others.map(f =>
                                    `<option value="${f.setId}:${f.fieldId}">${f.fieldName} (${f.setName})</option>`
                                ).join('');
                                html += '</optgroup>';
                            }

                            keySelect.innerHTML = html;
                        }

                        // Re-check if key mode is selected and update disabled state
                        const selectedMode = document.querySelector('input[name="viewCreationMode"]:checked')?.value;
                        if (selectedMode === 'key') {
                            keySelect.disabled = allFields.length === 0;
                        }
                    }
                }, 0);
            }

            syncIconSelector('newViewIcon');
            openModal('addViewModal');

            // Initialize key/value search
            initKeyValueSearch();
        }

        function initKeyValueSearch() {
            const searchInput = document.getElementById('keySearchInput');
            const resultsContainer = document.getElementById('keySearchResults');
            const keySelect = document.getElementById('keyCandidateSelect');

            if (!searchInput || !resultsContainer) return;

            // Clear previous state
            searchInput.value = '';
            resultsContainer.innerHTML = '';
            resultsContainer.classList.add('hidden');

            let debounceTimer;

            searchInput.oninput = () => {
                clearTimeout(debounceTimer);
                debounceTimer = setTimeout(() => {
                    const query = searchInput.value.trim();
                    if (query.length < 2) {
                        resultsContainer.classList.add('hidden');
                        return;
                    }

                    const results = searchKeysAndValues(query);
                    renderKeyValueSearchResults(results, resultsContainer, keySelect, searchInput);
                }, 150);
            };

            // Close dropdown when clicking outside
            searchInput.onblur = (e) => {
                setTimeout(() => {
                    if (!resultsContainer.contains(document.activeElement)) {
                        resultsContainer.classList.add('hidden');
                    }
                }, 200);
            };

            searchInput.onfocus = () => {
                if (searchInput.value.trim().length >= 2) {
                    resultsContainer.classList.remove('hidden');
                }
            };
        }

        function searchKeysAndValues(query) {
            const q = query.toLowerCase();
            const results = [];
            const seen = new Set();

            getSetsForWorld().forEach(set => {
                if (!set || !set.schema) return;

                // Search fields by name
                set.schema.forEach(field => {
                    if (field && field.name && field.name.toLowerCase().includes(q)) {
                        const key = `field:${set.id}:${field.id}`;
                        if (!seen.has(key)) {
                            results.push({
                                type: 'field',
                                setId: set.id,
                                setName: set.name,
                                fieldId: field.id,
                                fieldName: field.name,
                                fieldType: field.type,
                                label: field.name,
                                sublabel: `Field in ${set.name}`
                            });
                            seen.add(key);
                        }
                    }
                });

                // Search unique values in fields
                if (set.records && set.records.size > 0) {
                    set.schema.forEach(field => {
                        if (!field) return;

                        const uniqueValues = new Map();
                        set.records.forEach((record, recordId) => {
                            const value = record[field.id];
                            if (value != null && value !== '') {
                                const valueStr = String(value);
                                if (valueStr.toLowerCase().includes(q)) {
                                    if (!uniqueValues.has(valueStr)) {
                                        uniqueValues.set(valueStr, { count: 0, recordId });
                                    }
                                    uniqueValues.get(valueStr).count++;
                                }
                            }
                        });

                        // Add unique values that appear multiple times (good key candidates)
                        uniqueValues.forEach((info, valueStr) => {
                            const key = `value:${set.id}:${field.id}:${valueStr}`;
                            if (!seen.has(key) && results.length < 50) {
                                results.push({
                                    type: 'value',
                                    setId: set.id,
                                    setName: set.name,
                                    fieldId: field.id,
                                    fieldName: field.name,
                                    value: valueStr,
                                    count: info.count,
                                    label: valueStr,
                                    sublabel: `${field.name} in ${set.name} (${info.count} records)`
                                });
                                seen.add(key);
                            }
                        });
                    });
                }
            });

            // Sort: fields first, then values by count
            results.sort((a, b) => {
                if (a.type !== b.type) return a.type === 'field' ? -1 : 1;
                if (a.type === 'value') return (b.count || 0) - (a.count || 0);
                return a.label.localeCompare(b.label);
            });

            return results.slice(0, 20);
        }

        function renderKeyValueSearchResults(results, container, keySelect, searchInput) {
            if (results.length === 0) {
                container.innerHTML = '<div class="px-3 py-2 text-sm text-gray-500">No matching fields or values found</div>';
                container.classList.remove('hidden');
                return;
            }

            let html = '';
            results.forEach(result => {
                const icon = result.type === 'field' ? '<i class="ph ph-columns"></i>' : '<i class="ph ph-hash"></i>';
                html += `
                    <div class="key-search-result px-3 py-2 hover:bg-blue-50 cursor-pointer border-b border-gray-100 last:border-0"
                         data-set-id="${result.setId}"
                         data-field-id="${result.fieldId}"
                         data-type="${result.type}"
                         data-value="${escapeHtml(result.value || '')}">
                        <div class="flex items-center gap-2">
                            ${icon}
                            <div class="flex-1 min-w-0">
                                <div class="text-sm font-medium text-gray-900 truncate">${escapeHtml(result.label)}</div>
                                <div class="text-xs text-gray-500 truncate">${escapeHtml(result.sublabel)}</div>
                            </div>
                            <span class="text-xs px-1.5 py-0.5 rounded bg-gray-100 text-gray-600">${result.type}</span>
                        </div>
                    </div>
                `;
            });

            container.innerHTML = html;
            container.classList.remove('hidden');

            // Add click handlers
            container.querySelectorAll('.key-search-result').forEach(el => {
                el.onclick = () => {
                    const setId = el.dataset.setId;
                    const fieldId = el.dataset.fieldId;
                    const selectValue = `${setId}:${fieldId}`;

                    // Update the select dropdown with this option
                    const existingOption = Array.from(keySelect.options).find(opt => opt.value === selectValue);
                    if (!existingOption) {
                        const optionText = el.querySelector('.text-sm.font-medium').textContent + ' (' + el.querySelector('.text-xs.text-gray-500').textContent.split(' in ')[1]?.replace(/\).*/, ')') || '';
                        const newOption = new Option(optionText || fieldId, selectValue, true, true);
                        keySelect.insertBefore(newOption, keySelect.firstChild);
                    }
                    keySelect.value = selectValue;
                    keySelect.disabled = false;

                    // Update search input to show selection
                    searchInput.value = el.querySelector('.text-sm.font-medium').textContent;

                    // Hide results
                    container.classList.add('hidden');

                    // Auto-select the "Create From Key or Value" radio
                    const radioKey = document.querySelector('input[name="viewCreationMode"][value="key"]');
                    if (radioKey) radioKey.checked = true;
                };
            });
        }

        function getTabKey(setId, viewId, specialView = null) {
            if (specialView) return `special::${specialView}`;
            return `${setId || ''}::${viewId || ''}`;
        }

        // Icons and labels for special view tabs
        const SPECIAL_VIEW_CONFIG = {
            dashboard: { icon: 'ph-house', label: 'Dashboard' },
            entities: { icon: 'ph-cube', label: 'Entities' },
            relations: { icon: 'ph-tree-structure', label: 'Relations' },
            definitions: { icon: 'ph-book-open', label: 'Definitions' },
            views: { icon: 'ph-layout', label: 'Views' },
            explore: { icon: 'ph-compass', label: 'Explore' },
            sandbox: { icon: 'ph-flask', label: 'Sandbox' }
        };

        function ensureOpenTab(setId, viewId) {
            const set = state.sets.get(setId);
            const view = set?.views.get(viewId);
            if (!set || !view) return;
            const key = getTabKey(setId, viewId);
            const exists = state.openTabs.some(tab => getTabKey(tab.setId, tab.viewId, tab.specialView) === key);
            if (!exists) {
                state.openTabs.push({ setId, viewId });
            }
            renderViewTabs();
        }

        function ensureOpenSpecialTab(specialView) {
            if (!SPECIAL_VIEW_CONFIG[specialView]) return;
            const key = getTabKey(null, null, specialView);
            const exists = state.openTabs.some(tab => getTabKey(tab.setId, tab.viewId, tab.specialView) === key);
            if (!exists) {
                state.openTabs.push({ specialView });
            }
            renderViewTabs();
        }

        function closeViewTab(setId, viewId, specialView = null) {
            const key = getTabKey(setId, viewId, specialView);
            const index = state.openTabs.findIndex(tab => getTabKey(tab.setId, tab.viewId, tab.specialView) === key);
            if (index === -1) return;

            const closingActive = specialView
                ? state.currentSpecialView === specialView
                : (state.currentSetId === setId && state.currentViewId === viewId);
            const fallback = closingActive ? (state.openTabs[index + 1] || state.openTabs[index - 1]) : null;
            state.openTabs.splice(index, 1);
            renderViewTabs();

            if (closingActive) {
                if (fallback) {
                    if (fallback.specialView) {
                        switchToSpecialTab(fallback.specialView);
                    } else {
                        switchSet(fallback.setId, fallback.viewId);
                    }
                } else {
                    state.currentSetId = null;
                    state.currentViewId = null;
                    state.currentSpecialView = null;
                    renderSidebar();
                    renderCurrentView();
                    updateMobileChrome();
                }
            }
        }

        function showViewTabContextMenu(event, setId, viewId) {
            const set = state.sets.get(setId);
            const view = set?.views.get(viewId);
            if (!set || !view) return;

            // Remove any existing context menu
            document.querySelectorAll('.view-tab-context-menu').forEach(menu => menu.remove());

            const menu = document.createElement('div');
            menu.className = 'context-menu view-tab-context-menu';
            // Check if this tab is already a shortcut
            const shortcuts = getTabShortcuts();
            const isShortcut = shortcuts.some(s => s.setId === setId && s.viewId === viewId);

            menu.innerHTML = `
                <div class="menu-item" data-action="edit">
                    <span class="icon"><i class="ph ph-pencil-simple"></i></span> Edit View
                </div>
                <div class="menu-item" data-action="duplicate">
                    <span class="icon"><i class="ph ph-copy"></i></span> Duplicate
                </div>
                <div class="menu-separator"></div>
                <div class="menu-item" data-action="shortcut">
                    <span class="icon"><i class="ph ${isShortcut ? 'ph-bookmark-simple-fill' : 'ph-bookmark-simple'}"></i></span>
                    ${isShortcut ? 'Remove Shortcut' : 'Save as Shortcut'}
                </div>
                <div class="menu-separator"></div>
                <div class="menu-item" data-action="close">
                    <span class="icon"><i class="ph ph-x"></i></span> Close Tab
                </div>
                <div class="menu-item danger" data-action="delete">
                    <span class="icon"><i class="ph ph-trash"></i></span> Delete View
                </div>
            `;

            menu.style.position = 'fixed';
            menu.style.top = `${event.clientY}px`;
            menu.style.left = `${event.clientX}px`;
            menu.style.zIndex = '10000';

            document.body.appendChild(menu);

            // Handle menu item clicks
            menu.querySelectorAll('.menu-item').forEach(item => {
                item.addEventListener('click', () => {
                    const action = item.dataset.action;
                    menu.remove();

                    switch (action) {
                        case 'edit':
                            showEditViewDialog(setId, viewId);
                            break;
                        case 'duplicate':
                            const newName = `${view.name} (copy)`;
                            cloneView(state, viewId, newName);
                            renderSidebar();
                            renderViewTabs();
                            break;
                        case 'shortcut':
                            if (isShortcut) {
                                const existingShortcut = shortcuts.find(s => s.setId === setId && s.viewId === viewId);
                                if (existingShortcut) removeTabShortcut(existingShortcut.id);
                            } else {
                                addTabShortcut({ setId, viewId });
                            }
                            break;
                        case 'close':
                            closeViewTab(setId, viewId);
                            break;
                        case 'delete':
                            if (confirm(`Delete view "${view.name}"? This cannot be undone.`)) {
                                deleteView(state, viewId);
                                closeViewTab(setId, viewId);
                                renderSidebar();
                            }
                            break;
                    }
                });
            });

            // Close on click outside
            setTimeout(() => {
                document.addEventListener('click', function closeMenu(e) {
                    if (!menu.contains(e.target)) {
                        menu.remove();
                        document.removeEventListener('click', closeMenu);
                    }
                });
            }, 0);
        }

        function showEditViewDialog(setId, viewId) {
            const set = state.sets.get(setId);
            const view = set?.views.get(viewId);
            if (!set || !view) return;

            const dialog = document.createElement('div');
            dialog.className = 'modal-overlay';
            dialog.innerHTML = `
                <div class="modal edit-view-modal">
                    <div class="modal-header">
                        <div class="modal-title-group">
                            <div class="modal-icon">
                                <i class="ph ph-pencil-simple"></i>
                            </div>
                            <h2>Edit View</h2>
                        </div>
                        <button class="modal-close" aria-label="Close">
                            <i class="ph ph-x"></i>
                        </button>
                    </div>
                    <div class="modal-body">
                        <div class="form-group">
                            <label>View Name</label>
                            <input type="text" id="edit-view-name" placeholder="Enter view name..." value="${escapeHtml(view.name)}">
                        </div>
                        <div class="form-group">
                            <label>Icon</label>
                            <div id="editViewIconSelector" class="icon-selector" role="button" tabindex="0">
                                <div id="editViewIconPreview" class="icon-selector-icon" aria-hidden="true">${view.icon || VIEW_TYPE_ICONS[view.type]}</div>
                                <div class="icon-selector-text">
                                    <div class="icon-selector-label">Choose an icon</div>
                                    <div id="editViewIconToken" class="icon-selector-token">${view.icon || VIEW_TYPE_ICONS[view.type]}</div>
                                </div>
                                <i class="ph ph-caret-down icon-selector-chevron"></i>
                            </div>
                            <input type="hidden" id="edit-view-icon" value="${view.icon || VIEW_TYPE_ICONS[view.type]}">
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button class="btn-secondary modal-close">Cancel</button>
                        <button class="btn-primary" id="btn-save-view">
                            <i class="ph ph-check"></i>
                            Save Changes
                        </button>
                    </div>
                </div>
            `;

            document.body.appendChild(dialog);

            // Setup icon selector for this dialog
            const iconSelectorId = 'edit-view-icon';
            ICON_SELECTOR_TARGETS[iconSelectorId] = {
                inputId: iconSelectorId,
                selectorId: 'editViewIconSelector',
                previewId: 'editViewIconPreview',
                tokenId: 'editViewIconToken'
            };
            bindIconSelector(iconSelectorId);

            // Event listeners
            dialog.querySelectorAll('.modal-close').forEach(btn => {
                btn.addEventListener('click', () => {
                    delete ICON_SELECTOR_TARGETS[iconSelectorId];
                    dialog.remove();
                });
            });

            dialog.querySelector('#btn-save-view').addEventListener('click', () => {
                const name = dialog.querySelector('#edit-view-name').value.trim() || 'Untitled view';
                const icon = dialog.querySelector('#edit-view-icon').value;

                updateView(state, viewId, { name, icon });

                delete ICON_SELECTOR_TARGETS[iconSelectorId];
                dialog.remove();

                // Re-render everything to show the changes
                renderSidebar();
                renderViewTabs();
                renderCurrentView();
            });

            // Focus the name input
            setTimeout(() => {
                dialog.querySelector('#edit-view-name')?.focus();
            }, 100);
        }

        function reorderOpenTabs(dragKey, targetKey, position) {
            const fromIndex = state.openTabs.findIndex(tab => getTabKey(tab.setId, tab.viewId, tab.specialView) === dragKey);
            const targetIndex = state.openTabs.findIndex(tab => getTabKey(tab.setId, tab.viewId, tab.specialView) === targetKey);
            if (fromIndex === -1 || targetIndex === -1 || dragKey === targetKey) return;

            const [dragged] = state.openTabs.splice(fromIndex, 1);
            const adjustedTarget = fromIndex < targetIndex ? targetIndex - 1 : targetIndex;
            const insertIndex = position === 'before' ? adjustedTarget : adjustedTarget + 1;
            state.openTabs.splice(insertIndex, 0, dragged);
            renderViewTabs();
        }

        function clearTabDropIndicators() {
            document.querySelectorAll('.view-tab').forEach(tab => {
                tab.classList.remove('tab-drop-before', 'tab-drop-after', 'tab-being-dragged');
            });
        }

        function handleTabDragStart(event, tab) {
            const key = getTabKey(tab.setId, tab.viewId, tab.specialView);
            tabDragState.draggingKey = key;
            tabDragState.dropKey = null;
            tabDragState.dropPosition = null;
            event.dataTransfer.effectAllowed = 'move';
            event.dataTransfer.setData('text/plain', key);
            event.currentTarget.classList.add('tab-being-dragged');
        }

        function handleTabDragOver(event, targetTab) {
            if (!tabDragState.draggingKey) return;
            event.preventDefault();

            const targetKey = getTabKey(targetTab.setId, targetTab.viewId, targetTab.specialView);
            if (targetKey === tabDragState.draggingKey) return;

            const rect = event.currentTarget.getBoundingClientRect();
            const position = event.clientX < rect.left + rect.width / 2 ? 'before' : 'after';
            clearTabDropIndicators();
            event.currentTarget.classList.add(position === 'before' ? 'tab-drop-before' : 'tab-drop-after');
            tabDragState.dropKey = targetKey;
            tabDragState.dropPosition = position;
        }

        function finalizeTabDrag() {
            clearTabDropIndicators();
            tabDragState.draggingKey = null;
            tabDragState.dropKey = null;
            tabDragState.dropPosition = null;
        }

        function handleTabDrop(event, targetTab) {
            if (!tabDragState.draggingKey) return;
            event.preventDefault();
            const targetKey = getTabKey(targetTab.setId, targetTab.viewId, targetTab.specialView);
            const position = tabDragState.dropPosition || 'after';
            reorderOpenTabs(tabDragState.draggingKey, targetKey, position);
            finalizeTabDrag();
        }

        // ============================================================================
        // FLEXIBLE LAYOUT SYSTEM
        // ============================================================================

        // Layout drag state for cross-pane dragging
        const layoutDragState = {
            dragging: false,
            draggedTab: null,
            sourcePaneId: null,
            targetPaneId: null,
            dropZone: null
        };

        // Divider resize state
        const dividerResizeState = {
            resizing: false,
            splitId: null,
            direction: null,
            startPos: 0,
            startRatio: 0
        };

        /**
         * Initialize the layout system
         */
        function initializeLayoutSystem() {
            if (typeof EOLayout === 'undefined') {
                console.warn('EOLayout not loaded, using legacy tab system');
                return;
            }

            // Initialize layout state
            EOLayout.initializeLayout(state);

            // Migrate existing openTabs to layout
            if (state.openTabs && state.openTabs.length > 0) {
                const mainPane = EOLayout.findPaneById(state.layout.root, 'pane-main');
                if (mainPane) {
                    mainPane.tabs = [...state.openTabs];
                    // Set active tab based on current view
                    const activeIndex = mainPane.tabs.findIndex(
                        t => t.setId === state.currentSetId && t.viewId === state.currentViewId
                    );
                    mainPane.activeTabIndex = activeIndex >= 0 ? activeIndex : 0;
                }
            }

            // Set up global event listeners for drag and resize
            document.addEventListener('mousemove', handleLayoutMouseMove);
            document.addEventListener('mouseup', handleLayoutMouseUp);

            console.log('Layout system initialized');
        }

        /**
         * Render the entire layout tree
         */
        function renderLayout() {
            if (!state.layout) {
                initializeLayoutSystem();
            }

            const container = document.getElementById('layoutContainer');
            if (!container) return;

            // Render the layout tree
            container.innerHTML = renderLayoutNode(state.layout.root);

            // Update active pane focus
            updatePaneFocus();

            // Re-attach event listeners
            attachLayoutEventListeners();
        }

        /**
         * Recursively render a layout node (pane or split)
         */
        function renderLayoutNode(node) {
            if (!node) return '';

            if (node.type === 'pane') {
                return renderPaneHTML(node);
            }

            if (node.type === 'split') {
                const ratioPercent = (node.ratio * 100).toFixed(2);
                return `
                    <div class="layout-split ${node.direction}" data-split-id="${node.id}" style="--split-ratio: ${node.ratio}">
                        ${renderLayoutNode(node.first)}
                        <div class="layout-divider"
                             data-split-id="${node.id}"
                             data-direction="${node.direction}"
                             onmousedown="startDividerResize(event, '${node.id}', '${node.direction}')"></div>
                        ${renderLayoutNode(node.second)}
                    </div>
                `;
            }

            return '';
        }

        /**
         * Render a single pane's HTML
         */
        function renderPaneHTML(pane) {
            const isActive = state.layout?.activePaneId === pane.id;

            // Validate and clean up tabs - remove ones where set/view no longer exists
            const validTabs = (pane.tabs || []).filter(tab => {
                if (tab.specialView) {
                    return SPECIAL_VIEW_CONFIG[tab.specialView] != null;
                }
                const set = state.sets.get(tab.setId);
                const view = set?.views.get(tab.viewId);
                return set && view;
            });

            // Update pane tabs if any were removed
            if (validTabs.length !== (pane.tabs || []).length) {
                pane.tabs = validTabs;
                // Adjust activeTabIndex if needed
                if (pane.activeTabIndex >= validTabs.length) {
                    pane.activeTabIndex = Math.max(0, validTabs.length - 1);
                }
            }

            const tabs = pane.tabs || [];
            const activeTabIndex = pane.activeTabIndex || 0;

            // Render tabs
            let tabsHTML = '';
            tabs.forEach((tab, index) => {
                const isActiveTab = index === activeTabIndex;

                // Handle special view tabs (entities, relations, etc.)
                if (tab.specialView) {
                    const config = SPECIAL_VIEW_CONFIG[tab.specialView];
                    if (!config) return;

                    tabsHTML += `
                        <div class="pane-tab special-view-tab ${isActiveTab ? 'active' : ''}"
                             data-pane-id="${pane.id}"
                             data-tab-index="${index}"
                             data-special-view="${tab.specialView}"
                             draggable="true"
                             onclick="handlePaneTabClick('${pane.id}', ${index})"
                             oncontextmenu="showPaneTabContextMenu(event, '${pane.id}', ${index})"
                             ondragstart="handlePaneTabDragStart(event, '${pane.id}', ${index})"
                             ondragend="handlePaneTabDragEnd(event)">
                            <span class="pane-tab-icon"><i class="ph ${config.icon}"></i></span>
                            <div class="pane-tab-text">
                                <span class="pane-tab-name">${config.label}</span>
                            </div>
                            <div class="pane-tab-actions">
                                <button class="pane-tab-btn" onclick="event.stopPropagation(); closePaneTab('${pane.id}', ${index})">
                                    <i class="ph ph-x"></i>
                                </button>
                            </div>
                        </div>
                    `;
                    return;
                }

                // Handle regular set/view tabs
                const set = state.sets.get(tab.setId);
                const view = set?.views.get(tab.viewId);
                if (!set || !view) return;

                const isImportView = view.isTemporary && view.importMetadata;
                const viewIcon = view.icon || VIEW_TYPE_ICONS[view.type] || 'ph-table';

                tabsHTML += `
                    <div class="pane-tab ${isActiveTab ? 'active' : ''} ${isImportView ? 'import-view-tab' : ''}"
                         data-pane-id="${pane.id}"
                         data-tab-index="${index}"
                         data-set-id="${tab.setId}"
                         data-view-id="${tab.viewId}"
                         draggable="true"
                         onclick="handlePaneTabClick('${pane.id}', ${index})"
                         oncontextmenu="showPaneTabContextMenu(event, '${pane.id}', ${index})"
                         ondragstart="handlePaneTabDragStart(event, '${pane.id}', ${index})"
                         ondragend="handlePaneTabDragEnd(event)">
                        <span class="pane-tab-icon">${renderIcon(viewIcon)}</span>
                        <div class="pane-tab-text">
                            <span class="pane-tab-name">${escapeHtml(view.name)}</span>
                            <span class="pane-tab-meta">${escapeHtml(set.name)}</span>
                        </div>
                        <div class="pane-tab-actions">
                            ${isImportView ? `
                                <button class="pane-tab-btn" title="Save as permanent view" onclick="event.stopPropagation(); saveImportView('${pane.id}', ${index})">
                                    <i class="ph ph-floppy-disk"></i>
                                </button>
                            ` : ''}
                            <button class="pane-tab-btn" onclick="event.stopPropagation(); closePaneTab('${pane.id}', ${index})">
                                <i class="ph ph-x"></i>
                            </button>
                        </div>
                    </div>
                `;
            });

            // Check if this pane is in a split
            const isInSplit = EOLayout.isPaneInSplit(state.layout, pane.id);

            return `
                <div class="layout-pane ${isActive ? 'focused' : ''} ${isInSplit ? 'in-split' : ''}"
                     id="${pane.id}"
                     data-pane-id="${pane.id}"
                     ondragover="handlePaneDragOver(event, '${pane.id}')"
                     ondragleave="handlePaneDragLeave(event, '${pane.id}')"
                     ondrop="handlePaneDrop(event, '${pane.id}')"
                     onclick="focusPaneById('${pane.id}')">
                    <div class="pane-tabs-bar">
                        <div class="pane-tabs">${tabsHTML}</div>
                        ${isInSplit ? `
                            <button class="pane-exit-split" onclick="event.stopPropagation(); exitSplitModeForPane('${pane.id}')" title="Exit split mode and merge tabs">
                                <i class="ph ph-arrows-in-simple"></i>
                            </button>
                        ` : ''}
                        <button class="pane-tab-add" onclick="event.stopPropagation(); handleAddViewToPane('${pane.id}')" title="New view">
                            <i class="ph ph-plus"></i>
                        </button>
                        <div class="pane-actions">
                            <button class="pane-action-btn" onclick="event.stopPropagation(); splitPaneById('${pane.id}', 'horizontal')" title="Split right">
                                <i class="ph ph-split-horizontal"></i>
                            </button>
                            <button class="pane-action-btn" onclick="event.stopPropagation(); splitPaneById('${pane.id}', 'vertical')" title="Split down">
                                <i class="ph ph-split-vertical"></i>
                            </button>
                            <button class="pane-action-btn" onclick="event.stopPropagation(); popOutPaneTab('${pane.id}')" title="Pop out">
                                <i class="ph ph-arrow-square-out"></i>
                            </button>
                        </div>
                    </div>
                    <div class="pane-content" id="pane-content-${pane.id}">
                        ${tabs.length === 0 ? `
                            <div class="pane-empty">
                                <i class="ph ph-squares-four pane-empty-icon"></i>
                                <div class="pane-empty-text">No views open in this pane</div>
                                <button class="pane-empty-action" onclick="handleAddViewToPane('${pane.id}')">Open a View</button>
                            </div>
                        ` : `<div class="view-surface"><div id="${isActive ? 'viewContainer' : 'viewContainer-' + pane.id}"></div></div>`}
                    </div>
                    <!-- Drop zone indicators -->
                    <div class="drop-zone-indicator left" data-zone="left" data-label="Split Left"></div>
                    <div class="drop-zone-indicator right" data-zone="right" data-label="Split Right"></div>
                    <div class="drop-zone-indicator top" data-zone="top" data-label="Split Above"></div>
                    <div class="drop-zone-indicator bottom" data-zone="bottom" data-label="Split Below"></div>
                    <div class="drop-zone-indicator center" data-zone="center" data-label="Add to Tabs"></div>
                </div>
            `;
        }

        /**
         * Update pane focus visual state
         */
        function updatePaneFocus() {
            document.querySelectorAll('.layout-pane').forEach(pane => {
                const paneId = pane.dataset.paneId;
                if (paneId === state.layout?.activePaneId) {
                    pane.classList.add('focused');
                } else {
                    pane.classList.remove('focused');
                }
            });
        }

        /**
         * Attach event listeners after layout render
         */
        function attachLayoutEventListeners() {
            // Tab drag events are handled inline via HTML attributes
            // Additional listeners can be added here if needed
        }

        // ============================================================================
        // PANE TAB INTERACTIONS
        // ============================================================================

        /**
         * Handle click on a pane tab
         */
        function handlePaneTabClick(paneId, tabIndex) {
            if (!state.layout) return;

            const pane = EOLayout.findPaneById(state.layout.root, paneId);
            if (!pane || tabIndex >= pane.tabs.length) return;

            // Update active tab in pane
            pane.activeTabIndex = tabIndex;
            state.layout.activePaneId = paneId;

            // Update global state
            const tab = pane.tabs[tabIndex];
            if (tab) {
                // Handle special view tabs
                if (tab.specialView) {
                    state.currentSpecialView = tab.specialView;
                    state.currentSetId = null;
                    state.currentViewId = null;
                    // Update openTabs for backward compatibility
                    ensureOpenSpecialTab(tab.specialView);
                } else {
                    // Handle regular set/view tabs
                    state.currentSetId = tab.setId;
                    state.currentViewId = tab.viewId;
                    state.currentSpecialView = null;
                    // Update openTabs for backward compatibility
                    ensureOpenTab(tab.setId, tab.viewId);
                }
            }

            // Re-render
            renderLayout();
            // Render all pane contents in split mode (container IDs change when active pane changes)
            const allPanes = EOLayout.getAllPanes(state.layout.root);
            if (allPanes.length > 1) {
                renderAllPaneContents();
            } else {
                renderPaneContent(paneId);
            }
            renderSidebar();
        }

        /**
         * Close a tab in a pane
         */
        function closePaneTab(paneId, tabIndex) {
            if (!state.layout) return;

            const pane = EOLayout.findPaneById(state.layout.root, paneId);
            if (!pane || tabIndex >= pane.tabs.length) return;

            const tab = pane.tabs[tabIndex];

            // Remove from pane
            pane.tabs.splice(tabIndex, 1);

            // Adjust active index
            if (pane.activeTabIndex >= pane.tabs.length) {
                pane.activeTabIndex = Math.max(0, pane.tabs.length - 1);
            }

            // Also remove from openTabs for backward compatibility
            if (tab) {
                let openTabIndex;
                if (tab.specialView) {
                    // Handle special view tabs
                    openTabIndex = state.openTabs.findIndex(t => t.specialView === tab.specialView);
                } else {
                    // Handle regular set/view tabs
                    openTabIndex = state.openTabs.findIndex(
                        t => t.setId === tab.setId && t.viewId === tab.viewId
                    );
                }
                if (openTabIndex !== -1) {
                    state.openTabs.splice(openTabIndex, 1);
                }
            }

            // If pane is empty and not the main pane, collapse it
            if (pane.tabs.length === 0 && pane.id !== 'pane-main') {
                EOLayout.collapseEmptyPane(state, paneId, null);
            }

            // Update current view if we closed the active tab
            if (pane.tabs.length > 0) {
                const newActiveTab = pane.tabs[pane.activeTabIndex];
                if (newActiveTab) {
                    // Handle special view tabs
                    if (newActiveTab.specialView) {
                        state.currentSpecialView = newActiveTab.specialView;
                        state.currentSetId = null;
                        state.currentViewId = null;
                    } else {
                        // Handle regular set/view tabs
                        state.currentSetId = newActiveTab.setId;
                        state.currentViewId = newActiveTab.viewId;
                        state.currentSpecialView = null;
                    }
                }
            } else if (paneId === state.layout.activePaneId) {
                // Find another pane with tabs
                const allPanes = EOLayout.getAllPanes(state.layout.root);
                const paneWithTabs = allPanes.find(p => p.tabs.length > 0);
                if (paneWithTabs) {
                    state.layout.activePaneId = paneWithTabs.id;
                    const fallbackTab = paneWithTabs.tabs[paneWithTabs.activeTabIndex];
                    if (fallbackTab) {
                        // Handle special view tabs
                        if (fallbackTab.specialView) {
                            state.currentSpecialView = fallbackTab.specialView;
                            state.currentSetId = null;
                            state.currentViewId = null;
                        } else {
                            // Handle regular set/view tabs
                            state.currentSetId = fallbackTab.setId;
                            state.currentViewId = fallbackTab.viewId;
                            state.currentSpecialView = null;
                        }
                    }
                } else {
                    // No tabs left anywhere
                    state.currentSpecialView = null;
                    state.currentSetId = null;
                    state.currentViewId = null;
                }
            }

            // Log event
            EOLayout.emitLayoutEvent(state, EOLayout.LAYOUT_EVENT_TYPES.TAB_CLOSED, {
                paneId,
                setId: tab?.setId,
                viewId: tab?.viewId,
                specialView: tab?.specialView
            });

            renderLayout();
            // Render all pane contents in split mode, otherwise just active pane
            const allPanes = EOLayout.getAllPanes(state.layout.root);
            if (allPanes.length > 1) {
                renderAllPaneContents();
            } else {
                renderPaneContent(state.layout.activePaneId);
            }
            renderSidebar();
        }

        /**
         * Render content for a specific pane
         */
        function renderPaneContent(paneId) {
            const pane = EOLayout.findPaneById(state.layout.root, paneId);
            if (!pane) return;

            // Get container - use main viewContainer if this is the active pane
            const isActivePane = paneId === state.layout.activePaneId;
            let container;
            if (isActivePane) {
                container = document.getElementById('viewContainer');
            } else {
                container = document.getElementById(`viewContainer-${paneId}`);
            }
            if (!container) return;

            if (pane.tabs.length === 0) {
                container.innerHTML = '';
                return;
            }

            const tab = pane.tabs[pane.activeTabIndex];
            if (!tab) return;

            // Update state for rendering based on tab type
            if (tab.specialView) {
                // Handle special view tabs
                state.currentSpecialView = tab.specialView;
                state.currentSetId = null;
                state.currentViewId = null;
            } else {
                // Handle regular set/view tabs
                state.currentSetId = tab.setId;
                state.currentViewId = tab.viewId;
                state.currentSpecialView = null;
            }

            // For non-active panes, temporarily swap the container ID so renderCurrentView
            // targets the correct container
            const originalId = container.id;
            if (!isActivePane) {
                container.id = 'viewContainer';
            }

            // Call existing render function
            renderCurrentView();

            // Restore original container ID
            if (!isActivePane) {
                container.id = originalId;
            }
        }

        /**
         * Render content for all panes in the layout
         */
        function renderAllPaneContents() {
            if (!state.layout || typeof EOLayout === 'undefined') return;

            const allPanes = EOLayout.getAllPanes(state.layout.root);

            // Save current state
            const savedSetId = state.currentSetId;
            const savedViewId = state.currentViewId;
            const savedSpecialView = state.currentSpecialView;

            // Render each pane's content
            allPanes.forEach(pane => {
                if (pane.tabs.length > 0) {
                    renderPaneContent(pane.id);
                }
            });

            // Restore state to active pane's tab
            const activePane = EOLayout.findPaneById(state.layout.root, state.layout.activePaneId);
            if (activePane && activePane.tabs.length > 0) {
                const activeTab = activePane.tabs[activePane.activeTabIndex];
                if (activeTab) {
                    if (activeTab.specialView) {
                        state.currentSpecialView = activeTab.specialView;
                        state.currentSetId = null;
                        state.currentViewId = null;
                    } else {
                        state.currentSetId = activeTab.setId;
                        state.currentViewId = activeTab.viewId;
                        state.currentSpecialView = null;
                    }
                }
            }
        }

        // ============================================================================
        // SPLIT OPERATIONS
        // ============================================================================

        /**
         * Split a pane by ID
         */
        function splitPaneById(paneId, direction) {
            if (!state.layout || typeof EOLayout === 'undefined') return;

            const newPane = EOLayout.splitPane(state, paneId, direction);
            if (newPane) {
                renderLayout();
                renderAllPaneContents();
            }
        }

        /**
         * Split the currently active pane
         */
        function splitActivePane(direction) {
            if (!state.layout) return;
            splitPaneById(state.layout.activePaneId, direction);
        }

        /**
         * Focus a pane by ID
         */
        function focusPaneById(paneId) {
            if (!state.layout) return;

            const pane = EOLayout.findPaneById(state.layout.root, paneId);
            if (!pane) return;

            state.layout.activePaneId = paneId;

            // Update current view based on pane's active tab
            if (pane.tabs.length > 0) {
                const tab = pane.tabs[pane.activeTabIndex];
                if (tab) {
                    // Handle special view tabs
                    if (tab.specialView) {
                        state.currentSpecialView = tab.specialView;
                        state.currentSetId = null;
                        state.currentViewId = null;
                    } else {
                        // Handle regular set/view tabs
                        state.currentSetId = tab.setId;
                        state.currentViewId = tab.viewId;
                        state.currentSpecialView = null;
                    }
                }
            }

            updatePaneFocus();
            renderPaneContent(paneId);
        }

        // ============================================================================
        // DIVIDER RESIZE
        // ============================================================================

        /**
         * Start resizing a divider
         */
        function startDividerResize(event, splitId, direction) {
            event.preventDefault();

            // Find the split
            const splitEl = document.querySelector(`[data-split-id="${splitId}"].layout-split`);
            if (!splitEl) return;

            const divider = event.target;
            divider.classList.add('dragging');

            dividerResizeState.resizing = true;
            dividerResizeState.splitId = splitId;
            dividerResizeState.direction = direction;
            dividerResizeState.startPos = direction === 'horizontal' ? event.clientX : event.clientY;

            // Get current ratio from style
            const currentRatio = parseFloat(getComputedStyle(splitEl).getPropertyValue('--split-ratio')) || 0.5;
            dividerResizeState.startRatio = currentRatio;
            dividerResizeState.splitRect = splitEl.getBoundingClientRect();
        }

        /**
         * Handle mouse move for divider resize
         */
        function handleLayoutMouseMove(event) {
            if (dividerResizeState.resizing) {
                event.preventDefault();

                const { splitId, direction, startPos, startRatio, splitRect } = dividerResizeState;
                const splitEl = document.querySelector(`[data-split-id="${splitId}"].layout-split`);
                if (!splitEl) return;

                // Calculate new ratio
                let delta, totalSize;
                if (direction === 'horizontal') {
                    delta = event.clientX - startPos;
                    totalSize = splitRect.width;
                } else {
                    delta = event.clientY - startPos;
                    totalSize = splitRect.height;
                }

                const ratioDelta = delta / totalSize;
                const newRatio = Math.max(0.1, Math.min(0.9, startRatio + ratioDelta));

                // Update visual
                splitEl.style.setProperty('--split-ratio', newRatio);
            }
        }

        /**
         * Handle mouse up for divider resize
         */
        function handleLayoutMouseUp(event) {
            if (dividerResizeState.resizing) {
                const { splitId, direction, startPos, startRatio, splitRect } = dividerResizeState;
                const divider = document.querySelector(`.layout-divider[data-split-id="${splitId}"]`);
                if (divider) {
                    divider.classList.remove('dragging');
                }

                // Calculate final ratio
                let delta, totalSize;
                if (direction === 'horizontal') {
                    delta = event.clientX - startPos;
                    totalSize = splitRect.width;
                } else {
                    delta = event.clientY - startPos;
                    totalSize = splitRect.height;
                }

                const ratioDelta = delta / totalSize;
                const newRatio = Math.max(0.1, Math.min(0.9, startRatio + ratioDelta));

                // Update state
                EOLayout.resizeSplit(state, splitId, newRatio);

                // Reset resize state
                dividerResizeState.resizing = false;
                dividerResizeState.splitId = null;
                dividerResizeState.direction = null;
            }
        }

        // ============================================================================
        // DRAG AND DROP BETWEEN PANES
        // ============================================================================

        /**
         * Handle drag start for a pane tab
         */
        function handlePaneTabDragStart(event, paneId, tabIndex) {
            const pane = EOLayout.findPaneById(state.layout.root, paneId);
            if (!pane) return;

            const tab = pane.tabs[tabIndex];
            if (!tab) return;

            layoutDragState.dragging = true;
            layoutDragState.draggedTab = { ...tab, tabIndex };
            layoutDragState.sourcePaneId = paneId;

            event.dataTransfer.effectAllowed = 'move';
            event.dataTransfer.setData('text/plain', JSON.stringify({
                type: 'pane-tab',
                paneId,
                tabIndex,
                setId: tab.setId,
                viewId: tab.viewId,
                specialView: tab.specialView
            }));

            event.target.classList.add('dragging');
        }

        /**
         * Handle drag end for a pane tab
         */
        function handlePaneTabDragEnd(event) {
            event.target.classList.remove('dragging');

            // Hide all drop zones
            document.querySelectorAll('.drop-zone-indicator').forEach(zone => {
                zone.classList.remove('visible');
            });
            document.querySelectorAll('.layout-pane').forEach(pane => {
                pane.classList.remove('drag-over');
            });

            layoutDragState.dragging = false;
            layoutDragState.draggedTab = null;
            layoutDragState.sourcePaneId = null;
            layoutDragState.targetPaneId = null;
            layoutDragState.dropZone = null;
        }

        /**
         * Handle drag over a pane
         */
        function handlePaneDragOver(event, paneId) {
            if (!layoutDragState.dragging) return;

            event.preventDefault();
            event.dataTransfer.dropEffect = 'move';

            const paneEl = document.getElementById(paneId);
            if (!paneEl) return;

            paneEl.classList.add('drag-over');
            layoutDragState.targetPaneId = paneId;

            // Determine which drop zone based on mouse position
            const rect = paneEl.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            const w = rect.width;
            const h = rect.height;

            // Calculate zone (edges vs center)
            const edgeThreshold = 0.25;
            let zone = 'center';

            if (x < w * edgeThreshold) zone = 'left';
            else if (x > w * (1 - edgeThreshold)) zone = 'right';
            else if (y < h * edgeThreshold) zone = 'top';
            else if (y > h * (1 - edgeThreshold)) zone = 'bottom';

            layoutDragState.dropZone = zone;

            // Show appropriate drop zone indicator
            paneEl.querySelectorAll('.drop-zone-indicator').forEach(indicator => {
                const indicatorZone = indicator.dataset.zone;
                if (indicatorZone === zone) {
                    indicator.classList.add('visible');
                } else {
                    indicator.classList.remove('visible');
                }
            });
        }

        /**
         * Handle drag leave from a pane
         */
        function handlePaneDragLeave(event, paneId) {
            const paneEl = document.getElementById(paneId);
            if (!paneEl) return;

            // Only remove if truly leaving (not entering a child)
            if (!paneEl.contains(event.relatedTarget)) {
                paneEl.classList.remove('drag-over');
                paneEl.querySelectorAll('.drop-zone-indicator').forEach(zone => {
                    zone.classList.remove('visible');
                });
            }
        }

        /**
         * Handle drop on a pane
         */
        function handlePaneDrop(event, targetPaneId) {
            event.preventDefault();

            if (!layoutDragState.dragging || !layoutDragState.draggedTab) return;

            const { draggedTab, sourcePaneId, dropZone } = layoutDragState;
            const { setId, viewId, specialView } = draggedTab;

            // Hide indicators
            document.querySelectorAll('.drop-zone-indicator').forEach(zone => {
                zone.classList.remove('visible');
            });
            document.querySelectorAll('.layout-pane').forEach(pane => {
                pane.classList.remove('drag-over');
            });

            if (dropZone === 'center') {
                // Add to target pane's tabs
                if (sourcePaneId === targetPaneId) {
                    // Same pane, just reorder - do nothing for now
                    return;
                }

                // Handle special view tabs
                if (specialView) {
                    // Find and remove from source pane
                    const sourcePane = EOLayout.findPaneById(state.layout.root, sourcePaneId);
                    const targetPane = EOLayout.findPaneById(state.layout.root, targetPaneId);
                    if (sourcePane && targetPane) {
                        const tabIdx = sourcePane.tabs.findIndex(t => t.specialView === specialView);
                        if (tabIdx !== -1) {
                            sourcePane.tabs.splice(tabIdx, 1);
                            if (sourcePane.activeTabIndex >= sourcePane.tabs.length) {
                                sourcePane.activeTabIndex = Math.max(0, sourcePane.tabs.length - 1);
                            }
                            // Add to target pane
                            targetPane.tabs.push({ specialView });
                            targetPane.activeTabIndex = targetPane.tabs.length - 1;
                        }
                    }
                } else {
                    EOLayout.moveTabToPane(state, sourcePaneId, setId, viewId, targetPaneId);
                }
            } else {
                // Create split
                const direction = (dropZone === 'left' || dropZone === 'right') ? 'horizontal' : 'vertical';

                // First, remove from source pane
                const sourcePane = EOLayout.findPaneById(state.layout.root, sourcePaneId);
                if (sourcePane) {
                    let tabIdx;
                    if (specialView) {
                        tabIdx = sourcePane.tabs.findIndex(t => t.specialView === specialView);
                    } else {
                        tabIdx = sourcePane.tabs.findIndex(t => t.setId === setId && t.viewId === viewId);
                    }
                    if (tabIdx !== -1) {
                        sourcePane.tabs.splice(tabIdx, 1);
                        if (sourcePane.activeTabIndex >= sourcePane.tabs.length) {
                            sourcePane.activeTabIndex = Math.max(0, sourcePane.tabs.length - 1);
                        }
                    }
                }

                // Create split
                const newPane = EOLayout.splitPane(state, targetPaneId, direction);
                if (newPane) {
                    // Determine which pane gets the tab based on drop zone
                    if (specialView) {
                        newPane.tabs = [{ specialView }];
                        newPane.activeTabIndex = 0;
                        state.layout.activePaneId = newPane.id;
                        state.currentSpecialView = specialView;
                        state.currentSetId = null;
                        state.currentViewId = null;
                    } else {
                        newPane.tabs = [{ setId, viewId }];
                        newPane.activeTabIndex = 0;
                        state.layout.activePaneId = newPane.id;
                        state.currentSetId = setId;
                        state.currentViewId = viewId;
                        state.currentSpecialView = null;
                    }
                }

                // Check if source pane is empty
                if (sourcePane && sourcePane.tabs.length === 0 && sourcePane.id !== 'pane-main') {
                    EOLayout.collapseEmptyPane(state, sourcePaneId, null);
                }
            }

            // Update backward compatibility
            if (specialView) {
                ensureOpenSpecialTab(specialView);
            } else {
                ensureOpenTab(setId, viewId);
            }

            // Log event
            EOLayout.emitLayoutEvent(state, EOLayout.LAYOUT_EVENT_TYPES.TAB_MOVED, {
                fromPaneId: sourcePaneId,
                toPaneId: targetPaneId,
                setId,
                viewId,
                specialView,
                dropZone
            });

            renderLayout();
            renderAllPaneContents();
            renderSidebar();
        }

        // ============================================================================
        // POP OUT (PORTAL) FUNCTIONALITY
        // ============================================================================

        /**
         * Pop out the active tab from a pane
         */
        function popOutPaneTab(paneId) {
            if (!state.layout || typeof EOLayout === 'undefined') return;

            const pane = EOLayout.findPaneById(state.layout.root, paneId);
            if (!pane || pane.tabs.length === 0) return;

            const tab = pane.tabs[pane.activeTabIndex];
            if (!tab) return;

            EOLayout.popOutTab(state, paneId, tab.setId, tab.viewId);

            // Update openTabs
            const openTabIndex = state.openTabs.findIndex(
                t => t.setId === tab.setId && t.viewId === tab.viewId
            );
            if (openTabIndex !== -1) {
                state.openTabs.splice(openTabIndex, 1);
            }

            renderLayout();
            renderAllPaneContents();
            renderSidebar();
        }

        /**
         * Pop out the active tab from the active pane
         */
        function popOutActiveTab() {
            if (!state.layout) return;
            popOutPaneTab(state.layout.activePaneId);
        }

        // ============================================================================
        // PANE TAB CONTEXT MENU
        // ============================================================================

        /**
         * Show context menu for a pane tab
         */
        function showPaneTabContextMenu(event, paneId, tabIndex) {
            event.preventDefault();
            event.stopPropagation();

            const pane = EOLayout.findPaneById(state.layout.root, paneId);
            if (!pane) return;

            const tab = pane.tabs[tabIndex];
            if (!tab) return;

            // Remove existing menu
            document.querySelector('.layout-context-menu')?.remove();

            const menu = document.createElement('div');
            menu.className = 'layout-context-menu';

            // Check if pane is in a split
            const isInSplit = EOLayout.isPaneInSplit(state.layout, paneId);
            const exitSplitHTML = isInSplit ? `
                    <div class="layout-context-menu-item" onclick="exitSplitModeForPane('${paneId}')">
                        <i class="ph ph-arrows-in-simple"></i>
                        Exit Split Mode
                    </div>
            ` : '';

            // Handle special view tabs (entities, relations, etc.)
            if (tab.specialView) {
                const config = SPECIAL_VIEW_CONFIG[tab.specialView];
                if (!config) return;

                menu.innerHTML = `
                    <div class="layout-context-menu-item" onclick="splitPaneWithTab('${paneId}', ${tabIndex}, 'horizontal')">
                        <i class="ph ph-split-horizontal"></i>
                        Split Right
                    </div>
                    <div class="layout-context-menu-item" onclick="splitPaneWithTab('${paneId}', ${tabIndex}, 'vertical')">
                        <i class="ph ph-split-vertical"></i>
                        Split Down
                    </div>
                    ${exitSplitHTML}
                    <div class="layout-context-menu-item" onclick="popOutSpecificTab('${paneId}', ${tabIndex})">
                        <i class="ph ph-arrow-square-out"></i>
                        Pop Out
                    </div>
                    <div class="layout-context-menu-divider"></div>
                    <div class="layout-context-menu-item" onclick="closePaneTab('${paneId}', ${tabIndex})">
                        <i class="ph ph-x"></i>
                        Close Tab
                    </div>
                `;
            } else {
                // Handle regular set/view tabs
                const set = state.sets.get(tab.setId);
                const view = set?.views.get(tab.viewId);
                if (!set || !view) return;

                menu.innerHTML = `
                    <div class="layout-context-menu-item" onclick="editViewFromContextMenu('${tab.viewId}')">
                        <i class="ph ph-pencil-simple"></i>
                        Edit View
                    </div>
                    <div class="layout-context-menu-item" onclick="duplicateViewFromContextMenu('${tab.viewId}')">
                        <i class="ph ph-copy"></i>
                        Duplicate View
                    </div>
                    <div class="layout-context-menu-divider"></div>
                    <div class="layout-context-menu-item" onclick="splitPaneWithTab('${paneId}', ${tabIndex}, 'horizontal')">
                        <i class="ph ph-split-horizontal"></i>
                        Split Right
                    </div>
                    <div class="layout-context-menu-item" onclick="splitPaneWithTab('${paneId}', ${tabIndex}, 'vertical')">
                        <i class="ph ph-split-vertical"></i>
                        Split Down
                    </div>
                    ${exitSplitHTML}
                    <div class="layout-context-menu-item" onclick="popOutSpecificTab('${paneId}', ${tabIndex})">
                        <i class="ph ph-arrow-square-out"></i>
                        Pop Out
                    </div>
                    <div class="layout-context-menu-divider"></div>
                    <div class="layout-context-menu-item" onclick="closePaneTab('${paneId}', ${tabIndex})">
                        <i class="ph ph-x"></i>
                        Close Tab
                    </div>
                    <div class="layout-context-menu-item danger" onclick="deleteViewFromContextMenu('${tab.viewId}', '${paneId}', ${tabIndex})">
                        <i class="ph ph-trash"></i>
                        Delete View
                    </div>
                `;
            }

            // Position menu
            menu.style.left = `${event.clientX}px`;
            menu.style.top = `${event.clientY}px`;

            document.body.appendChild(menu);

            // Close on click outside
            setTimeout(() => {
                document.addEventListener('click', function closeMenu(e) {
                    if (!menu.contains(e.target)) {
                        menu.remove();
                        document.removeEventListener('click', closeMenu);
                    }
                });
            }, 0);
        }

        /**
         * Split a pane and move a specific tab to the new pane
         */
        function splitPaneWithTab(paneId, tabIndex, direction) {
            document.querySelector('.layout-context-menu')?.remove();

            const pane = EOLayout.findPaneById(state.layout.root, paneId);
            if (!pane) return;

            const tab = pane.tabs[tabIndex];
            if (!tab) return;

            const newPane = EOLayout.splitPane(state, paneId, direction, tab);
            if (newPane) {
                state.layout.activePaneId = newPane.id;
                // Handle special view tabs
                if (tab.specialView) {
                    state.currentSpecialView = tab.specialView;
                    state.currentSetId = null;
                    state.currentViewId = null;
                } else {
                    state.currentSetId = tab.setId;
                    state.currentViewId = tab.viewId;
                    state.currentSpecialView = null;
                }
                renderLayout();
                renderAllPaneContents();
            }
        }

        /**
         * Pop out a specific tab
         */
        function popOutSpecificTab(paneId, tabIndex) {
            document.querySelector('.layout-context-menu')?.remove();

            const pane = EOLayout.findPaneById(state.layout.root, paneId);
            if (!pane) return;

            const tab = pane.tabs[tabIndex];
            if (!tab) return;

            // Handle special view tabs
            if (tab.specialView) {
                EOLayout.popOutTab(state, paneId, null, null, tab.specialView);
            } else {
                EOLayout.popOutTab(state, paneId, tab.setId, tab.viewId);
            }
            renderLayout();
            renderAllPaneContents();
        }

        /**
         * Edit view from context menu
         */
        function editViewFromContextMenu(viewId) {
            document.querySelector('.layout-context-menu')?.remove();
            openEditViewModal(viewId);
        }

        /**
         * Duplicate view from context menu
         */
        function duplicateViewFromContextMenu(viewId) {
            document.querySelector('.layout-context-menu')?.remove();
            duplicateView(viewId);
        }

        /**
         * Delete view from context menu
         */
        function deleteViewFromContextMenu(viewId, paneId, tabIndex) {
            document.querySelector('.layout-context-menu')?.remove();

            if (confirm('Are you sure you want to delete this view? This action cannot be undone.')) {
                closePaneTab(paneId, tabIndex);
                deleteView(state, viewId);
                renderSidebar();
            }
        }

        /**
         * Exit split mode for a pane - moves tabs to sibling pane and collapses split
         */
        function exitSplitModeForPane(paneId) {
            document.querySelector('.layout-context-menu')?.remove();

            if (EOLayout.exitSplitMode(state, paneId)) {
                renderLayout();
                renderAllPaneContents();
            }
        }

        // ============================================================================
        // ADD VIEW TO PANE
        // ============================================================================

        /**
         * Handle adding a view to a specific pane
         */
        function handleAddViewToPane(paneId) {
            // For now, use the existing add view flow
            // Store target pane for the callback
            state._targetPaneId = paneId;
            handleAddViewClick();
        }

        /**
         * Open a view in a pane (called from sidebar or elsewhere)
         */
        function openViewInPane(setId, viewId, paneId = null) {
            if (!state.layout) {
                initializeLayoutSystem();
            }

            const targetPaneId = paneId || state.layout.activePaneId || 'pane-main';
            const pane = EOLayout.findPaneById(state.layout.root, targetPaneId);
            if (!pane) return;

            // Check if view is already open somewhere
            const existingLocation = EOLayout.findPaneContainingView(state.layout, setId, viewId);
            if (existingLocation) {
                // Focus existing
                state.layout.activePaneId = existingLocation.pane.id;
                existingLocation.pane.activeTabIndex = existingLocation.tabIndex;
                state.currentSetId = setId;
                state.currentViewId = viewId;
            } else {
                // Add to pane
                pane.tabs.push({ setId, viewId });
                pane.activeTabIndex = pane.tabs.length - 1;
                state.currentSetId = setId;
                state.currentViewId = viewId;

                // Also add to openTabs for backward compatibility
                ensureOpenTab(setId, viewId);
            }

            EOLayout.emitLayoutEvent(state, EOLayout.LAYOUT_EVENT_TYPES.TAB_OPENED, {
                paneId: targetPaneId,
                setId,
                viewId
            });

            renderLayout();
            renderPaneContent(state.layout.activePaneId);
            renderSidebar();
        }

        // ============================================================================
        // BACKWARD COMPATIBILITY WRAPPER
        // ============================================================================

        /**
         * Render view tabs - wrapper that uses layout system if available
         */
        function renderViewTabs() {
            // Use the new layout system if available
            if (state.layout && typeof EOLayout !== 'undefined') {
                renderLayout();
                // Render all pane contents when in split mode
                const allPanes = EOLayout.getAllPanes(state.layout.root);
                if (allPanes.length > 1) {
                    renderAllPaneContents();
                }
                return;
            }

            // Legacy fallback for when layout system isn't loaded
            const container = document.getElementById('viewTabs');
            const surface = document.getElementById('viewSurface');
            if (!container) return;

            // Validate tabs - keep special views and valid set views
            const validatedTabs = [];
            state.openTabs.forEach(tab => {
                if (tab.specialView && SPECIAL_VIEW_CONFIG[tab.specialView]) {
                    validatedTabs.push(tab);
                } else {
                    const set = state.sets.get(tab.setId);
                    const view = set?.views.get(tab.viewId);
                    if (set && view) validatedTabs.push(tab);
                }
            });
            state.openTabs = validatedTabs;

            if (state.openTabs.length === 0) {
                container.innerHTML = '';
                // Still show the "+" button if there are sets available
                const setsForWorld = getSetsForWorld();
                if (setsForWorld.length > 0) {
                    container.classList.remove('hidden');
                    const addBtn = document.createElement('button');
                    addBtn.className = 'view-tab-add';
                    addBtn.title = 'New view';
                    addBtn.innerHTML = '<i class="ph ph-plus"></i>';
                    addBtn.onclick = () => handleAddViewClick();
                    container.appendChild(addBtn);
                } else {
                    container.classList.add('hidden');
                }
                if (state.currentSpecialView) {
                    surface?.classList.remove('hidden');
                } else {
                    surface?.classList.add('hidden');
                }
                return;
            }

            container.classList.remove('hidden');
            surface?.classList.remove('hidden');
            container.innerHTML = '';

            state.openTabs.forEach((tab, index) => {
                const tabKey = getTabKey(tab.setId, tab.viewId, tab.specialView);
                const tabEl = document.createElement('div');

                // Handle special view tabs
                if (tab.specialView) {
                    const config = SPECIAL_VIEW_CONFIG[tab.specialView];
                    const isActive = state.currentSpecialView === tab.specialView;

                    tabEl.className = `view-tab special-view-tab ${isActive ? 'active' : ''}`;
                    tabEl.dataset.tabKey = tabKey;
                    tabEl.draggable = true;
                    tabEl.onclick = () => switchToSpecialTab(tab.specialView);
                    tabEl.oncontextmenu = (e) => { e.preventDefault(); showSpecialTabContextMenu(e, tab.specialView); };
                    tabEl.ondragstart = (e) => handleTabDragStart(e, tab);
                    tabEl.ondragover = (e) => handleTabDragOver(e, tab);
                    tabEl.ondragleave = () => clearTabDropIndicators();
                    tabEl.ondrop = (e) => handleTabDrop(e, tab);
                    tabEl.ondragend = finalizeTabDrag;

                    const iconSpan = document.createElement('span');
                    iconSpan.className = 'view-tab-icon';
                    iconSpan.innerHTML = `<i class="ph ${config.icon}"></i>`;

                    const textWrap = document.createElement('div');
                    textWrap.className = 'view-tab-text';
                    textWrap.innerHTML = `<span class="view-tab-name">${config.label}</span>`;

                    const actions = document.createElement('div');
                    actions.className = 'view-tab-actions';
                    const closeBtn = document.createElement('button');
                    closeBtn.className = 'view-tab-btn';
                    closeBtn.innerHTML = '<i class="ph ph-x"></i>';
                    closeBtn.onclick = (e) => { e.stopPropagation(); closeViewTab(null, null, tab.specialView); };
                    actions.appendChild(closeBtn);

                    tabEl.appendChild(iconSpan);
                    tabEl.appendChild(textWrap);
                    tabEl.appendChild(actions);
                } else {
                    // Handle regular set view tabs
                    const set = state.sets.get(tab.setId);
                    const view = set?.views.get(tab.viewId);
                    if (!set || !view) return;
                    const isActive = state.currentSetId === tab.setId && state.currentViewId === tab.viewId && !state.currentSpecialView;
                    const isImportView = view.isTemporary && view.importMetadata;

                    tabEl.className = `view-tab ${isActive ? 'active' : ''} ${isImportView ? 'import-view-tab' : ''}`;
                    tabEl.dataset.tabKey = tabKey;
                    tabEl.draggable = true;
                    tabEl.onclick = () => switchSet(tab.setId, tab.viewId);
                    tabEl.oncontextmenu = (e) => { e.preventDefault(); showViewTabContextMenu(e, tab.setId, tab.viewId); };
                    tabEl.ondragstart = (e) => handleTabDragStart(e, tab);
                    tabEl.ondragover = (e) => handleTabDragOver(e, tab);
                    tabEl.ondragleave = () => clearTabDropIndicators();
                    tabEl.ondrop = (e) => handleTabDrop(e, tab);
                    tabEl.ondragend = finalizeTabDrag;

                    const iconSpan = document.createElement('span');
                    iconSpan.className = 'view-tab-icon';
                    iconSpan.innerHTML = renderIcon(view.icon || VIEW_TYPE_ICONS[view.type]);

                    const textWrap = document.createElement('div');
                    textWrap.className = 'view-tab-text';
                    textWrap.innerHTML = `
                        <span class="view-tab-name">${view.name}</span>
                        <span class="view-tab-meta">${set.name}</span>
                    `;

                    const actions = document.createElement('div');
                    actions.className = 'view-tab-actions';

                    // Add save button for import views
                    if (isImportView) {
                        const saveBtn = document.createElement('button');
                        saveBtn.className = 'view-tab-btn view-tab-save-btn';
                        saveBtn.title = 'Save as permanent view';
                        saveBtn.innerHTML = '<i class="ph ph-floppy-disk"></i>';
                        saveBtn.onclick = (e) => {
                            e.stopPropagation();
                            switchSet(tab.setId, tab.viewId);
                            setTimeout(() => showSaveImportAsViewDialog(), 50);
                        };
                        actions.appendChild(saveBtn);
                    }

                    const closeBtn = document.createElement('button');
                    closeBtn.className = 'view-tab-btn';
                    closeBtn.innerHTML = '<i class="ph ph-x"></i>';
                    closeBtn.onclick = (e) => { e.stopPropagation(); closeViewTab(tab.setId, tab.viewId); };
                    actions.appendChild(closeBtn);

                    tabEl.appendChild(iconSpan);
                    tabEl.appendChild(textWrap);
                    tabEl.appendChild(actions);
                }

                container.appendChild(tabEl);
            });

            // Add "New View" button at the end of tabs
            const addBtn = document.createElement('button');
            addBtn.className = 'view-tab-add';
            addBtn.title = 'New view';
            addBtn.innerHTML = '<i class="ph ph-plus"></i>';
            addBtn.onclick = () => handleAddViewClick();
            container.appendChild(addBtn);
        }

        function switchSet(setId, viewId) {
            const set = state.sets.get(setId);
            if (!set) return;
            if (set.worldId && state.currentWorldId !== set.worldId) {
                state.currentWorldId = set.worldId;
                renderWorldSelector();
            }
            state.currentSpecialView = null;
            state.currentSetId = setId;
            state.currentViewId = viewId;
            if (!viewId && set.views.size > 0) {
                state.currentViewId = Array.from(set.views.keys())[0];
            }
            // Track last-used view for returning users
            if (state.currentSetId && state.currentViewId) {
                state.lastUsedSetId = state.currentSetId;
                state.lastUsedViewId = state.currentViewId;
            }
            if (state.currentViewId) ensureOpenTab(state.currentSetId, state.currentViewId);

            // Sync with layout system if available
            if (state.layout && typeof EOLayout !== 'undefined') {
                const targetPaneId = state.layout.activePaneId || 'pane-main';
                const pane = EOLayout.findPaneById(state.layout.root, targetPaneId);
                if (pane) {
                    // Check if view is already in this pane
                    const existingIdx = pane.tabs.findIndex(
                        t => t.setId === state.currentSetId && t.viewId === state.currentViewId
                    );
                    if (existingIdx !== -1) {
                        pane.activeTabIndex = existingIdx;
                    } else {
                        // Add to active pane
                        pane.tabs.push({ setId: state.currentSetId, viewId: state.currentViewId });
                        pane.activeTabIndex = pane.tabs.length - 1;
                    }
                }
            }

            closeMobileSidebar();
            renderSidebar();
            renderViewTabs();
            renderCurrentView();
            updateMobileChrome();
            // syncUrlState(); // Commented out to prevent URL manipulation
        }

        function switchToSpecialTab(specialView) {
            if (!SPECIAL_VIEW_CONFIG[specialView]) return;
            state.currentSpecialView = specialView;
            state.currentSetId = null;
            state.currentViewId = null;
            ensureOpenSpecialTab(specialView);

            // Sync with layout system if available
            if (state.layout && typeof EOLayout !== 'undefined') {
                const targetPaneId = state.layout.activePaneId || 'pane-main';
                const pane = EOLayout.findPaneById(state.layout.root, targetPaneId);
                if (pane) {
                    // Check if special view is already in this pane
                    const existingIdx = pane.tabs.findIndex(t => t.specialView === specialView);
                    if (existingIdx !== -1) {
                        pane.activeTabIndex = existingIdx;
                    } else {
                        // Add special view tab to active pane
                        pane.tabs.push({ specialView });
                        pane.activeTabIndex = pane.tabs.length - 1;
                    }
                }
            }

            closeMobileSidebar();
            renderSidebar();
            renderViewTabs();
            renderCurrentView();
            updateMobileChrome();
        }

        function showSpecialTabContextMenu(event, specialView) {
            const config = SPECIAL_VIEW_CONFIG[specialView];
            if (!config) return;

            // Remove any existing context menu
            document.querySelectorAll('.view-tab-context-menu').forEach(menu => menu.remove());

            // Check if this special view is already a shortcut
            const shortcuts = getTabShortcuts();
            const isShortcut = shortcuts.some(s => s.specialView === specialView);

            const menu = document.createElement('div');
            menu.className = 'context-menu view-tab-context-menu';
            menu.innerHTML = `
                <div class="menu-item" data-action="shortcut">
                    <span class="icon"><i class="ph ${isShortcut ? 'ph-bookmark-simple-fill' : 'ph-bookmark-simple'}"></i></span>
                    ${isShortcut ? 'Remove Shortcut' : 'Save as Shortcut'}
                </div>
                <div class="menu-separator"></div>
                <div class="menu-item" data-action="close">
                    <span class="icon"><i class="ph ph-x"></i></span> Close Tab
                </div>
            `;

            menu.style.position = 'fixed';
            menu.style.top = `${event.clientY}px`;
            menu.style.left = `${event.clientX}px`;
            menu.style.zIndex = '10000';

            document.body.appendChild(menu);

            menu.querySelectorAll('.menu-item').forEach(item => {
                item.addEventListener('click', () => {
                    const action = item.dataset.action;
                    menu.remove();
                    if (action === 'shortcut') {
                        if (isShortcut) {
                            const existingShortcut = shortcuts.find(s => s.specialView === specialView);
                            if (existingShortcut) removeTabShortcut(existingShortcut.id);
                        } else {
                            addTabShortcut({ specialView });
                        }
                    } else if (action === 'close') {
                        closeViewTab(null, null, specialView);
                    }
                });
            });

            setTimeout(() => {
                document.addEventListener('click', function closeMenu(e) {
                    if (!menu.contains(e.target)) {
                        menu.remove();
                        document.removeEventListener('click', closeMenu);
                    }
                });
            }, 0);
        }

        // ============================================================================
        // TAB SHORTCUTS (Browser-like bookmarks for quick tab access)
        // ============================================================================

        /**
         * Get tab shortcuts for the current world
         */
        function getTabShortcuts() {
            const world = getWorld();
            return world?.tabShortcuts || [];
        }

        /**
         * Save tab shortcuts to the current world
         */
        function saveTabShortcuts(shortcuts) {
            const world = getWorld();
            if (world) {
                world.tabShortcuts = shortcuts;
            }
        }

        /**
         * Add a tab as a shortcut
         * @param {Object} tab - { setId, viewId } or { specialView }
         */
        function addTabShortcut(tab) {
            const shortcuts = getTabShortcuts();

            // Check if shortcut already exists
            const exists = shortcuts.some(s => {
                if (tab.specialView) {
                    return s.specialView === tab.specialView;
                }
                return s.setId === tab.setId && s.viewId === tab.viewId;
            });

            if (exists) {
                showToast('This tab is already a shortcut');
                return false;
            }

            // Get display info for the shortcut
            let shortcut;
            if (tab.specialView) {
                const config = SPECIAL_VIEW_CONFIG[tab.specialView];
                shortcut = {
                    id: `shortcut_${Date.now()}`,
                    specialView: tab.specialView,
                    label: config?.label || tab.specialView,
                    icon: config?.icon || 'ph-bookmark'
                };
            } else {
                const set = state.sets.get(tab.setId);
                const view = set?.views.get(tab.viewId);
                if (!set || !view) {
                    showToast('Could not save shortcut: view not found');
                    return false;
                }
                shortcut = {
                    id: `shortcut_${Date.now()}`,
                    setId: tab.setId,
                    viewId: tab.viewId,
                    label: view.name,
                    setName: set.name,
                    icon: view.icon || VIEW_TYPE_ICONS[view.type] || 'ph-table'
                };
            }

            shortcuts.push(shortcut);
            saveTabShortcuts(shortcuts);
            showToast(' Saved as shortcut');

            // Re-render dashboard if currently viewing it
            if (state.currentSpecialView === 'dashboard') {
                renderDashboardPage();
            }

            return true;
        }

        /**
         * Remove a tab shortcut by id
         */
        function removeTabShortcut(shortcutId) {
            const shortcuts = getTabShortcuts();
            const index = shortcuts.findIndex(s => s.id === shortcutId);
            if (index !== -1) {
                shortcuts.splice(index, 1);
                saveTabShortcuts(shortcuts);
                showToast(' Shortcut removed');

                // Re-render dashboard if currently viewing it
                if (state.currentSpecialView === 'dashboard') {
                    renderDashboardPage();
                }
            }
        }

        /**
         * Navigate to a shortcut
         */
        function navigateToShortcut(shortcut) {
            if (shortcut.specialView) {
                switchToSpecialTab(shortcut.specialView);
            } else {
                switchSet(shortcut.setId, shortcut.viewId);
            }
        }

        /**
         * Move a shortcut to a new position
         */
        function reorderShortcut(shortcutId, newIndex) {
            const shortcuts = getTabShortcuts();
            const currentIndex = shortcuts.findIndex(s => s.id === shortcutId);
            if (currentIndex === -1 || currentIndex === newIndex) return;

            const [shortcut] = shortcuts.splice(currentIndex, 1);
            shortcuts.splice(newIndex, 0, shortcut);
            saveTabShortcuts(shortcuts);

            // Re-render dashboard if currently viewing it
            if (state.currentSpecialView === 'dashboard') {
                renderDashboardPage();
            }
        }

        function getCurrentSet() { return state.sets.get(state.currentSetId); }
        function getCurrentView() { const set = getCurrentSet(); return set?.views.get(state.currentViewId); }
        function getCurrentProfile() { const set = getCurrentSet(); return set?.profiles.get(state.currentProfileId); }

        // VIEW SWITCHING
        function switchViewType(type) {
            const view = getCurrentView();
            if (!view) return;
            view.type = type;

            renderCurrentView();
            updateMobileChrome();
            // syncUrlState(); // Commented out to prevent URL manipulation
        }

        function renderCurrentView() {
            const container = document.getElementById('viewContainer');

            // Update floating import banner (hide if not on import view)
            updateFloatingImportBanner();

            // Dashboard (new landing page)
            if (state.currentSpecialView === 'dashboard') {
                renderDashboardPage();
                updateMobileChrome();
                return;
            }

            if (state.currentSpecialView === 'entities') {
                renderEntitiesPage();
                updateMobileChrome();
                return;
            }
            if (state.currentSpecialView === 'definitions') {
                renderDefinitionsPage();
                updateMobileChrome();
                return;
            }

            if (state.currentSpecialView === 'relations') {
                renderRelationsPage();
                updateMobileChrome();
                return;
            }

            if (state.currentSpecialView === 'visualizations') {
                renderVisualizationsPage();
                updateMobileChrome();
                return;
            }

            if (state.currentSpecialView === 'views') {
                renderViewsPage();
                updateMobileChrome();
                return;
            }

            if (state.currentSpecialView === 'explore') {
                renderExplorePage();
                updateMobileChrome();
                return;
            }

            if (state.currentSpecialView === 'sandbox') {
                renderSandboxPage();
                updateMobileChrome();
                return;
            }

            const view = getCurrentView();
            if (!view) {
                const set = getCurrentSet();
                if (set && set.views && set.views.size > 0) {
                    renderViewSelector(container, set);
                } else if (container) {
                    container.innerHTML = '<div class="p-6 text-sm text-gray-500">Select a view to get started.</div>';
                }
                return;
            }

            ensureViewDefaults(view);

            updateMobileChrome();

            switch(view.type) {
                case 'grid':
                    renderGridView();
                    break;
                case 'card':
                    renderCardView();
                    break;
                case 'kanban':
                    renderKanbanView();
                    break;
                case 'graph':
                    renderGraphView();
                    break;
                case 'KEY_DERIVED':
                    renderKeyDerivedView();
                    break;
            }
        }

        // Export renderCurrentView globally for external modules (TossPileUI, etc.)
        window.renderCurrentView = renderCurrentView;

        function renderViewSelector(container, set) {
            if (!container || !set) return;

            const views = Array.from(set.views.entries()).map(([viewId, viewRef]) => {
                // Get full view data from state.views or use viewRef
                const fullView = state.views?.get(viewId) || viewRef;
                return { id: viewId, ...fullView };
            }).filter(v => v && v.id);

            // Sort views by name
            views.sort((a, b) => (a.name || '').localeCompare(b.name || ''));

            const recordCount = set.records ? set.records.size : 0;

            container.innerHTML = `
                <div class="p-6">
                    <div class="mb-6">
                        <div class="flex items-center gap-3 mb-2">
                            <span class="text-2xl">${renderIcon(set.icon || 'ph-database')}</span>
                            <h2 class="text-xl font-semibold text-gray-900">${escapeHtml(set.name || 'Untitled Set')}</h2>
                        </div>
                        <p class="text-sm text-gray-500">${recordCount} record${recordCount !== 1 ? 's' : ''}  ${views.length} view${views.length !== 1 ? 's' : ''}</p>
                    </div>

                    <div class="mb-4">
                        <h3 class="text-sm font-medium text-gray-700 mb-3">Select a view</h3>
                    </div>

                    <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4">
                        ${views.map(view => {
                            const viewIcon = view.icon || VIEW_TYPE_ICONS[view.type] || 'ph-table';
                            const viewType = formatViewType(view.type);
                            const filterCount = (view.filters || []).length;

                            return `
                                <div class="view-selector-card group cursor-pointer bg-white border border-gray-200 rounded-lg p-4 hover:border-blue-300 hover:shadow-md transition-all" data-view-select="${view.id}">
                                    <div class="flex items-start gap-3">
                                        <div class="flex-shrink-0 w-10 h-10 rounded-lg bg-gray-50 group-hover:bg-blue-50 flex items-center justify-center text-gray-400 group-hover:text-blue-500 transition-colors">
                                            <span class="text-xl">${renderIcon(viewIcon)}</span>
                                        </div>
                                        <div class="flex-1 min-w-0">
                                            <h4 class="font-medium text-gray-900 truncate group-hover:text-blue-600 transition-colors">${escapeHtml(view.name || 'Untitled View')}</h4>
                                            <div class="flex items-center gap-2 mt-1">
                                                <span class="inline-flex items-center px-1.5 py-0.5 rounded text-xs font-medium bg-gray-100 text-gray-600">${viewType}</span>
                                                ${filterCount > 0 ? `<span class="inline-flex items-center px-1.5 py-0.5 rounded text-xs font-medium bg-blue-50 text-blue-600">${filterCount} filter${filterCount !== 1 ? 's' : ''}</span>` : ''}
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            `;
                        }).join('')}

                        <div class="view-selector-card cursor-pointer bg-gray-50 border border-dashed border-gray-300 rounded-lg p-4 hover:border-blue-300 hover:bg-blue-50 transition-all flex items-center justify-center" data-add-view="${set.id}">
                            <div class="text-center">
                                <span class="text-gray-400 hover:text-blue-500"><i class="ph ph-plus text-xl"></i></span>
                                <p class="text-sm text-gray-500 mt-1">Add View</p>
                            </div>
                        </div>
                    </div>
                </div>
            `;

            // Add click handlers for view selection
            container.querySelectorAll('[data-view-select]').forEach(card => {
                card.addEventListener('click', () => {
                    const viewId = card.dataset.viewSelect;
                    switchSet(set.id, viewId);
                });
            });

            // Add click handler for add view button
            container.querySelectorAll('[data-add-view]').forEach(btn => {
                btn.addEventListener('click', () => {
                    openAddViewModal(set.id);
                });
            });
        }

        function ensureViewDefaults(view) {
            if (!view.icon) view.icon = VIEW_TYPE_ICONS[view.type] || 'ph-note';
            if (!view.sorts) view.sorts = [];
            if (!view.columnRules) view.columnRules = {};
            if (typeof view.showRecordId === 'undefined') view.showRecordId = false;
            if (typeof view.showRowNumbers === 'undefined') view.showRowNumbers = true;
        }

        function syncSelectionState(visibleRecords = []) {
            const set = getCurrentSet();
            if (!set) return;

            const visibleIds = visibleRecords.map(r => r.id);
            const validIds = new Set(visibleIds.length ? visibleIds : Array.from(set.records.keys()));
            state.selectedRecordIds = new Set(
                [...(state.selectedRecordIds || new Set())].filter(id => validIds.has(id))
            );

            if (state.selectedRecordIds.size === 0) state.lastSelectedRecordId = null;
        }

        function handleRecordSelection(recordId, isRange, orderedRecords = []) {
            const visibleIds = orderedRecords.map(r => r.id);
            if (!state.selectedRecordIds) state.selectedRecordIds = new Set();

            if (isRange && state.lastSelectedRecordId && visibleIds.includes(state.lastSelectedRecordId)) {
                const startIndex = visibleIds.indexOf(state.lastSelectedRecordId);
                const endIndex = visibleIds.indexOf(recordId);
                if (startIndex >= 0 && endIndex >= 0) {
                    const [from, to] = startIndex < endIndex ? [startIndex, endIndex] : [endIndex, startIndex];
                    for (let i = from; i <= to; i++) {
                        state.selectedRecordIds.add(visibleIds[i]);
                    }
                }
            } else {
                if (state.selectedRecordIds.has(recordId)) state.selectedRecordIds.delete(recordId);
                else state.selectedRecordIds.add(recordId);
                state.lastSelectedRecordId = recordId;
            }

            updateSelectionUI(orderedRecords);
        }

        function updateSelectionUI(visibleRecords = []) {
            const rows = document.querySelectorAll('#tableBody tr');
            rows.forEach(row => {
                const id = row.dataset.recordId;
                const isSelected = state.selectedRecordIds?.has(id);
                row.classList.toggle('row-selected', !!isSelected);
                const checkbox = row.querySelector('input[data-row-select]');
                if (checkbox) checkbox.checked = !!isSelected;
            });

            const visibleIds = visibleRecords.map(r => r.id);
            const selectedVisibleCount = visibleIds.filter(id => state.selectedRecordIds?.has(id)).length;
            const selectAllCheckbox = document.getElementById('selectAllRows');
            if (selectAllCheckbox) {
                const allSelected = visibleIds.length > 0 && selectedVisibleCount === visibleIds.length;
                selectAllCheckbox.checked = allSelected;
                selectAllCheckbox.indeterminate = selectedVisibleCount > 0 && !allSelected;
            }

            const indicator = document.getElementById('selectionIndicator');
            const countEl = document.getElementById('selectedCount');
            if (indicator && countEl) {
                const count = state.selectedRecordIds?.size || 0;
                indicator.classList.toggle('hidden', count === 0);
                countEl.textContent = count;
            }

            const tossBtn = document.getElementById('tossSelectedBtn');
            if (tossBtn) tossBtn.disabled = !state.selectedRecordIds || state.selectedRecordIds.size === 0;

            // Show/hide the visible toss button based on selection
            const tossBtnVisible = document.getElementById('tossSelectedBtnVisible');
            if (tossBtnVisible) {
                const hasSelection = state.selectedRecordIds && state.selectedRecordIds.size > 0;
                tossBtnVisible.classList.toggle('hidden', !hasSelection);
            }
        }

        function handleTossSelectedRecords() {
            const set = getCurrentSet();
            if (!set || !state.selectedRecordIds || state.selectedRecordIds.size === 0) return;

            const ids = [...state.selectedRecordIds].filter(id => set.records.has(id));
            if (ids.length === 0) return;

            const message = `Are you sure you want to toss ${ids.length} selected record${ids.length === 1 ? '' : 's'}? ` +
                'Items can be restored from the toss pile.';

            showConfirm(message, () => {
                // Use TossPile for soft delete with restoration capability
                if (typeof TossPile !== 'undefined') {
                    const action = TossPile.tossRecords(state, ids);
                    if (action) {
                        state.selectedRecordIds.clear();
                        state.lastSelectedRecordId = null;
                        renderCurrentView();
                        showToast(` ${ids.length} record${ids.length === 1 ? '' : 's'} tossed (can be restored)`);
                        return;
                    }
                }

                // Fallback to hard delete
                ids.forEach(recordId => {
                    set.records.delete(recordId);
                    deleteEntity(recordId);
                    createEvent(
                        'Toss Record',
                        'NUL',
                        { type: 'Record', id: recordId, setId: set.id },
                        { setId: set.id, recordId, summary: 'Record tossed' }
                    );
                });

                state.selectedRecordIds.clear();
                state.lastSelectedRecordId = null;
                renderCurrentView();
                showToast(' Selected records tossed');
            });
        }

        function getRecordIdFieldDefinition() {
            return { id: '__recordId', name: 'Record ID', type: 'RECORD_ID', width: '200' };
        }

        function applyColumnWidth(fieldId, width) {
            const normalizedWidth = clampColumnWidth(width);
            const widthPx = `${normalizedWidth}px`;
            const set = getCurrentSet();
            const view = getCurrentView();
            const field = set?.schema.find(f => f.id === fieldId);
            if (field) field.width = widthPx;

            // Save to view-level column widths
            if (view) {
                if (!view.columnWidths) view.columnWidths = {};
                view.columnWidths[fieldId] = normalizedWidth;
                view.columnWidthMode = 'custom';
                view.isDirty = true;
            }

            document.querySelectorAll(`[data-field-id="${fieldId}"]`).forEach(el => {
                el.style.width = widthPx;
            });

            const table = document.getElementById('dataTable');
            if (table && set) {
                const totalWidth = set.schema.reduce((sum, f) => sum + getFieldWidth(f, view), 0);
                table.style.minWidth = `${Math.max(totalWidth, 600)}px`;
            }
        }

        function addColumnResizer(element, field) {
            const existingResizer = element.querySelector('.column-resizer');
            if (existingResizer) return;

            const resizer = document.createElement('div');
            resizer.className = 'column-resizer';
            element.appendChild(resizer);

            let startX = 0;
            let startWidth = getFieldWidth(field, getCurrentView());

            const onMouseMove = (event) => {
                const delta = event.clientX - startX;
                applyColumnWidth(field.id, startWidth + delta);
            };

            const onMouseUp = () => {
                document.body.classList.remove('resizing');
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
            };

            resizer.addEventListener('mousedown', (event) => {
                event.stopPropagation();
                event.preventDefault();
                startX = event.clientX;
                startWidth = getFieldWidth(field, getCurrentView());
                document.body.classList.add('resizing');
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            });

            // Double-click to auto-fit column width
            resizer.addEventListener('dblclick', (event) => {
                event.stopPropagation();
                event.preventDefault();
                const cells = document.querySelectorAll(`td[data-field-id="${field.id}"]`);
                const header = document.querySelector(`th[data-field-id="${field.id}"]`);
                let maxWidth = 80; // minimum auto-fit width

                // Measure header text
                if (header) {
                    const headerSpan = header.querySelector('.column-title span');
                    if (headerSpan) {
                        const tempSpan = document.createElement('span');
                        tempSpan.style.cssText = 'visibility:hidden;position:absolute;white-space:nowrap;font-size:11px;font-weight:600;';
                        tempSpan.textContent = headerSpan.textContent;
                        document.body.appendChild(tempSpan);
                        maxWidth = Math.max(maxWidth, tempSpan.offsetWidth + 50);
                        document.body.removeChild(tempSpan);
                    }
                }

                // Measure cell contents
                cells.forEach(cell => {
                    const tempDiv = document.createElement('div');
                    tempDiv.style.cssText = 'visibility:hidden;position:absolute;white-space:nowrap;font-size:13px;';
                    tempDiv.innerHTML = cell.innerHTML;
                    document.body.appendChild(tempDiv);
                    maxWidth = Math.max(maxWidth, tempDiv.offsetWidth + 32);
                    document.body.removeChild(tempDiv);
                });

                applyColumnWidth(field.id, Math.min(maxWidth, COLUMN_WIDTH_MAX));
            });
        }

        function getPointerPosition(event) {
            if (!event) return { clientX: 0, clientY: 0 };
            if (event.touches && event.touches.length > 0) {
                return { clientX: event.touches[0].clientX, clientY: event.touches[0].clientY };
            }
            if (event.changedTouches && event.changedTouches.length > 0) {
                return { clientX: event.changedTouches[0].clientX, clientY: event.changedTouches[0].clientY };
            }
            return { clientX: event.clientX, clientY: event.clientY };
        }

        function createColumnGhost(element, position) {
            const ghost = document.createElement('div');
            ghost.className = 'column-drag-ghost';
            ghost.style.width = `${element.offsetWidth}px`;
            ghost.innerHTML = element.innerHTML;
            ghost.style.left = `${position.clientX - columnDragState.offsetX}px`;
            ghost.style.top = `${position.clientY - columnDragState.offsetY}px`;
            document.body.appendChild(ghost);
            return ghost;
        }

        function clearColumnDropIndicators() {
            document.querySelectorAll('#tableHeader .column-header').forEach(header => {
                header.classList.remove('column-drop-before', 'column-drop-after');
            });
        }

        function updateColumnDropTarget(clientX) {
            const headers = Array.from(document.querySelectorAll('#tableHeader .column-header'));
            clearColumnDropIndicators();

            const target = headers.find(h => {
                const rect = h.getBoundingClientRect();
                return clientX >= rect.left && clientX <= rect.right;
            });

            if (!target || target.dataset.fieldId === columnDragState.draggedFieldId) {
                columnDragState.dropFieldId = null;
                columnDragState.dropPosition = null;
                return;
            }

            const rect = target.getBoundingClientRect();
            const position = clientX < rect.left + rect.width / 2 ? 'before' : 'after';
            target.classList.add(position === 'before' ? 'column-drop-before' : 'column-drop-after');
            columnDragState.dropFieldId = target.dataset.fieldId;
            columnDragState.dropPosition = position;
        }

        function reorderSchemaField(draggedFieldId, targetFieldId, position) {
            const set = getCurrentSet();
            const view = getCurrentView();
            if (!set || !view) return;

            const columnOrder = ensureViewColumnOrder(view, set.schema, view.showRecordId);
            const fromIndex = columnOrder.indexOf(draggedFieldId);
            let targetIndex = columnOrder.indexOf(targetFieldId);
            if (fromIndex === -1 || targetIndex === -1) return;

            const [moved] = columnOrder.splice(fromIndex, 1);
            if (fromIndex < targetIndex) targetIndex -= 1;
            const insertIndex = position === 'after' ? targetIndex + 1 : targetIndex;
            columnOrder.splice(insertIndex, 0, moved);
            view.columnOrder = columnOrder;

            if (draggedFieldId !== '__recordId' && targetFieldId !== '__recordId') {
                const schemaFrom = set.schema.findIndex(f => f.id === draggedFieldId);
                let schemaTarget = set.schema.findIndex(f => f.id === targetFieldId);
                if (schemaFrom === -1 || schemaTarget === -1) return;

                const [field] = set.schema.splice(schemaFrom, 1);
                if (schemaFrom < schemaTarget) schemaTarget -= 1;
                const schemaInsert = position === 'after' ? schemaTarget + 1 : schemaTarget;
                set.schema.splice(schemaInsert, 0, field);
            }
        }

        function endColumnDrag() {
            resetColumnGrabState(columnDragState.sourceElement);
            document.body.classList.remove('column-dragging');
            document.removeEventListener('mousemove', handleColumnDragMove);
            document.removeEventListener('touchmove', handleColumnDragMove);
            document.removeEventListener('mouseup', endColumnDrag);
            document.removeEventListener('touchend', endColumnDrag);
            document.removeEventListener('touchcancel', endColumnDrag);

            if (columnDragState.ghost) columnDragState.ghost.remove();
            if (columnDragState.sourceElement) columnDragState.sourceElement.classList.remove('column-being-dragged');
            clearColumnDropIndicators();

            if (columnDragState.draggedFieldId && columnDragState.dropFieldId) {
                reorderSchemaField(columnDragState.draggedFieldId, columnDragState.dropFieldId, columnDragState.dropPosition);
                renderCurrentView();
            }

            columnDragState.draggedFieldId = null;
            columnDragState.dropFieldId = null;
            columnDragState.dropPosition = null;
            columnDragState.ghost = null;
            columnDragState.sourceElement = null;

            setTimeout(() => { columnDragState.preventClick = false; }, 30);
        }

        function handleColumnDragMove(event) {
            if (!columnDragState.draggedFieldId || !columnDragState.ghost) return;
            if (event.cancelable) event.preventDefault();
            const position = getPointerPosition(event);
            columnDragState.ghost.style.left = `${position.clientX - columnDragState.offsetX}px`;
            columnDragState.ghost.style.top = `${position.clientY - columnDragState.offsetY}px`;
            updateColumnDropTarget(position.clientX);
        }

        function startColumnDrag(startPosition, element, field) {
            columnDragState.timer = null;
            columnDragState.holdReady = false;
            columnDragState.draggedFieldId = field.id;
            columnDragState.sourceElement = element;
            columnDragState.preventClick = true;

            const rect = element.getBoundingClientRect();
            columnDragState.offsetX = startPosition.clientX - rect.left;
            columnDragState.offsetY = startPosition.clientY - rect.top;

            columnDragState.ghost = createColumnGhost(element, startPosition);
            element.classList.add('column-being-dragged');
            document.body.classList.add('column-dragging');

            document.addEventListener('mousemove', handleColumnDragMove);
            document.addEventListener('touchmove', handleColumnDragMove, { passive: false });
            document.addEventListener('mouseup', endColumnDrag);
            document.addEventListener('touchend', endColumnDrag);
            document.addEventListener('touchcancel', endColumnDrag);
        }

        function resetColumnGrabState(element) {
            if (columnDragState.holdTimer) {
                clearTimeout(columnDragState.holdTimer);
                columnDragState.holdTimer = null;
            }
            columnDragState.holdReady = false;
            if (element) element.classList.remove('column-grab-ready');
            document.body.classList.remove('column-grab-ready');
        }

        function setupColumnDragInteractions(element, field) {
            let pointerActive = false;
            let dragStarted = false;
            let startPosition = null;

            const handlePointerDown = (event) => {
                if (event.button !== undefined && event.button !== 0) return;
                if (event.target.closest('.column-resizer')) return;
                pointerActive = true;
                dragStarted = false;
                startPosition = getPointerPosition(event);
                resetColumnGrabState(element);
                columnDragState.holdTimer = setTimeout(() => {
                    if (!pointerActive || dragStarted) return;
                    columnDragState.holdReady = true;
                    element.classList.add('column-grab-ready');
                    document.body.classList.add('column-grab-ready');
                }, 180);
            };

            const handlePointerMove = (event) => {
                if (!pointerActive || dragStarted) return;
                const position = getPointerPosition(event);
                const deltaX = Math.abs(position.clientX - startPosition.clientX);
                const deltaY = Math.abs(position.clientY - startPosition.clientY);
                if (!columnDragState.holdReady) {
                    if (deltaX > 6 || deltaY > 6) resetColumnGrabState(element);
                    return;
                }
                if (deltaX > 6 || deltaY > 6) {
                    dragStarted = true;
                    resetColumnGrabState(element);
                    startColumnDrag(position, element, field);
                }
            };

            const resetPointerState = () => {
                pointerActive = false;
                dragStarted = false;
                resetColumnGrabState(element);
                startPosition = null;
            };

            element.addEventListener('mousedown', handlePointerDown);
            element.addEventListener('touchstart', handlePointerDown);
            element.addEventListener('mousemove', handlePointerMove);
            element.addEventListener('touchmove', handlePointerMove, { passive: false });
            element.addEventListener('mouseup', resetPointerState);
            element.addEventListener('mouseleave', resetPointerState);
            element.addEventListener('touchend', resetPointerState);
            element.addEventListener('touchcancel', resetPointerState);
        }

        // GRID VIEW
        function renderGridView() {
            const set = getCurrentSet();
            if (!set) return;

            const previousSelection = state.selectedCell
                ? { recordId: state.selectedCell.recordId, fieldId: state.selectedCell.fieldId }
                : state.lastSelectedCell;
            state.selectedCell = null;
            state.editingCell = null;

            const view = getCurrentView();
            const profile = getCurrentProfile();
            if (view && !view.identifierField) view.identifierField = inferIdentifierFieldId(set);
            const schema = set.schema.filter(f =>
                !profile || profile.visibleFields.length === 0 || profile.visibleFields.includes(f.id)
            );

            const tableSchema = buildTableSchema(view, schema);

            let records = Array.from(set.records.values());
            if (view && view.filters.length > 0) records = applyFilterGroups(records, view.filters, schema);
            if (view?.sorts?.length) records = applySorts(records, view.sorts, tableSchema);

            const recordCount = records.length;
            const recordLabel = recordCount === 1 ? 'record' : 'records';

            syncSelectionState(records);

            const viewMode = view.viewMode || 'live';
            const viewModeBadge = renderViewModeBadge(viewMode);
            const tableShellClass = viewMode === 'sandbox' ? 'view-table-shell sandbox' : 'view-table-shell';

            const container = document.getElementById('viewContainer');
            container.innerHTML = `
                <div class="view-stage-header">
                    ${renderViewBreadcrumb()}
                    <div class="view-stage-title">
                        <span class="view-stage-pill">${set.name}</span>
                        <div class="min-w-0">
                            <div class="view-stage-name">${view.name}${viewModeBadge}</div>
                            <div class="view-stage-sub">Grid view  ${recordCount} ${recordLabel}</div>
                        </div>
                    </div>
                    ${renderViewActions()}
                </div>
                <div class="view-stage-body">
                    <div class="${tableShellClass}">
                        <div class="table-scroll">
                            <table id="dataTable" class="border-collapse">
                                <thead><tr id="tableHeader"></tr></thead>
                                <tbody id="tableBody"></tbody>
                            </table>
                        </div>
                        <div class="table-footer">
                            <span class="record-counter" id="recordCounter">${recordCount} ${recordLabel}</span>
                        </div>
                    </div>
                </div>
            `;

            const headerRow = document.getElementById('tableHeader');

            // Checkbox column comes first (leftmost)
            const selectAllHeader = document.createElement('th');
            selectAllHeader.className = 'column-header selection-header';
            selectAllHeader.style.cursor = 'pointer';
            selectAllHeader.innerHTML = `<input type="checkbox" id="selectAllRows" aria-label="Select all rows">`;
            const selectAllCheckbox = selectAllHeader.querySelector('input');

            const toggleSelectAll = () => {
                const visibleIds = records.map(r => r.id);
                if (!state.selectedRecordIds) state.selectedRecordIds = new Set();
                const allSelected = visibleIds.length > 0 && visibleIds.every(id => state.selectedRecordIds.has(id));
                if (allSelected) {
                    visibleIds.forEach(id => state.selectedRecordIds.delete(id));
                } else {
                    visibleIds.forEach(id => state.selectedRecordIds.add(id));
                }
                updateSelectionUI(records);
            };

            selectAllCheckbox.onclick = (e) => e.stopPropagation();
            selectAllCheckbox.onchange = toggleSelectAll;

            // Make entire header cell clickable
            selectAllHeader.onclick = (e) => {
                if (e.target === selectAllCheckbox) return;
                toggleSelectAll();
            };
            headerRow.appendChild(selectAllHeader);

            // Row numbers come after checkbox
            if (view.showRowNumbers) {
                const rowNumberHeader = document.createElement('th');
                rowNumberHeader.className = 'column-header row-number-header';
                rowNumberHeader.innerHTML = '#';
                rowNumberHeader.oncontextmenu = (e) => {
                    e.preventDefault();
                    showContextMenu(e, [
                        { label: 'Hide Row Numbers', action: () => toggleRowNumbers(false) }
                    ]);
                };
                headerRow.appendChild(rowNumberHeader);
            }

            tableSchema.forEach(field => {
                const th = document.createElement('th');
                th.className = 'column-header';
                th.dataset.type = field.type;
                th.dataset.fieldId = field.id;
                const width = `${getFieldWidth(field, view)}px`;
                th.style.width = width;
                const sortIndex = view?.sorts?.findIndex(s => s.fieldId === field.id) ?? -1;
                const sortConfig = sortIndex >= 0 ? view.sorts[sortIndex] : null;
                const directionIcon = sortConfig ? (sortConfig.direction === 'desc' ? '' : '') : '';
                const indicatorClass = sortConfig ? 'sort-indicator' : 'sort-indicator muted';
                const orderBadge = sortConfig ? `<span class="order-badge">${sortIndex + 1}</span>` : '';
                const isNameField = view?.identifierField === field.id;
                const headerTitle = `
                    <span class="column-title">
                        <span>${field.name}</span>
                        ${isNameField ? '<span class="column-badge">Name</span>' : ''}
                    </span>
                `;
                th.innerHTML = `${headerTitle}<span class="${indicatorClass}"><span class="direction-icon">${directionIcon}</span>${orderBadge}</span>`;
                th.title = isNameField ? 'This is the Name field (right-click for options)' : 'Click to sort, right-click to set as Name or for more options';
                th.onclick = () => {
                    if (columnDragState.preventClick) return;
                    toggleColumnSort(field.id);
                };
                addColumnResizer(th, field);
                setupColumnDragInteractions(th, field);
                th.oncontextmenu = (e) => { e.preventDefault(); showColumnMenu(e, field); };
                headerRow.appendChild(th);
            });

            // Hidden fields column (last column)
            const hiddenFieldsCount = getHiddenFieldsCount(view, set);
            if (hiddenFieldsCount > 0) {
                const hiddenHeader = document.createElement('th');
                hiddenHeader.className = 'column-header hidden-fields-header';
                hiddenHeader.innerHTML = `
                    <span class="hidden-fields-trigger">
                        <i class="ph ph-eye-slash"></i>
                        <span class="hidden-count">${hiddenFieldsCount} hidden</span>
                    </span>
                `;
                hiddenHeader.title = 'Click to manage hidden fields';
                hiddenHeader.style.cursor = 'pointer';
                hiddenHeader.onclick = () => openFieldsExplorerWithFilter('hidden');
                headerRow.appendChild(hiddenHeader);
            }

            // Add column button (always last)
            const addColumnHeader = document.createElement('th');
            addColumnHeader.className = 'column-header add-column-header';
            addColumnHeader.innerHTML = `
                <span class="add-column-trigger">
                    <i class="ph ph-plus"></i>
                </span>
            `;
            addColumnHeader.title = 'Add a new column';
            addColumnHeader.style.cursor = 'pointer';
            addColumnHeader.onclick = () => openAddFieldModal();
            headerRow.appendChild(addColumnHeader);

            const table = document.getElementById('dataTable');
            const minimumTableWidth = tableSchema.reduce((sum, field) => sum + getFieldWidth(field, view), 0);
            table.style.minWidth = `${Math.max(minimumTableWidth, 600)}px`;

            // Apply content overflow class
            const overflowMode = view?.contentOverflow || 'clip';
            table.classList.remove('overflow-clip', 'overflow-wrap', 'overflow-expand', 'overflow-tooltip');
            table.classList.add(`overflow-${overflowMode}`);

            const tbody = document.getElementById('tableBody');
            records.forEach((record, index) => {
                const tr = document.createElement('tr');
                tr.dataset.recordId = record.id;

                tr.onclick = (event) => {
                    if (event.defaultPrevented) return;

                    const interactiveTarget = event.target.closest(
                        'button, a, input, select, textarea, label, [contenteditable="true"], .cell-editing'
                    );
                    if (interactiveTarget) return;

                    // Click on row background opens record modal (cells handle their own clicks)
                    openExpandedRecord(record.id);
                };

                // Right-click context menu for record
                tr.oncontextmenu = (event) => {
                    // Don't show if clicking on a cell (cells have their own context menus)
                    const cell = event.target.closest('td.cell-editable');
                    if (cell) return; // Let the cell context menu handle it

                    event.preventDefault();
                    showRecordContextMenu(event, record.id);
                };

                // Checkbox cell comes first (leftmost)
                const selectTd = document.createElement('td');
                selectTd.className = 'row-select-cell';
                const checkboxId = `select-${record.id}`;
                selectTd.innerHTML = `<input type="checkbox" data-row-select id="${checkboxId}" aria-label="Select record ${record.id}">`;
                const rowCheckbox = selectTd.querySelector('input');
                rowCheckbox.checked = state.selectedRecordIds?.has(record.id);

                // Handle checkbox click (prevent cell click from firing)
                rowCheckbox.onclick = (event) => {
                    event.stopPropagation();
                };
                rowCheckbox.onchange = (event) => {
                    event.stopPropagation();
                    handleRecordSelection(record.id, event.shiftKey, records);
                };

                // Make entire cell clickable for selection with shift-select support
                selectTd.onclick = (event) => {
                    event.stopPropagation();
                    // Don't double-handle if clicking directly on checkbox
                    if (event.target === rowCheckbox) return;
                    handleRecordSelection(record.id, event.shiftKey, records);
                };
                tr.appendChild(selectTd);

                // Row number cell comes after checkbox
                if (view.showRowNumbers) {
                    const rowNumberTd = document.createElement('td');
                    rowNumberTd.className = 'row-number-cell';
                    rowNumberTd.textContent = index + 1;
                    tr.appendChild(rowNumberTd);
                }

                tableSchema.forEach(field => {
                    const td = document.createElement('td');
                    const isRecordIdColumn = field.id === '__recordId';
                    td.className = isRecordIdColumn ? 'cell-static' : 'cell-editable';
                    td.dataset.recordId = record.id;
                    td.dataset.fieldId = field.id;
                    td.style.width = `${getFieldWidth(field, view)}px`;
                    const value = record[field.id];
                    td.innerHTML = renderCellValue(value, field, record);
                    addColumnResizer(td, field);
                    if (isRecordIdColumn) {
                        td.onclick = (e) => { e.stopPropagation(); openExpandedRecord(record.id); };
                    } else if (field.type === 'CHECKBOX') {
                        td.onclick = (e) => {
                            e.stopPropagation();
                            const now = Date.now();
                            if (td._lastToggleTime && now - td._lastToggleTime < 250) return;
                            td._lastToggleTime = now;
                            toggleCheckbox(record.id, field.id);
                        };
                    } else {
                        td.onclick = (e) => {
                            e.stopPropagation();
                            handleCellClick(td, record.id, field);
                        };
                    }
                    if (!isRecordIdColumn) {
                        td.oncontextmenu = (e) => { e.preventDefault(); showCellMenu(e, record.id, field); };
                    }
                    tr.appendChild(td);
                });

                // Add empty cell for hidden fields column
                if (hiddenFieldsCount > 0) {
                    const hiddenTd = document.createElement('td');
                    hiddenTd.className = 'hidden-fields-cell';
                    tr.appendChild(hiddenTd);
                }

                // Add empty cell for add column button
                const addColumnTd = document.createElement('td');
                addColumnTd.className = 'add-column-cell';
                tr.appendChild(addColumnTd);

                tbody.appendChild(tr);
            });

            // Focus on newly added record if it exists
            if (state.newlyAddedRecordId) {
                const newRecordRow = tbody.querySelector(`[data-record-id="${state.newlyAddedRecordId}"]`);
                if (newRecordRow) {
                    // Find the first editable cell in the new record
                    const firstEditableCell = newRecordRow.parentElement.querySelector(`[data-record-id="${state.newlyAddedRecordId}"].cell-editable`);
                    if (firstEditableCell) {
                        const fieldId = firstEditableCell.getAttribute('data-field-id');
                        selectCell(firstEditableCell, state.newlyAddedRecordId, fieldId);
                        // Scroll into view
                        firstEditableCell.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }
                }
                state.newlyAddedRecordId = null;
            } else if (previousSelection) {
                const match = tbody.querySelector(`[data-record-id="${previousSelection.recordId}"][data-field-id="${previousSelection.fieldId}"]`);
                if (match) {
                    selectCell(match, previousSelection.recordId, previousSelection.fieldId);
                }
            }

            // Render ghost rows from toss pile
            if (typeof TossPileUI !== 'undefined') {
                TossPileUI.renderGhostRows(state, tbody, tableSchema, view);
            }

            // Update toss pile panel if open
            if (typeof TossPileUI !== 'undefined') {
                TossPileUI.updateTossPilePanel();
            }

            wireViewStageActions();
            setupToolbarMenu();
        }

        function renderKeyDerivedView() {
            const view = getCurrentView();
            if (!view?.key) return renderGridView();

            const keyRef = view.key;
            const allItems = findAllItemsForKey(keyRef.setId, keyRef.fieldId);
            const grouped = groupByKeyValue(allItems, keyRef.fieldId);
            const rows = buildRowsFromGroups(grouped, view);

            const viewMode = view.viewMode || 'live';
            const viewModeBadge = renderViewModeBadge(viewMode);
            const tableShellClass = viewMode === 'sandbox' ? 'view-table-shell sandbox' : 'view-table-shell';

            const container = document.getElementById('viewContainer');
            container.innerHTML = `
                <div class="view-stage-header">
                    ${renderViewBreadcrumb()}
                    <div class="view-stage-title">
                        <span class="view-stage-pill">${state.sets.get(keyRef.setId)?.name || 'Key set'}</span>
                        <div class="min-w-0">
                            <div class="view-stage-name">${view.name}${viewModeBadge}</div>
                            <div class="view-stage-sub">Generated key view  ${rows.length} collections</div>
                        </div>
                    </div>
                    ${renderViewActions()}
                </div>
                <div class="view-stage-body">
                    <div class="${tableShellClass}">
                        <div class="table-scroll">
                            <table id="dataTable" class="border-collapse">
                                <thead><tr id="tableHeader"></tr></thead>
                                <tbody id="tableBody"></tbody>
                            </table>
                        </div>
                        <div class="table-footer">
                            <span class="record-counter" id="recordCounter">${rows.length} collections</span>
                        </div>
                    </div>
                </div>
            `;

            const headerRow = document.getElementById('tableHeader');
            headerRow.innerHTML = '';
            const keyHeader = document.createElement('th');
            keyHeader.className = 'column-header';
            keyHeader.textContent = 'Identity Property';
            headerRow.appendChild(keyHeader);

            (view.schema || []).forEach(field => {
                const th = document.createElement('th');
                th.className = 'column-header';
                th.dataset.fieldId = field.id;
                th.textContent = field.name;
                th.style.cursor = 'context-menu';
                th.title = 'Right-click for field options';
                th.oncontextmenu = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    showColumnMenu(e, field);
                };
                headerRow.appendChild(th);
            });

            const tbody = document.getElementById('tableBody');
            rows.forEach(row => {
                const tr = document.createElement('tr');
                const identityCell = document.createElement('td');
                identityCell.textContent = row.keyValue;
                tr.appendChild(identityCell);

                (view.schema || []).forEach(field => {
                    const td = document.createElement('td');
                    td.className = 'cell-editable';
                    const value = row[field.id];
                    td.innerHTML = renderCellValue(value, field, row);
                    td.onclick = () => openObservationModal({ keyValue: row.keyValue, field, items: row.__sourceItems });
                    tr.appendChild(td);
                });

                tbody.appendChild(tr);
            });

            finalizeViewStage();
            updateSelectionUI(rows);
        }

        function evaluateLinkedLookup(lookupConfig, record, state) {
            const {
                sourceFieldId,
                targetSetId,
                targetFieldId,
                direction,
                sourceSetId
            } = lookupConfig;

            // Handle incoming links differently - need to find records that link TO this record
            if (direction === 'incoming' && sourceSetId) {
                const sourceSet = state.sets.get(sourceSetId);
                if (!sourceSet) return [];

                const targetField = sourceSet.schema.find(f => f.id === targetFieldId);

                // Find all records in sourceSet that link to this record via sourceFieldId
                const values = [];
                sourceSet.records.forEach((sourceRecord) => {
                    const linkedValue = sourceRecord[sourceFieldId];
                    if (!linkedValue) return;

                    // Check if this record links to our current record
                    const linkedIds = Array.isArray(linkedValue) ? linkedValue : [linkedValue];
                    if (!linkedIds.includes(record.id)) return;

                    // Get the target field value from this linked record
                    const value = sourceRecord[targetFieldId];
                    if (value === undefined || value === null || value === '') return;

                    // Prevent recursion for linked field types
                    if (targetField?.type === 'LINKED_LOOKUP' || targetField?.type === 'LINKED_ROLLUP') {
                        values.push(String(value));
                        return;
                    }

                    // Format value based on target field type
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = renderCellValue(value, targetField || { type: 'TEXT', id: targetFieldId }, sourceRecord);
                    const formatted = tempDiv.textContent || tempDiv.innerText || String(value);
                    values.push(formatted);
                });

                return values;
            }

            // Original outgoing link logic
            // Get linked record ID(s) from source field
            const linkedRecordId = record[sourceFieldId];

            if (!linkedRecordId) return [];

            // Handle both single IDs and arrays
            const recordIds = Array.isArray(linkedRecordId) ? linkedRecordId : [linkedRecordId];
            const validIds = recordIds.filter(id => id && typeof id === 'string');

            if (validIds.length === 0) return [];

            // Get target set
            const targetSet = state.sets.get(targetSetId);
            if (!targetSet) return [];

            const targetField = targetSet.schema.find(f => f.id === targetFieldId);

            // Get values from all linked records
            const values = validIds.map(recordId => {
                const linkedRecord = targetSet.records.get(recordId);
                if (!linkedRecord) return null;

                const value = linkedRecord[targetFieldId];
                if (value === undefined || value === null || value === '') return null;

                // Prevent recursion for linked field types
                if (targetField?.type === 'LINKED_LOOKUP' || targetField?.type === 'LINKED_ROLLUP') {
                    return String(value);
                }

                // Format value based on target field type using temporary element
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = renderCellValue(value, targetField || { type: 'TEXT', id: targetFieldId }, linkedRecord);
                return tempDiv.textContent || tempDiv.innerText || String(value);
            }).filter(v => v !== null);

            return values;
        }

        function renderCellValue(value, field, record) {
            if (value && typeof value === 'object' && value._sup) {
                return renderSuperpositionCell(value.value || []);
            }

            // Get effective type and subtype (handle legacy fields)
            let effectiveType = field.type;
            let effectiveSubtype = field.subtype;

            // Map legacy types to new structure
            if (field.type === 'LONG_TEXT') {
                effectiveType = 'TEXT';
                effectiveSubtype = 'STRING';
            } else if (field.type === 'EMAIL' || field.type === 'URL' || field.type === 'PHONE') {
                effectiveType = 'CONTACT';
                effectiveSubtype = field.type;
            } else if (field.type === 'CURRENCY') {
                effectiveType = 'NUMBER';
                effectiveSubtype = 'CURRENCY';
            }
            // Map legacy TEXT subtypes to new subtypes
            if (effectiveType === 'TEXT') {
                if (effectiveSubtype === 'SHORT' || effectiveSubtype === 'LONG') {
                    effectiveSubtype = 'STRING';
                } else if (effectiveSubtype === 'RICH') {
                    effectiveSubtype = 'RICH_TEXT';
                }
            }

            // Handle TEXT with subtypes
            if (effectiveType === 'TEXT') {
                const subtype = effectiveSubtype || 'STRING';
                if (subtype === 'RICH_TEXT' && value) {
                    // Render rich text with markdown support
                    return renderRichText(value);
                } else {
                    return value || '';
                }
            }

            // Handle JSON with subtypes
            if (effectiveType === 'JSON') {
                if (value === null || value === undefined) return '';
                const subtype = effectiveSubtype || 'DISPLAY';
                if (subtype === 'RENDER') {
                    return renderJsonTree(value);
                } else {
                    // DISPLAY: syntax-highlighted JSON
                    return renderJsonDisplay(value);
                }
            }

            // Handle NUMBER with subtypes
            if (effectiveType === 'NUMBER') {
                const subtype = effectiveSubtype || 'NUMBER';
                if (subtype === 'CURRENCY') {
                    return value ? new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD' }).format(value) : '';
                } else {
                    return value ? Number(value).toLocaleString() : '';
                }
            }

            // Handle CONTACT with subtypes
            if (effectiveType === 'CONTACT') {
                const subtype = effectiveSubtype || 'EMAIL';
                if (subtype === 'EMAIL' && value) {
                    return `<a href="mailto:${value}" class="text-blue-600 hover:underline" onclick="event.stopPropagation()">${value}</a>`;
                } else if (subtype === 'URL' && value) {
                    return `<a href="${value}" target="_blank" class="text-blue-600 hover:underline" onclick="event.stopPropagation()">${value}</a>`;
                } else if (subtype === 'PHONE' && value) {
                    return `<a href="tel:${value}" class="text-blue-600 hover:underline" onclick="event.stopPropagation()">${value}</a>`;
                }
                return value || '';
            }

            switch(effectiveType) {
                case 'DATE':
                    return value ? new Date(value).toLocaleDateString() : '';
                case 'CHECKBOX':
                    return value ? '' : '';
                case 'LINK_RECORD':
                    if (!value) return '';
                    // Handle both single values and arrays
                    const linkedRecordIds = Array.isArray(value) ? value : [value];
                    if (linkedRecordIds.length === 0) return '';

                    const maxVisible = 3;
                    const visibleIds = linkedRecordIds.slice(0, maxVisible);
                    const hiddenCount = Math.max(0, linkedRecordIds.length - maxVisible);
                    const showSuperscripts = linkedRecordIds.length > 1;

                    const pills = visibleIds.map((recordId, idx) => {
                        const displayName = getRecordDisplayName(recordId) || field.config?.linkedSetId && state.sets.get(field.config?.linkedSetId)?.name || 'Record';
                        const superscript = showSuperscripts ? `<span class="linked-superscript">${idx + 1}</span>` : '';
                        return `<button class="linked-record-pill" onclick="event.stopPropagation(); openLinkedRecord('${recordId}')" title="${displayName}">${displayName}${superscript}</button>`;
                    }).join('');

                    const morePill = hiddenCount > 0 ? `<span class="linked-record-more">+${hiddenCount}</span>` : '';

                    return `<div class="linked-record-container" data-linked-field-id="${field.id}">${pills}${morePill}</div>`;
                case 'LOOKUP':
                    if (!value) return '';
                    const lookupName = getRecordDisplayName(value) || 'Record';
                    return `<span class="text-gray-700">${lookupName}</span>`;
                case 'SELECT':
                    if (!value) return '';
                    const color = field.config?.colors?.[value] || 'gray';
                    return `<span class="badge badge-${color}">${value}</span>`;
                case 'FORMULA':
                    if (!field.config?.formula) return '';
                    const set = getCurrentSet();
                    const formulaResult = FormulaEngine.evaluate(field.config.formula, record, set.schema);
                    if (formulaResult === '#ERROR') {
                        return '<span class="text-red-600" title="Formula error">#ERROR</span>';
                    }
                    const formatted = FormulaEngine.formatFormulaValue(
                        formulaResult,
                        field.config.format || 'number',
                        field.config.decimals || 2
                    );
                    return formatted;
                case 'RECORD_ID':
                    const displayName = getRecordDisplayName(record?.id) || 'Record';
                    return `<span class="font-mono text-xs text-gray-700">${displayName}</span>`;
                case 'LINKED_LOOKUP':
                    // Render linked lookup field
                    if (!field._linkedConfig) return '';
                    const lookupValues = evaluateLinkedLookup(field._linkedConfig, record, state);
                    if (!lookupValues || lookupValues.length === 0) return '';

                    // Display all values as pills with superscript numbers when multiple
                    const showLookupSuperscripts = lookupValues.length > 1;
                    if (lookupValues.length > 1) {
                        const lookupPills = lookupValues.map((val, idx) => {
                            const lookupSuperscript = showLookupSuperscripts ? `<span class="linked-superscript">${idx + 1}</span>` : '';
                            return `<span class="lookup-value-pill">${val}${lookupSuperscript}</span>`;
                        }).join(' ');
                        return `<div class="lookup-array-container" data-source-field-id="${field._linkedConfig.sourceFieldId}">${lookupPills}</div>`;
                    }

                    // Single value - display normally (no superscript needed)
                    return `<span class="lookup-value-pill">${lookupValues[0]}</span>`;
                case 'LINKED_ROLLUP':
                    // Render linked rollup field
                    if (!field._linkedConfig) return '';
                    if (!window.EOCRollupEngine) return '<span class="text-red-600">Rollup engine not loaded</span>';
                    const rollupValue = window.EOCRollupEngine.evaluate(field._linkedConfig, record, state);
                    const targetSet = state.sets.get(field._linkedConfig.targetSetId);
                    const targetField = targetSet?.schema.find(f => f.id === field._linkedConfig.targetFieldId);
                    const formattedRollup = window.EOCRollupEngine.formatValue(rollupValue, field._linkedConfig.aggregation, targetField);
                    return `<span class="text-gray-700">${formattedRollup}</span>`;
                default:
                    return value || '';
            }
        }

        function renderRichText(text) {
            if (!text) return '';

            // Basic markdown to HTML conversion
            let html = text
                // Headers
                .replace(/^### (.*$)/gim, '<h3 class="text-lg font-semibold mt-2">$1</h3>')
                .replace(/^## (.*$)/gim, '<h2 class="text-xl font-semibold mt-2">$1</h2>')
                .replace(/^# (.*$)/gim, '<h1 class="text-2xl font-bold mt-2">$1</h1>')
                // Bold
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                .replace(/__(.*?)__/g, '<strong>$1</strong>')
                // Italic
                .replace(/\*(.*?)\*/g, '<em>$1</em>')
                .replace(/_(.*?)_/g, '<em>$1</em>')
                // Links
                .replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" class="text-blue-600 hover:underline" target="_blank" onclick="event.stopPropagation()">$1</a>')
                // Line breaks
                .replace(/\n/g, '<br>');

            return `<div class="rich-text">${html}</div>`;
        }

        function renderJsonDisplay(value) {
            // Display syntax-highlighted JSON in a compact cell view
            try {
                const jsonStr = typeof value === 'string' ? value : JSON.stringify(value, null, 2);
                const parsed = typeof value === 'string' ? JSON.parse(value) : value;
                const highlighted = syntaxHighlight(JSON.stringify(parsed, null, 2));
                return `<div class="json-cell-display" onclick="event.stopPropagation(); showJsonViewerForValue(this)" data-json='${encodeURIComponent(jsonStr)}'><pre class="json-code-preview">${highlighted}</pre></div>`;
            } catch (e) {
                return `<span class="text-red-500">Invalid JSON</span>`;
            }
        }

        function renderJsonTree(value) {
            // Render JSON as a visual tree with collapsible objects/arrays
            try {
                const data = typeof value === 'string' ? JSON.parse(value) : value;
                return `<div class="json-tree-container" onclick="event.stopPropagation()">${buildJsonTree(data, true)}</div>`;
            } catch (e) {
                return `<span class="text-red-500">Invalid JSON</span>`;
            }
        }

        function buildJsonTree(data, isRoot = false) {
            if (data === null) return '<span class="json-null">null</span>';
            if (data === undefined) return '<span class="json-null">undefined</span>';

            const type = typeof data;

            if (type === 'boolean') {
                return `<span class="json-boolean">${data}</span>`;
            }
            if (type === 'number') {
                return `<span class="json-number">${data}</span>`;
            }
            if (type === 'string') {
                return `<span class="json-string">"${escapeHtml(data)}"</span>`;
            }

            if (Array.isArray(data)) {
                if (data.length === 0) return '<span class="json-bracket">[]</span>';
                const items = data.map((item, idx) =>
                    `<div class="json-tree-item"><span class="json-index">[${idx}]</span> ${buildJsonTree(item)}</div>`
                ).join('');
                const collapsed = !isRoot && data.length > 3;
                return `<div class="json-tree-node ${collapsed ? 'collapsed' : ''}" onclick="event.stopPropagation(); this.classList.toggle('collapsed')">
                    <span class="json-toggle"></span><span class="json-bracket">[</span><span class="json-collapse-hint">${data.length} items</span>
                    <div class="json-tree-children">${items}</div>
                    <span class="json-bracket">]</span>
                </div>`;
            }

            if (type === 'object') {
                const keys = Object.keys(data);
                if (keys.length === 0) return '<span class="json-bracket">{}</span>';
                const items = keys.map(key =>
                    `<div class="json-tree-item"><span class="json-key">"${escapeHtml(key)}"</span>: ${buildJsonTree(data[key])}</div>`
                ).join('');
                const collapsed = !isRoot && keys.length > 3;
                return `<div class="json-tree-node ${collapsed ? 'collapsed' : ''}" onclick="event.stopPropagation(); this.classList.toggle('collapsed')">
                    <span class="json-toggle"></span><span class="json-bracket">{</span><span class="json-collapse-hint">${keys.length} keys</span>
                    <div class="json-tree-children">${items}</div>
                    <span class="json-bracket">}</span>
                </div>`;
            }

            return `<span>${String(data)}</span>`;
        }

        function escapeHtml(str) {
            return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
        }

        function showJsonViewerForValue(element) {
            try {
                const jsonStr = decodeURIComponent(element.dataset.json);
                const data = JSON.parse(jsonStr);
                const highlighted = syntaxHighlight(JSON.stringify(data, null, 2));
                document.getElementById('jsonContent').innerHTML = highlighted;
                openModal('jsonViewerModal');
            } catch (e) {
                showToast('Invalid JSON data');
            }
        }

        function openColumnRulesModal() {
            const modal = document.getElementById('columnRulesModal');
            const view = getCurrentView();
            if (!modal || !view) return;

            const fields = view.type === 'KEY_DERIVED' ? (view.schema || []) : getCurrentSet()?.schema || [];
            const fieldSelect = document.getElementById('columnRulesFieldSelect');
            fieldSelect.innerHTML = '';
            fields.forEach(f => {
                const opt = document.createElement('option');
                opt.value = f.id;
                opt.textContent = f.name;
                fieldSelect.appendChild(opt);
            });

            const ruleSelect = document.getElementById('columnRulesRuleSelect');
            const setPicker = document.getElementById('columnRulesSetPicker');
            const preferredSet = document.getElementById('columnRulesPreferredSet');
            preferredSet.innerHTML = '';
            getSetsForWorld().forEach(set => {
                const opt = document.createElement('option');
                opt.value = set.id;
                opt.textContent = set.name;
                preferredSet.appendChild(opt);
            });

            const currentRule = view.columnRules?.[fieldSelect.value] || { rule: 'sup_all' };
            ruleSelect.value = currentRule.rule || 'sup_all';
            preferredSet.value = currentRule.setId || '';
            setPicker.classList.toggle('hidden', ruleSelect.value !== 'prefer_set');

            const recordIdCheckbox = document.getElementById('recordIdVisibilityToggle');
            const recordIdToggle = document.getElementById('recordIdToggle');
            if (recordIdCheckbox) {
                recordIdCheckbox.checked = !!view.showRecordId;
                if (recordIdToggle) recordIdToggle.classList.toggle('active', !!view.showRecordId);
            }

            const rowNumbersCheckbox = document.getElementById('rowNumbersVisibilityToggle');
            const rowNumbersToggle = document.getElementById('rowNumbersToggle');
            if (rowNumbersCheckbox) {
                rowNumbersCheckbox.checked = !!view.showRowNumbers;
                if (rowNumbersToggle) rowNumbersToggle.classList.toggle('active', !!view.showRowNumbers);
            }

            updateColumnRulesSummary();
            openModal('columnRulesModal');
        }

        function updateColumnRulesSummary() {
            const view = getCurrentView();
            if (!view) return;
            const summary = document.getElementById('columnRulesSummary');
            const fieldSelect = document.getElementById('columnRulesFieldSelect');
            const ruleSelect = document.getElementById('columnRulesRuleSelect');
            const preferredSet = document.getElementById('columnRulesPreferredSet');
            const field = (view.schema || getCurrentSet()?.schema || []).find(f => f.id === fieldSelect.value);
            const ruleText = ruleSelect.options[ruleSelect.selectedIndex]?.textContent;
            const setName = preferredSet.value ? state.sets.get(preferredSet.value)?.name : null;
            summary.textContent = `${field?.name || 'Field'}  ${ruleText}${setName ? ` (${setName})` : ''}`;
        }

        function toggleRecordIdVisibility(isVisible) {
            const view = getCurrentView();
            if (!view) return;

            view.showRecordId = isVisible;
            if (isVisible) {
                view.hiddenFields = (view.hiddenFields || []).filter(id => id !== '__recordId');
            } else {
                view.hiddenFields = view.hiddenFields || [];
                if (!view.hiddenFields.includes('__recordId')) view.hiddenFields.push('__recordId');
            }
            ensureViewColumnOrder(view, getCurrentSet()?.schema || [], isVisible);
            createEvent(
                'View Schema Update',
                'SEG',
                { type: 'View', id: view.id, setId: view.key?.setId || state.currentSetId },
                { viewId: view.id, changes: { showRecordId: isVisible }, summary: isVisible ? 'Enabled Record ID column' : 'Hid Record ID column' },
                { scale: 'collection' }
            );

            renderCurrentView();
        }

        function toggleRowNumbers(isVisible) {
            const view = getCurrentView();
            if (!view) return;

            view.showRowNumbers = isVisible;
            createEvent(
                'View Schema Update',
                'SEG',
                { type: 'View', id: view.id, setId: view.key?.setId || state.currentSetId },
                { viewId: view.id, changes: { showRowNumbers: isVisible }, summary: isVisible ? 'Enabled row numbers' : 'Hid row numbers' },
                { scale: 'collection' }
            );

            renderCurrentView();
            showToast(isVisible ? ' Row numbers enabled' : ' Row numbers hidden');
        }

        function saveColumnRule() {
            const view = getCurrentView();
            if (!view) return;
            const fieldId = document.getElementById('columnRulesFieldSelect').value;
            const rule = document.getElementById('columnRulesRuleSelect').value;
            const setId = document.getElementById('columnRulesPreferredSet').value || null;

            view.columnRules = view.columnRules || {};
            view.columnRules[fieldId] = { rule, ...(rule === 'prefer_set' ? { setId } : {}) };

            createEvent(
                'View Schema Update',
                'SEG',
                { type: 'View', id: view.id, setId: view.key?.setId || state.currentSetId },
                { viewId: view.id, changes: { columnRules: view.columnRules }, summary: 'Updated column rules' },
                { scale: 'collection' }
            );

            closeModal('columnRulesModal');
            renderCurrentView();
        }

        function deleteColumnRule() {
            const view = getCurrentView();
            if (!view) return;
            const fieldId = document.getElementById('columnRulesFieldSelect').value;
            if (view.columnRules?.[fieldId]) {
                delete view.columnRules[fieldId];
                createEvent(
                    'View Schema Update',
                    'SEG',
                    { type: 'View', id: view.id, setId: view.key?.setId || state.currentSetId },
                    { viewId: view.id, changes: { columnRules: view.columnRules }, summary: 'Cleared column rule' },
                    { scale: 'collection' }
                );
            }
            closeModal('columnRulesModal');
            renderCurrentView();
        }

        // FIELD MANAGER
        let fieldManagerDragState = {
            draggingFieldId: null,
            dropTargetFieldId: null,
            dropPosition: null
        };

        function openFieldManager() {
            const set = getCurrentSet();
            if (!set) {
                showToast(' No set selected');
                return;
            }

            // Clear search field
            const searchInput = document.getElementById('fieldManagerSearch');
            const clearSearchBtn = document.getElementById('clearFieldSearch');
            if (searchInput) {
                searchInput.value = '';
            }
            if (clearSearchBtn) {
                clearSearchBtn.classList.add('hidden');
            }

            // Render the field list
            renderFieldManagerList();

            // Setup event listeners
            setupFieldManagerEvents();

            // Open the modal
            openModal('fieldManagerModal');
        }

        function renderFieldManagerList(searchQuery = '') {
            const set = getCurrentSet();
            if (!set) return;

            const view = getCurrentView();
            const hiddenFields = view?.hiddenFields || [];

            const listContainer = document.getElementById('fieldManagerList');
            listContainer.innerHTML = '';

            // Filter fields based on search query
            const query = searchQuery.toLowerCase().trim();
            let filteredSchema = set.schema;
            if (query) {
                filteredSchema = set.schema.filter(field => {
                    const fieldName = field.name.toLowerCase();
                    const fieldType = (FIELD_TYPES[field.type]?.name || field.type).toLowerCase();
                    return fieldName.includes(query) || fieldType.includes(query);
                });
            }

            // Split fields into visible and hidden
            const visibleFields = filteredSchema.filter(field => !hiddenFields.includes(field.id));
            const hiddenFieldsList = filteredSchema.filter(field => hiddenFields.includes(field.id));

            // Show "no results" message if search returned no results
            if (query && filteredSchema.length === 0) {
                const noResults = document.createElement('div');
                noResults.className = 'text-center py-8 text-gray-500';
                noResults.innerHTML = `
                    <i class="ph ph-magnifying-glass text-4xl mb-2 block"></i>
                    <p>No fields found matching "${searchQuery}"</p>
                `;
                listContainer.appendChild(noResults);
                return;
            }

            // Render visible fields
            if (visibleFields.length > 0) {
                const visibleHeader = document.createElement('div');
                visibleHeader.className = 'text-sm font-semibold text-gray-700 mb-2 mt-2';
                visibleHeader.textContent = 'Visible Fields';
                listContainer.appendChild(visibleHeader);

                visibleFields.forEach((field, index) => {
                    const fieldItem = createFieldManagerItem(field, index, false);
                    listContainer.appendChild(fieldItem);
                });
            }

            // Render hidden fields
            if (hiddenFieldsList.length > 0) {
                const hiddenHeader = document.createElement('div');
                hiddenHeader.className = 'text-sm font-semibold text-gray-500 mb-2 mt-4';
                hiddenHeader.textContent = 'Hidden Fields';
                listContainer.appendChild(hiddenHeader);

                hiddenFieldsList.forEach((field, index) => {
                    const fieldItem = createFieldManagerItem(field, index, true);
                    listContainer.appendChild(fieldItem);
                });
            }
        }

        function createFieldManagerItem(field, index, isHidden) {
            const fieldType = FIELD_TYPES[field.type] || { name: field.type, icon: 'ph-question' };

            // Get subtype info if available
            let displayName = fieldType.name;
            let displayIcon = fieldType.icon;

            if (field.subtype && fieldType.subtypes && fieldType.subtypes[field.subtype]) {
                const subtype = fieldType.subtypes[field.subtype];
                displayName = subtype.name;
                displayIcon = subtype.icon;
            }

            const div = document.createElement('div');
            div.className = 'field-manager-item';
            if (isHidden) {
                div.style.opacity = '0.6';
            }
            div.dataset.fieldId = field.id;
            div.draggable = true;

            const visibilityIcon = isHidden ? 'ph-eye-slash' : 'ph-eye';
            const visibilityTitle = isHidden ? 'Show field' : 'Hide field';
            const visibilityAction = isHidden ? `showField('${field.id}')` : `hideField('${field.id}')`;

            div.innerHTML = `
                <button class="field-manager-action-btn" title="${visibilityTitle}" onclick="${visibilityAction}">
                    <i class="ph ${visibilityIcon}"></i>
                </button>
                <i class="ph ph-dots-six-vertical field-drag-handle"></i>
                <div class="field-manager-icon">
                    <i class="ph ${displayIcon}"></i>
                </div>
                <div class="field-manager-info">
                    <div class="field-manager-name" data-field-id="${field.id}">
                        <span class="field-name-display">${field.name}</span>
                    </div>
                    <div class="field-manager-type-label">${displayName}</div>
                </div>
                <div class="field-manager-actions">
                    <button class="field-manager-action-btn" title="Rename field" onclick="enableFieldRename('${field.id}')">
                        <i class="ph ph-pencil-simple"></i>
                    </button>
                    <button class="field-manager-action-btn" title="Change field type" onclick="openFieldTypeChanger('${field.id}')">
                        <i class="ph ph-swap"></i>
                    </button>
                    <button class="field-manager-action-btn danger" title="Delete field" onclick="confirmDeleteFieldFromManager('${field.id}')">
                        <i class="ph ph-trash"></i>
                    </button>
                </div>
            `;

            // Setup drag and drop
            setupFieldDragAndDrop(div, field.id);

            return div;
        }

        function setupFieldDragAndDrop(element, fieldId) {
            element.addEventListener('dragstart', (e) => {
                fieldManagerDragState.draggingFieldId = fieldId;
                element.classList.add('dragging');
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/plain', fieldId);
            });

            element.addEventListener('dragend', (e) => {
                element.classList.remove('dragging');
                clearFieldDragIndicators();
                fieldManagerDragState.draggingFieldId = null;
                fieldManagerDragState.dropTargetFieldId = null;
                fieldManagerDragState.dropPosition = null;
            });

            element.addEventListener('dragover', (e) => {
                if (!fieldManagerDragState.draggingFieldId || fieldManagerDragState.draggingFieldId === fieldId) {
                    return;
                }
                e.preventDefault();

                const rect = element.getBoundingClientRect();
                const midpoint = rect.top + rect.height / 2;
                const position = e.clientY < midpoint ? 'before' : 'after';

                clearFieldDragIndicators();
                element.classList.add('drag-over');
                fieldManagerDragState.dropTargetFieldId = fieldId;
                fieldManagerDragState.dropPosition = position;
            });

            element.addEventListener('drop', (e) => {
                e.preventDefault();
                if (!fieldManagerDragState.draggingFieldId || !fieldManagerDragState.dropTargetFieldId) {
                    return;
                }

                reorderFieldInSchema(
                    fieldManagerDragState.draggingFieldId,
                    fieldManagerDragState.dropTargetFieldId,
                    fieldManagerDragState.dropPosition
                );

                clearFieldDragIndicators();
                renderFieldManagerList();
            });
        }

        function clearFieldDragIndicators() {
            document.querySelectorAll('.field-manager-item').forEach(item => {
                item.classList.remove('drag-over');
            });
        }

        function reorderFieldInSchema(draggedFieldId, targetFieldId, position) {
            const set = getCurrentSet();
            if (!set) return;

            const schema = set.schema;
            const fromIndex = schema.findIndex(f => f.id === draggedFieldId);
            let toIndex = schema.findIndex(f => f.id === targetFieldId);

            if (fromIndex === -1 || toIndex === -1) return;

            // Remove from old position
            const [movedField] = schema.splice(fromIndex, 1);

            // Adjust toIndex if we removed an item before it
            if (fromIndex < toIndex) {
                toIndex -= 1;
            }

            // Insert at new position
            const insertIndex = position === 'after' ? toIndex + 1 : toIndex;
            schema.splice(insertIndex, 0, movedField);

            // Update view column order if exists
            const view = getCurrentView();
            if (view) {
                ensureViewColumnOrder(view, schema, view.showRecordId);
            }

            createEvent(
                'Reorder Fields',
                'SEG',
                { type: 'Set', id: set.id },
                { setId: set.id, fieldId: draggedFieldId, summary: `Reordered field ${movedField.name}` },
                { frame: 'schema', scale: 'collection' }
            );

            renderCurrentView();
            showToast(' Field reordered');
        }

        function enableFieldRename(fieldId) {
            const set = getCurrentSet();
            if (!set) return;

            const field = set.schema.find(f => f.id === fieldId);
            if (!field) return;

            const nameDisplay = document.querySelector(`.field-manager-name[data-field-id="${fieldId}"] .field-name-display`);
            if (!nameDisplay) return;

            const currentName = field.name;
            const input = document.createElement('input');
            input.type = 'text';
            input.value = currentName;
            input.className = 'w-full';

            const parent = nameDisplay.parentElement;
            parent.replaceChild(input, nameDisplay);
            input.focus();
            input.select();

            const saveRename = () => {
                const newName = input.value.trim();
                if (newName && newName !== currentName) {
                    field.name = newName;
                    createEvent(
                        'Rename Field',
                        'SEG',
                        { type: 'Field', id: fieldId, setId: set.id },
                        { setId: set.id, fieldId, oldName: currentName, newName, summary: `Renamed field from "${currentName}" to "${newName}"` },
                        { frame: 'schema', scale: 'collection' }
                    );
                    renderCurrentView();
                    showToast(` Field renamed to "${newName}"`);
                }
                renderFieldManagerList();
            };

            input.addEventListener('blur', saveRename);
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    saveRename();
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    renderFieldManagerList();
                }
            });
        }

        function openFieldTypeChanger(fieldId) {
            const set = getCurrentSet();
            if (!set) return;

            const field = set.schema.find(f => f.id === fieldId);
            if (!field) return;

            // Close field manager and open the existing change field type modal
            closeModal('fieldManagerModal');
            openChangeFieldTypeModal(field);
        }

        function confirmDeleteFieldFromManager(fieldId) {
            const set = getCurrentSet();
            if (!set) return;

            const field = set.schema.find(f => f.id === fieldId);
            if (!field) return;

            showConfirm(
                `Are you sure you want to delete the field "${field.name}"? This will remove all data in this field from all records.`,
                () => {
                    deleteField(fieldId);
                    renderFieldManagerList();
                },
                () => {}
            );
        }

        function setupFieldManagerEvents() {
            // Close button
            const closeBtn = document.getElementById('closeFieldManagerBtn');
            const closeFooterBtn = document.getElementById('closeFieldManagerFooterBtn');

            if (closeBtn) {
                closeBtn.onclick = () => closeModal('fieldManagerModal');
            }
            if (closeFooterBtn) {
                closeFooterBtn.onclick = () => closeModal('fieldManagerModal');
            }

            // Search field
            const searchInput = document.getElementById('fieldManagerSearch');
            const clearSearchBtn = document.getElementById('clearFieldSearch');

            if (searchInput) {
                searchInput.oninput = (e) => {
                    const query = e.target.value;
                    if (query.trim()) {
                        clearSearchBtn.classList.remove('hidden');
                    } else {
                        clearSearchBtn.classList.add('hidden');
                    }
                    renderFieldManagerList(query);
                };
            }

            if (clearSearchBtn) {
                clearSearchBtn.onclick = () => {
                    searchInput.value = '';
                    clearSearchBtn.classList.add('hidden');
                    renderFieldManagerList('');
                };
            }

            // Add field trigger button
            const addFieldTrigger = document.getElementById('addFieldTriggerBtn');
            if (addFieldTrigger) {
                addFieldTrigger.onclick = showFieldManagerAddForm;
            }

            // Cancel add field button
            const cancelNewField = document.getElementById('cancelNewFieldBtn');
            if (cancelNewField) {
                cancelNewField.onclick = hideFieldManagerAddForm;
            }

            // Save new field button
            const saveNewField = document.getElementById('saveNewFieldBtn');
            if (saveNewField) {
                saveNewField.onclick = saveFieldFromManager;
            }

            // Set up field type trigger
            const fieldManagerTypeTrigger = document.getElementById('fieldManagerTypeTrigger');
            if (fieldManagerTypeTrigger) {
                fieldManagerTypeTrigger.onclick = (event) => {
                    event.preventDefault();
                    toggleFieldManagerTypeDropdown();
                };
            }
        }

        function showFieldManagerAddForm() {
            const form = document.getElementById('addFieldForm');
            const trigger = document.getElementById('addFieldTriggerBtn');

            if (form && trigger) {
                form.classList.remove('hidden');
                trigger.classList.add('hidden');

                // Initialize select options state
                state.fieldManagerSelectOptions = [{ value: 'Option 1', color: 'blue' }];

                // Clear form
                const nameInput = document.getElementById('fieldManagerNewName');
                if (nameInput) nameInput.value = '';

                // Set default field type to TEXT
                document.getElementById('fieldManagerNewType').value = 'TEXT';
                renderFieldManagerTypeGrid('TEXT');
                closeFieldManagerTypeDropdown();
                updateFieldManagerConfig('TEXT');

                // Populate link to set dropdown
                const linkSelect = document.getElementById('fieldManagerLinkToSet');
                if (linkSelect) {
                    linkSelect.innerHTML = '';
                    getSetsForWorld(state.currentWorldId).forEach(set => {
                        const label = set.id === state.currentSetId ? `${set.name} (this set)` : set.name;
                        linkSelect.innerHTML += `<option value="${set.id}">${label}</option>`;
                    });
                    if (linkSelect.options.length === 0) {
                        linkSelect.innerHTML = '<option value="">No sets available</option>';
                        linkSelect.disabled = true;
                    } else {
                        linkSelect.disabled = false;
                        const defaultValue = state.sets.has(state.currentSetId) ? state.currentSetId : linkSelect.options[0].value;
                        linkSelect.value = defaultValue;
                    }
                }

                // Focus name input
                if (nameInput) nameInput.focus();
            }
        }

        function hideFieldManagerAddForm() {
            const form = document.getElementById('addFieldForm');
            const trigger = document.getElementById('addFieldTriggerBtn');

            if (form && trigger) {
                form.classList.add('hidden');
                trigger.classList.remove('hidden');
            }
        }

        function updateFieldManagerConfig(typeId) {
            document.getElementById('fieldManagerSelectConfig').classList.remove('visible');
            document.getElementById('fieldManagerLinkToRecordConfig').classList.remove('visible');
            document.getElementById('fieldManagerFormulaConfig').classList.remove('visible');
            document.getElementById('fieldManagerNumberConfig').classList.remove('visible');
            document.getElementById('fieldManagerDateConfig').classList.remove('visible');

            if (typeId === 'SELECT') {
                document.getElementById('fieldManagerSelectConfig').classList.add('visible');
                renderFieldManagerSelectOptions();
            } else if (typeId === 'LINK_RECORD') {
                document.getElementById('fieldManagerLinkToRecordConfig').classList.add('visible');
                // Set up cardinality radio event listeners
                setupLinkCardinalityListeners('fieldManagerLinkCardinality', 'fieldManagerLinkLimitInput');
            } else if (typeId === 'FORMULA') {
                document.getElementById('fieldManagerFormulaConfig').classList.add('visible');
                initFieldManagerFormulaAutocomplete();
            } else if (typeId === 'NUMBER' || typeId === 'CURRENCY') {
                document.getElementById('fieldManagerNumberConfig').classList.add('visible');
                setupNumberConfigListeners();
                // Pre-select currency format if CURRENCY type
                if (typeId === 'CURRENCY') {
                    const currencyRadio = document.querySelector('input[name="fieldManagerNumberFormat"][value="currency"]');
                    if (currencyRadio) currencyRadio.checked = true;
                    document.getElementById('fieldManagerCurrencyOptions')?.classList.remove('hidden');
                }
            } else if (typeId === 'DATE' || typeId === 'DATETIME' || typeId === 'TIME') {
                document.getElementById('fieldManagerDateConfig').classList.add('visible');
                setupDateConfigListeners();
                // Set initial mode based on type
                const modeRadio = document.querySelector(`input[name="fieldManagerDateMode"][value="${typeId.toLowerCase()}"]`);
                if (modeRadio) modeRadio.checked = true;
                updateDateConfigVisibility();
            }
        }

        // Setup cardinality radio listeners to show/hide limit input
        function setupLinkCardinalityListeners(radioName, limitContainerId) {
            const radios = document.querySelectorAll(`input[name="${radioName}"]`);
            const limitContainer = document.getElementById(limitContainerId);
            if (!radios.length || !limitContainer) return;

            radios.forEach(radio => {
                radio.addEventListener('change', () => {
                    if (radio.value === 'limit') {
                        limitContainer.classList.remove('hidden');
                    } else {
                        limitContainer.classList.add('hidden');
                    }
                });
            });
        }

        function renderFieldManagerTypeGrid(selectedType) {
            const trigger = document.getElementById('fieldManagerTypeTrigger');
            const dropdown = document.getElementById('fieldManagerTypeDropdown');
            const selectedName = document.getElementById('fieldManagerSelectedTypeName');
            const selectedDescription = document.getElementById('fieldManagerSelectedTypeDescription');

            if (!trigger || !dropdown) return;

            const fieldType = FIELD_TYPES[selectedType] || Object.values(FIELD_TYPES)[0];
            const iconTarget = trigger.querySelector('.field-type-trigger-icon');
            if (iconTarget) iconTarget.innerHTML = renderIcon(fieldType.icon);
            if (selectedName) selectedName.textContent = fieldType.name;
            if (selectedDescription) selectedDescription.textContent = fieldType.description || fieldType.id.replace(/_/g, ' ');

            dropdown.innerHTML = '';
            Object.values(FIELD_TYPES).forEach(optionType => {
                const option = document.createElement('div');
                option.className = `field-type-option ${optionType.id === selectedType ? 'selected' : ''}`;
                option.dataset.typeId = optionType.id;
                option.innerHTML = `
                    <div class="field-type-icon">${renderIcon(optionType.icon)}</div>
                    <div class="field-type-info">
                        <div class="field-type-name">${optionType.name}</div>
                        <div class="field-type-description">${optionType.description || optionType.id.replace(/_/g, ' ')}</div>
                    </div>
                    <span class="field-type-check">${optionType.id === selectedType ? '' : ''}</span>
                `;
                option.onclick = () => selectFieldManagerType(optionType.id);
                dropdown.appendChild(option);
            });
        }

        function selectFieldManagerType(typeId) {
            document.getElementById('fieldManagerNewType').value = typeId;
            renderFieldManagerTypeGrid(typeId);
            updateFieldManagerConfig(typeId);
            closeFieldManagerTypeDropdown();
        }

        function toggleFieldManagerTypeDropdown() {
            if (state.fieldManagerTypeDropdownOpen) {
                closeFieldManagerTypeDropdown();
            } else {
                openFieldManagerTypeDropdown();
            }
        }

        function openFieldManagerTypeDropdown() {
            const dropdown = document.getElementById('fieldManagerTypeDropdown');
            const trigger = document.getElementById('fieldManagerTypeTrigger');
            if (!dropdown || !trigger) return;
            dropdown.classList.remove('hidden');
            trigger.classList.add('active');
            state.fieldManagerTypeDropdownOpen = true;
        }

        function closeFieldManagerTypeDropdown() {
            const dropdown = document.getElementById('fieldManagerTypeDropdown');
            const trigger = document.getElementById('fieldManagerTypeTrigger');
            if (!dropdown || !trigger) return;
            dropdown.classList.add('hidden');
            trigger.classList.remove('active');
            state.fieldManagerTypeDropdownOpen = false;
        }

        function renderFieldManagerSelectOptions() {
            const list = document.getElementById('fieldManagerSelectOptionsList');
            if (!list) return;

            list.innerHTML = '';
            if (!state.fieldManagerSelectOptions) {
                state.fieldManagerSelectOptions = [{ value: 'Option 1', color: 'blue' }];
            }

            state.fieldManagerSelectOptions.forEach((option, index) => {
                const optionDiv = document.createElement('div');
                optionDiv.className = 'flex items-center gap-2';
                optionDiv.innerHTML = `
                    <input type="text" value="${option.value}" onchange="state.fieldManagerSelectOptions[${index}].value = this.value" class="flex-1 px-3 py-2 border border-gray-300 rounded-lg">
                    <select onchange="state.fieldManagerSelectOptions[${index}].color = this.value" class="px-2 py-2 border border-gray-300 rounded-lg">
                        <option value="blue" ${option.color === 'blue' ? 'selected' : ''}> Blue</option>
                        <option value="green" ${option.color === 'green' ? 'selected' : ''}> Green</option>
                        <option value="red" ${option.color === 'red' ? 'selected' : ''}> Red</option>
                        <option value="yellow" ${option.color === 'yellow' ? 'selected' : ''}> Yellow</option>
                        <option value="purple" ${option.color === 'purple' ? 'selected' : ''}> Purple</option>
                        <option value="gray" ${option.color === 'gray' ? 'selected' : ''}> Gray</option>
                    </select>
                    <button onclick="removeFieldManagerSelectOption(${index})" class="text-red-500 hover:text-red-700 p-2" ${state.fieldManagerSelectOptions.length === 1 ? 'disabled' : ''}>
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                        </svg>
                    </button>
                `;
                list.appendChild(optionDiv);
            });
        }

        function addFieldManagerSelectOption() {
            if (!state.fieldManagerSelectOptions) {
                state.fieldManagerSelectOptions = [];
            }
            state.fieldManagerSelectOptions.push({ value: `Option ${state.fieldManagerSelectOptions.length + 1}`, color: 'blue' });
            renderFieldManagerSelectOptions();
        }

        function removeFieldManagerSelectOption(index) {
            if (state.fieldManagerSelectOptions && state.fieldManagerSelectOptions.length > 1) {
                state.fieldManagerSelectOptions.splice(index, 1);
                renderFieldManagerSelectOptions();
            }
        }

        function initFieldManagerFormulaAutocomplete() {
            const formulaInput = document.getElementById('fieldManagerFormulaInput');
            if (!formulaInput) return;

            // For now, just add a placeholder. Full autocomplete implementation would be more complex
            // and should match the main formula autocomplete functionality
            formulaInput.placeholder = 'e.g., {Price} * {Quantity}';
        }

        function setupNumberConfigListeners() {
            // Show/hide currency options based on format selection
            const formatRadios = document.querySelectorAll('input[name="fieldManagerNumberFormat"]');
            const currencyOptions = document.getElementById('fieldManagerCurrencyOptions');

            formatRadios.forEach(radio => {
                radio.addEventListener('change', () => {
                    if (radio.value === 'currency') {
                        currencyOptions.classList.remove('hidden');
                    } else {
                        currencyOptions.classList.add('hidden');
                    }
                });
            });
        }

        function setupDateConfigListeners() {
            // Show/hide time format based on mode selection
            const modeRadios = document.querySelectorAll('input[name="fieldManagerDateMode"]');
            const showTimezoneCheckbox = document.getElementById('fieldManagerShowTimezone');
            const timezoneSelect = document.getElementById('fieldManagerTimezone');

            modeRadios.forEach(radio => {
                radio.addEventListener('change', updateDateConfigVisibility);
            });

            // Toggle timezone select visibility
            if (showTimezoneCheckbox) {
                showTimezoneCheckbox.addEventListener('change', () => {
                    if (showTimezoneCheckbox.checked) {
                        timezoneSelect.classList.remove('hidden');
                    } else {
                        timezoneSelect.classList.add('hidden');
                    }
                });
            }
        }

        function updateDateConfigVisibility() {
            const mode = document.querySelector('input[name="fieldManagerDateMode"]:checked')?.value || 'date';
            const dateFormatSection = document.getElementById('fieldManagerDateFormatSection');
            const timeFormatSection = document.getElementById('fieldManagerTimeFormatSection');

            if (mode === 'time') {
                dateFormatSection.classList.add('hidden');
                timeFormatSection.classList.remove('hidden');
            } else if (mode === 'date') {
                dateFormatSection.classList.remove('hidden');
                timeFormatSection.classList.add('hidden');
            } else {
                // datetime - show both
                dateFormatSection.classList.remove('hidden');
                timeFormatSection.classList.remove('hidden');
            }
        }

        function saveFieldFromManager() {
            const set = getCurrentSet();
            if (!set) return;

            const name = document.getElementById('fieldManagerNewName').value.trim();
            if (!name) {
                showToast(' Field name is required');
                return;
            }

            const fieldId = name.toLowerCase().replace(/[^a-z0-9]/g, '_');

            // Check for duplicates
            if (set.schema.find(f => f.id === fieldId)) {
                showToast(' A field with this name already exists');
                return;
            }

            const type = document.getElementById('fieldManagerNewType').value;
            const subtype = document.getElementById('fieldManagerNewSubtype')?.value || null;

            const newField = {
                id: fieldId,
                name: name,
                type: type,
                subtype: subtype,
                width: '150',
                config: null
            };

            // Get type-specific config
            if (type === 'SELECT') {
                if (!state.fieldManagerSelectOptions || state.fieldManagerSelectOptions.length === 0) {
                    showToast(' Please add at least one option');
                    return;
                }
                const acceptNewOptions = document.getElementById('fieldManagerAcceptNewOptions')?.checked ?? true;
                const options = state.fieldManagerSelectOptions.map(opt => opt.value);
                const colors = Object.fromEntries(state.fieldManagerSelectOptions.map(opt => [opt.value, opt.color]));
                newField.config = { options, colors, acceptNewOptions };
            } else if (type === 'LINK_RECORD') {
                const linkedSetId = document.getElementById('fieldManagerLinkToSet')?.value;
                if (!linkedSetId) {
                    showToast(' Please select a set to link to');
                    return;
                }
                const cardinalityRadio = document.querySelector('input[name="fieldManagerLinkCardinality"]:checked');
                const cardinality = cardinalityRadio?.value || 'many';
                const limit = cardinality === 'limit' ? parseInt(document.getElementById('fieldManagerLinkLimit')?.value || '3', 10) : null;
                newField.config = { linkedSetId, cardinality, limit };
            } else if (type === 'FORMULA') {
                const formula = document.getElementById('fieldManagerFormulaInput')?.value.trim();
                if (!formula) {
                    showToast(' Please enter a formula');
                    return;
                }
                newField.config = {
                    formula: formula,
                    format: document.getElementById('fieldManagerFormulaFormat')?.value || 'text',
                    decimals: parseInt(document.getElementById('fieldManagerFormulaDecimals')?.value || '2')
                };
            } else if (type === 'NUMBER' || type === 'CURRENCY') {
                const formatRadio = document.querySelector('input[name="fieldManagerNumberFormat"]:checked');
                const format = formatRadio?.value || 'decimal';
                const minVal = document.getElementById('fieldManagerNumberMin')?.value;
                const maxVal = document.getElementById('fieldManagerNumberMax')?.value;
                newField.config = {
                    format: format,
                    decimalPlaces: parseInt(document.getElementById('fieldManagerNumberDecimals')?.value || '2'),
                    roundingMode: document.getElementById('fieldManagerNumberRounding')?.value || 'round',
                    thousandSeparator: document.getElementById('fieldManagerThousandSep')?.checked ?? true,
                    allowNegative: document.getElementById('fieldManagerAllowNegative')?.checked ?? true,
                    currencyCode: format === 'currency' ? (document.getElementById('fieldManagerCurrencyCode')?.value || 'USD') : null,
                    min: minVal !== '' ? parseFloat(minVal) : null,
                    max: maxVal !== '' ? parseFloat(maxVal) : null
                };
                // Set type to NUMBER if currency format selected under NUMBER
                if (type === 'NUMBER' && format === 'currency') {
                    newField.type = 'CURRENCY';
                }
            } else if (type === 'DATE' || type === 'DATETIME' || type === 'TIME') {
                const modeRadio = document.querySelector('input[name="fieldManagerDateMode"]:checked');
                const mode = modeRadio?.value || 'date';
                const timeFormatRadio = document.querySelector('input[name="fieldManagerTimeFormat"]:checked');
                newField.config = {
                    mode: mode,
                    dateFormat: document.getElementById('fieldManagerDateFormat')?.value || 'MM/DD/YYYY',
                    timeFormat: timeFormatRadio?.value || '12h_ampm',
                    includeSeconds: document.getElementById('fieldManagerIncludeSeconds')?.checked ?? false,
                    showTimezone: document.getElementById('fieldManagerShowTimezone')?.checked ?? false,
                    timezone: document.getElementById('fieldManagerTimezone')?.value || null
                };
                // Update the type based on the mode selected
                if (mode === 'datetime') {
                    newField.type = 'DATETIME';
                } else if (mode === 'time') {
                    newField.type = 'TIME';
                } else {
                    newField.type = 'DATE';
                }
            }

            // Add field to schema
            set.schema.push(newField);

            // Add field to current view so it appears immediately
            addFieldToCurrentView(fieldId);

            // Initialize field values in all records
            const defaultValue = FIELD_TYPES[type]?.defaultValue ?? '';
            set.records.forEach(record => {
                record[fieldId] = defaultValue;
            });

            // Create event
            createEvent(
                'Add Field',
                'ADD',
                { type: 'Field', id: fieldId, setId: set.id },
                { setId: set.id, fieldId, fieldName: name, fieldType: type, summary: `Added field ${name} (${FIELD_TYPES[type]?.name})` },
                { frame: 'schema', scale: 'collection' }
            );

            // Auto-create lookup fields for LINK_RECORD
            const view = getCurrentView();
            if (type === 'LINK_RECORD' && newField.config?.linkedSetId && view) {
                autoCreateLookupFieldsForLink(set, view, newField);
            }

            // Re-render
            renderCurrentView();
            showToast(` Field "${name}" added`);

            // Update field manager
            hideFieldManagerAddForm();
            renderFieldManagerList();
        }

        function renderSuperpositionCell(entries) {
            if (!Array.isArray(entries) || entries.length === 0) return '';

            const maxVisible = 3; // Show max 3 values in cell
            const visibleEntries = entries.slice(0, maxVisible);
            const hiddenCount = Math.max(0, entries.length - maxVisible);

            // Create badge for each visible entry
            const badges = visibleEntries
                .map(e => e?.val ?? '')
                .filter(Boolean)
                .map(val => `<span class="sup-value-badge">${val}</span>`)
                .join('');

            // Add "+N more" badge if there are hidden values
            const moreBadge = hiddenCount > 0
                ? `<span class="sup-count-badge">+${hiddenCount} more</span>`
                : '';

            // Tooltip showing all values
            const tooltip = entries
                .map(e => `${e?.val ?? ''}  ${e?.context?.source || 'observation'}`)
                .join('\n');

            return `<div class="sup-chip-container" title="${tooltip}">${badges}${moreBadge}</div>`;
        }

        // LEAN CONTEXT COMPARISON (Phase 2)
        function showQuickDiff(recordId, fieldId, event) {
            event?.stopPropagation();

            const set = getCurrentSet();
            if (!set || !state.leanContext) return;

            const record = set.records.get(recordId);
            const value = record?.[fieldId];

            if (!value?._sup || !value.value || value.value.length < 2) return;

            // Get contexts for comparison
            const contexts = value.value.slice(0, 2).map(() => state.leanContext.getFieldContext(record, fieldId));
            const diff = state.leanContext.explainContextDifference(contexts[0], contexts[1]);

            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black bg-opacity-20 flex items-center justify-center z-50';
            modal.onclick = (e) => e.target === modal && modal.remove();

            modal.innerHTML = `
                <div class="bg-white rounded-lg shadow-xl max-w-md p-4" onclick="event.stopPropagation()">
                    <div class="flex justify-between items-start mb-3">
                        <h4 class="font-semibold">Why Different?</h4>
                        <button onclick="this.closest('.fixed').remove()" class="text-gray-400 hover:text-gray-600"></button>
                    </div>
                    ${diff.diffs.length === 0 ? '<p class="text-gray-600">No significant differences found.</p>' : ''}
                    ${diff.diffs.map(d => `
                        <div class="text-sm mb-2">
                            <span class="font-medium">${d.label}:</span>
                            <div class="ml-4">
                                <div class="text-red-600">${d.a || '(not set)'}</div>
                                <div class="text-green-600">${d.b || '(not set)'}</div>
                            </div>
                        </div>
                    `).join('')}
                    <div class="mt-3 text-xs text-gray-600 border-t pt-2">
                        ${diff.compatible ? ' Can compare with caution' : ' Should not compare'}
                    </div>
                </div>
            `;

            document.body.appendChild(modal);
        }

        function getStabilityColor(tag) {
            const colors = {
                'emerging': 'yellow',
                'forming': 'gray',
                'stable': 'green'
            };
            return colors[tag] || 'gray';
        }

        // CARD VIEW
        function renderCardView() {
            const set = getCurrentSet();
            if (!set) return;

            const view = getCurrentView();
            let records = Array.from(set.records.values());
            if (view && view.filters.length > 0) records = applyFilterGroups(records, view.filters, set.schema);
            if (view?.sorts?.length) records = applySorts(records, view.sorts, set.schema);

            const stabilityToggle = state.leanContext ? `
                <label class="flex items-center gap-2 text-sm text-gray-700 bg-gray-50 border border-gray-200 px-3 py-2 rounded-lg">
                    <input type="checkbox" id="showStabilityToggle" ${view?.showStability ? 'checked' : ''}
                           onchange="toggleStabilityDisplay()">
                    <span>Show stability</span>
                </label>
            ` : '';

            const container = document.getElementById('viewContainer');
            container.innerHTML = `
                <div class="view-stage-header">
                    ${renderViewBreadcrumb()}
                    <div class="view-stage-title">
                        <span class="view-stage-pill">${set.name}</span>
                        <div class="min-w-0">
                            <div class="view-stage-name">${view.name}</div>
                            <div class="view-stage-sub">Card view  ${records.length} ${records.length === 1 ? 'record' : 'records'}</div>
                        </div>
                    </div>
                    ${renderViewActions(stabilityToggle)}
                </div>
                <div class="view-stage-body">
                    <div class="cards-grid" id="cardsGrid"></div>
                </div>`;

            const grid = document.getElementById('cardsGrid');
            records.forEach(record => {
                const card = document.createElement('div');
                card.className = 'card';
                card.onclick = () => openExpandedRecord(record.id);

                // Use the identifier field set for this view, or infer one
                const identifierFieldId = view.identifierField || inferIdentifierFieldId(set);
                const identifierField = set.schema.find(f => f.id === identifierFieldId) || set.schema[0];

                // Get display fields (all fields except the identifier and recordId)
                const displayFields = set.schema.filter(f => f.id !== identifierField.id && f.id !== '__recordId').slice(0, 5);

                // Create card header
                const header = document.createElement('div');
                header.className = 'flex items-start justify-between mb-2';

                const titleDiv = document.createElement('div');
                titleDiv.className = 'card-title';
                titleDiv.textContent = record[identifierField.id] || 'Untitled';
                header.appendChild(titleDiv);

                if (view?.showStability && state.leanContext) {
                    const badge = document.createElement('span');
                    badge.className = `badge badge-${getStabilityColor(state.leanContext.getRecordStability(record.id))} text-xs`;
                    badge.textContent = state.leanContext.getRecordStability(record.id);
                    header.appendChild(badge);
                }

                card.appendChild(header);

                // Create field elements with context menus
                displayFields.forEach(field => {
                    const value = record[field.id];
                    if (!value && value !== 0 && value !== false) return;

                    const fieldDiv = document.createElement('div');
                    fieldDiv.className = 'card-field';

                    const labelDiv = document.createElement('div');
                    labelDiv.className = 'card-field-label';
                    labelDiv.textContent = field.name;
                    labelDiv.style.cursor = 'context-menu';
                    labelDiv.title = 'Right-click for field options';
                    labelDiv.oncontextmenu = (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        showColumnMenu(e, field);
                    };

                    const valueDiv = document.createElement('div');
                    valueDiv.className = 'card-field-value';
                    valueDiv.innerHTML = renderCellValue(value, field, record);

                    fieldDiv.appendChild(labelDiv);
                    fieldDiv.appendChild(valueDiv);
                    card.appendChild(fieldDiv);
                });

                grid.appendChild(card);
            });

            finalizeViewStage();
        }

        function toggleStabilityDisplay() {
            const view = getCurrentView();
            if (!view) return;
            view.showStability = document.getElementById('showStabilityToggle')?.checked || false;
            renderCurrentView();
        }

        // KANBAN VIEW
        function renderKanbanView() {
            const set = getCurrentSet();
            const view = getCurrentView();
            if (!set || !view) return;

            const pickGroupingAction = `<button onclick="openKanbanConfig()" class="btn btn-secondary btn-sm">Pick grouping</button>`;
            const changeGroupingAction = `<button onclick="openKanbanConfig()" class="btn btn-secondary btn-sm">Change grouping</button>`;

            if (!view.kanbanGroupField) {
                const container = document.getElementById('viewContainer');
                container.innerHTML = `
                    <div class="view-stage-header">
                        ${renderViewBreadcrumb()}
                        <div class="view-stage-title">
                            <span class="view-stage-pill">${set.name}</span>
                            <div class="min-w-0">
                                <div class="view-stage-name">${view.name}</div>
                                <div class="view-stage-sub">Kanban view  Choose a grouping</div>
                            </div>
                        </div>
                        ${renderViewActions(pickGroupingAction)}
                    </div>
                    <div class="view-stage-body">
                        <div class="kanban-empty-state">
                            <div class="text-4xl mb-4"></div>
                            <p class="text-lg font-semibold mb-2">Configure Kanban Board</p>
                            <p class="mb-4">Select a single-select field to group your records</p>
                            <button onclick="openKanbanConfig()" class="btn btn-primary">Configure Kanban</button>
                        </div>
                    </div>
                `;
                finalizeViewStage();
                return;
            }
            
            const groupField = set.schema.find(f => f.id === view.kanbanGroupField);
            if (!groupField || groupField.type !== 'SELECT') {
                showToast(' Invalid kanban configuration');
                return;
            }
            
            let records = Array.from(set.records.values());
            if (view.filters.length > 0) records = applyFilterGroups(records, view.filters, set.schema);
            if (view?.sorts?.length) records = applySorts(records, view.sorts, set.schema);

            const recordCount = records.length;
            const recordLabel = recordCount === 1 ? 'record' : 'records';

            const container = document.getElementById('viewContainer');
            container.innerHTML = `
                <div class="view-stage-header">
                    ${renderViewBreadcrumb()}
                    <div class="view-stage-title">
                        <span class="view-stage-pill">${set.name}</span>
                        <div class="min-w-0">
                            <div class="view-stage-name">${view.name}</div>
                            <div class="view-stage-sub">Kanban view  ${groupField.name}  ${recordCount} ${recordLabel}</div>
                        </div>
                    </div>
                    ${renderViewActions(changeGroupingAction)}
                </div>
                <div class="view-stage-body">
                    <div class="kanban-board" id="kanbanBoard"></div>
                </div>
            `;

            const board = document.getElementById('kanbanBoard');
            const options = groupField.config.options || [];
            
            options.forEach(option => {
                const columnRecords = records.filter(r => r[groupField.id] === option);
                const column = createKanbanColumn(option, columnRecords, groupField);
                board.appendChild(column);
            });
            
            // Uncategorized column
            const uncategorized = records.filter(r => !r[groupField.id]);
            if (uncategorized.length > 0) {
                const column = createKanbanColumn('Uncategorized', uncategorized, groupField);
                board.appendChild(column);
            }

            finalizeViewStage();
        }

        function createKanbanColumn(title, records, groupField) {
            const column = document.createElement('div');
            column.className = 'kanban-column';
            column.dataset.value = title;
            
            const color = groupField.config?.colors?.[title] || 'gray';
            
            column.innerHTML = `
                <div class="kanban-column-header">
                    <div class="kanban-column-title">
                        <span class="badge badge-${color}">${title}</span>
                    </div>
                    <span class="kanban-column-count">${records.length}</span>
                </div>
                <div class="kanban-cards" data-column="${title}"></div>
            `;
            
            const cardsContainer = column.querySelector('.kanban-cards');
            
            // Enable drop
            cardsContainer.addEventListener('dragover', (e) => {
                e.preventDefault();
                column.classList.add('drag-over');
            });
            
            cardsContainer.addEventListener('dragleave', () => {
                column.classList.remove('drag-over');
            });
            
            cardsContainer.addEventListener('drop', (e) => {
                e.preventDefault();
                column.classList.remove('drag-over');
                
                if (state.draggedRecord) {
                    const newValue = title === 'Uncategorized' ? '' : title;
                    updateRecord(state.draggedRecord.id, groupField.id, newValue, state.draggedRecord[groupField.id]);
                    state.draggedRecord = null;
                    renderKanbanView();
                }
            });
            
            records.forEach(record => {
                const card = createKanbanCard(record);
                cardsContainer.appendChild(card);
            });
            
            return column;
        }

        function createKanbanCard(record) {
            const set = getCurrentSet();
            const view = getCurrentView();
            const card = document.createElement('div');
            card.className = 'kanban-card';
            card.draggable = true;
            card.dataset.recordId = record.id;

            // Use the identifier field set for this view, or infer one
            const identifierFieldId = view.identifierField || inferIdentifierFieldId(set);
            const identifierField = set.schema.find(f => f.id === identifierFieldId) || set.schema[0];

            // Get display fields (all fields except the identifier and recordId)
            const displayFields = set.schema.filter(f => f.id !== identifierField.id && f.id !== '__recordId').slice(0, 3);

            // Create card title
            const titleDiv = document.createElement('div');
            titleDiv.className = 'font-semibold mb-2';
            titleDiv.textContent = record[identifierField.id] || 'Untitled';
            card.appendChild(titleDiv);

            // Create field elements with context menus
            displayFields.forEach(field => {
                const value = record[field.id];
                if (!value && value !== 0 && value !== false) return;

                const fieldDiv = document.createElement('div');
                fieldDiv.className = 'text-sm text-gray-600 mb-1';

                const labelSpan = document.createElement('span');
                labelSpan.textContent = field.name + ': ';
                labelSpan.style.fontWeight = '500';
                labelSpan.style.cursor = 'context-menu';
                labelSpan.title = 'Right-click for field options';
                labelSpan.oncontextmenu = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    showColumnMenu(e, field);
                };

                const valueSpan = document.createElement('span');
                valueSpan.innerHTML = renderCellValue(value, field, record);

                fieldDiv.appendChild(labelSpan);
                fieldDiv.appendChild(valueSpan);
                card.appendChild(fieldDiv);
            });

            card.addEventListener('dragstart', (e) => {
                state.draggedRecord = record;
                card.classList.add('dragging');
            });

            card.addEventListener('dragend', () => {
                card.classList.remove('dragging');
            });
            
            card.onclick = (e) => {
                if (!card.classList.contains('dragging')) {
                    openExpandedRecord(record.id);
                }
            };
            
            return card;
        }

        function openKanbanConfig() {
            const set = getCurrentSet();
            const select = document.getElementById('kanbanGroupField');
            select.innerHTML = '<option value="">Select a field...</option>';
            
            set.schema.forEach(field => {
                if (field.type === 'SELECT') {
                    select.innerHTML += `<option value="${field.id}">${field.name}</option>`;
                }
            });
            
            const view = getCurrentView();
            if (view.kanbanGroupField) {
                select.value = view.kanbanGroupField;
            }
            
            openModal('kanbanConfigModal');
        }

        function saveKanbanConfig() {
            const fieldId = document.getElementById('kanbanGroupField').value;
            if (!fieldId) {
                showConfirm('Please select a field to group by', () => {});
                return;
            }

            const view = getCurrentView();
            view.kanbanGroupField = fieldId;

            closeModal('kanbanConfigModal');
            renderKanbanView();
            showToast(' Kanban configured');
        }

        // ENTITIES
        // Helper functions to get child objects for each entity type
        function getChildrenForRecord(recordId) {
            const record = getRecordById(recordId);
            if (!record) return null;

            const set = record.set;
            const fields = set?.schema || [];
            const outgoingConnections = getConnectionView(c => c.subject?.id === recordId);
            const incomingConnections = getConnectionView(c => c.operand?.id === recordId);
            const definitions = getDefinitionView(d => d.entity?.type === 'Record' && d.entity?.id === recordId);
            const derivedViews = getEntityView(e => e.type === 'ViewEntity' && e.memberRefs?.some(ref => ref.id === recordId));

            return { fields, outgoingConnections, incomingConnections, definitions, derivedViews, record, set };
        }

        function getChildrenForSet(setId) {
            const set = state.sets.get(setId);
            if (!set) return null;

            const records = Array.from(set.records.values()).map(r => ({ ...r, setId, setName: set.name }));
            const fields = set.schema || [];
            const views = Array.from(set.views.values());
            const definitions = getDefinitionView(d => d.entity?.type === 'Set' && d.entity?.id === setId);
            const connections = getConnectionView(c =>
                (c.subject?.type === 'Set' && c.subject?.id === setId) ||
                (c.operand?.type === 'Set' && c.operand?.id === setId)
            );
            const viewEntities = getEntityView(e => e.type === 'ViewEntity' && e.viewRef?.setId === setId);

            return { records, fields, views, definitions, connections, viewEntities, set };
        }

        function getChildrenForField(fieldId, setId) {
            const set = state.sets.get(setId);
            if (!set) return null;

            const field = set.schema.find(f => f.id === fieldId);
            if (!field) return null;

            const records = Array.from(set.records.values()).map(r => ({ id: r.id, value: r[fieldId] }));
            const definitions = getDefinitionView(d => d.entity?.type === 'Field' && d.entity?.id === fieldId);

            return { field, records, definitions, set };
        }

        function getChildrenForConnection(connectionId) {
            const connection = state.connections.get(connectionId);
            if (!connection) return null;

            const relation = connection.relationId ? state.connectionRelations.get(connection.relationId) : null;
            const subjectEntity = state.entities.get(connection.subject?.id);
            const operandEntity = state.entities.get(connection.operand?.id);
            const definitions = getDefinitionView(d => d.entity?.type === 'Connection' && d.entity?.id === connectionId);

            return { connection, relation, subjectEntity, operandEntity, definitions };
        }

        function getChildrenForViewEntity(viewEntityId) {
            const viewEntity = state.entities.get(viewEntityId);
            if (!viewEntity) return null;

            const viewRef = viewEntity.viewRef;
            const set = viewRef?.setId ? state.sets.get(viewRef.setId) : null;
            const view = set && viewRef?.viewId ? set.views.get(viewRef.viewId) : null;
            const memberRefs = viewEntity.memberRefs || [];
            const lineageConnections = getConnectionView(c => c.operand?.id === viewEntityId);
            const definitions = getDefinitionView(d => d.entity?.type === 'ViewEntity' && d.entity?.id === viewEntityId);

            return { viewEntity, set, view, memberRefs, lineageConnections, definitions };
        }

        function getChildrenForDefinition(definitionId) {
            const definition = state.definitions.get(definitionId);
            if (!definition) return null;

            const targetEntity = definition.entity ? state.entities.get(definition.entity.id) : null;

            return { definition, targetEntity };
        }

        function groupEntitiesByType(entities = []) {
            const groups = new Map();
            entities.forEach(entity => {
                const key = entity.entityType || entity.type || 'Unknown';
                if (!groups.has(key)) groups.set(key, []);
                groups.get(key).push(entity);
            });
            return groups;
        }

        function renderEntityMembership(entity) {
            if (!entity?.memberRefs?.length) return '';
            const preview = entity.memberRefs.slice(0, 3)
                .map(ref => renderEntityLabel(ref))
                .join(', ');
            const remaining = entity.memberRefs.length > 3 ? ` +${entity.memberRefs.length - 3} more` : '';
            return `
                <div class="mt-2 text-xs text-gray-600 bg-gray-50 border border-gray-200 rounded-md px-3 py-2">
                    <div class="font-semibold text-gray-800 flex items-center gap-1">
                        <i class="ph ph-tree-structure"></i>
                        Entity table  ${entity.memberRefs.length} items
                    </div>
                    <div class="mt-1 text-gray-500">${preview}${remaining}</div>
                </div>
            `;
        }

        // Render child tables for expanded entities
        function renderChildTable(title, icon, items, renderItem) {
            if (!items || items.length === 0) return '';
            return `
                <div class="mt-2 bg-white border border-gray-200 rounded-md overflow-hidden">
                    <div class="px-3 py-2 bg-gray-50 border-b border-gray-200 flex items-center gap-2">
                        <i class="ph ${icon} text-gray-600"></i>
                        <span class="text-xs font-semibold text-gray-700">${title} (${items.length})</span>
                    </div>
                    <div class="p-2 space-y-1 max-h-60 overflow-y-auto">
                        ${items.map(renderItem).join('')}
                    </div>
                </div>
            `;
        }

        function renderRecordChildren(recordId) {
            const children = getChildrenForRecord(recordId);
            if (!children) return '<p class="text-xs text-gray-500 mt-2">Record not found</p>';

            const { fields, outgoingConnections, incomingConnections, definitions, derivedViews, set } = children;

            return `
                <div class="mt-3 space-y-2 pl-4 border-l-2 border-blue-200">
                    <div class="text-xs text-gray-600 flex items-center gap-1 mb-2">
                        <i class="ph ph-fingerprint"></i>
                        <strong>ID:</strong>
                        <span class="font-mono">${recordId}</span>
                    </div>
                    ${set ? `<div class="text-xs text-gray-600"><strong>Set:</strong> ${set.name}</div>` : ''}
                    ${renderChildTable('Fields', 'ph-columns', fields, field => `
                        <div class="text-xs px-2 py-1 hover:bg-gray-50 rounded flex items-center justify-between">
                            <span><strong>${field.name}</strong></span>
                            <span class="text-gray-500">${field.type}</span>
                        </div>
                    `)}
                    ${renderChildTable('Outgoing Relationships', 'ph-arrow-right', outgoingConnections, conn => `
                        <div class="text-xs px-2 py-1 hover:bg-gray-50 rounded">
                            ${renderEntityLabel(conn.subject)} ${conn.mode || ''} ${renderEntityLabel(conn.operand)}
                        </div>
                    `)}
                    ${renderChildTable('Incoming Relationships', 'ph-arrow-left', incomingConnections, conn => `
                        <div class="text-xs px-2 py-1 hover:bg-gray-50 rounded">
                            ${renderEntityLabel(conn.subject)} ${conn.mode || ''} ${renderEntityLabel(conn.operand)}
                        </div>
                    `)}
                    ${renderChildTable('Definitions', 'ph-book-open', definitions, def => `
                        <div class="text-xs px-2 py-1 hover:bg-gray-50 rounded">
                            <strong>${def.term}:</strong> ${def.definition}
                        </div>
                    `)}
                    ${renderChildTable('Derived Views', 'ph-eye', derivedViews, view => `
                        <div class="text-xs px-2 py-1 hover:bg-gray-50 rounded">
                            ${renderEntityLabel(view)}
                        </div>
                    `)}
                </div>
            `;
        }

        function renderSetChildren(setId) {
            const children = getChildrenForSet(setId);
            if (!children) return '<p class="text-xs text-gray-500 mt-2">Set not found</p>';

            const { records, fields, views, definitions, connections, viewEntities } = children;

            return `
                <div class="mt-3 space-y-2 pl-4 border-l-2 border-green-200">
                    <div class="text-xs text-gray-600 flex items-center gap-1 mb-2">
                        <i class="ph ph-fingerprint"></i>
                        <strong>ID:</strong>
                        <span class="font-mono">${setId}</span>
                    </div>
                    ${renderChildTable('Records', 'ph-database', records.slice(0, 20), record => `
                        <div class="text-xs px-2 py-1 hover:bg-gray-50 rounded">
                            ${getRecordDisplayName(record.id) || 'Record'}
                        </div>
                    `)}
                    ${records.length > 20 ? `<div class="text-xs text-gray-500 px-2">... and ${records.length - 20} more records</div>` : ''}
                    ${renderChildTable('Fields', 'ph-columns', fields, field => `
                        <div class="text-xs px-2 py-1 hover:bg-gray-50 rounded flex items-center justify-between">
                            <span><strong>${field.name}</strong></span>
                            <span class="text-gray-500">${field.type}</span>
                        </div>
                    `)}
                    ${renderChildTable('Views', 'ph-stack', views, view => `
                        <div class="text-xs px-2 py-1 hover:bg-gray-50 rounded flex items-center justify-between">
                            <span>${view.name}</span>
                            <span class="text-gray-500">${view.type}</span>
                        </div>
                    `)}
                    ${renderChildTable('Relationships', 'ph-git-branch', connections, conn => `
                        <div class="text-xs px-2 py-1 hover:bg-gray-50 rounded">
                            ${renderEntityLabel(conn.subject)} ${conn.mode || ''} ${renderEntityLabel(conn.operand)}
                        </div>
                    `)}
                    ${renderChildTable('View Entities', 'ph-eye', viewEntities, ve => `
                        <div class="text-xs px-2 py-1 hover:bg-gray-50 rounded">
                            ${renderEntityLabel(ve)}
                        </div>
                    `)}
                    ${renderChildTable('Definitions', 'ph-book-open', definitions, def => `
                        <div class="text-xs px-2 py-1 hover:bg-gray-50 rounded">
                            <strong>${def.term}:</strong> ${def.definition}
                        </div>
                    `)}
                </div>
            `;
        }

        function renderConnectionChildren(connectionId) {
            const children = getChildrenForConnection(connectionId);
            if (!children) return '<p class="text-xs text-gray-500 mt-2">Connection not found</p>';

            const { connection, relation, subjectEntity, operandEntity, definitions } = children;

            return `
                <div class="mt-3 space-y-2 pl-4 border-l-2 border-purple-200">
                    <div class="text-xs text-gray-600 flex items-center gap-1 mb-2">
                        <i class="ph ph-fingerprint"></i>
                        <strong>ID:</strong>
                        <span class="font-mono">${connectionId}</span>
                    </div>
                    <div class="text-xs space-y-1">
                        ${relation ? `<div><strong>Relation:</strong> ${relation.name || relation.id}</div>` : ''}
                        <div><strong>Subject:</strong> ${renderEntityLabel(connection.subject)}</div>
                        <div><strong>Operator:</strong> ${connection.operator || connection.mode || ''}</div>
                        <div><strong>Operand:</strong> ${renderEntityLabel(connection.operand)}</div>
                        ${connection.params && Object.keys(connection.params).length > 0 ? `
                            <div class="mt-2">
                                <strong>Parameters:</strong>
                                <pre class="mt-1 p-2 bg-gray-50 rounded text-xs overflow-x-auto">${JSON.stringify(connection.params, null, 2)}</pre>
                            </div>
                        ` : ''}
                    </div>
                    ${renderChildTable('Definitions', 'ph-book-open', definitions, def => `
                        <div class="text-xs px-2 py-1 hover:bg-gray-50 rounded">
                            <strong>${def.term}:</strong> ${def.definition}
                        </div>
                    `)}
                </div>
            `;
        }

        function renderViewEntityChildren(viewEntityId) {
            const children = getChildrenForViewEntity(viewEntityId);
            if (!children) return '<p class="text-xs text-gray-500 mt-2">View entity not found</p>';

            const { viewEntity, set, view, memberRefs, lineageConnections, definitions } = children;

            return `
                <div class="mt-3 space-y-2 pl-4 border-l-2 border-indigo-200">
                    <div class="text-xs text-gray-600 flex items-center gap-1 mb-2">
                        <i class="ph ph-fingerprint"></i>
                        <strong>ID:</strong>
                        <span class="font-mono">${viewEntityId}</span>
                    </div>
                    <div class="text-xs space-y-1">
                        ${set ? `<div><strong>Source Set:</strong> ${set.name}</div>` : ''}
                        ${view ? `<div><strong>Source View:</strong> ${view.name} (${view.type})</div>` : ''}
                        ${viewEntity.viewRef ? `<div class="text-gray-600">View Ref: ${viewEntity.viewRef.setId} / ${viewEntity.viewRef.viewId}</div>` : ''}
                    </div>
                    ${renderChildTable('Members', 'ph-users', memberRefs, ref => `
                        <div class="text-xs px-2 py-1 hover:bg-gray-50 rounded">
                            ${renderEntityLabel(ref)}
                        </div>
                    `)}
                    ${renderChildTable('Lineage Relationships', 'ph-git-branch', lineageConnections, conn => `
                        <div class="text-xs px-2 py-1 hover:bg-gray-50 rounded">
                            ${renderEntityLabel(conn.subject)} ${conn.mode || ''} ${renderEntityLabel(conn.operand)}
                        </div>
                    `)}
                    ${renderChildTable('Definitions', 'ph-book-open', definitions, def => `
                        <div class="text-xs px-2 py-1 hover:bg-gray-50 rounded">
                            <strong>${def.term}:</strong> ${def.definition}
                        </div>
                    `)}
                </div>
            `;
        }

        function renderDefinitionChildren(definitionId) {
            const children = getChildrenForDefinition(definitionId);
            if (!children) return '<p class="text-xs text-gray-500 mt-2">Definition not found</p>';

            const { definition, targetEntity } = children;

            return `
                <div class="mt-3 space-y-2 pl-4 border-l-2 border-yellow-200">
                    <div class="text-xs text-gray-600 flex items-center gap-1 mb-2">
                        <i class="ph ph-fingerprint"></i>
                        <strong>ID:</strong>
                        <span class="font-mono">${definitionId}</span>
                    </div>
                    <div class="text-xs space-y-1">
                        <div><strong>Term:</strong> ${definition.term}</div>
                        <div><strong>Definition:</strong> ${definition.definition}</div>
                        ${definition.notes ? `<div><strong>Notes:</strong> ${definition.notes}</div>` : ''}
                        ${definition.tags?.length > 0 ? `<div><strong>Tags:</strong> ${definition.tags.join(', ')}</div>` : ''}
                        ${targetEntity ? `<div class="mt-2"><strong>Target Entity:</strong> ${renderEntityLabel(targetEntity)}</div>` : ''}
                    </div>
                </div>
            `;
        }

        function renderChildTables(entity) {
            const entityType = (entity.type || '').toLowerCase();

            switch (entityType) {
                case 'record':
                    return renderRecordChildren(entity.id);
                case 'set':
                    return renderSetChildren(entity.id);
                case 'connection':
                    return renderConnectionChildren(entity.id);
                case 'viewentity':
                    return renderViewEntityChildren(entity.id);
                case 'definition':
                    return renderDefinitionChildren(entity.id);
                default:
                    return '';
            }
        }

        function renderEntityGroups(groupMap) {
            if (!groupMap?.size) return '<p class="text-sm text-gray-500">No entities yet. Reify a view or add one manually.</p>';

            return Array.from(groupMap.entries()).map(([groupKey, entities]) => {
                const reifiedCount = entities.filter(e => e.origin === 'reified').length;
                const manualCount = entities.filter(e => e.origin === 'manual').length;
                return `
                    <div class="border border-gray-200 rounded-lg p-4 bg-white shadow-sm">
                        <div class="flex items-start justify-between gap-3">
                            <div>
                                <div class="text-xs font-semibold uppercase tracking-wide text-gray-500">${groupKey}</div>
                                <div class="text-lg font-semibold text-gray-900">${entities.length} entr${entities.length === 1 ? 'y' : 'ies'}</div>
                                <div class="text-sm text-gray-500">${reifiedCount} reified  ${manualCount} direct</div>
                            </div>
                            <div class="text-right text-xs text-gray-500 leading-tight">
                                <div>Tracked in ${getWorld()?.name || 'world'}</div>
                                <div>Last updated ${new Date(Math.max(...entities.map(e => e.updatedAt || e.createdAt || Date.now()))).toLocaleString()}</div>
                            </div>
                        </div>
                        <div class="mt-3 space-y-2">
                            ${entities.map(entity => `
                                <div class="border border-gray-100 rounded-md p-3 bg-gray-50">
                                    <div class="flex items-center justify-between gap-2">
                                        <div class="min-w-0">
                                            <div class="text-sm font-semibold text-gray-800 truncate">${renderEntityLabel(entity)}</div>
                                            <div class="text-xs text-gray-500 flex flex-wrap items-center gap-2">
                                                <span class="inline-flex items-center gap-1"><i class="ph ph-tag"></i>${entity.type}</span>
                                                ${entity.origin ? `<span class="inline-flex items-center gap-1"><i class="ph ph-compass"></i>${entity.origin}</span>` : ''}
                                                ${entity.viewRef ? `<span class="inline-flex items-center gap-1 text-blue-600"><i class="ph ph-eye"></i>View: ${entity.viewRef.viewName || entity.viewRef.viewId}</span>` : ''}
                                            </div>
                                        </div>
                                        <div class="flex items-center gap-2 text-xs">
                                            ${entity.origin === 'manual' ? `<button class="text-red-500" data-entity-delete="${entity.id}">Delete</button>` : `<span class="text-gray-400" title="Reified entities are protected">Protected</span>`}
                                        </div>
                                    </div>
                                    ${renderEntityMembership(entity)}
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
            }).join('');
        }

        function resetEntityForm() {
            const form = document.getElementById('entityForm');
            if (!form) return;
            form.reset();
            state.entityFormState.editingId = null;
        }

        function handleEntityFormSubmit() {
            const form = document.getElementById('entityForm');
            if (!form) return;

            const id = form.querySelector('#entityId')?.value.trim();
            const type = form.querySelector('#entityKind')?.value.trim();
            const entityType = form.querySelector('#entityType')?.value.trim();
            const label = form.querySelector('#entityLabel')?.value.trim();
            const notes = form.querySelector('#entityNotes')?.value.trim();

            if (!id || !type) {
                showToast('Please provide both an entity id and type');
                return;
            }

            registerEntity({
                id,
                type,
                entityType: entityType || type,
                name: label || undefined,
                notes,
                origin: 'manual',
                createdAt: new Date().toISOString(),
                updatedAt: new Date().toISOString(),
                worldId: state.currentWorldId
            });

            showToast(' Entity captured');
            resetEntityForm();
            renderEntitiesPage(state.entityFormState.activeFilter || 'all');
        }

        function renderEntitiesPage(selectedType = null) {
            // Clean up any orphaned record entities first
            cleanupOrphanedEntities();

            // Tier 1: Entity Type Selection with full class names for Tailwind
            const entityTypes = [
                {
                    key: 'set',
                    label: 'Sets',
                    icon: 'ph-squares-four',
                    iconClass: 'text-green-600',
                    activeBorder: 'border-green-500',
                    activeBg: 'bg-green-50',
                    activeText: 'text-green-900',
                    activeCount: 'text-green-700'
                },
                {
                    key: 'record',
                    label: 'Records',
                    icon: 'ph-database',
                    iconClass: 'text-blue-600',
                    activeBorder: 'border-blue-500',
                    activeBg: 'bg-blue-50',
                    activeText: 'text-blue-900',
                    activeCount: 'text-blue-700'
                },
                {
                    key: 'connection',
                    label: 'Relationships',
                    icon: 'ph-git-branch',
                    iconClass: 'text-purple-600',
                    activeBorder: 'border-purple-500',
                    activeBg: 'bg-purple-50',
                    activeText: 'text-purple-900',
                    activeCount: 'text-purple-700'
                },
                {
                    key: 'viewentity',
                    label: 'Views',
                    icon: 'ph-eye',
                    iconClass: 'text-indigo-600',
                    activeBorder: 'border-indigo-500',
                    activeBg: 'bg-indigo-50',
                    activeText: 'text-indigo-900',
                    activeCount: 'text-indigo-700'
                },
                {
                    key: 'definition',
                    label: 'Definitions',
                    icon: 'ph-book-open',
                    iconClass: 'text-yellow-600',
                    activeBorder: 'border-yellow-500',
                    activeBg: 'bg-yellow-50',
                    activeText: 'text-yellow-900',
                    activeCount: 'text-yellow-700'
                }
            ];

            // Set default selected type
            if (!selectedType) {
                selectedType = state.entityFormState.selectedType || 'set';
            }
            state.entityFormState.selectedType = selectedType;

            // Get all entities and filter by selected type
            const allEntities = getEntityView();
            // Filter by type and also validate that records actually exist in their sets
            const filteredEntities = allEntities.filter(e => {
                const entityType = (e.type || '').toLowerCase();
                if (entityType !== selectedType.toLowerCase()) return false;
                // For records, validate they still exist in a set (not orphaned)
                if (entityType === 'record') {
                    return getRecordById(e.id) !== null;
                }
                return true;
            });

            // Stats
            const totalCount = allEntities.length;
            const typeCount = filteredEntities.length;
            const reifiedCount = filteredEntities.filter(e => e.origin === 'reified').length;
            const manualCount = filteredEntities.filter(e => e.origin === 'manual').length;

            const container = document.getElementById('viewContainer');

            // Tier 2 & 3: Render entity list with expandable rows
            const renderEntityRow = (entity) => {
                const isExpanded = state.entityFormState.expandedEntities.has(entity.id);
                const entityTypeInfo = entityTypes.find(t => t.key === selectedType) || entityTypes[0];

                return `
                    <div class="border border-gray-200 rounded-lg bg-white shadow-sm hover:shadow-md transition-shadow">
                        <div class="p-4 cursor-pointer" data-entity-expand="${entity.id}">
                            <div class="flex items-center justify-between gap-3">
                                <div class="flex items-center gap-3 min-w-0 flex-1">
                                    <div class="flex-shrink-0">
                                        <i class="ph ${entityTypeInfo.icon} ${entityTypeInfo.iconClass} text-xl"></i>
                                    </div>
                                    <div class="min-w-0 flex-1">
                                        <div class="font-semibold text-gray-900 truncate">${renderEntityLabel(entity)}</div>
                                        <div class="text-xs text-gray-500 flex flex-wrap items-center gap-2 mt-1">
                                            ${entity.origin ? `
                                                <span class="inline-flex items-center gap-1 px-2 py-0.5 rounded-full ${entity.origin === 'reified' ? 'bg-blue-100 text-blue-700' : 'bg-gray-100 text-gray-700'}">
                                                    ${entity.origin}
                                                </span>
                                            ` : ''}
                                            ${entity.createdAt ? `
                                                <span class="inline-flex items-center gap-1">
                                                    <i class="ph ph-clock"></i>${new Date(entity.createdAt).toLocaleDateString()}
                                                </span>
                                            ` : ''}
                                        </div>
                                    </div>
                                </div>
                                <div class="flex items-center gap-2 flex-shrink-0">
                                    ${entity.origin === 'manual' ? `
                                        <button class="btn btn-secondary btn-sm text-red-600 hover:bg-red-50" data-entity-delete="${entity.id}" onclick="event.stopPropagation()">
                                            <i class="ph ph-trash"></i>
                                        </button>
                                    ` : `
                                        <span class="text-xs text-gray-400 px-2 py-1 bg-gray-50 rounded" title="Reified entities are protected">
                                            <i class="ph ph-lock"></i>
                                        </span>
                                    `}
                                    <button class="text-gray-400 hover:text-gray-600 transition-transform ${isExpanded ? 'rotate-180' : ''}" onclick="event.stopPropagation()">
                                        <i class="ph ph-caret-down text-xl"></i>
                                    </button>
                                </div>
                            </div>
                        </div>
                        ${isExpanded ? `
                            <div class="border-t border-gray-200 p-4 bg-gray-50">
                                ${renderChildTables(entity)}
                            </div>
                        ` : ''}
                    </div>
                `;
            };

            container.innerHTML = `
                <div class="view-stage-header">
                    <div class="view-stage-title">
                        <span class="view-stage-pill">${getWorld()?.name || 'Entities'}</span>
                        <div class="min-w-0">
                            <div class="view-stage-name">Entity Navigator</div>
                            <div class="view-stage-sub">${totalCount} total  ${typeCount} ${selectedType}${typeCount !== 1 ? 's' : ''}</div>
                        </div>
                    </div>
                </div>
                <div class="view-stage-body space-y-6">
                    <!-- Tier 1: Entity Type Selector -->
                    <div class="space-y-3">
                        <div class="flex items-center justify-between gap-3">
                            <div class="space-y-1">
                                <div class="font-semibold text-gray-900">Entity Types</div>
                                <p class="text-sm text-gray-500">Browse entities organized by type</p>
                            </div>
                        </div>
                        <div class="grid grid-cols-2 md:grid-cols-5 gap-3">
                            ${entityTypes.map(type => {
                                const count = allEntities.filter(e => (e.type || '').toLowerCase() === type.key).length;
                                const isActive = selectedType === type.key;
                                return `
                                    <button
                                        class="p-4 rounded-lg border-2 ${isActive ? `${type.activeBorder} ${type.activeBg}` : 'border-gray-200 bg-white hover:border-gray-300'} transition-all"
                                        data-entity-type="${type.key}"
                                    >
                                        <div class="flex flex-col items-center gap-2">
                                            <i class="ph ${type.icon} text-2xl ${isActive ? type.iconClass : 'text-gray-600'}"></i>
                                            <div class="text-sm font-semibold ${isActive ? type.activeText : 'text-gray-900'}">${type.label}</div>
                                            <div class="text-xl font-bold ${isActive ? type.activeCount : 'text-gray-700'}">${count}</div>
                                        </div>
                                    </button>
                                `;
                            }).join('')}
                        </div>
                    </div>

                    <!-- Statistics Cards -->
                    <div class="grid grid-cols-1 md:grid-cols-3 gap-3">
                        <div class="p-4 rounded-lg border border-gray-200 bg-white shadow-sm">
                            <div class="text-xs font-semibold uppercase tracking-wide text-gray-500">Total</div>
                            <div class="text-2xl font-bold text-gray-900">${typeCount}</div>
                            <div class="text-xs text-gray-500">${selectedType}${typeCount !== 1 ? 's' : ''} in this world</div>
                        </div>
                        <div class="p-4 rounded-lg border border-gray-200 bg-white shadow-sm">
                            <div class="text-xs font-semibold uppercase tracking-wide text-gray-500">Reified</div>
                            <div class="text-2xl font-bold text-gray-900">${reifiedCount}</div>
                            <div class="text-xs text-gray-500">Made persistent from views</div>
                        </div>
                        <div class="p-4 rounded-lg border border-gray-200 bg-white shadow-sm">
                            <div class="text-xs font-semibold uppercase tracking-wide text-gray-500">Manual</div>
                            <div class="text-2xl font-bold text-gray-900">${manualCount}</div>
                            <div class="text-xs text-gray-500">Added directly</div>
                        </div>
                    </div>

                    <!-- Tier 2 & 3: Entity List with Expandable Rows -->
                    <div class="space-y-2">
                        <div class="flex items-center justify-between">
                            <div class="font-semibold text-gray-900">${entityTypes.find(t => t.key === selectedType)?.label || 'Entities'}</div>
                            <div class="text-sm text-gray-500">${typeCount} item${typeCount !== 1 ? 's' : ''}</div>
                        </div>
                        ${filteredEntities.length > 0 ? `
                            <div class="space-y-2">
                                ${filteredEntities.map(renderEntityRow).join('')}
                            </div>
                        ` : `
                            <div class="p-8 text-center border-2 border-dashed border-gray-300 rounded-lg">
                                <i class="ph ph-package text-4xl text-gray-400 mb-2"></i>
                                <p class="text-gray-500">No ${selectedType}s found</p>
                                <p class="text-sm text-gray-400 mt-1">Create one to get started</p>
                            </div>
                        `}
                    </div>
                </div>
            `;

            // Event handlers for type selection
            document.querySelectorAll('[data-entity-type]').forEach(btn => {
                btn.onclick = () => renderEntitiesPage(btn.dataset.entityType);
            });

            // Event handlers for expanding/collapsing entities
            document.querySelectorAll('[data-entity-expand]').forEach(elem => {
                elem.onclick = () => {
                    const entityId = elem.dataset.entityExpand;
                    if (state.entityFormState.expandedEntities.has(entityId)) {
                        state.entityFormState.expandedEntities.delete(entityId);
                    } else {
                        state.entityFormState.expandedEntities.add(entityId);
                    }
                    renderEntitiesPage(selectedType);
                };
            });

            // Event handlers for deleting entities
            document.querySelectorAll('[data-entity-delete]').forEach(btn => {
                btn.onclick = (e) => {
                    e.stopPropagation();
                    deleteEntity(btn.dataset.entityDelete);
                    renderEntitiesPage(selectedType);
                    showToast(' Entity removed');
                };
            });
        }

        // GRAPH VIEW
        let graphNetwork = null;
        let graphConnectionState = {
            isConnecting: false,
            sourceNodeId: null,
            tempEdgeId: null
        };

        function renderGraphView() {
            const set = getCurrentSet();
            const view = getCurrentView();
            const definitions = getDefinitionView();
            const connections = getConnectionView();
            const entities = getEntityView();

            const container = document.getElementById('viewContainer');
            const nodeLabel = definitions.length === 1 ? 'node' : 'nodes';
            const edgeLabel = connections.length === 1 ? 'edge' : 'edges';

            container.innerHTML = `
                <div class="view-stage-header">
                    ${set ? renderViewBreadcrumb() : ''}
                    <div class="view-stage-title">
                        <span class="view-stage-pill">${getWorld()?.name || 'Graph'}</span>
                        <div class="min-w-0">
                            <div class="view-stage-name">${view?.name || 'Graph View'}</div>
                            <div class="view-stage-sub">${definitions.length} ${nodeLabel}  ${connections.length} ${edgeLabel}</div>
                        </div>
                    </div>
                    ${set ? renderViewActions() : ''}
                </div>
                <div class="view-stage-body">
                    <div class="graph-container" id="graphContainer" style="position: relative;">
                        <div class="graph-nav-controls" style="position: absolute; top: 10px; right: 10px; z-index: 10; display: flex; flex-direction: column; gap: 8px;">
                            <button id="graphZoomIn" class="graph-nav-btn" title="Zoom In" style="width: 36px; height: 36px; border: 1px solid #e5e7eb; background: white; border-radius: 6px; cursor: pointer; display: flex; align-items: center; justify-content: center; box-shadow: 0 2px 4px rgba(0,0,0,0.1); font-size: 18px; font-weight: bold; color: #374151;">+</button>
                            <button id="graphZoomOut" class="graph-nav-btn" title="Zoom Out" style="width: 36px; height: 36px; border: 1px solid #e5e7eb; background: white; border-radius: 6px; cursor: pointer; display: flex; align-items: center; justify-content: center; box-shadow: 0 2px 4px rgba(0,0,0,0.1); font-size: 18px; font-weight: bold; color: #374151;"></button>
                            <button id="graphFit" class="graph-nav-btn" title="Fit to View" style="width: 36px; height: 36px; border: 1px solid #e5e7eb; background: white; border-radius: 6px; cursor: pointer; display: flex; align-items: center; justify-content: center; box-shadow: 0 2px 4px rgba(0,0,0,0.1); font-size: 14px; color: #374151;"></button>
                        </div>
                    </div>
                </div>
            `;

            renderGraph(definitions, connections, entities);

            finalizeViewStage();
        }

        function getEntityDisplayName(entityType, entityId) {
            if (!entityType || !entityId) return 'Unknown';

            if (entityType === 'Record') {
                const displayName = getRecordDisplayName(entityId);
                if (displayName) return displayName;
                // Fall back to set name if available
                const ref = getRecordById(entityId);
                return ref?.set?.name || 'Record';
            } else if (entityType === 'Set') {
                const set = state.sets.get(entityId);
                return set?.name || 'Set';
            } else if (entityType === 'World') {
                const world = state.worlds.get(entityId);
                return world?.name || 'World';
            } else if (entityType === 'View') {
                // Try to find the view in sets from the current world
                for (const set of getSetsForWorld()) {
                    if (set.views.has(entityId)) {
                        return set.views.get(entityId)?.name || 'View';
                    }
                }
                return 'View';
            }

            return entityType || 'Entity';
        }

        function renderGraph(definitions, connections, entities = []) {
            const container = document.getElementById('graphContainer');
            if (!container) return;

            // Clean up previous network instance
            if (graphNetwork) {
                graphNetwork.destroy();
                graphNetwork = null;
            }

            // Reset connection state
            graphConnectionState = {
                isConnecting: false,
                sourceNodeId: null,
                tempEdgeId: null
            };

            // Define color scheme based on tags
            const getNodeStyle = (def) => {
                const tags = def.tags || [];
                const term = (def.term || '').toLowerCase();

                // Color by tag/entity type
                if (tags.includes('project') || term.includes('project')) {
                    return { color: '#4F46E5', shape: 'box', font: { color: '#FFFFFF' } }; // Indigo
                } else if (tags.includes('person') || term.includes('dr.') || term.includes('alex') || term.includes('jordan')) {
                    return { color: '#059669', shape: 'dot', size: 25, font: { color: '#000000' } }; // Green
                } else if (tags.includes('concept') || term.includes('observability') || term.includes('graph')) {
                    return { color: '#DC2626', shape: 'diamond', font: { color: '#FFFFFF' } }; // Red
                } else if (term.includes('task') || term.includes('design') || term.includes('implement') || term.includes('build') || term.includes('add') || term.includes('research')) {
                    return { color: '#EA580C', shape: 'ellipse', font: { color: '#FFFFFF' } }; // Orange
                } else {
                    return { color: '#6B7280', shape: 'dot', font: { color: '#000000' } }; // Gray
                }
            };

            // Build nodes from definitions
            const nodes = [];
            const nodeMap = new Map();
            const defMap = new Map();

            definitions.forEach(def => {
                const key = `${def.entity?.type}:${def.entity?.id}`;
                defMap.set(key, def);
                if (!nodeMap.has(key)) {
                    const displayName = getEntityDisplayName(def.entity?.type, def.entity?.id);
                    const label = def.term || displayName;
                    const style = getNodeStyle(def);
                    nodes.push({
                        id: key,
                        label: label,
                        title: def.definition || def.notes || label,
                        entityType: def.entity?.type,
                        entityId: def.entity?.id,
                        ...style
                    });
                    nodeMap.set(key, true);
                }
            });

            // Build edges from connections
            const edges = [];
            const edgeColorMap = {
                'OWN': '#059669',   // Green for ownership
                'ASG': '#3B82F6',   // Blue for assignment
                'SUB': '#8B5CF6',   // Purple for part-of
                'IMP': '#EC4899',   // Pink for implements
                'DEP': '#F59E0B',   // Amber for dependencies
                'REL': '#6B7280'    // Gray for relates
            };

            connections.forEach((conn, idx) => {
                const fromKey = `${conn.subject?.type}:${conn.subject?.id}`;
                const toKey = `${conn.operand?.type}:${conn.operand?.id}`;

                // Add nodes if they don't exist
                if (!nodeMap.has(fromKey)) {
                    const def = defMap.get(fromKey);
                    const displayName = getEntityDisplayName(conn.subject?.type, conn.subject?.id);
                    const style = def ? getNodeStyle(def) : { color: '#6B7280', shape: 'dot' };
                    nodes.push({
                        id: fromKey,
                        label: displayName,
                        entityType: conn.subject?.type,
                        entityId: conn.subject?.id,
                        ...style
                    });
                    nodeMap.set(fromKey, true);
                }
                if (!nodeMap.has(toKey)) {
                    const def = defMap.get(toKey);
                    const displayName = getEntityDisplayName(conn.operand?.type, conn.operand?.id);
                    const style = def ? getNodeStyle(def) : { color: '#6B7280', shape: 'dot' };
                    nodes.push({
                        id: toKey,
                        label: displayName,
                        entityType: conn.operand?.type,
                        entityId: conn.operand?.id,
                        ...style
                    });
                    nodeMap.set(toKey, true);
                }

                const edgeColor = edgeColorMap[conn.operator] || '#999999';
                edges.push({
                    id: `edge-${idx}`,
                    from: fromKey,
                    to: toKey,
                    label: conn.mode || conn.operator || '',
                    arrows: { to: { enabled: true, scaleFactor: 0.5 } },
                    color: { color: edgeColor, highlight: edgeColor },
                    font: { size: 12, align: 'middle', color: '#666666', background: '#FFFFFFCC' },
                    smooth: { type: 'continuous' }
                });
            });

            if (nodes.length === 0) {
                container.innerHTML = '<div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #999;">No graph data available</div>';
                return;
            }

            // Create network with enhanced options
            const data = {
                nodes: new vis.DataSet(nodes),
                edges: new vis.DataSet(edges)
            };

            const options = {
                autoResize: true,
                height: '100%',
                width: '100%',
                physics: {
                    enabled: true,
                    stabilization: {
                        enabled: true,
                        iterations: 200,
                        updateInterval: 25
                    },
                    barnesHut: {
                        gravitationalConstant: -8000,
                        centralGravity: 0.3,
                        springLength: 150,
                        springConstant: 0.04,
                        damping: 0.09,
                        avoidOverlap: 0.5
                    }
                },
                layout: {
                    improvedLayout: true,
                    hierarchical: false
                },
                nodes: {
                    borderWidth: 2,
                    borderWidthSelected: 3,
                    font: {
                        size: 14,
                        face: 'system-ui, -apple-system, sans-serif'
                    },
                    shadow: {
                        enabled: true,
                        color: 'rgba(0,0,0,0.2)',
                        size: 10,
                        x: 2,
                        y: 2
                    }
                },
                edges: {
                    width: 2,
                    selectionWidth: 3
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 200,
                    navigationButtons: false,
                    keyboard: true
                },
                manipulation: {
                    enabled: false
                }
            };

            graphNetwork = new vis.Network(container, data, options);

            // Setup navigation controls
            const zoomInBtn = document.getElementById('graphZoomIn');
            const zoomOutBtn = document.getElementById('graphZoomOut');
            const fitBtn = document.getElementById('graphFit');

            if (zoomInBtn) {
                zoomInBtn.onclick = () => {
                    const scale = graphNetwork.getScale();
                    graphNetwork.moveTo({ scale: scale * 1.2 });
                };
            }

            if (zoomOutBtn) {
                zoomOutBtn.onclick = () => {
                    const scale = graphNetwork.getScale();
                    graphNetwork.moveTo({ scale: scale * 0.8 });
                };
            }

            if (fitBtn) {
                fitBtn.onclick = () => {
                    graphNetwork.fit({ padding: 50, animation: { duration: 500, easingFunction: 'easeInOutQuad' } });
                };
            }

            // Click to open record detail or connect nodes
            graphNetwork.on('click', (params) => {
                if (params.nodes.length > 0) {
                    const clickedNodeId = params.nodes[0];
                    const clickedNode = data.nodes.get(clickedNodeId);

                    // If clicking on a Record node and not in connection mode, open record detail
                    if (clickedNode?.entityType === 'Record' && !graphConnectionState.isConnecting) {
                        openExpandedRecord(clickedNode.entityId);
                        return;
                    }

                    if (!graphConnectionState.isConnecting) {
                        // Start connection
                        graphConnectionState.isConnecting = true;
                        graphConnectionState.sourceNodeId = clickedNodeId;

                        // Highlight source node
                        graphNetwork.selectNodes([clickedNodeId]);
                        showToast('Click on another node to connect');
                    } else {
                        // Complete connection
                        const targetNodeId = clickedNodeId;

                        if (graphConnectionState.sourceNodeId === targetNodeId) {
                            showToast('Cannot connect a node to itself');
                            graphConnectionState.isConnecting = false;
                            graphConnectionState.sourceNodeId = null;
                            graphNetwork.unselectAll();
                            return;
                        }

                        // Get node data
                        const sourceNode = data.nodes.get(graphConnectionState.sourceNodeId);
                        const targetNode = data.nodes.get(targetNodeId);

                        if (sourceNode && targetNode) {
                            openGraphConnectionModal(sourceNode, targetNode);
                        }

                        // Reset state
                        graphConnectionState.isConnecting = false;
                        graphConnectionState.sourceNodeId = null;
                        graphNetwork.unselectAll();
                    }
                } else if (graphConnectionState.isConnecting) {
                    // Cancel connection if clicking on empty space
                    graphConnectionState.isConnecting = false;
                    graphConnectionState.sourceNodeId = null;
                    graphNetwork.unselectAll();
                    showToast('Cancelled');
                }
            });

            // Disable physics after stabilization
            graphNetwork.once('stabilizationIterationsDone', () => {
                graphNetwork.setOptions({ physics: false });
            });

            // Fit to view after stabilization
            graphNetwork.once('stabilizationIterationsDone', () => {
                setTimeout(() => {
                    graphNetwork.fit({ padding: 50, animation: { duration: 1000, easingFunction: 'easeInOutQuad' } });
                }, 100);
            });
        }

        function openGraphConnectionModal(sourceNode, targetNode) {
            const formats = getConnectionRelationView();

            // Pre-populate the connection modal with source and target
            resetConnectionForm();

            // Open a custom modal for selecting connection type
            const modalHtml = `
                <div id="graphConnectionModal" class="fixed inset-0 bg-black bg-opacity-20 modal-overlay flex items-center justify-center p-6 z-50">
                    <div class="bg-white rounded-lg shadow-xl max-w-md w-full modal-container">
                        <div class="modal-header">
                            <h2 class="text-xl font-bold text-gray-900">Create Connection</h2>
                            <button class="text-gray-400 hover:text-gray-600 transition" onclick="closeGraphConnectionModal()" aria-label="Close">
                                <i class="ph ph-x text-xl"></i>
                            </button>
                        </div>
                        <div class="modal-body">
                            <div class="mb-4">
                                <p class="text-sm text-gray-600 mb-2">From:</p>
                                <p class="font-semibold text-gray-900">${sourceNode.label}</p>
                                <p class="text-xs text-gray-500">${sourceNode.entityType}: ${sourceNode.entityId}</p>
                            </div>
                            <div class="mb-4">
                                <p class="text-sm text-gray-600 mb-2">To:</p>
                                <p class="font-semibold text-gray-900">${targetNode.label}</p>
                                <p class="text-xs text-gray-500">${targetNode.entityType}: ${targetNode.entityId}</p>
                            </div>
                            <div class="mb-4">
                                <label class="block text-sm font-medium text-gray-700 mb-2">Connection Type</label>
                                <select id="graphConnectionRelation" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                                    <option value="">Select a connection type...</option>
                                    ${formats.map(fmt => `<option value="${fmt.id}">${fmt.operator} - ${fmt.mode || 'No mode'}</option>`).join('')}
                                </select>
                            </div>
                            <div class="mb-4">
                                <label class="block text-sm font-medium text-gray-700 mb-2">Description (optional)</label>
                                <textarea id="graphConnectionDescription" rows="2" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"></textarea>
                            </div>
                        </div>
                        <div class="modal-footer flex gap-2 justify-end">
                            <button class="btn btn-secondary" type="button" onclick="closeGraphConnectionModal()">Cancel</button>
                            <button class="btn btn-primary" type="button" onclick="handleGraphConnectionSubmit('${sourceNode.entityType}', '${sourceNode.entityId}', '${targetNode.entityType}', '${targetNode.entityId}')">Create Connection</button>
                        </div>
                    </div>
                </div>
            `;

            // Remove any existing modal
            const existingModal = document.getElementById('graphConnectionModal');
            if (existingModal) existingModal.remove();

            // Add modal to page
            document.body.insertAdjacentHTML('beforeend', modalHtml);
        }

        function closeGraphConnectionModal() {
            const modal = document.getElementById('graphConnectionModal');
            if (modal) modal.remove();
        }

        function handleGraphConnectionSubmit(sourceType, sourceId, targetType, targetId) {
            const formatId = document.getElementById('graphConnectionRelation')?.value;
            const description = document.getElementById('graphConnectionDescription')?.value?.trim() || '';

            if (!formatId) {
                showToast('Please select a connection type');
                return;
            }

            const payload = {
                formatId,
                subject: { type: sourceType, id: sourceId },
                operand: { type: targetType, id: targetId },
                description,
                params: {}
            };

            try {
                addConnection(payload);
                showToast('Relationship created');
                closeGraphConnectionModal();

                // Refresh the graph view
                const definitions = getDefinitionView();
                const connections = getConnectionView();
                renderGraph(definitions, connections);
            } catch (error) {
                showToast(` ${error.message || 'Failed to create connection'}`);
            }
        }

        function serializeTagsInput(value) {
            return (value || '')
                .split(',')
                .map(tag => tag.trim())
                .filter(Boolean);
        }

        function parseDefinitionGridRows(text) {
            const lines = (text || '').split('\n').map(line => line.trim()).filter(Boolean);
            if (!lines.length) return [];

            const delimiter = lines.some(line => line.includes('\t')) ? '\t' : ',';
            const splitLine = (line) => line.split(delimiter).map(cell => cell.trim());
            const headerCells = splitLine(lines[0]).map(cell => cell.toLowerCase());
            const headerKeywords = ['entity type', 'entity id', 'term', 'definition'];
            const hasHeader = headerKeywords.some(keyword => headerCells.some(cell => cell.includes(keyword.replace(' ', '_')) || cell.includes(keyword)));
            const startIndex = hasHeader ? 1 : 0;

            const rows = [];
            for (let i = startIndex; i < lines.length; i++) {
                const cells = splitLine(lines[i]);
                if (!cells.length || cells.every(cell => !cell)) continue;
                const [entityType, entityId, term, definitionText, notes = '', tags = ''] = cells;
                rows.push({
                    entityType: entityType || '',
                    entityId: entityId || '',
                    term: term || '',
                    definition: definitionText || '',
                    notes: notes || '',
                    tags: serializeTagsInput(tags)
                });
            }

            return rows;
        }

        function handleDefinitionImportSubmit() {
            const textarea = document.getElementById('definitionImportText');
            if (!textarea) return;

            const rows = parseDefinitionGridRows(textarea.value);
            if (!rows.length) {
                showToast('Please paste at least one row');
                return;
            }

            let added = 0;
            let updated = 0;
            let skipped = 0;

            rows.forEach(row => {
                const entityType = row.entityType?.trim();
                const entityId = row.entityId?.trim();
                const term = row.term?.trim();
                const definitionText = row.definition?.trim();

                if (!entityType || !entityId || !term || !definitionText) {
                    skipped += 1;
                    return;
                }

                const payload = {
                    entity: { type: entityType, id: entityId },
                    term,
                    definition: definitionText,
                    notes: row.notes?.trim() || '',
                    tags: row.tags || []
                };

                const existing = findDefinitionByEntity(payload.entity);
                if (existing) {
                    updateDefinition(existing.id, payload);
                    updated += 1;
                } else {
                    addDefinition(payload);
                    added += 1;
                }
            });

            renderDefinitionsPage(state.definitionFormState.activeFilter || 'all');
            showToast(` Imported ${added + updated} definitions${updated ? ` (${updated} updated)` : ''}${skipped ? `  ${skipped} skipped` : ''}`);
        }

        function openDefinitionModal(definitionId = null) {
            resetDefinitionForm();
            if (definitionId) populateDefinitionForm(definitionId);
            openModal('definitionModal');

            // Attach form submit handler (in case it wasn't attached from renderDefinitionsPage)
            const form = document.getElementById('definitionForm');
            if (form) {
                form.onsubmit = (event) => {
                    event.preventDefault();
                    handleDefinitionFormSubmit();
                };
            }

            const entityTypeSelect = document.getElementById('definitionEntityType');
            if (entityTypeSelect) entityTypeSelect.focus();
        }

        function closeDefinitionModal() {
            closeModal('definitionModal');
        }

        function resetDefinitionForm() {
            state.definitionFormState.editingId = null;
            const form = document.getElementById('definitionForm');
            if (!form) return;
            form.reset();
            const submit = document.getElementById('definitionSubmit');
            if (submit) submit.textContent = 'Add Definition';
            const title = document.getElementById('definitionModalTitle');
            if (title) title.textContent = 'Add Definition';
        }

        function populateDefinitionForm(definitionId) {
            const def = state.definitions.get(definitionId);
            if (!def) return;
            const form = document.getElementById('definitionForm');
            if (!form) return;
            form.querySelector('#definitionEntityType').value = def.entity?.type || '';
            form.querySelector('#definitionEntityId').value = def.entity?.id || '';
            form.querySelector('#definitionTerm').value = def.term || '';
            form.querySelector('#definitionDefinition').value = def.definition || '';
            form.querySelector('#definitionNotes').value = def.notes || '';
            form.querySelector('#definitionTags').value = (def.tags || []).join(', ');
            const submit = document.getElementById('definitionSubmit');
            if (submit) submit.textContent = 'Save Definition';
            const title = document.getElementById('definitionModalTitle');
            if (title) title.textContent = 'Edit Definition';
            state.definitionFormState.editingId = def.id;
            openModal('definitionModal');
        }

        function handleDefinitionFormSubmit() {
            const form = document.getElementById('definitionForm');
            if (!form) return;
            const entityType = form.querySelector('#definitionEntityType').value;
            const entityId = form.querySelector('#definitionEntityId').value.trim();
            const term = form.querySelector('#definitionTerm').value.trim();
            const definitionText = form.querySelector('#definitionDefinition').value.trim();
            const notes = form.querySelector('#definitionNotes').value.trim();
            const tags = serializeTagsInput(form.querySelector('#definitionTags').value);

            if (!entityType || !entityId || !term || !definitionText) {
                showToast('Please complete entity, term, and definition');
                return;
            }

            const payload = {
                id: state.definitionFormState.editingId,
                entity: { type: entityType, id: entityId },
                term,
                definition: definitionText,
                notes,
                tags
            };

            if (state.definitionFormState.editingId) {
                updateDefinition(payload.id, payload);
                showToast(' Definition updated');
            } else {
                addDefinition(payload);
                showToast(' Definition added');
            }

            resetDefinitionForm();
            closeDefinitionModal();
            renderDefinitionsPage(state.definitionFormState.activeFilter || 'all');
        }

        function attachDefinitionInlineEditing() {
            document.querySelectorAll('[data-def-inline]').forEach(cell => {
                const [field, defId] = (cell.dataset.defInline || '').split(':');
                if (!field || !defId) return;

                const original = cell.textContent.trim();
                cell.contentEditable = 'true';
                cell.onfocus = () => cell.dataset.originalValue = cell.textContent.trim();
                cell.onkeydown = (event) => {
                    if (event.key === 'Enter') {
                        event.preventDefault();
                        cell.blur();
                    }
                };
                cell.onblur = () => {
                    const current = (cell.textContent || '').trim();
                    const baseline = cell.dataset.originalValue !== undefined ? cell.dataset.originalValue : original;
                    if (current === baseline) return;

                    const def = state.definitions.get(defId);
                    if (!def) return;
                    const updates = { ...def };
                    if (field === 'tags') {
                        updates.tags = current ? current.split(',').map(t => t.trim()).filter(Boolean) : [];
                    } else {
                        updates[field] = current;
                    }

                    updateDefinition(defId, updates);
                    showToast(' Definition updated');
                    renderDefinitionsPage(state.definitionFormState.activeFilter || 'all');
                };
            });
        }

        function renderDefinitionsTable(definitions) {
            if (!definitions.length) return '<p class="text-sm text-gray-500">No definitions yet.</p>';
            return `
                <div class="overflow-auto border border-gray-200 rounded-lg bg-white">
                    <table class="min-w-full text-sm">
                        <thead class="bg-gray-50">
                            <tr>
                                <th class="px-4 py-3 text-left text-xs font-semibold text-gray-500">Entity</th>
                                <th class="px-4 py-3 text-left text-xs font-semibold text-gray-500">Term</th>
                                <th class="px-4 py-3 text-left text-xs font-semibold text-gray-500">Definition</th>
                                <th class="px-4 py-3 text-left text-xs font-semibold text-gray-500">Notes</th>
                                <th class="px-4 py-3 text-left text-xs font-semibold text-gray-500">Tags</th>
                                <th class="px-4 py-3 text-left text-xs font-semibold text-gray-500">Actions</th>
                            </tr>
                        </thead>
                        <tbody class="divide-y divide-gray-200">
                            ${definitions.map(def => `
                                <tr>
                                    <td class="px-4 py-3 whitespace-nowrap text-gray-800">${def.entity.type}: ${renderEntityLabel(def.entity)}</td>
                                    <td class="px-4 py-3 font-semibold text-gray-900" data-def-inline="term:${def.id}">${def.term}</td>
                                    <td class="px-4 py-3 text-gray-700" data-def-inline="definition:${def.id}">${def.definition}</td>
                                    <td class="px-4 py-3 text-gray-500" data-def-inline="notes:${def.id}">${def.notes || ''}</td>
                                    <td class="px-4 py-3 text-gray-500" data-def-inline="tags:${def.id}">${(def.tags || []).join(', ')}</td>
                                    <td class="px-4 py-3 whitespace-nowrap space-x-3">
                                        <button class="text-blue-600" data-def-edit="${def.id}">Edit</button>
                                        <button class="text-red-500" data-def-delete="${def.id}">Delete</button>
                                    </td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                </div>
            `;
        }

        function renderDefinitionsPage(filterKey = 'all') {
            state.definitionFormState.activeFilter = filterKey;
            const filters = {
                all: () => true,
                records: def => def.entity?.type === 'Record',
                fields: def => def.entity?.type === 'Field',
                connections: def => def.entity?.type === 'Connection',
                viewEntities: def => def.entity?.type === 'ViewEntity',
                core: def => (def.tags || []).includes('core'),
                demo: def => (def.tags || []).includes('demo')
            };

            const definitions = getDefinitionView(filters[filterKey]);
            const container = document.getElementById('viewContainer');
            container.innerHTML = `
                <div class="view-stage-header">
                    <div class="view-stage-title">
                        <span class="view-stage-pill">${getWorld()?.name || 'World'}</span>
                        <div class="min-w-0">
                            <div class="view-stage-name">Definitions</div>
                            <div class="view-stage-sub">${definitions.length} entries</div>
                        </div>
                    </div>
                </div>
                <div class="view-stage-body space-y-4">
                    <div class="flex flex-wrap items-center justify-between gap-3">
                        <div class="flex flex-wrap gap-2">
                            ${Object.keys(filters).map(key => `<button class="btn btn-secondary btn-sm ${filterKey === key ? 'btn-primary' : ''}" data-def-filter="${key}">${key === 'all' ? 'All' : key.charAt(0).toUpperCase() + key.slice(1)}</button>`).join('')}
                        </div>
                        <div class="flex gap-2">
                            <button class="btn btn-secondary btn-sm" id="toggleDefinitionImport">${state.definitionFormState.showImportPanel ? 'Hide Import' : 'Import Definitions'}</button>
                            <button class="btn btn-primary btn-sm" id="openDefinitionModalBtn">Add Definition</button>
                        </div>
                    </div>
                    ${state.definitionFormState.showImportPanel ? `
                    <div class="border border-gray-200 rounded-lg bg-white p-4 space-y-3">
                        <div class="flex items-center justify-between">
                            <div>
                                <div class="font-semibold">Import definitions</div>
                                <p class="text-sm text-gray-500">Paste tab or comma separated rows: Entity Type, Entity ID, Term, Definition, Notes, Tags.</p>
                            </div>
                            <button class="btn btn-secondary btn-sm" id="closeDefinitionImport">Close</button>
                        </div>
                        <textarea id="definitionImportText" class="w-full border rounded px-3 py-2 text-sm font-mono" rows="5" placeholder="Record\tobs_123\tSnow depth\tDepth of snow in cm\tMetric reference\twinter, core"></textarea>
                        <div class="text-xs text-gray-500">Existing rows update matching entities; missing fields are skipped.</div>
                        <div class="flex justify-end">
                            <button class="btn btn-primary btn-sm" id="runDefinitionImport">Import pasted rows</button>
                        </div>
                    </div>
                    ` : ''}
                    ${renderDefinitionsTable(definitions)}
                </div>
            `;

            document.querySelectorAll('[data-def-filter]').forEach(btn => {
                btn.onclick = () => renderDefinitionsPage(btn.dataset.defFilter);
            });

            document.querySelectorAll('[data-def-edit]').forEach(btn => {
                btn.onclick = () => openDefinitionModal(btn.dataset.defEdit);
            });

            document.querySelectorAll('[data-def-delete]').forEach(btn => {
                btn.onclick = () => {
                    deleteDefinition(btn.dataset.defDelete);
                    renderDefinitionsPage(filterKey);
                    showToast(' Definition removed');
                };
            });

            const importToggleBtn = document.getElementById('toggleDefinitionImport');
            if (importToggleBtn) {
                importToggleBtn.onclick = () => {
                    state.definitionFormState.showImportPanel = !state.definitionFormState.showImportPanel;
                    renderDefinitionsPage(filterKey);
                };
            }

            const importCloseBtn = document.getElementById('closeDefinitionImport');
            if (importCloseBtn) {
                importCloseBtn.onclick = () => {
                    state.definitionFormState.showImportPanel = false;
                    renderDefinitionsPage(filterKey);
                };
            }

            const importRunBtn = document.getElementById('runDefinitionImport');
            if (importRunBtn) importRunBtn.onclick = handleDefinitionImportSubmit;

            const openModalBtn = document.getElementById('openDefinitionModalBtn');
            if (openModalBtn) openModalBtn.onclick = () => openDefinitionModal();

            const form = document.getElementById('definitionForm');
            if (form) form.onsubmit = (event) => { event.preventDefault(); handleDefinitionFormSubmit(); };

            attachDefinitionInlineEditing();
        }

        // ============================================================================
        // VIEWS PAGE
        // ============================================================================

        function renderViewsPage(filterType = 'all') {
            state.viewsPageState = state.viewsPageState || { activeFilter: 'all' };
            state.viewsPageState.activeFilter = filterType;

            const container = document.getElementById('viewContainer');
            if (!container) return;

            // Collect all views from all sets
            const allViews = [];
            const setsForWorld = getSetsForWorld();

            setsForWorld.forEach(set => {
                if (set.views && set.views.size > 0) {
                    set.views.forEach((viewRef, viewId) => {
                        // Get full view from global state if available
                        const fullView = state.views?.get(viewId) || viewRef;
                        allViews.push({
                            ...fullView,
                            id: viewId,
                            setId: set.id,
                            setName: set.name,
                            recordCount: set.records ? set.records.size : 0
                        });
                    });
                }
            });

            // Apply filter
            const filters = {
                all: () => true,
                grid: v => v.type === 'grid',
                card: v => v.type === 'card',
                kanban: v => v.type === 'kanban',
                graph: v => v.type === 'graph',
                KEY_DERIVED: v => v.type === 'KEY_DERIVED'
            };

            const filteredViews = allViews.filter(filters[filterType] || filters.all);

            // Sort by set name, then view name
            filteredViews.sort((a, b) => {
                if (a.setName !== b.setName) return a.setName.localeCompare(b.setName);
                return (a.name || '').localeCompare(b.name || '');
            });

            container.innerHTML = `
                <div class="view-stage-header">
                    <div class="view-stage-title">
                        <span class="view-stage-pill">${getWorld()?.name || 'World'}</span>
                        <div class="min-w-0">
                            <div class="view-stage-name">Views</div>
                            <div class="view-stage-sub">${filteredViews.length} view${filteredViews.length !== 1 ? 's' : ''}</div>
                        </div>
                    </div>
                </div>
                <div class="view-stage-body space-y-4">
                    <div class="flex flex-wrap items-center justify-between gap-3">
                        <div class="flex flex-wrap gap-2">
                            <button class="btn btn-secondary btn-sm ${filterType === 'all' ? 'btn-primary' : ''}" data-view-filter="all">All</button>
                            <button class="btn btn-secondary btn-sm ${filterType === 'grid' ? 'btn-primary' : ''}" data-view-filter="grid">
                                <i class="ph ph-table"></i> Grid
                            </button>
                            <button class="btn btn-secondary btn-sm ${filterType === 'card' ? 'btn-primary' : ''}" data-view-filter="card">
                                <i class="ph ph-cards-three"></i> Gallery
                            </button>
                            <button class="btn btn-secondary btn-sm ${filterType === 'kanban' ? 'btn-primary' : ''}" data-view-filter="kanban">
                                <i class="ph ph-kanban"></i> Kanban
                            </button>
                            <button class="btn btn-secondary btn-sm ${filterType === 'graph' ? 'btn-primary' : ''}" data-view-filter="graph">
                                <i class="ph ph-graph"></i> Graph
                            </button>
                        </div>
                        <div class="flex gap-2">
                            <button class="btn btn-primary btn-sm" onclick="handleAddViewClick()">
                                <i class="ph ph-plus"></i> New View
                            </button>
                        </div>
                    </div>
                    ${renderViewsTable(filteredViews)}
                </div>
            `;

            // Attach filter button handlers
            document.querySelectorAll('[data-view-filter]').forEach(btn => {
                btn.onclick = () => renderViewsPage(btn.dataset.viewFilter);
            });

            // Attach action handlers
            document.querySelectorAll('[data-view-open]').forEach(btn => {
                btn.onclick = () => {
                    const [setId, viewId] = btn.dataset.viewOpen.split(':');
                    switchSet(setId, viewId);
                };
            });

            document.querySelectorAll('[data-view-edit]').forEach(btn => {
                btn.onclick = () => {
                    const [setId, viewId] = btn.dataset.viewEdit.split(':');
                    openEditViewModal(setId, viewId);
                };
            });

            document.querySelectorAll('[data-view-duplicate]').forEach(btn => {
                btn.onclick = () => {
                    const [setId, viewId] = btn.dataset.viewDuplicate.split(':');
                    duplicateView(setId, viewId);
                };
            });

            document.querySelectorAll('[data-view-delete]').forEach(btn => {
                btn.onclick = () => {
                    const [setId, viewId] = btn.dataset.viewDelete.split(':');
                    if (confirm('Are you sure you want to delete this view?')) {
                        deleteViewFromSet(setId, viewId);
                        renderViewsPage(filterType);
                        showToast('View deleted');
                    }
                };
            });
        }

        function renderViewsTable(views) {
            if (!views.length) {
                return `
                    <div class="text-center py-12 text-gray-500">
                        <i class="ph ph-layout text-4xl mb-3 block opacity-50"></i>
                        <p class="text-sm">No views found</p>
                        <p class="text-xs mt-1">Create a view to organize and visualize your data</p>
                    </div>
                `;
            }

            return `
                <div class="overflow-auto border border-gray-200 rounded-lg bg-white">
                    <table class="min-w-full text-sm">
                        <thead class="bg-gray-50">
                            <tr>
                                <th class="px-4 py-3 text-left text-xs font-semibold text-gray-500">View</th>
                                <th class="px-4 py-3 text-left text-xs font-semibold text-gray-500">Type</th>
                                <th class="px-4 py-3 text-left text-xs font-semibold text-gray-500">Set</th>
                                <th class="px-4 py-3 text-left text-xs font-semibold text-gray-500">Records</th>
                                <th class="px-4 py-3 text-left text-xs font-semibold text-gray-500">Filters</th>
                                <th class="px-4 py-3 text-left text-xs font-semibold text-gray-500">Created</th>
                                <th class="px-4 py-3 text-right text-xs font-semibold text-gray-500">Actions</th>
                            </tr>
                        </thead>
                        <tbody class="divide-y divide-gray-200">
                            ${views.map(view => {
                                const viewIcon = view.icon || VIEW_TYPE_ICONS[view.type] || 'ph-table';
                                const viewType = formatViewType(view.type);
                                const filterCount = (view.filters || []).length;
                                const createdAt = view.provenance?.createdAt
                                    ? new Date(view.provenance.createdAt).toLocaleDateString()
                                    : (view.createdAt ? new Date(view.createdAt).toLocaleDateString() : '');

                                return `
                                    <tr class="hover:bg-gray-50 transition-colors cursor-pointer" data-view-row="${view.setId}:${view.id}">
                                        <td class="px-4 py-3">
                                            <div class="flex items-center gap-2">
                                                <span class="text-gray-400">${renderIcon(viewIcon)}</span>
                                                <span class="font-medium text-gray-900">${escapeHtml(view.name || 'Untitled')}</span>
                                            </div>
                                        </td>
                                        <td class="px-4 py-3">
                                            <span class="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-gray-100 text-gray-700">
                                                ${viewType}
                                            </span>
                                        </td>
                                        <td class="px-4 py-3 text-gray-600">${escapeHtml(view.setName || '')}</td>
                                        <td class="px-4 py-3 text-gray-600">${view.recordCount}</td>
                                        <td class="px-4 py-3">
                                            ${filterCount > 0
                                                ? `<span class="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-blue-50 text-blue-700">${filterCount} filter${filterCount !== 1 ? 's' : ''}</span>`
                                                : '<span class="text-gray-400"></span>'
                                            }
                                        </td>
                                        <td class="px-4 py-3 text-gray-500 text-xs">${createdAt}</td>
                                        <td class="px-4 py-3 text-right">
                                            <div class="flex items-center justify-end gap-1">
                                                <button class="p-1.5 text-gray-400 hover:text-blue-600 hover:bg-blue-50 rounded transition-colors" data-view-open="${view.setId}:${view.id}" title="Open view">
                                                    <i class="ph ph-arrow-square-out text-sm"></i>
                                                </button>
                                                <button class="p-1.5 text-gray-400 hover:text-gray-600 hover:bg-gray-100 rounded transition-colors" data-view-edit="${view.setId}:${view.id}" title="Edit view">
                                                    <i class="ph ph-pencil-simple text-sm"></i>
                                                </button>
                                                <button class="p-1.5 text-gray-400 hover:text-gray-600 hover:bg-gray-100 rounded transition-colors" data-view-duplicate="${view.setId}:${view.id}" title="Duplicate view">
                                                    <i class="ph ph-copy text-sm"></i>
                                                </button>
                                                <button class="p-1.5 text-gray-400 hover:text-red-600 hover:bg-red-50 rounded transition-colors" data-view-delete="${view.setId}:${view.id}" title="Delete view">
                                                    <i class="ph ph-trash text-sm"></i>
                                                </button>
                                            </div>
                                        </td>
                                    </tr>
                                `;
                            }).join('')}
                        </tbody>
                    </table>
                </div>
            `;
        }

        // ============================================================
        // SANDBOX PAGE - Shows all Imports, Sets, and Views
        // ============================================================
        function renderSandboxPage(activeSection = 'all', modeFilter = 'all') {
            state.sandboxPageState = state.sandboxPageState || { activeSection: 'all', modeFilter: 'all' };
            state.sandboxPageState.activeSection = activeSection;
            state.sandboxPageState.modeFilter = modeFilter;

            const container = document.getElementById('viewContainer');
            if (!container) return;

            // Collect all data
            const setsForWorld = getSetsForWorld();

            // Collect imports
            const allImports = [];
            if (state.imports && state.imports.size > 0) {
                state.imports.forEach((imp, impId) => {
                    allImports.push({ ...imp, id: impId });
                });
            }

            // Collect sets with metadata
            const allSets = setsForWorld.map(set => ({
                ...set,
                viewCount: set.views ? set.views.size : 0,
                recordCount: set.records ? set.records.size : 0
            }));

            // Collect views with mode info
            const allViews = [];
            setsForWorld.forEach(set => {
                if (set.views && set.views.size > 0) {
                    set.views.forEach((viewRef, viewId) => {
                        const fullView = state.views?.get(viewId) || viewRef;
                        allViews.push({
                            ...fullView,
                            id: viewId,
                            setId: set.id,
                            setName: set.name,
                            recordCount: set.records ? set.records.size : 0
                        });
                    });
                }
            });

            // Filter views by mode
            const filteredViews = modeFilter === 'all'
                ? allViews
                : allViews.filter(v => (v.viewMode || 'live') === modeFilter);

            // Counts for badges
            const liveCount = allViews.filter(v => (v.viewMode || 'live') === 'live').length;
            const sandboxCount = allViews.filter(v => v.viewMode === 'sandbox').length;

            container.innerHTML = `
                <div class="view-stage-header">
                    <div class="view-stage-title">
                        <span class="view-stage-pill"><i class="ph ph-flask"></i> ${getWorld()?.name || 'World'}</span>
                        <div class="min-w-0">
                            <div class="view-stage-name">Sandbox</div>
                            <div class="view-stage-sub">Imports, Sets & Views</div>
                        </div>
                    </div>
                </div>
                <div class="view-stage-body space-y-6">
                    <!-- Section Filters -->
                    <div class="flex flex-wrap items-center justify-between gap-3">
                        <div class="flex flex-wrap gap-2">
                            <button class="btn btn-secondary btn-sm ${activeSection === 'all' ? 'btn-primary' : ''}" data-sandbox-section="all">All</button>
                            <button class="btn btn-secondary btn-sm ${activeSection === 'imports' ? 'btn-primary' : ''}" data-sandbox-section="imports">
                                <i class="ph ph-upload-simple"></i> Imports <span class="sandbox-count-badge">${allImports.length}</span>
                            </button>
                            <button class="btn btn-secondary btn-sm ${activeSection === 'sets' ? 'btn-primary' : ''}" data-sandbox-section="sets">
                                <i class="ph ph-squares-four"></i> Sets <span class="sandbox-count-badge">${allSets.length}</span>
                            </button>
                            <button class="btn btn-secondary btn-sm ${activeSection === 'views' ? 'btn-primary' : ''}" data-sandbox-section="views">
                                <i class="ph ph-layout"></i> Views <span class="sandbox-count-badge">${allViews.length}</span>
                            </button>
                        </div>
                        <div class="flex gap-2 items-center">
                            <span class="text-xs text-gray-500">Mode:</span>
                            <button class="btn btn-secondary btn-sm ${modeFilter === 'all' ? 'btn-primary' : ''}" data-sandbox-mode="all">All</button>
                            <button class="btn btn-secondary btn-sm ${modeFilter === 'live' ? 'btn-primary' : ''}" data-sandbox-mode="live">
                                <span class="sandbox-mode-dot live"></span> Live <span class="sandbox-count-badge">${liveCount}</span>
                            </button>
                            <button class="btn btn-secondary btn-sm ${modeFilter === 'sandbox' ? 'btn-primary' : ''}" data-sandbox-mode="sandbox">
                                <span class="sandbox-mode-dot sandbox"></span> Dev <span class="sandbox-count-badge">${sandboxCount}</span>
                            </button>
                        </div>
                    </div>

                    <!-- IMPORTS Section -->
                    ${(activeSection === 'all' || activeSection === 'imports') ? `
                    <div class="sandbox-section">
                        <div class="sandbox-section-header">
                            <h3><i class="ph ph-upload-simple"></i> Imports</h3>
                            <button class="btn btn-primary btn-sm" onclick="triggerFileImport()">
                                <i class="ph ph-plus"></i> Import File
                            </button>
                        </div>
                        ${renderSandboxImportsTable(allImports)}
                    </div>
                    ` : ''}

                    <!-- SETS Section -->
                    ${(activeSection === 'all' || activeSection === 'sets') ? `
                    <div class="sandbox-section">
                        <div class="sandbox-section-header">
                            <h3><i class="ph ph-squares-four"></i> Sets</h3>
                            <button class="btn btn-primary btn-sm" onclick="openAddSetModal()">
                                <i class="ph ph-plus"></i> New Set
                            </button>
                        </div>
                        ${renderSandboxSetsTable(allSets)}
                    </div>
                    ` : ''}

                    <!-- VIEWS Section -->
                    ${(activeSection === 'all' || activeSection === 'views') ? `
                    <div class="sandbox-section">
                        <div class="sandbox-section-header">
                            <h3><i class="ph ph-layout"></i> Views</h3>
                            <button class="btn btn-primary btn-sm" onclick="handleAddViewClick()">
                                <i class="ph ph-plus"></i> New View
                            </button>
                        </div>
                        ${renderSandboxViewsTable(filteredViews)}
                    </div>
                    ` : ''}
                </div>
            `;

            // Attach section filter handlers
            document.querySelectorAll('[data-sandbox-section]').forEach(btn => {
                btn.onclick = () => renderSandboxPage(btn.dataset.sandboxSection, modeFilter);
            });

            // Attach mode filter handlers
            document.querySelectorAll('[data-sandbox-mode]').forEach(btn => {
                btn.onclick = () => renderSandboxPage(activeSection, btn.dataset.sandboxMode);
            });

            // Attach import action handlers
            document.querySelectorAll('[data-import-open]').forEach(btn => {
                btn.onclick = () => {
                    const importId = btn.dataset.importOpen;
                    openImportView(importId);
                };
            });

            document.querySelectorAll('[data-import-delete]').forEach(btn => {
                btn.onclick = () => {
                    const importId = btn.dataset.importDelete;
                    if (confirm('Are you sure you want to delete this import?')) {
                        state.imports?.delete(importId);
                        renderSandboxPage(activeSection, modeFilter);
                        showToast('Import deleted');
                    }
                };
            });

            // Attach set action handlers
            document.querySelectorAll('[data-set-open]').forEach(btn => {
                btn.onclick = () => {
                    const setId = btn.dataset.setOpen;
                    const set = state.sets.get(setId);
                    if (set && set.views && set.views.size > 0) {
                        const firstViewId = Array.from(set.views.keys())[0];
                        switchSet(setId, firstViewId);
                    }
                };
            });

            document.querySelectorAll('[data-set-edit]').forEach(btn => {
                btn.onclick = () => {
                    const setId = btn.dataset.setEdit;
                    openEditSetModal(setId);
                };
            });

            // Attach view action handlers
            document.querySelectorAll('[data-sandbox-view-open]').forEach(btn => {
                btn.onclick = () => {
                    const [setId, viewId] = btn.dataset.sandboxViewOpen.split(':');
                    switchSet(setId, viewId);
                };
            });

            document.querySelectorAll('[data-sandbox-view-promote]').forEach(btn => {
                btn.onclick = () => {
                    const [setId, viewId] = btn.dataset.sandboxViewPromote.split(':');
                    const view = state.views?.get(viewId);
                    if (view) {
                        view.viewMode = 'live';
                        showToast('View promoted to Live');
                        renderSandboxPage(activeSection, modeFilter);
                    }
                };
            });

            document.querySelectorAll('[data-sandbox-view-demote]').forEach(btn => {
                btn.onclick = () => {
                    const [setId, viewId] = btn.dataset.sandboxViewDemote.split(':');
                    const view = state.views?.get(viewId);
                    if (view) {
                        view.viewMode = 'sandbox';
                        showToast('View demoted to Dev');
                        renderSandboxPage(activeSection, modeFilter);
                    }
                };
            });

            document.querySelectorAll('[data-sandbox-view-delete]').forEach(btn => {
                btn.onclick = () => {
                    const [setId, viewId] = btn.dataset.sandboxViewDelete.split(':');
                    if (confirm('Are you sure you want to delete this view?')) {
                        deleteViewFromSet(setId, viewId);
                        renderSandboxPage(activeSection, modeFilter);
                        showToast('View deleted');
                    }
                };
            });
        }

        function renderSandboxImportsTable(imports) {
            if (!imports.length) {
                return `
                    <div class="sandbox-empty-state">
                        <i class="ph ph-upload-simple"></i>
                        <p>No imports yet</p>
                        <p class="text-xs">Import CSV, JSON, or Excel files to get started</p>
                    </div>
                `;
            }

            return `
                <div class="overflow-auto border border-gray-200 rounded-lg bg-white">
                    <table class="min-w-full text-sm">
                        <thead class="bg-gray-50">
                            <tr>
                                <th class="px-4 py-3 text-left text-xs font-semibold text-gray-500">Name</th>
                                <th class="px-4 py-3 text-left text-xs font-semibold text-gray-500">Format</th>
                                <th class="px-4 py-3 text-left text-xs font-semibold text-gray-500">Rows</th>
                                <th class="px-4 py-3 text-left text-xs font-semibold text-gray-500">Columns</th>
                                <th class="px-4 py-3 text-left text-xs font-semibold text-gray-500">Imported</th>
                                <th class="px-4 py-3 text-left text-xs font-semibold text-gray-500">Used In</th>
                                <th class="px-4 py-3 text-right text-xs font-semibold text-gray-500">Actions</th>
                            </tr>
                        </thead>
                        <tbody class="divide-y divide-gray-200">
                            ${imports.map(imp => {
                                const format = imp.source?.format || imp.format || 'unknown';
                                const formatIcon = format === 'csv' ? 'ph-file-csv' : format === 'json' ? 'ph-file-code' : 'ph-file-xls';
                                const rows = imp.rowCount || imp.rows?.length || 0;
                                const cols = imp.columnCount || imp.headers?.length || 0;
                                const importedAt = imp.source?.importedAt
                                    ? new Date(imp.source.importedAt).toLocaleDateString()
                                    : '';
                                const usedIn = imp.usedIn?.length || 0;

                                return `
                                    <tr class="hover:bg-gray-50 transition-colors">
                                        <td class="px-4 py-3">
                                            <div class="flex items-center gap-2">
                                                <i class="ph ${formatIcon} text-gray-400"></i>
                                                <span class="font-medium text-gray-900">${escapeHtml(imp.name || 'Untitled')}</span>
                                            </div>
                                        </td>
                                        <td class="px-4 py-3">
                                            <span class="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-gray-100 text-gray-700 uppercase">
                                                ${format}
                                            </span>
                                        </td>
                                        <td class="px-4 py-3 text-gray-600">${rows.toLocaleString()}</td>
                                        <td class="px-4 py-3 text-gray-600">${cols}</td>
                                        <td class="px-4 py-3 text-gray-500 text-xs">${importedAt}</td>
                                        <td class="px-4 py-3">
                                            ${usedIn > 0
                                                ? `<span class="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-green-50 text-green-700">${usedIn} set${usedIn !== 1 ? 's' : ''}</span>`
                                                : '<span class="text-gray-400"></span>'
                                            }
                                        </td>
                                        <td class="px-4 py-3 text-right">
                                            <div class="flex items-center justify-end gap-1">
                                                <button class="p-1.5 text-gray-400 hover:text-blue-600 hover:bg-blue-50 rounded transition-colors" data-import-open="${imp.id}" title="View import">
                                                    <i class="ph ph-arrow-square-out text-sm"></i>
                                                </button>
                                                <button class="p-1.5 text-gray-400 hover:text-red-600 hover:bg-red-50 rounded transition-colors" data-import-delete="${imp.id}" title="Delete import">
                                                    <i class="ph ph-trash text-sm"></i>
                                                </button>
                                            </div>
                                        </td>
                                    </tr>
                                `;
                            }).join('')}
                        </tbody>
                    </table>
                </div>
            `;
        }

        function renderSandboxSetsTable(sets) {
            if (!sets.length) {
                return `
                    <div class="sandbox-empty-state">
                        <i class="ph ph-squares-four"></i>
                        <p>No sets yet</p>
                        <p class="text-xs">Create a set to organize your data</p>
                    </div>
                `;
            }

            return `
                <div class="overflow-auto border border-gray-200 rounded-lg bg-white">
                    <table class="min-w-full text-sm">
                        <thead class="bg-gray-50">
                            <tr>
                                <th class="px-4 py-3 text-left text-xs font-semibold text-gray-500">Set</th>
                                <th class="px-4 py-3 text-left text-xs font-semibold text-gray-500">Records</th>
                                <th class="px-4 py-3 text-left text-xs font-semibold text-gray-500">Views</th>
                                <th class="px-4 py-3 text-left text-xs font-semibold text-gray-500">Origin</th>
                                <th class="px-4 py-3 text-left text-xs font-semibold text-gray-500">Fields</th>
                                <th class="px-4 py-3 text-right text-xs font-semibold text-gray-500">Actions</th>
                            </tr>
                        </thead>
                        <tbody class="divide-y divide-gray-200">
                            ${sets.map(set => {
                                const origin = set.origin || 'manual';
                                const originIcon = origin === 'import' ? 'ph-upload-simple' : origin === 'derived' ? 'ph-git-branch' : 'ph-pencil-simple';
                                const fieldCount = set.schema?.length || 0;

                                return `
                                    <tr class="hover:bg-gray-50 transition-colors cursor-pointer" data-set-row="${set.id}">
                                        <td class="px-4 py-3">
                                            <div class="flex items-center gap-2">
                                                <span class="text-gray-400">${renderIcon(set.icon || 'ph-squares-four')}</span>
                                                <span class="font-medium text-gray-900">${escapeHtml(set.name || 'Untitled')}</span>
                                            </div>
                                        </td>
                                        <td class="px-4 py-3 text-gray-600">${set.recordCount.toLocaleString()}</td>
                                        <td class="px-4 py-3">
                                            <span class="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-blue-50 text-blue-700">
                                                ${set.viewCount} view${set.viewCount !== 1 ? 's' : ''}
                                            </span>
                                        </td>
                                        <td class="px-4 py-3">
                                            <span class="inline-flex items-center gap-1 text-xs text-gray-500">
                                                <i class="ph ${originIcon}"></i> ${origin}
                                            </span>
                                        </td>
                                        <td class="px-4 py-3 text-gray-600">${fieldCount}</td>
                                        <td class="px-4 py-3 text-right">
                                            <div class="flex items-center justify-end gap-1">
                                                <button class="p-1.5 text-gray-400 hover:text-blue-600 hover:bg-blue-50 rounded transition-colors" data-set-open="${set.id}" title="Open set">
                                                    <i class="ph ph-arrow-square-out text-sm"></i>
                                                </button>
                                                <button class="p-1.5 text-gray-400 hover:text-gray-600 hover:bg-gray-100 rounded transition-colors" data-set-edit="${set.id}" title="Edit set">
                                                    <i class="ph ph-pencil-simple text-sm"></i>
                                                </button>
                                            </div>
                                        </td>
                                    </tr>
                                `;
                            }).join('')}
                        </tbody>
                    </table>
                </div>
            `;
        }

        function renderSandboxViewsTable(views) {
            if (!views.length) {
                return `
                    <div class="sandbox-empty-state">
                        <i class="ph ph-layout"></i>
                        <p>No views found</p>
                        <p class="text-xs">Create a view to visualize your data</p>
                    </div>
                `;
            }

            return `
                <div class="overflow-auto border border-gray-200 rounded-lg bg-white">
                    <table class="min-w-full text-sm">
                        <thead class="bg-gray-50">
                            <tr>
                                <th class="px-4 py-3 text-left text-xs font-semibold text-gray-500">View</th>
                                <th class="px-4 py-3 text-left text-xs font-semibold text-gray-500">Mode</th>
                                <th class="px-4 py-3 text-left text-xs font-semibold text-gray-500">Type</th>
                                <th class="px-4 py-3 text-left text-xs font-semibold text-gray-500">Set</th>
                                <th class="px-4 py-3 text-left text-xs font-semibold text-gray-500">Records</th>
                                <th class="px-4 py-3 text-left text-xs font-semibold text-gray-500">Filters</th>
                                <th class="px-4 py-3 text-right text-xs font-semibold text-gray-500">Actions</th>
                            </tr>
                        </thead>
                        <tbody class="divide-y divide-gray-200">
                            ${views.map(view => {
                                const viewIcon = view.icon || VIEW_TYPE_ICONS[view.type] || 'ph-table';
                                const viewType = formatViewType(view.type);
                                const filterCount = (view.filters || []).length;
                                const viewMode = view.viewMode || 'live';
                                const modeLabel = viewMode === 'sandbox' ? 'Dev' : 'Live';
                                const modeClass = viewMode === 'sandbox' ? 'sandbox' : 'live';

                                return `
                                    <tr class="hover:bg-gray-50 transition-colors">
                                        <td class="px-4 py-3">
                                            <div class="flex items-center gap-2">
                                                <span class="text-gray-400">${renderIcon(viewIcon)}</span>
                                                <span class="font-medium text-gray-900">${escapeHtml(view.name || 'Untitled')}</span>
                                            </div>
                                        </td>
                                        <td class="px-4 py-3">
                                            <span class="sandbox-mode-badge ${modeClass}">
                                                <span class="sandbox-mode-dot ${modeClass}"></span>
                                                ${modeLabel}
                                            </span>
                                        </td>
                                        <td class="px-4 py-3">
                                            <span class="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-gray-100 text-gray-700">
                                                ${viewType}
                                            </span>
                                        </td>
                                        <td class="px-4 py-3 text-gray-600">${escapeHtml(view.setName || '')}</td>
                                        <td class="px-4 py-3 text-gray-600">${view.recordCount.toLocaleString()}</td>
                                        <td class="px-4 py-3">
                                            ${filterCount > 0
                                                ? `<span class="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-blue-50 text-blue-700">${filterCount}</span>`
                                                : '<span class="text-gray-400"></span>'
                                            }
                                        </td>
                                        <td class="px-4 py-3 text-right">
                                            <div class="flex items-center justify-end gap-1">
                                                <button class="p-1.5 text-gray-400 hover:text-blue-600 hover:bg-blue-50 rounded transition-colors" data-sandbox-view-open="${view.setId}:${view.id}" title="Open view">
                                                    <i class="ph ph-arrow-square-out text-sm"></i>
                                                </button>
                                                ${viewMode === 'sandbox'
                                                    ? `<button class="p-1.5 text-gray-400 hover:text-green-600 hover:bg-green-50 rounded transition-colors" data-sandbox-view-promote="${view.setId}:${view.id}" title="Promote to Live">
                                                        <i class="ph ph-arrow-fat-up text-sm"></i>
                                                       </button>`
                                                    : `<button class="p-1.5 text-gray-400 hover:text-amber-600 hover:bg-amber-50 rounded transition-colors" data-sandbox-view-demote="${view.setId}:${view.id}" title="Demote to Dev">
                                                        <i class="ph ph-arrow-fat-down text-sm"></i>
                                                       </button>`
                                                }
                                                <button class="p-1.5 text-gray-400 hover:text-red-600 hover:bg-red-50 rounded transition-colors" data-sandbox-view-delete="${view.setId}:${view.id}" title="Delete view">
                                                    <i class="ph ph-trash text-sm"></i>
                                                </button>
                                            </div>
                                        </td>
                                    </tr>
                                `;
                            }).join('')}
                        </tbody>
                    </table>
                </div>
            `;
        }

        function openImportView(importId) {
            const imp = state.imports?.get(importId);
            if (!imp) {
                showToast('Import not found');
                return;
            }
            // Open the imports table view with this import selected
            openImportsTableView();
        }

        function formatViewType(type) {
            const typeLabels = {
                grid: 'Grid',
                card: 'Gallery',
                kanban: 'Kanban',
                graph: 'Graph',
                KEY_DERIVED: 'Key Derived'
            };
            return typeLabels[type] || type || 'Grid';
        }

        function duplicateView(setId, viewId) {
            const set = state.sets.get(setId);
            if (!set || !set.views) return;

            const originalView = state.views?.get(viewId) || set.views.get(viewId);
            if (!originalView) return;

            const newViewId = `view_${Date.now()}_${Math.random().toString(36).slice(2, 9)}`;
            const newView = {
                ...originalView,
                id: newViewId,
                name: `${originalView.name || 'Untitled'} (copy)`,
                provenance: {
                    ...originalView.provenance,
                    createdAt: Date.now(),
                    updatedAt: null,
                    derivedFromViewIds: [viewId],
                    notes: `Duplicated from ${originalView.name}`
                }
            };

            // Add to global views
            if (!state.views) state.views = new Map();
            state.views.set(newViewId, newView);

            // Add to set
            set.views.set(newViewId, { id: newViewId });

            showToast('View duplicated');
            renderViewsPage(state.viewsPageState?.activeFilter || 'all');
        }

        function deleteViewFromSet(setId, viewId) {
            const set = state.sets.get(setId);
            if (!set || !set.views) return;

            // Remove from set
            set.views.delete(viewId);

            // Remove from global views
            if (state.views) {
                state.views.delete(viewId);
            }

            // If this was the current view, clear selection
            if (state.currentViewId === viewId) {
                state.currentViewId = null;
            }
        }

        function renderModeOptions(operator, selectedMode = '') {
            const modes = getModesForOperator(operator);
            return modes.map(mode => `<option value="${mode}" ${mode === selectedMode ? 'selected' : ''}>${mode}</option>`).join('');
        }

        function populateConnectionRelationOptions(selectedOperator = '') {
            const operatorSelect = document.getElementById('connectionRelationOperator');
            if (!operatorSelect) return;

            // Get operator codes, filtering out the 'operators' key that stores full info
            const operatorOptions = Object.keys(state.connectionModes || {}).filter(k => k !== 'operators' && k !== 'meta');
            const operators = state.connectionModes?.operators || {};

            operatorSelect.innerHTML = [
                '<option value="">Select operator</option>',
                ...operatorOptions.map(op => {
                    const opInfo = operators[op] || {};
                    const symbol = opInfo.symbol || '';
                    const name = opInfo.name || op;
                    return `<option value="${op}">${symbol} ${op} - ${name}</option>`;
                })
            ].join('');
            operatorSelect.value = selectedOperator || '';

            const modeSelect = document.getElementById('connectionRelationMode');
            if (modeSelect) {
                modeSelect.innerHTML = renderModeOptions(operatorSelect.value || selectedOperator, '');
            }
        }

        function populateConnectionRelationForm(relationId) {
            const relation = state.connectionRelations.get(relationId);
            if (!relation) return;
            const form = document.getElementById('connectionRelationForm');
            if (!form) return;

            populateConnectionRelationOptions(relation.operator);

            form.querySelector('#connectionRelationOperator').value = relation.operator;
            const modeSelect = form.querySelector('#connectionRelationMode');
            if (modeSelect) {
                modeSelect.innerHTML = renderModeOptions(relation.operator, relation.mode);
            }

            form.querySelector('#connectionRelationName').value = relation.name || '';
            form.querySelector('#connectionRelationDescription').value = relation.description || '';
            state.connectionRelationFormState.editingId = relation.id;

            // Load parameter schema into form state
            const schema = relation.parameterSchema || {};
            state.connectionRelationFormState.paramFields = Object.entries(schema).map(([name, fieldDef]) => ({
                name,
                type: fieldDef.type || 'text',
                label: fieldDef.label || name,
                required: fieldDef.required || false,
                default: fieldDef.default,
                description: fieldDef.description || '',
                options: fieldDef.options || []
            }));
            renderRelationParamFieldsList();

            const submit = document.getElementById('connectionRelationSubmit');
            if (submit) submit.textContent = 'Save';
            const title = document.getElementById('connectionRelationModalTitle');
            if (title) title.textContent = 'Edit Relation Type';
            openModal('connectionRelationModal');
        }

        function resetConnectionRelationForm() {
            state.connectionRelationFormState.editingId = null;
            state.connectionRelationFormState.paramFields = [];
            const form = document.getElementById('connectionRelationForm');
            if (!form) return;
            form.reset();
            populateConnectionRelationOptions();
            renderRelationParamFieldsList();
            const submit = document.getElementById('connectionRelationSubmit');
            if (submit) submit.textContent = 'Add';
            const title = document.getElementById('connectionRelationModalTitle');
            if (title) title.textContent = 'Add Relation Type';
        }

        // Parameter field management for relation form
        function renderRelationParamFieldsList() {
            const container = document.getElementById('relationParamFieldsList');
            if (!container) return;

            const fields = state.connectionRelationFormState.paramFields || [];

            if (fields.length === 0) {
                container.innerHTML = '<p class="text-xs text-gray-400 italic">No parameter fields defined yet</p>';
                return;
            }

            container.innerHTML = fields.map((field, index) => `
                <div class="bg-gray-50 rounded-lg p-3 border border-gray-200" data-param-index="${index}">
                    <div class="flex items-start justify-between gap-2 mb-2">
                        <input type="text" class="border rounded px-2 py-1 text-sm flex-1" placeholder="Field name"
                            value="${field.name || ''}" onchange="updateRelationParamField(${index}, 'name', this.value)" />
                        <button type="button" class="text-gray-400 hover:text-red-500 p-1" onclick="removeRelationParamField(${index})">
                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                            </svg>
                        </button>
                    </div>
                    <div class="grid grid-cols-2 gap-2 mb-2">
                        <select class="border rounded px-2 py-1 text-sm" onchange="updateRelationParamField(${index}, 'type', this.value)">
                            <option value="text" ${field.type === 'text' ? 'selected' : ''}>Text</option>
                            <option value="number" ${field.type === 'number' ? 'selected' : ''}>Number</option>
                            <option value="select" ${field.type === 'select' ? 'selected' : ''}>Select</option>
                            <option value="checkbox" ${field.type === 'checkbox' ? 'selected' : ''}>Checkbox</option>
                            <option value="date" ${field.type === 'date' ? 'selected' : ''}>Date</option>
                            <option value="textarea" ${field.type === 'textarea' ? 'selected' : ''}>Long text</option>
                        </select>
                        <label class="flex items-center gap-2 text-sm">
                            <input type="checkbox" ${field.required ? 'checked' : ''} onchange="updateRelationParamField(${index}, 'required', this.checked)" />
                            Required
                        </label>
                    </div>
                    <input type="text" class="border rounded px-2 py-1 text-sm w-full mb-2" placeholder="Label (display name)"
                        value="${field.label || ''}" onchange="updateRelationParamField(${index}, 'label', this.value)" />
                    <input type="text" class="border rounded px-2 py-1 text-sm w-full mb-2" placeholder="Default value (optional)"
                        value="${field.default !== undefined ? field.default : ''}" onchange="updateRelationParamField(${index}, 'default', this.value)" />
                    ${field.type === 'select' ? `
                        <input type="text" class="border rounded px-2 py-1 text-sm w-full" placeholder="Options (comma-separated)"
                            value="${(field.options || []).join(', ')}" onchange="updateRelationParamFieldOptions(${index}, this.value)" />
                    ` : ''}
                    <input type="text" class="border rounded px-2 py-1 text-sm w-full mt-2" placeholder="Description (optional)"
                        value="${field.description || ''}" onchange="updateRelationParamField(${index}, 'description', this.value)" />
                </div>
            `).join('');
        }

        function addRelationParamField() {
            if (!state.connectionRelationFormState.paramFields) {
                state.connectionRelationFormState.paramFields = [];
            }
            state.connectionRelationFormState.paramFields.push({
                name: '',
                type: 'text',
                label: '',
                required: false,
                default: undefined,
                description: ''
            });
            renderRelationParamFieldsList();
        }

        function removeRelationParamField(index) {
            state.connectionRelationFormState.paramFields.splice(index, 1);
            renderRelationParamFieldsList();
        }

        function updateRelationParamField(index, key, value) {
            if (state.connectionRelationFormState.paramFields[index]) {
                state.connectionRelationFormState.paramFields[index][key] = value;
            }
        }

        function updateRelationParamFieldOptions(index, value) {
            if (state.connectionRelationFormState.paramFields[index]) {
                state.connectionRelationFormState.paramFields[index].options = value.split(',').map(o => o.trim()).filter(Boolean);
            }
        }

        function collectRelationParamSchema() {
            const fields = state.connectionRelationFormState.paramFields || [];
            const schema = {};
            const requiredParams = [];
            const optionalParams = [];

            fields.forEach(field => {
                if (!field.name) return;
                const name = field.name.trim();
                if (!name) return;

                schema[name] = {
                    type: field.type || 'text',
                    label: field.label || name,
                    required: field.required || false,
                    description: field.description || ''
                };

                if (field.default !== undefined && field.default !== '') {
                    // Convert default value based on type
                    if (field.type === 'number') {
                        schema[name].default = parseFloat(field.default) || 0;
                    } else if (field.type === 'checkbox') {
                        schema[name].default = field.default === 'true' || field.default === true;
                    } else {
                        schema[name].default = field.default;
                    }
                }

                if (field.type === 'select' && field.options?.length) {
                    schema[name].options = field.options;
                }

                if (field.required) {
                    requiredParams.push(name);
                } else {
                    optionalParams.push(name);
                }
            });

            return { parameterSchema: schema, requiredParams, optionalParams };
        }

        function openConnectionRelationModal(relationId = null) {
            resetConnectionRelationForm();
            if (relationId) populateConnectionRelationForm(relationId);
            openModal('connectionRelationModal');
        }

        function handleConnectionRelationSubmit() {
            const form = document.getElementById('connectionRelationForm');
            if (!form) return;

            const operator = form.querySelector('#connectionRelationOperator')?.value;
            const mode = form.querySelector('#connectionRelationMode')?.value;
            const name = form.querySelector('#connectionRelationName')?.value || '';
            const description = form.querySelector('#connectionRelationDescription')?.value || '';

            // Collect parameter schema from form
            const { parameterSchema, requiredParams, optionalParams } = collectRelationParamSchema();

            const payload = {
                id: state.connectionRelationFormState.editingId,
                operator,
                mode,
                name,
                description,
                parameterSchema,
                requiredParams,
                optionalParams,
                worldId: state.currentWorldId
            };

            const isEdit = Boolean(state.connectionRelationFormState.editingId);
            try {
                if (isEdit) {
                    updateConnectionRelation(payload.id, payload);
                    showToast('Relation type updated');
                } else {
                    addConnectionRelation(payload);
                    showToast('Relation type added');
                }
            } catch (error) {
                showToast(error.message);
                return;
            }

            resetConnectionRelationForm();
            closeModal('connectionRelationModal');
            renderRelationsPage(state.connectionFormState.activeFilter || 'all');
        }

        function renderConnectionParamFields(containerId, relationId, params = {}) {
            const container = document.getElementById(containerId);
            if (!container) return;
            const relation = findConnectionRelation(relationId);
            if (!relation) {
                container.innerHTML = '<p class="text-sm text-gray-500">Select a relation to enter parameters.</p>';
                return;
            }

            // Use parameterSchema if available, otherwise fall back to simple param lists
            const schema = relation.parameterSchema || {};
            const allParams = Object.keys(schema).length > 0
                ? Object.keys(schema)
                : [...relation.requiredParams, ...relation.optionalParams];

            if (!allParams.length) {
                container.innerHTML = '<p class="text-sm text-gray-500">No parameters required for this relation.</p>';
                return;
            }

            container.innerHTML = allParams.map(name => {
                const fieldSchema = schema[name] || {
                    type: 'text',
                    label: name,
                    required: relation.requiredParams.includes(name)
                };
                const { type = 'text', label = name, required = false, options = [], min, max, step, description, placeholder } = fieldSchema;
                const defaultValue = fieldSchema.default;
                const value = params[name] !== undefined ? params[name] : (defaultValue !== undefined ? defaultValue : '');
                const safeValue = typeof value === 'object' ? JSON.stringify(value) : String(value ?? '');
                const escapedValue = safeValue
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/"/g, '&quot;');

                // Build the field based on type
                let fieldHtml = '';
                const commonAttrs = `data-param-name="${name}" data-param-required="${required ? 'true' : 'false'}" data-param-type="${type}" class="border rounded px-3 py-2 w-full text-sm"`;

                switch (type) {
                    case 'select':
                        const optionsList = Array.isArray(options) ? options : [];
                        fieldHtml = `
                            <select ${commonAttrs}>
                                <option value="">Select...</option>
                                ${optionsList.map(opt => {
                                    const optVal = typeof opt === 'object' ? opt.value : opt;
                                    const optLabel = typeof opt === 'object' ? opt.label : opt;
                                    return `<option value="${optVal}" ${String(value) === String(optVal) ? 'selected' : ''}>${optLabel}</option>`;
                                }).join('')}
                            </select>
                        `;
                        break;

                    case 'number':
                        fieldHtml = `
                            <input type="number" ${commonAttrs} value="${escapedValue}"
                                ${min !== undefined ? `min="${min}"` : ''}
                                ${max !== undefined ? `max="${max}"` : ''}
                                ${step !== undefined ? `step="${step}"` : ''} />
                        `;
                        break;

                    case 'checkbox':
                        const isChecked = value === true || value === 'true' || value === 1;
                        fieldHtml = `
                            <div class="flex items-center gap-2">
                                <input type="checkbox" ${commonAttrs.replace('w-full', '')} ${isChecked ? 'checked' : ''} />
                                ${description ? `<span class="text-sm text-gray-600">${description}</span>` : ''}
                            </div>
                        `;
                        break;

                    case 'date':
                        fieldHtml = `<input type="date" ${commonAttrs} value="${escapedValue}" />`;
                        break;

                    case 'textarea':
                        fieldHtml = `<textarea ${commonAttrs} rows="2">${escapedValue}</textarea>`;
                        break;

                    default: // text
                        fieldHtml = `<input type="text" ${commonAttrs} value="${escapedValue}" ${placeholder ? `placeholder="${placeholder}"` : ''} />`;
                }

                const defaultHint = defaultValue !== undefined
                    ? `<span class="text-xs text-gray-400 mt-0.5 block">Default: ${typeof defaultValue === 'object' ? JSON.stringify(defaultValue) : defaultValue}</span>`
                    : '';

                return `
                    <div>
                        <label class="form-label">${label}${required ? ' <span class="text-red-500">*</span>' : ''}</label>
                        ${fieldHtml}
                        ${description && type !== 'checkbox' ? `<p class="text-xs text-gray-500 mt-0.5">${description}</p>` : ''}
                        ${defaultHint}
                    </div>
                `;
            }).join('');
        }

        function populateConnectionForm(connId) {
            const conn = state.connections.get(connId);
            if (!conn) return;
            const form = document.getElementById('connectionForm');
            if (!form) return;

            // Populate subject entity for wizard
            const subjectEntity = conn.subject?.id ? state.entities.get(conn.subject.id) : null;
            const subjectIdInput = form.querySelector('#connectionSubjectId');
            const subjectTypeInput = form.querySelector('#connectionSubjectType');

            // Try to get display name from entity or look up record
            let subjectDisplayName = 'Unknown';
            if (subjectEntity) {
                subjectDisplayName = getEntityDisplayName(subjectEntity);
            } else if (conn.subject?.id) {
                // Try to find in records
                subjectDisplayName = getRecordDisplayName(conn.subject.id) || conn.subject.id;
            }

            subjectIdInput.value = conn.subject?.id || '';
            subjectTypeInput.value = conn.subject?.type || 'Entity';

            // Set wizard state for subject
            connectionWizardState.selectedSubject = {
                id: conn.subject?.id,
                type: conn.subject?.type || 'Entity',
                name: subjectDisplayName
            };

            // Update subject preview
            const subjectPreview = document.getElementById('subjectPreview');
            if (subjectPreview) {
                subjectPreview.classList.remove('hidden');
                document.getElementById('subjectPreviewName').textContent = subjectDisplayName;
                document.getElementById('subjectPreviewMeta').textContent = `${conn.subject?.type || 'Entity'}  ${conn.subject?.id?.substring(0, 30) || ''}...`;
            }

            // Populate operand entity for wizard
            const operandEntity = conn.operand?.id ? state.entities.get(conn.operand.id) : null;
            const operandIdInput = form.querySelector('#connectionOperandId');
            const operandTypeInput = form.querySelector('#connectionOperandType');

            let operandDisplayName = 'Unknown';
            if (operandEntity) {
                operandDisplayName = getEntityDisplayName(operandEntity);
            } else if (conn.operand?.id) {
                operandDisplayName = getRecordDisplayName(conn.operand.id) || conn.operand.id;
            }

            operandIdInput.value = conn.operand?.id || '';
            operandTypeInput.value = conn.operand?.type || 'Entity';

            // Set wizard state for operand
            connectionWizardState.selectedOperand = {
                id: conn.operand?.id,
                type: conn.operand?.type || 'Entity',
                name: operandDisplayName
            };

            // Update operand preview
            const operandPreview = document.getElementById('operandPreview');
            if (operandPreview) {
                operandPreview.classList.remove('hidden');
                document.getElementById('operandPreviewName').textContent = operandDisplayName;
                document.getElementById('operandPreviewMeta').textContent = `${conn.operand?.type || 'Entity'}  ${conn.operand?.id?.substring(0, 30) || ''}...`;
            }

            // Populate relation
            const relation = conn.relationId ? findConnectionRelation(conn.relationId) : null;
            const relationSelect = form.querySelector('#connectionRelationSelect');
            if (relation) {
                relationSelect.value = conn.relationId;
                connectionWizardState.selectedRelation = relation;

                // Update relation preview
                const relationPreview = document.getElementById('relationPreview');
                if (relationPreview) {
                    relationPreview.classList.remove('hidden');
                    const operatorInfo = state.connectionModes?.operators?.[relation.operator] || {};
                    document.getElementById('relationPreviewName').textContent = relation.mode;
                    document.getElementById('relationPreviewMeta').textContent = `${operatorInfo.symbol || ''} ${relation.operator}`;
                }
            }

            form.querySelector('#connectionDescription').value = conn.description || '';
            state.connectionFormState.editingId = conn.id;
            state.connectionFormState.selectedRelationId = conn.relationId;

            renderConnectionParamFields('connectionParamFields', conn.relationId, conn.params || {});

            const submit = document.getElementById('connectionSubmit');
            if (submit) submit.textContent = 'Save Changes';
            const title = document.getElementById('connectionModalTitle');
            if (title) title.textContent = 'Edit Relationship';

            // For editing, go directly to review step
            showWizardStep(4);
        }

        // Connection Wizard State
        const connectionWizardState = {
            currentStep: 1,
            selectedSubject: null,
            selectedRelation: null,
            selectedOperand: null,
            subjectPath: [],
            operandPath: []
        };

        function resetConnectionForm() {
            state.connectionFormState.editingId = null;
            state.connectionFormState.selectedRelationId = null;
            state.connectionFormState.selectedRelationType = null;

            // Reset wizard state
            connectionWizardState.currentStep = 1;
            connectionWizardState.selectedSubject = null;
            connectionWizardState.selectedRelation = null;
            connectionWizardState.selectedOperand = null;
            connectionWizardState.subjectPath = [];
            connectionWizardState.operandPath = [];

            const form = document.getElementById('connectionForm');
            if (!form) return;
            form.reset();

            // Clear hidden fields
            const hiddenFields = ['#connectionSubjectId', '#connectionOperandId', '#connectionRelationSelect'];
            hiddenFields.forEach(sel => {
                const el = form.querySelector(sel);
                if (el) el.value = '';
            });

            // Hide all previews
            ['subjectPreview', 'relationPreview', 'operandPreview'].forEach(id => {
                const el = document.getElementById(id);
                if (el) el.classList.add('hidden');
            });

            // Hide param fields
            const paramFields = document.getElementById('connectionParamFields');
            if (paramFields) {
                paramFields.innerHTML = '';
            }

            // Reset wizard UI
            updateWizardSteps(1);
            showWizardStep(1);

            const submit = document.getElementById('connectionSubmit');
            if (submit) submit.classList.add('hidden');
            const nextBtn = document.getElementById('connectionNextBtn');
            if (nextBtn) nextBtn.classList.remove('hidden');
            const backBtn = document.getElementById('connectionBackBtn');
            if (backBtn) backBtn.disabled = true;

            const title = document.getElementById('connectionModalTitle');
            if (title) title.textContent = 'Create Relationship';
        }

        function updateWizardSteps(currentStep) {
            document.querySelectorAll('.wizard-step').forEach(step => {
                const stepNum = parseInt(step.dataset.step);
                step.classList.remove('active', 'completed');
                if (stepNum === currentStep) {
                    step.classList.add('active');
                } else if (stepNum < currentStep) {
                    step.classList.add('completed');
                }
            });
        }

        function showWizardStep(stepNum) {
            for (let i = 1; i <= 4; i++) {
                const panel = document.getElementById(`connectionStep${i}`);
                if (panel) {
                    panel.classList.toggle('hidden', i !== stepNum);
                }
            }
            connectionWizardState.currentStep = stepNum;
            updateWizardSteps(stepNum);

            // Update buttons
            const backBtn = document.getElementById('connectionBackBtn');
            const nextBtn = document.getElementById('connectionNextBtn');
            const submitBtn = document.getElementById('connectionSubmit');

            if (backBtn) backBtn.disabled = stepNum === 1;

            if (stepNum === 4) {
                nextBtn?.classList.add('hidden');
                submitBtn?.classList.remove('hidden');
                updateReviewPanel();
            } else {
                nextBtn?.classList.remove('hidden');
                submitBtn?.classList.add('hidden');
            }

            // Render step content
            if (stepNum === 1) {
                renderEntitySelectionPanel('connectionSubjectPanel', 'subject', connectionWizardState.subjectPath);
                setupEntitySearchListener('connectionSubjectSearch', 'connectionSubjectPanel', 'subject');
            } else if (stepNum === 2) {
                renderRelationSelectionPanel();
                setupRelationSearchListener();
            } else if (stepNum === 3) {
                renderEntitySelectionPanel('connectionOperandPanel', 'operand', connectionWizardState.operandPath);
                setupEntitySearchListener('connectionOperandSearch', 'connectionOperandPanel', 'operand');
            }
        }

        function connectionWizardNext() {
            const step = connectionWizardState.currentStep;

            // Validate current step
            if (step === 1 && !connectionWizardState.selectedSubject) {
                showToast('Please select a subject entity');
                return;
            }
            if (step === 2 && !connectionWizardState.selectedRelation) {
                showToast('Please select a relation type');
                return;
            }
            if (step === 3 && !connectionWizardState.selectedOperand) {
                showToast('Please select an operand entity');
                return;
            }

            if (step < 4) {
                showWizardStep(step + 1);
            }
        }

        function connectionWizardBack() {
            const step = connectionWizardState.currentStep;
            if (step > 1) {
                showWizardStep(step - 1);
            }
        }

        function renderEntitySelectionPanel(containerId, type, currentPath) {
            const container = document.getElementById(containerId);
            if (!container) return;

            let html = '';

            // Breadcrumb
            if (currentPath.length > 0) {
                html += '<div class="hierarchy-breadcrumb">';
                html += `<span class="hierarchy-breadcrumb-item" data-path-index="-1">All</span>`;
                currentPath.forEach((item, idx) => {
                    html += '<span class="hierarchy-breadcrumb-sep">/</span>';
                    const isCurrent = idx === currentPath.length - 1;
                    html += `<span class="hierarchy-breadcrumb-item ${isCurrent ? 'current' : ''}" data-path-index="${idx}">${escapeHtml(item.name)}</span>`;
                });
                html += '</div>';
            }

            const level = currentPath.length;

            if (level === 0) {
                // Show sets
                const sets = getSetsForWorld();
                if (!sets.length) {
                    html += '<div class="text-sm text-gray-500 py-4 text-center">No sets found. Create a set first.</div>';
                } else {
                    html += '<div class="entity-selection-grid">';
                    sets.forEach(set => {
                        const recordCount = set.records.size;
                        html += `
                            <div class="entity-selection-item drill-down" data-action="drill" data-type="set" data-id="${set.id}" data-name="${escapeHtml(set.name)}">
                                <div class="entity-icon"></div>
                                <div class="entity-info">
                                    <div class="entity-name">${escapeHtml(set.name)}</div>
                                    <div class="entity-meta">${recordCount} record${recordCount !== 1 ? 's' : ''}</div>
                                </div>
                                <svg class="w-5 h-5 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>
                                </svg>
                            </div>
                        `;
                    });
                    html += '</div>';
                }
            } else if (level === 1) {
                // Show records for selected set
                const setId = currentPath[0].id;
                const set = state.sets.get(setId);
                if (!set) {
                    html += '<div class="text-sm text-gray-500 py-4 text-center">Set not found.</div>';
                } else {
                    const records = Array.from(set.records.values());
                    if (!records.length) {
                        html += '<div class="text-sm text-gray-500 py-4 text-center">No records in this set.</div>';
                    } else {
                        html += '<div class="entity-selection-grid">';
                        records.forEach(record => {
                            const displayName = getRecordDisplayName(record.id) || record.id;
                            const isSelected = type === 'subject'
                                ? connectionWizardState.selectedSubject?.id === record.id
                                : connectionWizardState.selectedOperand?.id === record.id;

                            html += `
                                <div class="entity-selection-item ${isSelected ? 'selected' : ''}"
                                     data-action="select"
                                     data-type="Record"
                                     data-id="${record.id}"
                                     data-name="${escapeHtml(displayName)}"
                                     data-set-id="${setId}">
                                    <div class="entity-icon"></div>
                                    <div class="entity-info">
                                        <div class="entity-name">${escapeHtml(displayName)}</div>
                                        <div class="entity-meta">Record in ${escapeHtml(set.name)}</div>
                                    </div>
                                </div>
                            `;
                        });
                        html += '</div>';
                    }
                }
            }

            container.innerHTML = html;

            // Add click handlers
            container.querySelectorAll('.entity-selection-item').forEach(item => {
                item.addEventListener('click', () => {
                    const action = item.dataset.action;
                    const itemType = item.dataset.type;
                    const itemId = item.dataset.id;
                    const itemName = item.dataset.name;

                    if (action === 'drill') {
                        if (type === 'subject') {
                            connectionWizardState.subjectPath.push({ type: itemType, id: itemId, name: itemName });
                            renderEntitySelectionPanel(containerId, type, connectionWizardState.subjectPath);
                        } else {
                            connectionWizardState.operandPath.push({ type: itemType, id: itemId, name: itemName });
                            renderEntitySelectionPanel(containerId, type, connectionWizardState.operandPath);
                        }
                    } else if (action === 'select') {
                        selectEntity(type, { type: itemType, id: itemId, name: itemName, setId: item.dataset.setId });
                    }
                });
            });

            // Breadcrumb navigation
            container.querySelectorAll('.hierarchy-breadcrumb-item:not(.current)').forEach(item => {
                item.addEventListener('click', () => {
                    const pathIndex = parseInt(item.dataset.pathIndex);
                    if (type === 'subject') {
                        connectionWizardState.subjectPath = pathIndex < 0 ? [] : connectionWizardState.subjectPath.slice(0, pathIndex + 1);
                        renderEntitySelectionPanel(containerId, type, connectionWizardState.subjectPath);
                    } else {
                        connectionWizardState.operandPath = pathIndex < 0 ? [] : connectionWizardState.operandPath.slice(0, pathIndex + 1);
                        renderEntitySelectionPanel(containerId, type, connectionWizardState.operandPath);
                    }
                });
            });
        }

        function selectEntity(type, entity) {
            if (type === 'subject') {
                connectionWizardState.selectedSubject = entity;
                document.getElementById('connectionSubjectId').value = entity.id;
                document.getElementById('connectionSubjectType').value = entity.type;

                // Update preview
                const preview = document.getElementById('subjectPreview');
                if (preview) {
                    preview.classList.remove('hidden');
                    document.getElementById('subjectPreviewName').textContent = entity.name;
                    document.getElementById('subjectPreviewMeta').textContent = `${entity.type}  ${entity.id.substring(0, 30)}...`;
                }
            } else {
                connectionWizardState.selectedOperand = entity;
                document.getElementById('connectionOperandId').value = entity.id;
                document.getElementById('connectionOperandType').value = entity.type;

                // Update preview
                const preview = document.getElementById('operandPreview');
                if (preview) {
                    preview.classList.remove('hidden');
                    document.getElementById('operandPreviewName').textContent = entity.name;
                    document.getElementById('operandPreviewMeta').textContent = `${entity.type}  ${entity.id.substring(0, 30)}...`;
                }
            }

            // Refresh panel to show selected state
            if (type === 'subject') {
                renderEntitySelectionPanel('connectionSubjectPanel', 'subject', connectionWizardState.subjectPath);
            } else {
                renderEntitySelectionPanel('connectionOperandPanel', 'operand', connectionWizardState.operandPath);
            }
        }

        function renderRelationSelectionPanel() {
            const container = document.getElementById('connectionRelationPanel');
            if (!container) return;

            const relations = getConnectionRelationView();

            if (!relations.length) {
                container.innerHTML = `
                    <div class="text-center py-8">
                        <p class="text-sm text-gray-500 mb-4">No relation types defined yet.</p>
                        <button type="button" class="btn btn-secondary btn-sm" onclick="openConnectionRelationModal(); return false;">
                            + Create Relation Type
                        </button>
                    </div>
                `;
                return;
            }

            let html = '<div class="relation-selection-grid">';
            relations.forEach(rel => {
                const operatorInfo = state.connectionModes?.operators?.[rel.operator] || {};
                const isSelected = connectionWizardState.selectedRelation?.id === rel.id;

                html += `
                    <div class="relation-selection-item ${isSelected ? 'selected' : ''}" data-relation-id="${rel.id}">
                        <div class="relation-header">
                            <span class="relation-mode">${escapeHtml(rel.mode)}</span>
                            <span class="relation-operator">${operatorInfo.symbol || ''} ${rel.operator}</span>
                        </div>
                        ${rel.description ? `<div class="relation-description">${escapeHtml(rel.description)}</div>` : ''}
                    </div>
                `;
            });
            html += '</div>';

            container.innerHTML = html;

            // Add click handlers
            container.querySelectorAll('.relation-selection-item').forEach(item => {
                item.addEventListener('click', () => {
                    const relationId = item.dataset.relationId;
                    const relation = findConnectionRelation(relationId);
                    if (relation) {
                        selectRelation(relation);
                    }
                });
            });
        }

        function selectRelation(relation) {
            connectionWizardState.selectedRelation = relation;
            state.connectionFormState.selectedRelationId = relation.id;
            document.getElementById('connectionRelationSelect').value = relation.id;

            // Update preview
            const preview = document.getElementById('relationPreview');
            if (preview) {
                preview.classList.remove('hidden');
                const operatorInfo = state.connectionModes?.operators?.[relation.operator] || {};
                document.getElementById('relationPreviewName').textContent = relation.mode;
                document.getElementById('relationPreviewMeta').textContent = `${operatorInfo.symbol || ''} ${relation.operator} - ${operatorInfo.name || ''}`;
            }

            // Render params if needed
            renderConnectionParamFields('connectionParamFields', relation.id, {});

            // Refresh panel to show selected state
            renderRelationSelectionPanel();
        }

        function setupEntitySearchListener(searchId, panelId, type) {
            const searchInput = document.getElementById(searchId);
            if (!searchInput) return;

            // Remove old listeners by cloning
            const newInput = searchInput.cloneNode(true);
            searchInput.parentNode.replaceChild(newInput, searchInput);

            newInput.addEventListener('input', (e) => {
                const query = e.target.value.trim().toLowerCase();
                if (!query) {
                    // Show normal hierarchy
                    const path = type === 'subject' ? connectionWizardState.subjectPath : connectionWizardState.operandPath;
                    renderEntitySelectionPanel(panelId, type, path);
                    return;
                }

                // Search entities
                const results = searchEntitiesForWizard(query);
                renderEntitySearchResults(panelId, type, results);
            });
        }

        function searchEntitiesForWizard(query) {
            const results = [];
            const lowerQuery = query.toLowerCase();

            // Search all sets and their records
            for (const [setId, set] of state.sets) {
                // Check set name
                if (set.name.toLowerCase().includes(lowerQuery)) {
                    results.push({
                        type: 'Set',
                        id: setId,
                        name: set.name,
                        meta: `${set.records.size} records`
                    });
                }

                // Search records
                for (const [recordId, record] of set.records) {
                    const displayName = getRecordDisplayName(recordId) || recordId;
                    if (displayName.toLowerCase().includes(lowerQuery)) {
                        results.push({
                            type: 'Record',
                            id: recordId,
                            name: displayName,
                            meta: `in ${set.name}`,
                            setId: setId
                        });
                    }
                }
            }

            // Also search reified entities
            for (const [entityId, entity] of state.entities) {
                const name = getEntityDisplayName(entity);
                if (name.toLowerCase().includes(lowerQuery)) {
                    results.push({
                        type: entity.entityType || 'Entity',
                        id: entityId,
                        name: name,
                        meta: entity.entityType || 'Reified Entity'
                    });
                }
            }

            return results.slice(0, 20); // Limit results
        }

        function renderEntitySearchResults(containerId, type, results) {
            const container = document.getElementById(containerId);
            if (!container) return;

            if (!results.length) {
                container.innerHTML = '<div class="text-sm text-gray-500 py-4 text-center">No matching entities found.</div>';
                return;
            }

            let html = '<div class="entity-selection-grid">';
            results.forEach(result => {
                const isSelected = type === 'subject'
                    ? connectionWizardState.selectedSubject?.id === result.id
                    : connectionWizardState.selectedOperand?.id === result.id;

                const icon = result.type === 'Set' ? '' : result.type === 'Record' ? '' : '';

                html += `
                    <div class="entity-selection-item ${isSelected ? 'selected' : ''}"
                         data-action="select"
                         data-type="${result.type}"
                         data-id="${result.id}"
                         data-name="${escapeHtml(result.name)}"
                         data-set-id="${result.setId || ''}">
                        <div class="entity-icon">${icon}</div>
                        <div class="entity-info">
                            <div class="entity-name">${escapeHtml(result.name)}</div>
                            <div class="entity-meta">${escapeHtml(result.meta)}</div>
                        </div>
                    </div>
                `;
            });
            html += '</div>';

            container.innerHTML = html;

            // Add click handlers
            container.querySelectorAll('.entity-selection-item').forEach(item => {
                item.addEventListener('click', () => {
                    selectEntity(type, {
                        type: item.dataset.type,
                        id: item.dataset.id,
                        name: item.dataset.name,
                        setId: item.dataset.setId
                    });
                });
            });
        }

        function setupRelationSearchListener() {
            const searchInput = document.getElementById('connectionRelationSearch');
            if (!searchInput) return;

            // Remove old listeners by cloning
            const newInput = searchInput.cloneNode(true);
            searchInput.parentNode.replaceChild(newInput, searchInput);

            newInput.addEventListener('input', (e) => {
                const query = e.target.value.trim().toLowerCase();
                if (!query) {
                    renderRelationSelectionPanel();
                    return;
                }

                // Filter relations
                const allRelations = getConnectionRelationView();
                const filtered = allRelations.filter(rel =>
                    rel.mode.toLowerCase().includes(query) ||
                    rel.operator.toLowerCase().includes(query) ||
                    (rel.description && rel.description.toLowerCase().includes(query))
                );

                renderFilteredRelations(filtered);
            });
        }

        function renderFilteredRelations(relations) {
            const container = document.getElementById('connectionRelationPanel');
            if (!container) return;

            if (!relations.length) {
                container.innerHTML = '<div class="text-sm text-gray-500 py-4 text-center">No matching relations found.</div>';
                return;
            }

            let html = '<div class="relation-selection-grid">';
            relations.forEach(rel => {
                const operatorInfo = state.connectionModes?.operators?.[rel.operator] || {};
                const isSelected = connectionWizardState.selectedRelation?.id === rel.id;

                html += `
                    <div class="relation-selection-item ${isSelected ? 'selected' : ''}" data-relation-id="${rel.id}">
                        <div class="relation-header">
                            <span class="relation-mode">${escapeHtml(rel.mode)}</span>
                            <span class="relation-operator">${operatorInfo.symbol || ''} ${rel.operator}</span>
                        </div>
                        ${rel.description ? `<div class="relation-description">${escapeHtml(rel.description)}</div>` : ''}
                    </div>
                `;
            });
            html += '</div>';

            container.innerHTML = html;

            container.querySelectorAll('.relation-selection-item').forEach(item => {
                item.addEventListener('click', () => {
                    const relationId = item.dataset.relationId;
                    const relation = findConnectionRelation(relationId);
                    if (relation) {
                        selectRelation(relation);
                    }
                });
            });
        }

        function updateReviewPanel() {
            const subject = connectionWizardState.selectedSubject;
            const relation = connectionWizardState.selectedRelation;
            const operand = connectionWizardState.selectedOperand;

            if (subject) {
                document.getElementById('reviewSubjectName').textContent = subject.name;
                document.getElementById('reviewSubjectType').textContent = subject.type;
            }

            if (relation) {
                document.getElementById('reviewRelationName').textContent = relation.mode;
            }

            if (operand) {
                document.getElementById('reviewOperandName').textContent = operand.name;
                document.getElementById('reviewOperandType').textContent = operand.type;
            }
        }

        function renderEntityDropdown(containerId, entities, onSelect, options = {}) {
            const container = document.getElementById(containerId);
            if (!container) return;

            const isSearchMode = options.searchMode !== false;

            if (!entities.length && isSearchMode) {
                container.innerHTML = '<div class="p-3 text-sm text-gray-500">No entities found. Reify a view to create entities.</div>';
                container.classList.remove('hidden');
                return;
            }

            container.innerHTML = entities.map(entity => {
                const name = getEntityDisplayName(entity);
                const type = entity.entityType || entity.type || 'Entity';
                const origin = entity.origin === 'reified' ? '(reified)' : '';
                return `
                    <div class="entity-option px-3 py-2 hover:bg-gray-100 cursor-pointer border-b border-gray-100 last:border-0"
                         data-entity-id="${entity.id}" data-entity-type="${type}">
                        <div class="font-medium text-gray-900">${escapeHtml(name)}</div>
                        <div class="text-xs text-gray-500">${escapeHtml(type)} ${origin}  ${entity.id.substring(0, 20)}...</div>
                    </div>
                `;
            }).join('');

            container.classList.remove('hidden');

            // Add click handlers
            container.querySelectorAll('.entity-option').forEach(option => {
                option.addEventListener('click', () => {
                    const entityId = option.dataset.entityId;
                    const entityType = option.dataset.entityType;
                    onSelect(entityId, entityType, entities.find(e => e.id === entityId));
                });
            });
        }

        // Track drill-down state to prevent blur from hiding dropdown during navigation
        let hierarchyDrilldownActive = false;

        function renderHierarchicalEntityBrowser(containerId, onSelect, currentPath = []) {
            const container = document.getElementById(containerId);
            if (!container) return;

            let html = '';

            // Breadcrumb navigation
            if (currentPath.length > 0) {
                html += '<div class="px-3 py-2 bg-gray-50 border-b border-gray-200 flex items-center gap-2 text-sm">';
                html += '<button class="hierarchy-back text-blue-600 hover:text-blue-800 font-medium"> Back</button>';
                html += '<span class="text-gray-400">|</span>';
                html += '<span class="text-gray-600">' + currentPath.map(p => escapeHtml(p.name)).join(' > ') + '</span>';
                html += '</div>';
            }

            const level = currentPath.length;

            if (level === 0) {
                // Show sets
                const sets = getSetsForWorld();
                if (!sets.length) {
                    html += '<div class="p-3 text-sm text-gray-500">No sets found. Create a set first.</div>';
                } else {
                    html += '<div class="px-3 py-2 bg-gray-100 text-xs font-semibold text-gray-600 sticky top-0">Select a Set</div>';
                    sets.forEach(set => {
                        const recordCount = set.records.size;
                        html += `
                            <div class="hierarchy-item px-3 py-2 hover:bg-blue-50 cursor-pointer border-b border-gray-100 last:border-0 flex justify-between items-center"
                                 data-type="set" data-id="${set.id}">
                                <div>
                                    <div class="font-medium text-gray-900">${escapeHtml(set.name)}</div>
                                    <div class="text-xs text-gray-500">${recordCount} record${recordCount !== 1 ? 's' : ''}</div>
                                </div>
                                <svg class="w-4 h-4 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>
                                </svg>
                            </div>
                        `;
                    });
                }
            } else if (level === 1) {
                // Show views for selected set
                const setId = currentPath[0].id;
                const set = state.sets.get(setId);
                if (!set) {
                    html += '<div class="p-3 text-sm text-gray-500">Set not found.</div>';
                } else {
                    const views = Array.from(set.views.values());
                    if (!views.length) {
                        html += '<div class="p-3 text-sm text-gray-500">No views found in this set.</div>';
                    } else {
                        html += '<div class="px-3 py-2 bg-gray-100 text-xs font-semibold text-gray-600 sticky top-0">Select a View</div>';
                        views.forEach(view => {
                            html += `
                                <div class="hierarchy-item px-3 py-2 hover:bg-blue-50 cursor-pointer border-b border-gray-100 last:border-0 flex justify-between items-center"
                                     data-type="view" data-id="${view.id}" data-set-id="${setId}">
                                    <div>
                                        <div class="font-medium text-gray-900">${escapeHtml(view.name)}</div>
                                        <div class="text-xs text-gray-500">View in ${escapeHtml(set.name)}</div>
                                    </div>
                                    <svg class="w-4 h-4 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>
                                    </svg>
                                </div>
                            `;
                        });
                    }
                }
            } else if (level === 2) {
                // Show records for selected view
                const setId = currentPath[0].id;
                const viewId = currentPath[1].id;
                const set = state.sets.get(setId);
                if (!set) {
                    html += '<div class="p-3 text-sm text-gray-500">Set not found.</div>';
                } else {
                    const records = Array.from(set.records.values());
                    if (!records.length) {
                        html += '<div class="p-3 text-sm text-gray-500">No records found. Reify this view to create records.</div>';
                    } else {
                        html += '<div class="px-3 py-2 bg-gray-100 text-xs font-semibold text-gray-600 sticky top-0">Select a Record</div>';
                        records.forEach(record => {
                            const displayName = getRecordDisplayName(record.id) || 'Unnamed Record';
                            html += `
                                <div class="hierarchy-item px-3 py-2 hover:bg-blue-50 cursor-pointer border-b border-gray-100 last:border-0"
                                     data-type="record" data-id="${record.id}">
                                    <div class="font-medium text-gray-900">${escapeHtml(displayName)}</div>
                                    <div class="text-xs text-gray-500">Record  ${record.id.substring(0, 20)}...</div>
                                </div>
                            `;
                        });
                    }
                }
            }

            container.innerHTML = html;
            container.classList.remove('hidden');

            // Add click handler for back button
            const backButton = container.querySelector('.hierarchy-back');
            if (backButton) {
                backButton.addEventListener('click', (e) => {
                    e.stopPropagation();
                    // Set flag to prevent blur from hiding dropdown during navigation
                    hierarchyDrilldownActive = true;
                    const newPath = currentPath.slice(0, -1);
                    renderHierarchicalEntityBrowser(containerId, onSelect, newPath);
                    // Reset flag after a short delay
                    setTimeout(() => { hierarchyDrilldownActive = false; }, 50);
                });
            }

            // Add click handlers for items
            container.querySelectorAll('.hierarchy-item').forEach(item => {
                item.addEventListener('click', () => {
                    const type = item.dataset.type;
                    const id = item.dataset.id;

                    if (type === 'set') {
                        const set = state.sets.get(id);
                        if (!set) {
                            console.error(`Set not found: ${id}`);
                            return;
                        }
                        // Set flag to prevent blur from hiding dropdown during drill-down
                        hierarchyDrilldownActive = true;
                        renderHierarchicalEntityBrowser(containerId, onSelect, [...currentPath, { type: 'Set', id, name: set.name }]);
                        // Reset flag after a short delay
                        setTimeout(() => { hierarchyDrilldownActive = false; }, 50);
                    } else if (type === 'view') {
                        const setId = item.dataset.setId;
                        const set = state.sets.get(setId);
                        const view = set?.views.get(id);
                        if (!view) {
                            console.error(`View not found: ${id} in set ${setId}`);
                            return;
                        }
                        // Set flag to prevent blur from hiding dropdown during drill-down
                        hierarchyDrilldownActive = true;
                        renderHierarchicalEntityBrowser(containerId, onSelect, [...currentPath, { type: 'View', id, name: view.name }]);
                        // Reset flag after a short delay
                        setTimeout(() => { hierarchyDrilldownActive = false; }, 50);
                    } else if (type === 'record') {
                        // Final selection - call the onSelect callback
                        const entity = { id, type: 'Record', entityType: 'Record' };
                        onSelect(id, 'Record', entity);
                    }
                });
            });
        }

        function renderRelationDropdown(containerId, relations, onSelect) {
            const container = document.getElementById(containerId);
            if (!container) return;

            if (!relations.length) {
                container.innerHTML = '<div class="p-3 text-sm text-gray-500">No relations found.</div>';
                container.classList.remove('hidden');
                return;
            }

            // Group by operator for better organization
            const grouped = {};
            relations.forEach(rel => {
                if (!grouped[rel.operator]) grouped[rel.operator] = [];
                grouped[rel.operator].push(rel);
            });

            let html = '';
            Object.entries(grouped).forEach(([operator, rels]) => {
                const operatorInfo = state.connectionModes?.operators?.[operator] || { name: operator, symbol: operator };
                html += `<div class="px-3 py-1 bg-gray-50 text-xs font-medium text-gray-600 sticky top-0">${operatorInfo.symbol || operator} ${operatorInfo.name || operator}</div>`;
                rels.forEach(rel => {
                    const domainLabel = state.relationshipDomains[rel.domain] || rel.domain;
                    html += `
                        <div class="relation-option px-3 py-2 hover:bg-blue-50 cursor-pointer border-b border-gray-100 last:border-0"
                             data-relation-id="${rel.id}" data-relation-name="${escapeHtml(rel.name)}" data-relation-operator="${rel.operator}">
                            <div class="font-medium text-gray-900">${escapeHtml(rel.name)}</div>
                            <div class="text-xs text-gray-500">${domainLabel}</div>
                        </div>
                    `;
                });
            });

            container.innerHTML = html;
            container.classList.remove('hidden');

            // Add click handlers
            container.querySelectorAll('.relation-option').forEach(option => {
                option.addEventListener('click', () => {
                    const relationId = option.dataset.relationId;
                    const relationName = option.dataset.relationName;
                    const operator = option.dataset.relationOperator;
                    onSelect(relationId, relationName, operator);
                });
            });
        }

        function setupEntitySearchHandlers() {
            // Subject entity search
            const subjectSearch = document.getElementById('connectionSubjectSearch');
            const subjectDropdown = document.getElementById('connectionSubjectDropdown');
            const subjectIdInput = document.getElementById('connectionSubjectId');
            const subjectTypeInput = document.getElementById('connectionSubjectType');
            const subjectInfo = document.getElementById('connectionSubjectInfo');

            if (subjectSearch) {
                const onSubjectSelect = (id, type, entity) => {
                    subjectSearch.value = getEntityDisplayName(entity);
                    subjectIdInput.value = id;
                    subjectTypeInput.value = type;
                    subjectInfo.textContent = `${type}  ${id}`;
                    subjectDropdown.classList.add('hidden');
                };

                subjectSearch.addEventListener('input', (e) => {
                    const query = e.target.value;
                    if (query.trim().length > 0) {
                        // Search mode - show matching entities
                        const results = searchEntities(query);
                        renderEntityDropdown('connectionSubjectDropdown', results, onSubjectSelect, { searchMode: true });
                    } else {
                        // Drill-down mode - show hierarchical browser
                        renderHierarchicalEntityBrowser('connectionSubjectDropdown', onSubjectSelect);
                    }
                });

                subjectSearch.addEventListener('focus', () => {
                    const query = subjectSearch.value;
                    if (query.trim().length > 0) {
                        const results = searchEntities(query);
                        renderEntityDropdown('connectionSubjectDropdown', results, onSubjectSelect, { searchMode: true });
                    } else {
                        renderHierarchicalEntityBrowser('connectionSubjectDropdown', onSubjectSelect);
                    }
                });

                subjectSearch.addEventListener('blur', () => {
                    setTimeout(() => {
                        // Don't hide if we're in the middle of a drill-down operation
                        if (!hierarchyDrilldownActive) {
                            subjectDropdown?.classList.add('hidden');
                        }
                    }, 200);
                });
            }

            // Operand entity search
            const operandSearch = document.getElementById('connectionOperandSearch');
            const operandDropdown = document.getElementById('connectionOperandDropdown');
            const operandIdInput = document.getElementById('connectionOperandId');
            const operandTypeInput = document.getElementById('connectionOperandType');
            const operandInfo = document.getElementById('connectionOperandInfo');

            if (operandSearch) {
                const onOperandSelect = (id, type, entity) => {
                    operandSearch.value = getEntityDisplayName(entity);
                    operandIdInput.value = id;
                    operandTypeInput.value = type;
                    operandInfo.textContent = `${type}  ${id}`;
                    operandDropdown.classList.add('hidden');
                };

                operandSearch.addEventListener('input', (e) => {
                    const query = e.target.value;
                    if (query.trim().length > 0) {
                        // Search mode - show matching entities
                        const results = searchEntities(query);
                        renderEntityDropdown('connectionOperandDropdown', results, onOperandSelect, { searchMode: true });
                    } else {
                        // Drill-down mode - show hierarchical browser
                        renderHierarchicalEntityBrowser('connectionOperandDropdown', onOperandSelect);
                    }
                });

                operandSearch.addEventListener('focus', () => {
                    const query = operandSearch.value;
                    if (query.trim().length > 0) {
                        const results = searchEntities(query);
                        renderEntityDropdown('connectionOperandDropdown', results, onOperandSelect, { searchMode: true });
                    } else {
                        renderHierarchicalEntityBrowser('connectionOperandDropdown', onOperandSelect);
                    }
                });

                operandSearch.addEventListener('blur', () => {
                    setTimeout(() => {
                        // Don't hide if we're in the middle of a drill-down operation
                        if (!hierarchyDrilldownActive) {
                            operandDropdown?.classList.add('hidden');
                        }
                    }, 200);
                });
            }

            // Relation search
            const relationSearch = document.getElementById('connectionRelationSearch');
            const relationDropdown = document.getElementById('connectionRelationDropdown');
            const relationSelect = document.getElementById('connectionRelationSelect');
            const relationSummary = document.getElementById('connectionRelationSummary');

            if (relationSearch) {
                relationSearch.addEventListener('input', (e) => {
                    const query = e.target.value;
                    const results = searchRelationshipTypes(query);
                    renderRelationDropdown('connectionRelationDropdown', results, (id, name, operator) => {
                        relationSearch.value = name;
                        // Create or find a connection relation for this relationship type
                        const relationId = ensureConnectionRelationExists(name, operator);
                        relationSelect.value = relationId;
                        state.connectionFormState.selectedRelationId = relationId;
                        state.connectionFormState.selectedRelationType = { id, name, operator };
                        const operatorInfo = state.connectionModes?.operators?.[operator] || {};
                        relationSummary.textContent = `${operatorInfo.symbol || operator} ${operatorInfo.name || operator}`;
                        relationDropdown.classList.add('hidden');
                        renderConnectionParamFields('connectionParamFields', relationId, {});
                    });
                });

                relationSearch.addEventListener('focus', () => {
                    const results = searchRelationshipTypes(relationSearch.value);
                    renderRelationDropdown('connectionRelationDropdown', results, (id, name, operator) => {
                        relationSearch.value = name;
                        const relationId = ensureConnectionRelationExists(name, operator);
                        relationSelect.value = relationId;
                        state.connectionFormState.selectedRelationId = relationId;
                        state.connectionFormState.selectedRelationType = { id, name, operator };
                        const operatorInfo = state.connectionModes?.operators?.[operator] || {};
                        relationSummary.textContent = `${operatorInfo.symbol || operator} ${operatorInfo.name || operator}`;
                        relationDropdown.classList.add('hidden');
                        renderConnectionParamFields('connectionParamFields', relationId, {});
                    });
                });

                relationSearch.addEventListener('blur', () => {
                    setTimeout(() => relationDropdown?.classList.add('hidden'), 200);
                });
            }
        }

        function ensureConnectionRelationExists(modeName, operator) {
            // Check if a relation with this mode already exists
            const existing = getConnectionRelationView(rel => rel.mode === modeName && rel.operator === operator);
            if (existing.length) return existing[0].id;

            // Create a new connection relation
            const newRelation = {
                operator,
                mode: modeName,
                name: modeName,
                description: `${modeName} (${operator} operator)`,
                requiredParams: [],
                optionalParams: []
            };

            return addConnectionRelation(newRelation);
        }

        function updateConnectionRelationSummary(relationId) {
            const summary = document.getElementById('connectionRelationSummary');
            const relation = relationId ? findConnectionRelation(relationId) : null;
            if (!summary) return;
            if (relation) {
                const operatorInfo = state.connectionModes?.operators?.[relation.operator] || {};
                summary.textContent = `${operatorInfo.symbol || relation.operator} ${operatorInfo.name || relation.operator} - ${relation.description || ''}`;
            } else {
                summary.textContent = '';
            }
        }

        function openConnectionModal(connId = null) {
            resetConnectionForm();
            if (connId) {
                populateConnectionForm(connId);
                // For editing, skip to review step
                // Note: populateConnectionForm will set up the wizard state
            }
            openModal('connectionModal');
            // Initialize first step
            showWizardStep(1);
            const searchInput = document.getElementById('connectionSubjectSearch');
            if (searchInput) searchInput.focus();
        }

        function collectParamsFromInputs(containerId, relation) {
            const container = document.getElementById(containerId);
            const params = {};
            if (!container || !relation) return params;

            const inputs = container.querySelectorAll('[data-param-name]');
            for (const input of inputs) {
                const name = input.dataset.paramName;
                const required = input.dataset.paramRequired === 'true';
                const rawValue = (input.value || '').trim();
                if (!rawValue) {
                    if (required) throw new Error(`Missing required param: ${name}`);
                    continue;
                }

                try {
                    params[name] = JSON.parse(rawValue);
                } catch (err) {
                    params[name] = rawValue;
                }
            }

            return params;
        }

        function handleConnectionFormSubmit() {
            const form = document.getElementById('connectionForm');
            if (!form) return;

            // Use the stored relation ID or get from hidden field
            const relationId = state.connectionFormState.selectedRelationId || form.querySelector('#connectionRelationSelect')?.value;
            if (!relationId) {
                showToast('Please select a relation type');
                return;
            }

            const relation = findConnectionRelation(relationId);
            if (!relation) {
                showToast('Selected relation type not found');
                return;
            }

            // Get subject entity
            const subjectId = form.querySelector('#connectionSubjectId')?.value?.trim();
            const subjectType = form.querySelector('#connectionSubjectType')?.value || 'Entity';
            if (!subjectId) {
                showToast('Please select a subject entity');
                return;
            }

            // Get operand entity
            const operandId = form.querySelector('#connectionOperandId')?.value?.trim();
            const operandType = form.querySelector('#connectionOperandType')?.value || 'Entity';
            if (!operandId) {
                showToast('Please select an operand entity');
                return;
            }

            let params = {};
            try {
                params = collectParamsFromInputs('connectionParamFields', relation);
            } catch (error) {
                showToast(error.message);
                return;
            }

            const payload = {
                id: state.connectionFormState.editingId,
                relationId,
                subject: { type: subjectType, id: subjectId },
                operand: { type: operandType, id: operandId },
                description: form.querySelector('#connectionDescription')?.value?.trim() || '',
                params
            };

            if (state.connectionFormState.editingId) {
                updateConnection(payload.id, payload);
                showToast('Relationship updated');
            } else {
                addConnection(payload);
                showToast('Relationship added');
            }

            resetConnectionForm();
            closeModal('connectionModal');
            renderRelationsPage(state.connectionFormState.activeFilter || 'all');
        }

        function renderRelationTypesList(relations) {
            if (!relations.length) return '<p class="text-sm text-gray-500">No relation types defined yet.</p>';
            return `
                <div class="space-y-2">
                    ${relations.map(rel => `
                        <div class="flex items-center justify-between py-2 px-3 bg-gray-50 rounded-lg">
                            <div class="flex items-center gap-3">
                                <span class="text-sm font-medium text-gray-900">${rel.mode}</span>
                                <span class="text-xs px-2 py-0.5 bg-gray-200 text-gray-600 rounded">${rel.operator}</span>
                                ${rel.description ? `<span class="text-xs text-gray-500">${rel.description}</span>` : ''}
                            </div>
                        </div>
                    `).join('')}
                </div>
            `;
        }

        function renderRelationshipCards(relationships) {
            if (!relationships.length) return '<p class="text-sm text-gray-500 py-8 text-center">No relationships yet. Click "Add" to create one.</p>';
            return `
                <div class="space-y-3">
                    ${relationships.map(conn => {
                        const relation = findConnectionRelation(conn.relationId);
                        const mode = relation?.mode || conn.mode || 'relates to';
                        return `
                            <div class="border border-gray-200 rounded-lg p-4 bg-white hover:border-gray-300 transition-colors">
                                <div class="flex items-start justify-between gap-4">
                                    <div class="flex-1 min-w-0">
                                        <div class="flex items-center gap-2 flex-wrap">
                                            <span class="font-medium text-gray-900">${renderEntityLabel(conn.subject)}</span>
                                            <span class="text-gray-400"></span>
                                            <span class="text-sm text-blue-600 font-medium">${mode}</span>
                                            <span class="text-gray-400"></span>
                                            <span class="font-medium text-gray-900">${renderEntityLabel(conn.operand)}</span>
                                        </div>
                                        ${conn.description ? `<p class="text-sm text-gray-500 mt-1">${conn.description}</p>` : ''}
                                    </div>
                                    <div class="flex items-center gap-2 flex-shrink-0">
                                        <button class="text-sm text-blue-600 hover:text-blue-800" data-conn-edit="${conn.id}">Edit</button>
                                        <button class="text-sm text-red-500 hover:text-red-700" data-conn-delete="${conn.id}">Delete</button>
                                    </div>
                                </div>
                            </div>
                        `;
                    }).join('')}
                </div>
            `;
        }

        function renderRelationsPage(filterKey = 'all') {
            state.connectionFormState.activeFilter = filterKey;
            // Build filters dynamically from EO_OPERATORS
            const filters = {
                all: () => true
            };

            // Add a filter for each of the 9 EO operators
            if (typeof EO_OPERATORS !== 'undefined') {
                Object.keys(EO_OPERATORS).forEach(opCode => {
                    filters[opCode.toLowerCase()] = conn => conn.operator === opCode;
                });
            } else {
                // Fallback if EO_OPERATORS not loaded
                ['NUL', 'DES', 'INS', 'SEG', 'CON', 'ALT', 'SYN', 'SUP', 'REC'].forEach(opCode => {
                    filters[opCode.toLowerCase()] = conn => conn.operator === opCode;
                });
            }

            const relationTypes = getConnectionRelationView();
            const relationships = getConnectionView(filters[filterKey]);
            const container = document.getElementById('viewContainer');

            container.innerHTML = `
                <div class="view-stage-header">
                    <div class="view-stage-title">
                        <span class="view-stage-pill">${getWorld()?.name || 'World'}</span>
                        <div class="min-w-0">
                            <div class="view-stage-name">Relations</div>
                            <div class="view-stage-sub">${relationships.length} relationship${relationships.length !== 1 ? 's' : ''}</div>
                        </div>
                    </div>
                    <button class="btn btn-primary btn-sm" id="openRelationshipModalBtn">+ Add</button>
                </div>
                <div class="view-stage-body space-y-4">
                    ${Object.keys(filters).length > 1 ? `
                        <div class="flex flex-wrap gap-2">
                            ${Object.keys(filters).map(key => `<button class="btn btn-secondary btn-sm ${filterKey === key ? 'btn-primary' : ''}" data-conn-filter="${key}">${key === 'all' ? 'All' : key.toUpperCase()}</button>`).join('')}
                        </div>
                    ` : ''}

                    ${renderRelationshipCards(relationships)}

                    <details class="border border-gray-200 rounded-lg bg-white">
                        <summary class="px-4 py-3 cursor-pointer text-sm font-medium text-gray-700 hover:bg-gray-50">
                            Relation types (${relationTypes.length})
                        </summary>
                        <div class="px-4 pb-4 pt-2 border-t border-gray-100">
                            <p class="text-xs text-gray-500 mb-3">Built-in EO operators for defining relationships</p>
                            ${renderRelationTypesList(relationTypes)}
                        </div>
                    </details>
                </div>
            `;

            document.querySelectorAll('[data-conn-filter]').forEach(btn => {
                btn.onclick = () => renderRelationsPage(btn.dataset.connFilter);
            });

            document.querySelectorAll('[data-conn-edit]').forEach(btn => {
                btn.onclick = () => openConnectionModal(btn.dataset.connEdit);
            });

            document.querySelectorAll('[data-conn-delete]').forEach(btn => {
                btn.onclick = () => {
                    deleteConnection(btn.dataset.connDelete);
                    renderRelationsPage(filterKey);
                    showToast('Relationship removed');
                };
            });

            document.querySelectorAll('[data-relation-edit]').forEach(btn => {
                btn.onclick = () => openConnectionRelationModal(btn.dataset.relationEdit);
            });

            document.querySelectorAll('[data-relation-delete]').forEach(btn => {
                btn.onclick = () => {
                    try {
                        deleteConnectionRelation(btn.dataset.relationDelete);
                        renderRelationsPage(filterKey);
                        showToast('Relation type removed');
                    } catch (error) {
                        showToast(error.message);
                    }
                };
            });

            const openRelationshipBtn = document.getElementById('openRelationshipModalBtn');
            if (openRelationshipBtn) openRelationshipBtn.onclick = () => openConnectionModal();

            const openRelationTypeBtn = document.getElementById('openRelationTypeModalBtn');
            if (openRelationTypeBtn) openRelationTypeBtn.onclick = () => openConnectionRelationModal();

            const formatOperatorSelect = document.getElementById('connectionRelationOperator');
            if (formatOperatorSelect) {
                formatOperatorSelect.onchange = (event) => {
                    const nextModes = renderModeOptions(event.target.value);
                    const modeSelect = document.getElementById('connectionRelationMode');
                    if (modeSelect) modeSelect.innerHTML = nextModes;
                };
            }

            const connFormatSelect = document.getElementById('connectionRelationSelect');
            if (connFormatSelect) {
                connFormatSelect.onchange = (event) => {
                    state.connectionFormState.selectedRelationId = event.target.value;
                    renderConnectionParamFields('connectionParamFields', event.target.value, {});
                    updateConnectionRelationSummary(event.target.value);
                };
            }

            const connForm = document.getElementById('connectionForm');
            if (connForm) connForm.onsubmit = (event) => { event.preventDefault(); handleConnectionFormSubmit(); };

            const formatForm = document.getElementById('connectionRelationForm');
            if (formatForm) formatForm.onsubmit = (event) => { event.preventDefault(); handleConnectionRelationSubmit(); };
        }

        function renderVisualizationsPage() {
            const container = document.getElementById('viewContainer');
            const setsForWorld = getSetsForWorld();

            container.innerHTML = `
                <div class="view-stage-header">
                    <div class="view-stage-title">
                        <span class="view-stage-pill">${getWorld()?.name || 'World'}</span>
                        <div class="min-w-0">
                            <div class="view-stage-name">Visualizations</div>
                            <div class="view-stage-sub">Interactive charts and data insights</div>
                        </div>
                    </div>
                </div>
                <div class="view-stage-body space-y-6">
                    <div class="border border-gray-200 rounded-lg bg-white p-6 space-y-4">
                        <div class="space-y-4">
                            <div>
                                <label class="block text-sm font-semibold mb-2">Select Set</label>
                                <select id="vizSetSelect" class="w-full px-3 py-2 border border-gray-300 rounded-lg">
                                    <option value="">Choose a set...</option>
                                    ${setsForWorld.map(set => `<option value="${set.id}">${set.name}</option>`).join('')}
                                </select>
                            </div>
                            <div id="vizViewSelectContainer" class="hidden">
                                <label class="block text-sm font-semibold mb-2">Select View</label>
                                <select id="vizViewSelect" class="w-full px-3 py-2 border border-gray-300 rounded-lg">
                                    <option value="">Choose a view...</option>
                                </select>
                            </div>
                            <div id="vizChartTypeContainer" class="hidden">
                                <label class="block text-sm font-semibold mb-2">Chart Type</label>
                                <div class="flex gap-2 flex-wrap">
                                    <button class="btn btn-secondary btn-sm viz-chart-btn" data-chart-type="bar">Bar Chart</button>
                                    <button class="btn btn-secondary btn-sm viz-chart-btn" data-chart-type="line">Line Chart</button>
                                    <button class="btn btn-secondary btn-sm viz-chart-btn" data-chart-type="pie">Pie Chart</button>
                                    <button class="btn btn-secondary btn-sm viz-chart-btn" data-chart-type="area">Area Chart</button>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div id="vizChartContainer" class="border border-gray-200 rounded-lg bg-white p-6">
                        <div class="text-center text-gray-500 py-12">
                            Select a set and view to visualize data
                        </div>
                    </div>
                </div>
            `;

            const setSelect = document.getElementById('vizSetSelect');
            const viewSelect = document.getElementById('vizViewSelect');
            const viewSelectContainer = document.getElementById('vizViewSelectContainer');
            const chartTypeContainer = document.getElementById('vizChartTypeContainer');

            if (setSelect) {
                setSelect.onchange = () => {
                    const setId = setSelect.value;
                    if (!setId) {
                        viewSelectContainer.classList.add('hidden');
                        chartTypeContainer.classList.add('hidden');
                        return;
                    }

                    const set = state.sets.get(setId);
                    if (set && set.views.size > 0) {
                        viewSelect.innerHTML = '<option value="">Choose a view...</option>' +
                            Array.from(set.views.values()).map(view =>
                                `<option value="${view.id}">${view.name}</option>`
                            ).join('');
                        viewSelectContainer.classList.remove('hidden');
                    }
                };
            }

            if (viewSelect) {
                viewSelect.onchange = () => {
                    if (viewSelect.value) {
                        chartTypeContainer.classList.remove('hidden');
                    } else {
                        chartTypeContainer.classList.add('hidden');
                    }
                };
            }

            document.querySelectorAll('.viz-chart-btn').forEach(btn => {
                btn.onclick = () => {
                    const chartType = btn.dataset.chartType;
                    const setId = setSelect.value;
                    const viewId = viewSelect.value;

                    if (setId && viewId) {
                        renderVisualizationChart(setId, viewId, chartType);
                    }
                };
            });
        }

        function renderVisualizationChart(setId, viewId, chartType) {
            const set = state.sets.get(setId);
            if (!set) return;

            const view = set.views.get(viewId);
            if (!view) return;

            // Get and filter records
            let records = Array.from(set.records.values());
            const schema = Array.from(set.fields.values());
            if (view && view.filters && view.filters.length > 0) {
                records = applyFilterGroups(records, view.filters, schema);
            }
            if (view?.sorts?.length) {
                records = applySorts(records, view.sorts, schema);
            }

            if (records.length === 0) {
                document.getElementById('vizChartContainer').innerHTML =
                    '<div class="text-center text-gray-500 py-12">No data available to visualize</div>';
                return;
            }

            // Prepare data for charts
            const fields = Array.from(set.fields.values());
            const numericFields = fields.filter(f =>
                f.type === 'number' || f.type === 'currency' || f.type === 'percent'
            );

            // Use first text field as label, first numeric field as value
            const labelField = fields.find(f => f.type === 'text' || f.type === 'singleSelect');
            const valueField = numericFields[0];

            if (!labelField || !valueField) {
                document.getElementById('vizChartContainer').innerHTML =
                    '<div class="text-center text-gray-500 py-12">View needs at least one text field and one numeric field for visualization</div>';
                return;
            }

            const chartData = records.slice(0, 10).map(record => ({
                name: String(record.data[labelField.id] || 'Untitled'),
                value: Number(record.data[valueField.id] || 0)
            }));

            const chartContainer = document.getElementById('vizChartContainer');
            chartContainer.innerHTML = '<div id="rechartRoot" style="width: 100%; height: 400px;"></div>';

            renderRechartsVisualization(chartType, chartData);
        }

        function renderRechartsVisualization(chartType, data) {
            const { BarChart, LineChart, PieChart, AreaChart, Bar, Line, Pie, Area, XAxis, YAxis, CartesianGrid, Tooltip, Legend, Cell, ResponsiveContainer } = window.Recharts;
            const React = window.React;
            const ReactDOM = window.ReactDOM;

            const COLORS = ['#3b82f6', '#8b5cf6', '#ec4899', '#f59e0b', '#10b981', '#06b6d4', '#6366f1', '#f97316'];

            let chart;
            switch(chartType) {
                case 'bar':
                    chart = React.createElement(ResponsiveContainer, { width: '100%', height: 400 },
                        React.createElement(BarChart, { data },
                            React.createElement(CartesianGrid, { strokeDasharray: '3 3' }),
                            React.createElement(XAxis, { dataKey: 'name' }),
                            React.createElement(YAxis, null),
                            React.createElement(Tooltip, null),
                            React.createElement(Legend, null),
                            React.createElement(Bar, { dataKey: 'value', fill: '#3b82f6' })
                        )
                    );
                    break;
                case 'line':
                    chart = React.createElement(ResponsiveContainer, { width: '100%', height: 400 },
                        React.createElement(LineChart, { data },
                            React.createElement(CartesianGrid, { strokeDasharray: '3 3' }),
                            React.createElement(XAxis, { dataKey: 'name' }),
                            React.createElement(YAxis, null),
                            React.createElement(Tooltip, null),
                            React.createElement(Legend, null),
                            React.createElement(Line, { type: 'monotone', dataKey: 'value', stroke: '#3b82f6', strokeWidth: 2 })
                        )
                    );
                    break;
                case 'pie':
                    chart = React.createElement(ResponsiveContainer, { width: '100%', height: 400 },
                        React.createElement(PieChart, null,
                            React.createElement(Pie, {
                                data,
                                dataKey: 'value',
                                nameKey: 'name',
                                cx: '50%',
                                cy: '50%',
                                outerRadius: 120,
                                label: true
                            }, data.map((entry, index) =>
                                React.createElement(Cell, { key: `cell-${index}`, fill: COLORS[index % COLORS.length] })
                            )),
                            React.createElement(Tooltip, null),
                            React.createElement(Legend, null)
                        )
                    );
                    break;
                case 'area':
                    chart = React.createElement(ResponsiveContainer, { width: '100%', height: 400 },
                        React.createElement(AreaChart, { data },
                            React.createElement(CartesianGrid, { strokeDasharray: '3 3' }),
                            React.createElement(XAxis, { dataKey: 'name' }),
                            React.createElement(YAxis, null),
                            React.createElement(Tooltip, null),
                            React.createElement(Legend, null),
                            React.createElement(Area, { type: 'monotone', dataKey: 'value', stroke: '#3b82f6', fill: '#93c5fd' })
                        )
                    );
                    break;
            }

            const root = document.getElementById('rechartRoot');
            if (root && ReactDOM && React) {
                ReactDOM.render(chart, root);
            }
        }

        // NEW COMPONENT FUNCTIONS FOR DASHBOARD
        function createSummaryCard(title, count, onClick) {
            return `
                <div class="summary-card" onclick="${onClick}">
                    <div class="summary-card-count">${count}</div>
                    <div class="summary-card-title">${title}</div>
                </div>
            `;
        }

        function createEntityTypeCard(label, count, onClick) {
            return `
                <div class="entity-type-card" onclick="${onClick}">
                    <div class="entity-type-card-label">${label}</div>
                    <div class="entity-type-card-count">${count} items</div>
                </div>
            `;
        }

        function renderDashboardPage() {
            const container = document.getElementById('viewContainer');
            const world = getWorld();
            const setsForWorld = getSetsForWorld();
            const hasData = setsForWorld.length > 0;
            const shortcuts = getTabShortcuts();

            // Build shortcuts HTML
            const shortcutsHtml = shortcuts.map((shortcut, index) => {
                const shortcutNum = index < 9 ? `<span class="shortcut-hint" style="font-size: 0.625rem; color: #94a3b8; margin-left: 0.25rem;">Ctrl+${index + 1}</span>` : '';
                const label = shortcut.label || 'Untitled';
                const subtitle = shortcut.setName ? `<div style="font-size: 0.75rem; color: #94a3b8; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${shortcut.setName}</div>` : '';
                return `
                    <div class="dashboard-shortcut-card" data-shortcut-id="${shortcut.id}"
                         style="padding: 0.75rem 1rem; border: 1px solid #e5e7eb; border-radius: 8px; cursor: pointer; transition: all 0.15s; background: white; min-width: 140px; max-width: 180px; position: relative;">
                        <button class="shortcut-remove-btn" data-shortcut-id="${shortcut.id}"
                                style="position: absolute; top: 4px; right: 4px; width: 20px; height: 20px; border: none; background: transparent; cursor: pointer; color: #94a3b8; border-radius: 4px; display: flex; align-items: center; justify-content: center; opacity: 0; transition: opacity 0.15s;"
                                title="Remove shortcut">
                            <i class="ph ph-x" style="font-size: 0.75rem;"></i>
                        </button>
                        <div style="display: flex; align-items: center; gap: 0.5rem;">
                            <i class="ph ${shortcut.icon || 'ph-bookmark'}" style="font-size: 1rem; color: #6366f1;"></i>
                            <div style="min-width: 0; flex: 1;">
                                <div style="font-weight: 500; color: #1e293b; font-size: 0.875rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; display: flex; align-items: center;">
                                    ${label}${shortcutNum}
                                </div>
                                ${subtitle}
                            </div>
                        </div>
                    </div>
                `;
            }).join('');

            // Build recent sets list for quick navigation
            const recentSetsHtml = setsForWorld.slice(0, 5).map(set => {
                const recordCount = set.records?.size || 0;
                const viewCount = set.views?.size || 0;
                const firstViewId = set.views?.size > 0 ? Array.from(set.views.keys())[0] : null;
                return `
                    <div class="dashboard-set-card" onclick="${firstViewId ? `switchSet('${set.id}', '${firstViewId}')` : `switchSet('${set.id}', null)`}"
                         style="padding: 1rem; border: 1px solid #e5e7eb; border-radius: 8px; cursor: pointer; transition: all 0.15s; background: white;">
                        <div style="display: flex; align-items: center; gap: 0.75rem;">
                            <i class="ph ${set.icon || 'ph-stack'}" style="font-size: 1.25rem; color: #6366f1;"></i>
                            <div>
                                <div style="font-weight: 600; color: #1e293b;">${set.name}</div>
                                <div style="font-size: 0.875rem; color: #64748b;">${recordCount} records  ${viewCount} views</div>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');

            container.innerHTML = `
                <div style="padding: 2rem; display: flex; flex-direction: column; gap: 2rem; max-width: 800px; margin: 0 auto;">

                    ${!hasData ? `
                        <!-- EMPTY STATE: Import-focused hero -->
                        <div style="text-align: center; padding: 3rem 2rem;">
                            <div style="font-size: 3rem; margin-bottom: 1rem;"></div>
                            <h1 style="font-size: 1.5rem; font-weight: 700; color: #1e293b; margin-bottom: 0.5rem;">What data would you like to work with?</h1>
                            <p style="color: #64748b; margin-bottom: 2rem;">Import CSV or JSON data, or create a new set to get started.</p>

                            <div style="display: flex; gap: 1rem; justify-content: center; flex-wrap: wrap;">
                                <button onclick="openCsvImportModal()" class="btn btn-primary" style="padding: 0.75rem 1.5rem; font-size: 1rem;">
                                    <i class="ph ph-file-csv"></i>
                                    Import CSV
                                </button>
                                <button onclick="openJsonImportModal()" class="btn btn-primary" style="padding: 0.75rem 1.5rem; font-size: 1rem;">
                                    <i class="ph ph-brackets-curly"></i>
                                    Import JSON
                                </button>
                                <button onclick="openAddSetModal()" class="btn btn-secondary" style="padding: 0.75rem 1.5rem; font-size: 1rem;">
                                    <i class="ph ph-plus"></i>
                                    Create Set
                                </button>
                            </div>
                        </div>
                    ` : `
                        <!-- HAS DATA: Quick navigation -->
                        <div style="text-align: center; padding: 1.5rem;">
                            <h1 style="font-size: 1.25rem; font-weight: 600; color: #1e293b; margin-bottom: 0.25rem;">
                                <i class="ph ph-globe-hemisphere-west" style="color: #6366f1;"></i>
                                ${world?.name || 'World'}
                            </h1>
                            <p style="color: #64748b; font-size: 0.875rem;">Jump into your data or import more</p>
                        </div>

                        ${shortcuts.length > 0 ? `
                        <!-- Shortcuts (browser-like bookmarks) -->
                        <div>
                            <div style="font-weight: 600; color: #475569; margin-bottom: 0.75rem; font-size: 0.875rem; text-transform: uppercase; letter-spacing: 0.05em; display: flex; align-items: center; gap: 0.5rem;">
                                <i class="ph ph-bookmark-simple" style="color: #6366f1;"></i>
                                Shortcuts
                            </div>
                            <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                                ${shortcutsHtml}
                            </div>
                            <div style="font-size: 0.75rem; color: #94a3b8; margin-top: 0.5rem;">
                                Right-click any tab to add or remove shortcuts
                            </div>
                        </div>
                        ` : ''}

                        <!-- Primary action: Import more data -->
                        <div style="display: flex; gap: 0.75rem; justify-content: center;">
                            <button onclick="openCsvImportModal()" class="btn btn-primary btn-sm">
                                <i class="ph ph-file-csv"></i>
                                Import CSV
                            </button>
                            <button onclick="openJsonImportModal()" class="btn btn-primary btn-sm">
                                <i class="ph ph-brackets-curly"></i>
                                Import JSON
                            </button>
                            <button onclick="openAddSetModal()" class="btn btn-secondary btn-sm">
                                <i class="ph ph-plus"></i>
                                New Set
                            </button>
                        </div>

                        <!-- Recent sets -->
                        <div>
                            <div style="font-weight: 600; color: #475569; margin-bottom: 0.75rem; font-size: 0.875rem; text-transform: uppercase; letter-spacing: 0.05em;">Your Data</div>
                            <div style="display: flex; flex-direction: column; gap: 0.5rem;">
                                ${recentSetsHtml}
                            </div>
                        </div>
                    `}

                    <!-- World tools (secondary) -->
                    <div style="border-top: 1px solid #e5e7eb; padding-top: 1.5rem; margin-top: 1rem;">
                        <div style="font-weight: 600; color: #475569; margin-bottom: 0.75rem; font-size: 0.875rem; text-transform: uppercase; letter-spacing: 0.05em;">World Tools</div>
                        <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                            <button class="btn btn-secondary btn-sm" onclick="openEditHistoryModal()">
                                <i class="ph ph-clock-counter-clockwise"></i>
                                Edit History
                            </button>
                            <button class="btn btn-secondary btn-sm" onclick="openJsonViewer()">
                                <i class="ph ph-code"></i>
                                JSON
                            </button>
                            <button class="btn btn-secondary btn-sm" onclick="document.getElementById('worldJsonInput').click()">
                                <i class="ph ph-upload-simple"></i>
                                Import World
                            </button>
                            <button class="btn btn-secondary btn-sm" onclick="exportJSON()">
                                <i class="ph ph-download-simple"></i>
                                Export
                            </button>
                        </div>
                    </div>

                </div>
            `;

            // Add hover effect for set cards
            container.querySelectorAll('.dashboard-set-card').forEach(card => {
                card.addEventListener('mouseenter', () => {
                    card.style.borderColor = '#6366f1';
                    card.style.background = '#f8fafc';
                });
                card.addEventListener('mouseleave', () => {
                    card.style.borderColor = '#e5e7eb';
                    card.style.background = 'white';
                });
            });

            // Add event handlers for shortcut cards
            container.querySelectorAll('.dashboard-shortcut-card').forEach(card => {
                const shortcutId = card.dataset.shortcutId;
                const shortcut = shortcuts.find(s => s.id === shortcutId);
                if (!shortcut) return;

                // Hover effects
                card.addEventListener('mouseenter', () => {
                    card.style.borderColor = '#6366f1';
                    card.style.background = '#f8fafc';
                    const removeBtn = card.querySelector('.shortcut-remove-btn');
                    if (removeBtn) removeBtn.style.opacity = '1';
                });
                card.addEventListener('mouseleave', () => {
                    card.style.borderColor = '#e5e7eb';
                    card.style.background = 'white';
                    const removeBtn = card.querySelector('.shortcut-remove-btn');
                    if (removeBtn) removeBtn.style.opacity = '0';
                });

                // Click to navigate
                card.addEventListener('click', (e) => {
                    if (e.target.closest('.shortcut-remove-btn')) return; // Don't navigate when clicking remove
                    navigateToShortcut(shortcut);
                });

                // Remove button
                const removeBtn = card.querySelector('.shortcut-remove-btn');
                if (removeBtn) {
                    removeBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        removeTabShortcut(shortcutId);
                    });
                    removeBtn.addEventListener('mouseenter', () => {
                        removeBtn.style.background = '#fee2e2';
                        removeBtn.style.color = '#dc2626';
                    });
                    removeBtn.addEventListener('mouseleave', () => {
                        removeBtn.style.background = 'transparent';
                        removeBtn.style.color = '#94a3b8';
                    });
                }
            });
        }

        function renderExplorePage() {
            const container = document.getElementById('viewContainer');
            if (!state.exploreState) {
                state.exploreState = {
                    searchQuery: '',
                    focusedRecordId: null,
                    sortField: 'lastModified',
                    sortDirection: 'desc',
                    filters: []
                };
            }

            // Gather all records from all sets
            const allRecords = [];
            state.sets.forEach(set => {
                set.records.forEach(record => {
                    allRecords.push({
                        ...record,
                        setId: set.id,
                        setName: set.name,
                        _set: set
                    });
                });
            });

            // Apply search filter
            let filteredRecords = allRecords;
            if (state.exploreState.searchQuery) {
                const query = state.exploreState.searchQuery.toLowerCase();
                filteredRecords = allRecords.filter(record => {
                    const label = getRecordDisplayLabel(record).toLowerCase();
                    return label.includes(query);
                });
            }

            // Apply sorting
            filteredRecords.sort((a, b) => {
                const direction = state.exploreState.sortDirection === 'asc' ? 1 : -1;
                switch (state.exploreState.sortField) {
                    case 'name':
                        return direction * getRecordDisplayLabel(a).localeCompare(getRecordDisplayLabel(b));
                    case 'set':
                        return direction * a.setName.localeCompare(b.setName);
                    case 'stability':
                        const stabilityOrder = { emerging: 0, forming: 1, stable: 2, evolved: 3 };
                        return direction * ((stabilityOrder[a.stability] || 0) - (stabilityOrder[b.stability] || 0));
                    case 'lastModified':
                    default:
                        const aTime = a.edit_history?.[a.edit_history.length - 1]?.timestamp || 0;
                        const bTime = b.edit_history?.[b.edit_history.length - 1]?.timestamp || 0;
                        return direction * (bTime - aTime);
                }
            });

            const recordCount = filteredRecords.length;

            container.innerHTML = `
                <div class="explore-page" style="display: flex; flex-direction: column; height: 100%;">
                    <!-- HEADER -->
                    <div class="view-stage-header" style="flex-shrink: 0;">
                        <div class="view-stage-title">
                            <div class="min-w-0">
                                <div class="view-stage-name">Explore</div>
                                <div class="view-stage-sub">Browse and search all records  ${recordCount} record${recordCount !== 1 ? 's' : ''}</div>
                            </div>
                        </div>
                        <div style="display: flex; gap: 0.5rem;">
                            <button class="btn btn-secondary btn-sm" onclick="openExploreFilters()">
                                <i class="ph ph-funnel"></i>
                                Filters
                            </button>
                            <button class="btn btn-secondary btn-sm" onclick="openExploreSort()">
                                <i class="ph ph-arrows-down-up"></i>
                                Sort
                            </button>
                        </div>
                    </div>

                    <!-- SEARCH BAR -->
                    <div style="padding: 1rem 1.5rem; border-bottom: 1px solid var(--border); flex-shrink: 0;">
                        <input
                            type="text"
                            id="exploreSearchInput"
                            placeholder="Search records..."
                            value="${state.exploreState.searchQuery}"
                            style="width: 100%; padding: 0.5rem 1rem; border: 1px solid var(--border); border-radius: 999px; font-size: 14px;"
                            oninput="updateExploreSearch(this.value)"
                        />
                    </div>

                    <!-- MAIN CONTENT: TABLE + FOCUS PANEL -->
                    <div style="display: flex; flex: 1; overflow: hidden;">
                        <!-- TABLE AREA -->
                        <div style="flex: 1; overflow: auto; min-width: 0;">
                            <div class="table-scroll" style="height: 100%;">
                                <table id="exploreTable" class="border-collapse" style="width: 100%;">
                                    <thead>
                                        <tr id="exploreTableHeader"></tr>
                                    </thead>
                                    <tbody id="exploreTableBody"></tbody>
                                </table>
                            </div>
                        </div>

                        <!-- FOCUS PANEL -->
                        <aside class="focus-panel" id="exploreFocusPanel" style="display: ${state.exploreState.focusedRecordId ? 'flex' : 'none'};">
                            <div class="focus-header">
                                <div class="focus-label">Focus</div>
                                <div class="focus-title-row">
                                    <div style="flex: 1;">
                                        <div class="focus-title" id="exploreFocusTitle">Select a record</div>
                                        <div class="focus-subtitle" id="exploreFocusSubtitle"></div>
                                    </div>
                                    <span class="focus-tag" id="exploreFocusTag">-</span>
                                </div>
                                <button class="focus-clear" onclick="clearExploreFocus()">Clear Focus</button>
                            </div>
                            <div class="focus-body" id="exploreFocusBody">
                                <p class="text-sm text-gray-500">Click any row to see detailed information here.</p>
                            </div>
                            <div class="focus-actions" id="exploreFocusActions"></div>
                        </aside>
                    </div>
                </div>
            `;

            // Render table header
            const headerRow = document.getElementById('exploreTableHeader');
            const columns = [
                { id: 'name', label: 'Name', width: '30%' },
                { id: 'set', label: 'Set', width: '15%' },
                { id: 'stability', label: 'Stability', width: '12%' },
                { id: 'lastModified', label: 'Last Modified', width: '13%' },
                { id: 'context', label: 'Context', width: '15%' },
                { id: 'relationships', label: 'Relationships', width: '15%' }
            ];

            columns.forEach(col => {
                const th = document.createElement('th');
                th.className = 'column-header';
                th.style.width = col.width;
                th.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 4px; cursor: pointer;" onclick="sortExploreBy('${col.id}')">
                        <span>${col.label}</span>
                        ${state.exploreState.sortField === col.id ?
                            `<i class="ph ph-caret-${state.exploreState.sortDirection === 'asc' ? 'up' : 'down'}" style="font-size: 12px;"></i>`
                            : ''}
                    </div>
                `;
                headerRow.appendChild(th);
            });

            // Render table body
            const tableBody = document.getElementById('exploreTableBody');
            filteredRecords.forEach(record => {
                const tr = document.createElement('tr');
                tr.className = 'table-row';
                if (state.exploreState.focusedRecordId === record.id) {
                    tr.classList.add('selected');
                }
                tr.onclick = () => focusOnExploreRecord(record.id, record.setId);

                // Name column
                const nameTd = document.createElement('td');
                nameTd.className = 'table-cell';
                nameTd.innerHTML = `<div style="font-weight: 500;">${escapeHtml(getRecordDisplayLabel(record))}</div>`;
                tr.appendChild(nameTd);

                // Set column
                const setTd = document.createElement('td');
                setTd.className = 'table-cell';
                setTd.innerHTML = `<span class="view-stage-pill" style="font-size: 11px;">${escapeHtml(record.setName)}</span>`;
                tr.appendChild(setTd);

                // Stability column
                const stabilityTd = document.createElement('td');
                stabilityTd.className = 'table-cell';
                stabilityTd.innerHTML = renderStabilityBadge(record.stability);
                tr.appendChild(stabilityTd);

                // Last Modified column
                const modifiedTd = document.createElement('td');
                modifiedTd.className = 'table-cell';
                modifiedTd.innerHTML = `<span style="font-size: 12px; color: var(--text-muted);">${getRelativeTime(record)}</span>`;
                tr.appendChild(modifiedTd);

                // Context column
                const contextTd = document.createElement('td');
                contextTd.className = 'table-cell';
                contextTd.innerHTML = renderContextBadges(record);
                tr.appendChild(contextTd);

                // Relationships column
                const relsTd = document.createElement('td');
                relsTd.className = 'table-cell';
                relsTd.innerHTML = renderRelationshipChips(record);
                tr.appendChild(relsTd);

                tableBody.appendChild(tr);
            });

            // If a record was focused, update the focus panel
            if (state.exploreState.focusedRecordId) {
                const focusedRecord = filteredRecords.find(r => r.id === state.exploreState.focusedRecordId);
                if (focusedRecord) {
                    updateExploreFocusPanel(focusedRecord);
                }
            }
        }

        function renderStabilityBadge(stability) {
            if (!stability) return '<span style="color: var(--text-muted); font-size: 12px;">-</span>';

            const config = {
                emerging: { color: '#ea580c', bg: '#ffedd5', label: 'Emerging' },
                forming: { color: '#ca8a04', bg: '#fef9c3', label: 'Forming' },
                stable: { color: '#16a34a', bg: '#dcfce7', label: 'Stable' },
                evolved: { color: '#2563eb', bg: '#dbeafe', label: 'Evolved' }
            };

            const cfg = config[stability] || config.stable;
            return `<span style="display: inline-block; padding: 2px 8px; border-radius: 999px; font-size: 11px; font-weight: 500; color: ${cfg.color}; background: ${cfg.bg};">${cfg.label}</span>`;
        }

        function renderContextBadges(record) {
            // Get dominant value observation from rollup
            const dominantValue = getDominantValue(record);
            if (!dominantValue || !dominantValue.context) {
                return '<span style="color: var(--text-muted); font-size: 12px;">-</span>';
            }

            const ctx = dominantValue.context;
            const badges = [];

            if (ctx.method) {
                badges.push(`<span style="display: inline-block; padding: 2px 6px; border-radius: 4px; font-size: 10px; background: #f3f4f6; color: #6b7280; margin-right: 4px;">${ctx.method}</span>`);
            }
            if (ctx.scale) {
                badges.push(`<span style="display: inline-block; padding: 2px 6px; border-radius: 4px; font-size: 10px; background: #f3f4f6; color: #6b7280;">${ctx.scale}</span>`);
            }

            return badges.length > 0 ? badges.join('') : '<span style="color: var(--text-muted); font-size: 12px;">-</span>';
        }

        function renderRelationshipChips(record) {
            const connections = getRecordConnections(record.id);
            if (!connections || connections.length === 0) {
                return '<span style="color: var(--text-muted); font-size: 12px;">-</span>';
            }

            // Count by operator
            const operatorCounts = {};
            connections.forEach(conn => {
                const operator = conn.operator || 'REF';
                operatorCounts[operator] = (operatorCounts[operator] || 0) + 1;
            });

            const operatorConfig = {
                'INS': { color: '#2563eb', bg: '#dbeafe' },
                'DES': { color: '#7c3aed', bg: '#ede9fe' },
                'REF': { color: '#6b7280', bg: '#e5e7eb' },
                'SUP': { color: '#16a34a', bg: '#dcfce7' }
            };

            const chips = Object.entries(operatorCounts).map(([op, count]) => {
                const cfg = operatorConfig[op] || operatorConfig['REF'];
                return `<span style="display: inline-flex; align-items: center; gap: 2px; padding: 2px 6px; border-radius: 4px; font-size: 10px; font-weight: 500; color: ${cfg.color}; background: ${cfg.bg}; margin-right: 4px;">${op}<span style="opacity: 0.6;"></span>${count}</span>`;
            });

            return chips.join('');
        }

        function getRelativeTime(record) {
            if (!record.edit_history || record.edit_history.length === 0) {
                return 'Never';
            }

            const lastEdit = record.edit_history[record.edit_history.length - 1];
            const timestamp = lastEdit.timestamp;
            const now = Date.now();
            const diff = now - timestamp;

            const seconds = Math.floor(diff / 1000);
            const minutes = Math.floor(seconds / 60);
            const hours = Math.floor(minutes / 60);
            const days = Math.floor(hours / 24);

            if (days > 0) return `${days} day${days !== 1 ? 's' : ''} ago`;
            if (hours > 0) return `${hours} hour${hours !== 1 ? 's' : ''} ago`;
            if (minutes > 0) return `${minutes} min${minutes !== 1 ? 's' : ''} ago`;
            return 'Just now';
        }

        function getDominantValue(record) {
            if (!record.value_history || record.value_history.length === 0) return null;
            return record.value_history[record.value_history.length - 1];
        }

        function getRecordConnections(recordId) {
            const connections = [];
            state.connections.forEach(conn => {
                if (conn.source === recordId || conn.target === recordId) {
                    connections.push(conn);
                }
            });
            return connections;
        }

        function focusOnExploreRecord(recordId, setId) {
            state.exploreState.focusedRecordId = recordId;

            // Find the record
            const set = state.sets.get(setId);
            if (!set) return;

            const record = set.records.get(recordId);
            if (!record) return;

            const recordWithSet = { ...record, setId, setName: set.name, _set: set };

            // Re-render to update selection and show focus panel
            renderExplorePage();
        }

        function updateExploreFocusPanel(record) {
            const titleEl = document.getElementById('exploreFocusTitle');
            const subtitleEl = document.getElementById('exploreFocusSubtitle');
            const tagEl = document.getElementById('exploreFocusTag');
            const bodyEl = document.getElementById('exploreFocusBody');
            const actionsEl = document.getElementById('exploreFocusActions');

            if (!titleEl) return;

            titleEl.textContent = getRecordDisplayLabel(record);
            subtitleEl.textContent = record.setName;
            tagEl.textContent = 'Record';

            // Build focus body content
            let bodyHTML = '';

            // Stability
            bodyHTML += `<div style="margin-bottom: 1rem;">
                <div style="font-size: 11px; text-transform: uppercase; letter-spacing: 0.08em; color: #9ca3af; margin-bottom: 4px;">Stability</div>
                ${renderStabilityBadge(record.stability)}
            </div>`;

            // Context
            const dominantValue = getDominantValue(record);
            if (dominantValue && dominantValue.context) {
                bodyHTML += `<div style="margin-bottom: 1rem;">
                    <div style="font-size: 11px; text-transform: uppercase; letter-spacing: 0.08em; color: #9ca3af; margin-bottom: 4px;">Context</div>
                    <div style="font-size: 12px; color: var(--text-muted);">
                        ${Object.entries(dominantValue.context).map(([key, val]) =>
                            `<div><strong>${key}:</strong> ${val}</div>`
                        ).join('')}
                    </div>
                </div>`;
            }

            // Relationships
            const connections = getRecordConnections(record.id);
            if (connections.length > 0) {
                bodyHTML += `<div style="margin-bottom: 1rem;">
                    <div style="font-size: 11px; text-transform: uppercase; letter-spacing: 0.08em; color: #9ca3af; margin-bottom: 4px;">Relationships</div>
                    <div style="font-size: 12px;">
                        ${connections.slice(0, 5).map(conn => {
                            const targetId = conn.source === record.id ? conn.target : conn.source;
                            const targetRecord = findRecordById(targetId);
                            const label = targetRecord ? getRecordDisplayLabel(targetRecord) : targetId;
                            return `<div style="padding: 4px 0;">${conn.operator || 'REF'}  ${escapeHtml(label)}</div>`;
                        }).join('')}
                        ${connections.length > 5 ? `<div style="color: var(--text-muted); margin-top: 4px;">+${connections.length - 5} more</div>` : ''}
                    </div>
                </div>`;
            }

            // Fields preview
            const fields = record._set ? record._set.schema.slice(0, 3) : [];
            if (fields.length > 0) {
                bodyHTML += `<div style="margin-bottom: 1rem;">
                    <div style="font-size: 11px; text-transform: uppercase; letter-spacing: 0.08em; color: #9ca3af; margin-bottom: 4px;">Fields Preview</div>
                    <div style="font-size: 12px;">
                        ${fields.map(field => {
                            const value = record.data?.[field.id];
                            return `<div style="padding: 4px 0;"><strong>${escapeHtml(field.name)}:</strong> ${escapeHtml(String(value || '-'))}</div>`;
                        }).join('')}
                    </div>
                </div>`;
            }

            bodyEl.innerHTML = bodyHTML;

            // Actions
            actionsEl.innerHTML = `
                <button class="btn btn-primary btn-sm" onclick="openExpandedRecord('${record.id}', '${record.setId}')">
                    <i class="ph ph-arrow-square-out"></i>
                    Open Record
                </button>
            `;
        }

        function findRecordById(recordId) {
            let found = null;
            state.sets.forEach(set => {
                const record = set.records.get(recordId);
                if (record) found = record;
            });
            return found;
        }

        function clearExploreFocus() {
            state.exploreState.focusedRecordId = null;
            renderExplorePage();
        }

        function updateExploreSearch(query) {
            state.exploreState.searchQuery = query;
            renderExplorePage();
        }

        function sortExploreBy(field) {
            if (state.exploreState.sortField === field) {
                // Toggle direction
                state.exploreState.sortDirection = state.exploreState.sortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                state.exploreState.sortField = field;
                state.exploreState.sortDirection = 'desc';
            }
            renderExplorePage();
        }

        function openExploreFilters() {
            showToast('Filter functionality coming soon');
            // TODO: Implement filter modal integration
        }

        function openExploreSort() {
            showToast('Advanced sort options coming soon');
            // TODO: Implement sort modal integration
        }

        function attachConnectionRelationInlineEditing() {
            document.querySelectorAll('[data-relation-inline]').forEach(cell => {
                const [field, relationId] = (cell.dataset.relationInline || '').split(':');
                if (!field || !relationId) return;
                const original = cell.textContent.trim();
                cell.contentEditable = 'true';
                cell.onfocus = () => cell.dataset.originalValue = cell.textContent.trim();
                cell.onkeydown = (event) => {
                    if (event.key === 'Enter') {
                        event.preventDefault();
                        cell.blur();
                    }
                };
                cell.onblur = () => {
                    const current = (cell.textContent || '').trim();
                    const baseline = cell.dataset.originalValue !== undefined ? cell.dataset.originalValue : original;
                    if (current === baseline) return;
                    const updates = { [field]: current };

                    updateConnectionRelation(relationId, updates);
                    showToast('Relation type updated');
                    renderRelationsPage(state.connectionFormState.activeFilter || 'all');
                };
            });
        }

        function attachConnectionInlineEditing() {
            document.querySelectorAll('[data-conn-inline]').forEach(cell => {
                const [field, connId] = (cell.dataset.connInline || '').split(':');
                if (!field || !connId) return;
                const original = cell.textContent.trim();
                cell.contentEditable = 'true';
                cell.onfocus = () => cell.dataset.originalValue = cell.textContent.trim();
                cell.onkeydown = (event) => {
                    if (event.key === 'Enter') {
                        event.preventDefault();
                        cell.blur();
                    }
                };
                cell.onblur = () => {
                    const current = (cell.textContent || '').trim();
                    const baseline = cell.dataset.originalValue !== undefined ? cell.dataset.originalValue : original;
                    if (current === baseline) return;

                    try {
                        if (field === 'params') {
                            const parsed = current ? JSON.parse(current) : {};
                            updateConnection(connId, { params: parsed });
                        } else {
                            updateConnection(connId, { [field]: current });
                        }
                        showToast('Relationship updated');
                        renderRelationsPage(state.connectionFormState.activeFilter || 'all');
                    } catch (error) {
                        showToast('Params must be valid JSON');
                        renderRelationsPage(state.connectionFormState.activeFilter || 'all');
                    }
                };
            });
        }

        // CELL EDITING
        function handleCellClick(td, recordId, field) {
            if (state.editingCell && state.editingCell.td !== td) {
                exitEditMode();
            }

            if (state.selectedCell?.td === td && state.selectedCell?.recordId === recordId) {
                enterEditMode(td, recordId, field);
                return;
            }

            selectCell(td, recordId, field.id);
        }

        function selectCell(td, recordId, fieldId) {
            if (state.editingCell) exitEditMode();

            if (state.selectedCell?.td) {
                state.selectedCell.td.classList.remove('cell-selected');
                state.selectedCell.td.tabIndex = -1;
            }

            td.classList.add('cell-selected');
            td.tabIndex = 0;
            td.focus();

            state.selectedCell = { td, recordId, fieldId };
            state.lastSelectedCell = { recordId, fieldId };

            const set = getCurrentSet();
            const record = set?.records.get(recordId);
            const value = record ? record[fieldId] : null;
            if (value && value._sup) {
                openObservationModal({ recordId, fieldId, setId: set?.id });
            }
        }

        function enterEditMode(td, recordId, field) {
            exitEditMode(false);

            td.classList.remove('cell-selected');
            td.classList.add('cell-editing');
            state.editingCell = { td, recordId, fieldId: field.id };

            if (field.type === 'DATE') {
                showDatePicker(td, recordId, field);
            } else if (field.type === 'SELECT') {
                showSelectDropdown(td, recordId, field);
            } else if (field.type === 'LINK_RECORD') {
                showLinkedRecordDropdown(td, recordId, field);
            } else if (field.type === 'FORMULA' || field.type === 'RECORD_ID') {
                // Formula and Record ID fields are read-only, exit edit mode
                exitEditMode(false);
                return;
            } else {
                makeContentEditable(td, recordId, field);
            }
        }

        function exitEditMode(save = true) {
            if (!state.editingCell) return;

            const { td, recordId, fieldId } = state.editingCell;

            if (td.contentEditable === 'true') {
                td.contentEditable = false;
                if (save) {
                    finalizeContentEdit(td, recordId, fieldId);
                }
            }

            td.classList.remove('cell-editing');
            td.classList.add('cell-selected');
            td.tabIndex = 0;

            state.editingCell = null;
            state.selectedCell = { td, recordId, fieldId };
            state.lastSelectedCell = { recordId, fieldId };
        }

        function makeContentEditable(td, recordId, field) {
            const set = getCurrentSet();
            const record = set.records.get(recordId);
            const currentValue = record[field.id];

            td.contentEditable = true;
            td.textContent = currentValue || '';
            td.focus();

            const range = document.createRange();
            range.selectNodeContents(td);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);

            // Add blur handler to save changes when focus is lost
            td.onblur = () => {
                if (state.editingCell && state.editingCell.td === td) {
                    exitEditMode(true);
                }
            };

            // Add keydown handler for Enter/Escape
            td.onkeydown = (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    exitEditMode(true);
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    exitEditMode(false);
                }
            };
        }

        function finalizeContentEdit(td, recordId, fieldId) {
            const set = getCurrentSet();
            const record = set.records.get(recordId);
            const field = set.schema.find(f => f.id === fieldId);
            const currentValue = record[fieldId];

            const rawTextValue = td.textContent.trim();

            // For number/currency: only convert non-empty values, pass empty as '' to trigger toss
            let newValue = rawTextValue;
            if (rawTextValue !== '' && (field.type === 'NUMBER' || field.type === 'CURRENCY')) {
                newValue = parseFloat(newValue) || 0;
            }

            if (String(newValue) !== String(currentValue)) {
                updateRecord(recordId, fieldId, newValue, currentValue);
            } else {
                renderCurrentView();
            }
        }

        function toggleCheckbox(recordId, fieldId) {
            const set = getCurrentSet();
            const record = set.records.get(recordId);
            const currentValue = record[fieldId];
            updateRecord(recordId, fieldId, !currentValue, currentValue);
        }

        /**
         * Normalize a date value to ISO format (YYYY-MM-DD) for native date inputs.
         * Handles various common date formats and returns empty string for invalid dates.
         */
        function normalizeDateToISO(value) {
            if (!value) return '';

            // Already in ISO format (YYYY-MM-DD)
            if (/^\d{4}-\d{2}-\d{2}$/.test(value)) {
                return value;
            }

            // Try parsing with Date object
            const date = new Date(value);
            if (!isNaN(date.getTime())) {
                // Return in YYYY-MM-DD format
                const year = date.getFullYear();
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const day = String(date.getDate()).padStart(2, '0');
                return `${year}-${month}-${day}`;
            }

            // Try common date formats
            // MM/DD/YYYY or M/D/YYYY
            let match = value.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})$/);
            if (match) {
                const [, month, day, year] = match;
                return `${year}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`;
            }

            // DD/MM/YYYY (European format - try if month > 12)
            match = value.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})$/);
            if (match) {
                const [, first, second, year] = match;
                if (parseInt(first) > 12) {
                    return `${year}-${second.padStart(2, '0')}-${first.padStart(2, '0')}`;
                }
            }

            // YYYY/MM/DD
            match = value.match(/^(\d{4})\/(\d{1,2})\/(\d{1,2})$/);
            if (match) {
                const [, year, month, day] = match;
                return `${year}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`;
            }

            // Return empty if we can't parse
            return '';
        }

        function showDatePicker(cell, recordId, field) {
            const set = getCurrentSet();
            const record = set.records.get(recordId);
            const currentValue = record[field.id];

            const input = document.createElement('input');
            input.type = 'date';
            // Normalize date to ISO format for the native date input
            input.value = normalizeDateToISO(currentValue);
            input.className = 'w-full px-2 py-1';
            cell.innerHTML = '';
            cell.appendChild(input);
            input.focus();
            input.onblur = () => {
                exitEditMode(false);
                const newValue = input.value;
                if (newValue !== currentValue) updateRecord(recordId, field.id, newValue, currentValue);
                else renderCurrentView();
            };
        }

        function showSelectDropdown(td, recordId, field) {
            const options = field.config.options.map(opt => ({
                value: opt,
                label: opt,
                color: field.config.colors?.[opt] || '#f3f4f6',
                icon: ''
            }));

            showEnhancedSelectDropdown(td, recordId, field, options);
        }

        function showEnhancedSelectDropdown(td, recordId, field, options) {
            const set = getCurrentSet();
            const record = set.records.get(recordId);
            const currentValue = record[field.id];

            document.querySelectorAll('.custom-select-dropdown').forEach(d => d.remove());

            const dropdown = document.createElement('div');
            dropdown.className = 'custom-select-dropdown';

            const rect = td.getBoundingClientRect();
            const spaceBelow = window.innerHeight - rect.bottom;
            const spaceAbove = rect.top;
            const dropdownHeight = Math.min(400, options.length * 40 + 100);

            if (spaceBelow >= dropdownHeight || spaceBelow > spaceAbove) {
                dropdown.style.top = `${rect.bottom + 4}px`;
            } else {
                dropdown.style.bottom = `${window.innerHeight - rect.top + 4}px`;
            }
            dropdown.style.left = `${rect.left}px`;
            dropdown.style.minWidth = `${rect.width}px`;

            dropdown.innerHTML = `
                <input 
                    type="text" 
                    class="custom-select-search" 
                    placeholder="Search or type to filter..."
                    autocomplete="off"
                    spellcheck="false"
                >
                <div class="custom-select-options"></div>
                <div class="custom-select-footer">
                    <button class="clear-btn">Clear</button>
                </div>
            `;

            document.body.appendChild(dropdown);

            const searchInput = dropdown.querySelector('.custom-select-search');
            const optionsContainer = dropdown.querySelector('.custom-select-options');
            const clearBtn = dropdown.querySelector('.clear-btn');

            let highlightedIndex = -1;
            let filteredOptions = [...options];

            function updateHighlight() {
                optionsContainer.querySelectorAll('.custom-select-option').forEach((el, i) => {
                    el.classList.toggle('highlighted', i === highlightedIndex);
                });
            }

            function scrollToHighlighted() {
                const highlighted = optionsContainer.querySelector('.highlighted');
                if (highlighted) {
                    highlighted.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
                }
            }

            function selectOption(value) {
                if (value !== currentValue) {
                    updateRecord(recordId, field.id, value, currentValue);
                }
                dropdown.remove();
                exitEditMode();
            }

            function renderOptions(query = '') {
                filteredOptions = query.trim() === ''
                    ? [...options]
                    : options.filter(opt => opt.label.toLowerCase().includes(query.toLowerCase()));

                if (filteredOptions.length === 0) {
                    optionsContainer.innerHTML = `
                        <div class="custom-select-empty">
                            <div class="custom-select-empty-icon"></div>
                            <div>No matches found</div>
                            <div style="font-size: 12px; margin-top: 4px;">Try a different search term</div>
                        </div>
                    `;
                    return;
                }

                optionsContainer.innerHTML = filteredOptions.map((opt, index) => {
                    const isSelected = opt.value === currentValue;
                    const isHighlighted = index === highlightedIndex;

                    let displayLabel = opt.label;
                    if (query.trim() !== '') {
                        const regex = new RegExp(`(${query})`, 'gi');
                        displayLabel = opt.label.replace(regex, '<span class="search-match">$1</span>');
                    }

                    return `
                        <div 
                            class="custom-select-option ${isSelected ? 'selected' : ''} ${isHighlighted ? 'highlighted' : ''}"
                            data-value="${opt.value}"
                            data-index="${index}"
                        >
                            <div class="custom-select-option-icon" style="background: ${opt.color || '#f3f4f6'}">
                                ${opt.icon || ''}
                            </div>
                            <div class="custom-select-option-text">${displayLabel}</div>
                            ${isSelected ? '<span class="custom-select-option-badge">Current</span>' : ''}
                        </div>
                    `;
                }).join('');

                optionsContainer.querySelectorAll('.custom-select-option').forEach(el => {
                    el.onclick = () => selectOption(el.dataset.value);
                    el.onmouseenter = () => {
                        highlightedIndex = parseInt(el.dataset.index);
                        updateHighlight();
                    };
                });
            }

            searchInput.oninput = (e) => {
                highlightedIndex = 0;
                renderOptions(e.target.value);
            };

            searchInput.onkeydown = (e) => {
                if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    highlightedIndex = Math.min(highlightedIndex + 1, filteredOptions.length - 1);
                    updateHighlight();
                    scrollToHighlighted();
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    highlightedIndex = Math.max(highlightedIndex - 1, 0);
                    updateHighlight();
                    scrollToHighlighted();
                } else if (e.key === 'Enter') {
                    e.preventDefault();
                    if (highlightedIndex >= 0 && highlightedIndex < filteredOptions.length) {
                        selectOption(filteredOptions[highlightedIndex].value);
                    }
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    dropdown.remove();
                    exitEditMode(false);
                }
            };

            clearBtn.onclick = () => {
                selectOption('');
            };

            setTimeout(() => {
                document.addEventListener('click', function closeDropdown(e) {
                    if (!dropdown.contains(e.target) && e.target !== td) {
                        dropdown.remove();
                        exitEditMode(false);
                        document.removeEventListener('click', closeDropdown);
                    }
                });
            }, 0);

            renderOptions();
            searchInput.focus();
        }

        function showLinkedRecordDropdown(td, recordId, field) {
            const linkedSet = getLinkedSet(field);
            if (!linkedSet) {
                showToast(' Configure linked set first');
                exitEditMode(false);
                return;
            }

            const options = Array.from(linkedSet.records.values()).map(rec => ({
                value: rec.id,
                label: getRecordDisplayName(rec.id) || linkedSet.name || 'Record',
                icon: '',
                color: '#e0f2fe'
            }));

            if (options.length === 0) {
                showToast(' No records in linked set');
                exitEditMode(false);
                return;
            }

            // Check cardinality to determine if multi-select is allowed
            const cardinality = field.config?.cardinality || 'many';
            const limit = field.config?.limit || null;
            const allowMultiple = cardinality === 'many' || (cardinality === 'limit' && limit > 1);

            if (allowMultiple) {
                showMultiLinkedRecordDropdown(td, recordId, field, options, limit);
            } else {
                showEnhancedSelectDropdown(td, recordId, field, options);
            }
        }

        function showMultiLinkedRecordDropdown(td, recordId, field, options, limit) {
            const set = getCurrentSet();
            const record = set.records.get(recordId);
            const currentValue = record[field.id];
            // Normalize to array
            const selectedIds = Array.isArray(currentValue) ? [...currentValue] : (currentValue ? [currentValue] : []);

            document.querySelectorAll('.custom-select-dropdown').forEach(d => d.remove());

            const dropdown = document.createElement('div');
            dropdown.className = 'custom-select-dropdown multi-select';

            const rect = td.getBoundingClientRect();
            const spaceBelow = window.innerHeight - rect.bottom;
            const spaceAbove = rect.top;
            const dropdownHeight = Math.min(450, options.length * 44 + 150);

            if (spaceBelow >= dropdownHeight || spaceBelow > spaceAbove) {
                dropdown.style.top = `${rect.bottom + 4}px`;
            } else {
                dropdown.style.bottom = `${window.innerHeight - rect.top + 4}px`;
            }
            dropdown.style.left = `${rect.left}px`;
            dropdown.style.minWidth = `${Math.max(rect.width, 280)}px`;

            const limitInfo = limit ? ` (max ${limit})` : '';
            dropdown.innerHTML = `
                <div class="multi-select-header">
                    <span class="multi-select-count">${selectedIds.length} selected${limitInfo}</span>
                </div>
                <input
                    type="text"
                    class="custom-select-search"
                    placeholder="Search records..."
                    autocomplete="off"
                    spellcheck="false"
                >
                <div class="custom-select-options"></div>
                <div class="custom-select-footer multi-select-footer">
                    <button class="clear-btn">Clear All</button>
                    <button class="done-btn">Done</button>
                </div>
            `;

            document.body.appendChild(dropdown);

            const searchInput = dropdown.querySelector('.custom-select-search');
            const optionsContainer = dropdown.querySelector('.custom-select-options');
            const clearBtn = dropdown.querySelector('.clear-btn');
            const doneBtn = dropdown.querySelector('.done-btn');
            const countSpan = dropdown.querySelector('.multi-select-count');

            let filteredOptions = [...options];

            function updateCount() {
                countSpan.textContent = `${selectedIds.length} selected${limitInfo}`;
            }

            function toggleSelection(value) {
                const idx = selectedIds.indexOf(value);
                if (idx >= 0) {
                    // Deselect
                    selectedIds.splice(idx, 1);
                } else {
                    // Check limit
                    if (limit && selectedIds.length >= limit) {
                        showToast(` Maximum ${limit} records allowed`);
                        return;
                    }
                    selectedIds.push(value);
                }
                updateCount();
                renderOptions(searchInput.value);
            }

            function renderOptions(query = '') {
                filteredOptions = query.trim() === ''
                    ? [...options]
                    : options.filter(opt => opt.label.toLowerCase().includes(query.toLowerCase()));

                if (filteredOptions.length === 0) {
                    optionsContainer.innerHTML = `
                        <div class="custom-select-empty">
                            <div class="custom-select-empty-icon"></div>
                            <div>No matches found</div>
                        </div>
                    `;
                    return;
                }

                optionsContainer.innerHTML = filteredOptions.map((opt) => {
                    const isSelected = selectedIds.includes(opt.value);

                    let displayLabel = opt.label;
                    if (query.trim() !== '') {
                        const regex = new RegExp(`(${query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
                        displayLabel = opt.label.replace(regex, '<span class="search-match">$1</span>');
                    }

                    return `
                        <div
                            class="custom-select-option multi-option ${isSelected ? 'selected' : ''}"
                            data-value="${opt.value}"
                        >
                            <div class="multi-checkbox ${isSelected ? 'checked' : ''}">
                                ${isSelected ? '<i class="ph-bold ph-check"></i>' : ''}
                            </div>
                            <div class="custom-select-option-icon" style="background: ${opt.color || '#f3f4f6'}">
                                ${opt.icon || ''}
                            </div>
                            <div class="custom-select-option-text">${displayLabel}</div>
                        </div>
                    `;
                }).join('');

                optionsContainer.querySelectorAll('.custom-select-option').forEach(el => {
                    el.onclick = () => toggleSelection(el.dataset.value);
                });
            }

            function saveAndClose() {
                const originalValue = record[field.id];
                const newValue = selectedIds.length === 0 ? null : (selectedIds.length === 1 ? selectedIds[0] : [...selectedIds]);
                if (JSON.stringify(newValue) !== JSON.stringify(originalValue)) {
                    updateRecord(recordId, field.id, newValue, originalValue);
                }
                dropdown.remove();
                exitEditMode();
            }

            searchInput.oninput = (e) => renderOptions(e.target.value);

            searchInput.onkeydown = (e) => {
                if (e.key === 'Escape') {
                    e.preventDefault();
                    dropdown.remove();
                    exitEditMode(false);
                } else if (e.key === 'Enter') {
                    e.preventDefault();
                    saveAndClose();
                }
            };

            clearBtn.onclick = () => {
                selectedIds.length = 0;
                updateCount();
                renderOptions(searchInput.value);
            };

            doneBtn.onclick = saveAndClose;

            setTimeout(() => {
                document.addEventListener('click', function closeDropdown(e) {
                    if (!dropdown.contains(e.target) && e.target !== td) {
                        saveAndClose();
                        document.removeEventListener('click', closeDropdown);
                    }
                });
            }, 0);

            renderOptions();
            searchInput.focus();
        }

        function toggleModalLinkedRecord(element) {
            const container = element.closest('.modal-multi-linked-record');
            if (!container) return;

            const recordId = container.dataset.recordId;
            const fieldId = container.dataset.fieldId;
            const limit = container.dataset.limit ? parseInt(container.dataset.limit) : null;
            const value = element.dataset.value;

            const set = getCurrentSet();
            const record = set.records.get(recordId);
            const field = set.schema.find(f => f.id === fieldId);

            // Get current selected values
            let currentValue = record[fieldId];
            let selectedIds = Array.isArray(currentValue) ? [...currentValue] : (currentValue ? [currentValue] : []);

            const idx = selectedIds.indexOf(value);
            if (idx >= 0) {
                // Deselect
                selectedIds.splice(idx, 1);
            } else {
                // Check limit
                if (limit && selectedIds.length >= limit) {
                    showToast(`Maximum ${limit} records allowed`);
                    return;
                }
                selectedIds.push(value);
            }

            // Update the record
            const newValue = selectedIds.length === 0 ? null : (selectedIds.length === 1 ? selectedIds[0] : selectedIds);
            updateRecord(recordId, fieldId, newValue, currentValue);

            // Re-render the modal
            if (!document.getElementById('expandedRecordModal').classList.contains('hidden')) {
                renderExpandedRecordMain(recordId);
            }
        }

        function filterModalLinkedRecords(containerId, query) {
            const container = document.getElementById(containerId);
            if (!container) return;

            const options = container.querySelectorAll('.modal-linked-option');
            const normalizedQuery = query.trim().toLowerCase();

            options.forEach(opt => {
                const label = opt.dataset.label?.toLowerCase() || '';
                if (normalizedQuery === '' || label.includes(normalizedQuery)) {
                    opt.style.display = '';
                } else {
                    opt.style.display = 'none';
                }
            });
        }

        function filterLinkedRecordSelect(selectId, query) {
            const select = document.getElementById(selectId);
            if (!select) return;

            const optionsData = select.dataset.options
                ? JSON.parse(decodeURIComponent(select.dataset.options))
                : [];
            const normalizedQuery = query.trim().toLowerCase();
            const filtered = optionsData.filter(opt => opt.label.toLowerCase().includes(normalizedQuery));
            const previousValue = select.value;

            select.innerHTML = '<option value="">Select a record</option>';

            if (filtered.length === 0) {
                const placeholder = document.createElement('option');
                placeholder.disabled = true;
                placeholder.textContent = 'No matches';
                select.appendChild(placeholder);
                select.value = '';
                select.disabled = true;
                return;
            }

            filtered.forEach(opt => {
                const option = document.createElement('option');
                option.value = opt.id;
                option.textContent = opt.label;
                select.appendChild(option);
            });

            const stillExists = filtered.some(opt => opt.id === previousValue);
            select.value = stillExists ? previousValue : '';
            select.disabled = false;
        }

      function updateRecord(recordId, fieldId, newValue, oldValue) {
          const set = getCurrentSet();
          const record = set.records.get(recordId);
          const field = set.schema.find(f => f.id === fieldId);

          // If clearing a field that had value, treat as toss
          const hasOldValue = oldValue !== null && oldValue !== undefined && oldValue !== '';
          const isClearing = newValue === null || newValue === undefined || newValue === '';
          if (hasOldValue && isClearing && typeof TossPile !== 'undefined' && TossPile.tossCell) {
              TossPile.tossCell(state, recordId, fieldId);
              renderCurrentView();
              showToast(` Cleared ${field.name}`);
              return;
          }

          record[fieldId] = newValue;
            createEvent(
                'Update Cell',
                'SEG',
                { type: 'Record', id: recordId, setId: set.id },
                {
                    fieldId: fieldId,
                    fieldName: field.name,
                    oldValue: oldValue,
                    newValue: newValue,
                    setId: set.id,
                    recordId: recordId,
                    summary: `Updated ${field.name}`
                }
            );
            renderCurrentView();
          showToast(` Updated ${field.name}`);
      }

        function buildDefaultConfigForType(type) {
            switch(type) {
                case 'SELECT':
                    return { options: [{ value: 'Option 1', color: 'blue' }], acceptNewOptions: true };
                case 'LINK_RECORD':
                    return { linkedSetId: state.currentSetId };
                default:
                    return null;
            }
        }

        function snapshotFieldValues(set, fieldId) {
            const values = new Map();
            set.records.forEach((record, recordId) => {
                values.set(recordId, record[fieldId]);
            });
            return values;
        }

        function restoreFieldValues(set, fieldId, values) {
            values.forEach((value, recordId) => {
                const record = set.records.get(recordId);
                if (record) record[fieldId] = value;
            });
        }

        function convertValueForType(value, fromType, toType, targetConfig = {}) {
            const defaults = FIELD_TYPES[toType]?.defaultValue;
            if (value === undefined || value === null) return defaults;

            switch(toType) {
                case 'TEXT':
                case 'LONG_TEXT':
                    return value === '' ? '' : String(value);
                case 'NUMBER':
                case 'CURRENCY': {
                    if (value === '') return 0;
                    if (value instanceof Date) return value.getTime();
                    if (typeof value === 'boolean') return value ? 1 : 0;
                    const cleaned = String(value).replace(/[$,]/g, '');
                    const parsed = Number(cleaned);
                    return Number.isNaN(parsed) ? 0 : parsed;
                }
                case 'DATE': {
                    if (value instanceof Date) return value;
                    if (typeof value === 'number') {
                        const date = new Date(value);
                        return Number.isNaN(date.getTime()) ? '' : date;
                    }
                    const parsed = new Date(value);
                    return Number.isNaN(parsed.getTime()) ? '' : parsed;
                }
                case 'EMAIL':
                case 'URL':
                case 'PHONE':
                    return String(value ?? '').trim();
                case 'CHECKBOX':
                    if (typeof value === 'string') {
                        return ['true', '1', 'yes', 'y', 'checked', 'on'].includes(value.trim().toLowerCase());
                    }
                    return Boolean(value);
                case 'SELECT': {
                    const str = String(value ?? '').trim();
                    if (!str) return '';
                    const options = targetConfig.options || [];
                    const acceptNewOptions = targetConfig.acceptNewOptions ?? true;
                    if (!options.some(opt => opt.value === str) && acceptNewOptions) {
                        options.push({ value: str, color: 'gray' });
                        targetConfig.options = options;
                    }
                    return str;
                }
                case 'LINK_RECORD':
                    return typeof value === 'string' ? value : '';
                default:
                    return value;
            }
        }

      // FIELD MANAGEMENT
      function resetFieldNameValidation() {
          const nameInput = document.getElementById('newFieldName');
          const nameError = document.getElementById('fieldNameError');
          if (nameInput) {
              nameInput.classList.remove('input-error');
              nameInput.removeAttribute('aria-invalid');
          }
          if (nameError) {
              nameError.classList.add('hidden');
              nameError.textContent = '';
          }
      }

      function openAddFieldModal() {
          // Reset select options
          state.selectOptions = [{ value: 'Option 1', color: 'blue' }];

          // Generate auto-name for the field
          const set = getCurrentSet();
          const view = getCurrentView();
          const isKeyDerived = view && view.type === 'KEY_DERIVED';
          let fieldNumber = 1;
          let autoName = `New Field ${fieldNumber}`;

          // Find the next available "New Field N" name
          // For KEY_DERIVED views, check view.schema; otherwise check set.schema
          const schemaToCheck = isKeyDerived ? (view.schema || []) : (set?.schema || []);
          while (schemaToCheck.some(f => f.name === autoName)) {
              fieldNumber++;
              autoName = `New Field ${fieldNumber}`;
          }

          // Set the auto-generated name
          const nameInput = document.getElementById('newFieldName');
          if (nameInput) {
              nameInput.value = autoName;
              // Select the text so user can easily replace it
              setTimeout(() => nameInput.select(), 100);
          }

          resetFieldNameValidation();

          // Reset field type to TEXT
          document.getElementById('newFieldType').value = 'TEXT';
          renderFieldTypeGrid('TEXT');
          closeFieldTypeDropdown();

          // Clear formula input
          const formulaInput = document.getElementById('formulaInput');
          if (formulaInput) formulaInput.value = '';

          // Reset formula format and decimals
          const formulaFormatContainer = document.getElementById('formulaFormatContainer');
          if (formulaFormatContainer) {
              formulaFormatContainer.innerHTML = '';
              state.formulaFormatDropdown = new EOCustomDropdown({
                  options: [
                      { value: 'number', label: 'Number', icon: '<i class="ph ph-hash"></i>' },
                      { value: 'currency', label: 'Currency', icon: '<i class="ph ph-currency-dollar"></i>' },
                      { value: 'percentage', label: 'Percentage', icon: '<i class="ph ph-percent"></i>' },
                      { value: 'text', label: 'Text', icon: '<i class="ph ph-text-aa"></i>' }
                  ],
                  value: 'number',
                  placeholder: 'Select format...'
              });
              formulaFormatContainer.appendChild(state.formulaFormatDropdown.create());
          }

          const formulaDecimals = document.getElementById('formulaDecimals');
          if (formulaDecimals) formulaDecimals.value = '2';

          // Update field config to show correct section
          updateFieldConfig('TEXT');

          // Populate link to set dropdown
          const linkToSetContainer = document.getElementById('linkToSetContainer');
          const sets = getSetsForWorld(state.currentWorldId);
          const setOptions = sets.map(set => ({
              value: set.id,
              label: set.id === state.currentSetId ? `${set.name} (this set)` : set.name,
              icon: '<i class="ph ph-table"></i>'
          }));

          // Clear existing dropdown if any
          linkToSetContainer.innerHTML = '';

          if (setOptions.length === 0) {
              state.linkToSetDropdown = new EOCustomDropdown({
                  options: [{ value: '', label: 'No sets available', disabled: true }],
                  placeholder: 'No sets available',
                  disabled: true
              });
          } else {
              const defaultValue = state.sets.has(state.currentSetId) ? state.currentSetId : setOptions[0].value;
              state.linkToSetDropdown = new EOCustomDropdown({
                  options: setOptions,
                  value: defaultValue,
                  placeholder: 'Select a set...',
                  searchable: setOptions.length > 5
              });
          }
          linkToSetContainer.appendChild(state.linkToSetDropdown.create())

          openModal('addFieldModal');
      }

        function renderFieldTypeGrid(selectedType) {
            const trigger = document.getElementById('fieldTypeTrigger');
            const dropdown = document.getElementById('fieldTypeDropdown');
            const selectedName = document.getElementById('selectedFieldTypeName');
            const selectedDescription = document.getElementById('selectedFieldTypeDescription');

            if (!trigger || !dropdown) return;

            const fieldType = FIELD_TYPES[selectedType] || Object.values(FIELD_TYPES)[0];
            const iconTarget = trigger.querySelector('.field-type-trigger-icon');
            if (iconTarget) iconTarget.innerHTML = renderIcon(fieldType.icon);
            if (selectedName) selectedName.textContent = fieldType.name;
            if (selectedDescription) selectedDescription.textContent = fieldType.description || fieldType.id.replace(/_/g, ' ');

            dropdown.innerHTML = '';
            Object.values(FIELD_TYPES).forEach(optionType => {
                const option = document.createElement('div');
                option.className = `field-type-option ${optionType.id === selectedType ? 'selected' : ''}`;
                option.dataset.typeId = optionType.id;
                option.innerHTML = `
                    <div class="field-type-icon">${renderIcon(optionType.icon)}</div>
                    <div class="field-type-info">
                        <div class="field-type-name">${optionType.name}</div>
                        <div class="field-type-description">${optionType.description || optionType.id.replace(/_/g, ' ')}</div>
                    </div>
                    <span class="field-type-check">${optionType.id === selectedType ? '' : ''}</span>
                `;
                option.onclick = () => selectFieldType(optionType.id);
                dropdown.appendChild(option);
            });
        }

        function selectFieldType(typeId) {
            document.getElementById('newFieldType').value = typeId;
            renderFieldTypeGrid(typeId);
            updateFieldConfig(typeId);
            closeFieldTypeDropdown();
        }

        function renderChangeFieldTypeGrid(selectedType) {
            const trigger = document.getElementById('changeFieldTypeTrigger');
            const dropdown = document.getElementById('changeFieldTypeDropdown');
            const selectedName = document.getElementById('changeSelectedFieldTypeName');
            const selectedDescription = document.getElementById('changeSelectedFieldTypeDescription');

            if (!trigger || !dropdown) return;

            const fieldType = FIELD_TYPES[selectedType] || Object.values(FIELD_TYPES)[0];
            const iconTarget = trigger.querySelector('.field-type-trigger-icon');
            if (iconTarget) iconTarget.innerHTML = renderIcon(fieldType.icon);
            if (selectedName) selectedName.textContent = fieldType.name;
            if (selectedDescription) selectedDescription.textContent = fieldType.description || fieldType.id.replace(/_/g, ' ');

            dropdown.innerHTML = '';
            Object.values(FIELD_TYPES).forEach(optionType => {
                // Skip derived types (not user-selectable)
                if (optionType.isDerived) return;

                const option = document.createElement('div');
                option.className = `field-type-option ${optionType.id === selectedType ? 'selected' : ''}`;
                option.dataset.typeId = optionType.id;
                option.innerHTML = `
                    <div class="field-type-icon">${renderIcon(optionType.icon)}</div>
                    <div class="field-type-info">
                        <div class="field-type-name">${optionType.name}</div>
                        <div class="field-type-description">${optionType.description || optionType.id.replace(/_/g, ' ')}</div>
                    </div>
                    <span class="field-type-check">${optionType.id === selectedType ? '' : ''}</span>
                `;
                option.onclick = () => selectChangeFieldType(optionType.id);
                dropdown.appendChild(option);
            });
        }

        function describeFieldType(typeId) {
            return FIELD_TYPES[typeId]?.name || typeId || '';
        }

        function updateChangeFieldTypeSummary(selectedType) {
            const summary = document.getElementById('changeFieldTypeSummary');
            if (!summary) return;

            const originalType = state.changeFieldOriginalType;
            const currentLabel = describeFieldType(selectedType);

            if (!originalType) {
                summary.textContent = currentLabel ? `Type: ${currentLabel}` : '';
                return;
            }

            const originalLabel = describeFieldType(originalType);
            if (selectedType === originalType) {
                summary.textContent = `Type: ${originalLabel}`;
            } else {
                summary.textContent = `Type: ${originalLabel}  ${currentLabel}`;
            }
        }

        function selectChangeFieldType(typeId) {
            const input = document.getElementById('changeFieldTypeInput');
            if (input) input.value = typeId;
            renderChangeFieldTypeGrid(typeId);
            resetChangeFieldConfig(typeId);
            renderChangeFieldConfig(typeId);
            if (typeId === 'LINK_RECORD') {
                renderChangeLinkSelect();
            }
            updateChangeFieldTypeSummary(typeId);
            closeChangeFieldTypeDropdown();
        }

        function toggleFieldTypeDropdown() {
            if (state.fieldTypeDropdownOpen) {
                closeFieldTypeDropdown();
            } else {
                openFieldTypeDropdown();
            }
        }

        function toggleChangeFieldTypeDropdown() {
            if (state.changeFieldTypeDropdownOpen) {
                closeChangeFieldTypeDropdown();
            } else {
                openChangeFieldTypeDropdown();
            }
        }

        function openFieldTypeDropdown() {
            const dropdown = document.getElementById('fieldTypeDropdown');
            const trigger = document.getElementById('fieldTypeTrigger');
            if (!dropdown || !trigger) return;
            dropdown.classList.remove('hidden');
            trigger.classList.add('active');
            state.fieldTypeDropdownOpen = true;
        }

        function openChangeFieldTypeDropdown() {
            const dropdown = document.getElementById('changeFieldTypeDropdown');
            const trigger = document.getElementById('changeFieldTypeTrigger');
            if (!dropdown || !trigger) return;
            dropdown.classList.remove('hidden');
            trigger.classList.add('active');
            state.changeFieldTypeDropdownOpen = true;
        }

        function closeFieldTypeDropdown() {
            const dropdown = document.getElementById('fieldTypeDropdown');
            const trigger = document.getElementById('fieldTypeTrigger');
            if (!dropdown || !trigger) return;
            dropdown.classList.add('hidden');
            trigger.classList.remove('active');
            state.fieldTypeDropdownOpen = false;
        }

        function closeChangeFieldTypeDropdown() {
            const dropdown = document.getElementById('changeFieldTypeDropdown');
            const trigger = document.getElementById('changeFieldTypeTrigger');
            if (!dropdown || !trigger) return;
            dropdown.classList.add('hidden');
            trigger.classList.remove('active');
            state.changeFieldTypeDropdownOpen = false;
        }

        function hasFieldHistory(setId, fieldId) {
            const key = `${setId}:${fieldId}`;
            const stack = state.fieldTypeHistory.get(key);
            return Array.isArray(stack) && stack.length > 0;
        }

        function buildChangeFieldConfig(typeId) {
            if (typeId === 'SELECT') {
                const acceptNewOptions = document.getElementById('changeAcceptNewOptions')?.checked ?? true;
                return {
                    options: state.changeSelectOptions.map(o => o.value),
                    colors: Object.fromEntries(state.changeSelectOptions.map(o => [o.value, o.color])),
                    acceptNewOptions: acceptNewOptions
                };
            }
            if (typeId === 'LINK_RECORD') {
                return { linkedSetId: state.changeLinkedSetId || state.currentSetId };
            }
            if (typeId === 'LOOKUP') {
                return { lookupSetId: state.changeLinkedSetId || state.currentSetId };
            }
            if (typeId === 'FORMULA') {
                const formula = document.getElementById('changeFormulaInput').value.trim();
                const format = document.getElementById('changeFormulaFormat').value;
                const decimals = parseInt(document.getElementById('changeFormulaDecimals').value) || 2;
                return { formula, format, decimals };
            }
            return null;
        }

        function changeFieldType(fieldId, newType, newSubtype = null, newConfig = null) {
            const set = getCurrentSet();
            const field = set.schema.find(f => f.id === fieldId);
            if (!field || !FIELD_TYPES[newType]) return;

            const previousType = field.type;
            const previousSubtype = field.subtype;
            const previousConfig = cloneConfig(field.config);
            const targetConfig = cloneConfig(newConfig ?? buildDefaultConfigForType(newType));
            const typeChanged = previousType !== newType;
            const subtypeChanged = previousSubtype !== newSubtype;
            const configChanged = JSON.stringify(previousConfig || null) !== JSON.stringify(targetConfig || null);

            if (!typeChanged && !subtypeChanged && !configChanged) return;

            const historyKey = `${set.id}:${fieldId}`;
            const historyStack = state.fieldTypeHistory.get(historyKey) || [];
            const historyEntry = {
                type: previousType,
                subtype: previousSubtype,
                config: cloneConfig(field.config)
            };
            if (typeChanged) {
                historyEntry.values = snapshotFieldValues(set, fieldId);
            }
            historyStack.push(historyEntry);
            state.fieldTypeHistory.set(historyKey, historyStack);

            if (typeChanged) {
                set.records.forEach((record, recordId) => {
                    const oldValue = record[fieldId];
                    record[fieldId] = convertValueForType(oldValue, previousType, newType, targetConfig || {});
                });
            }

            field.type = newType;
            field.subtype = newSubtype;
            field.config = targetConfig;

            createEvent(
                'Change Field Type',
                'SEG',
                { type: 'Field', id: fieldId, setId: set.id },
                { previousType, newType, fieldId, fieldName: field.name, setId: set.id, summary: typeChanged ? `Changed ${field.name} to ${FIELD_TYPES[newType].name}` : `Updated ${field.name}` }
            );

            renderCurrentView();
            showToast(typeChanged ? ` ${field.name} is now ${FIELD_TYPES[newType].name}` : ` ${field.name} updated`);
        }

        function saveChangeFieldType() {
            const context = state.changeFieldContext;
            const input = document.getElementById('changeFieldTypeInput');
            const subtypeSelect = document.getElementById('changeFieldSubtypeSelect');
            const newType = input?.value;
            const newSubtype = subtypeSelect?.value || null;
            if (!context || !newType) return;
            const newConfig = buildChangeFieldConfig(newType);
            changeFieldType(context.id, newType, newSubtype, newConfig);
            closeChangeFieldTypeModal();
        }

        function closeChangeFieldTypeModal() {
            state.changeFieldContext = null;
            state.changeFieldOriginalType = null;
            closeModal('changeFieldTypeModal');
        }

        function convertFormulaToEditable() {
            const context = state.changeFieldContext;
            if (!context || context.type !== 'FORMULA') {
                showToast('This field is not a formula field');
                return;
            }

            const set = getCurrentSet();
            const field = set.schema.find(f => f.id === context.id);
            if (!field) return;

            // Determine target type based on display format
            const format = field.config?.format || 'text';
            let targetType = 'TEXT';
            let targetSubtype = null;
            let targetConfig = null;

            if (format === 'currency') {
                targetType = 'CURRENCY';
            } else if (format === 'number' || format === 'percentage') {
                targetType = 'NUMBER';
            } else {
                targetType = 'TEXT';
            }

            // Calculate and freeze current formula values for all records
            set.records.forEach((record, recordId) => {
                // Calculate the formula value and store it as a static value
                const calculatedValue = FormulaEngine.evaluate(field.config?.formula || '', record, set.schema);
                record[field.id] = calculatedValue;
            });

            // Store history for undo
            const historyKey = `${set.id}:${field.id}`;
            const historyStack = state.fieldTypeHistory.get(historyKey) || [];
            historyStack.push({
                type: field.type,
                subtype: field.subtype,
                config: cloneConfig(field.config),
                values: snapshotFieldValues(set, field.id)
            });
            state.fieldTypeHistory.set(historyKey, historyStack);

            // Update field type
            field.type = targetType;
            field.subtype = targetSubtype;
            field.config = targetConfig;

            createEvent(
                'Convert Formula to Editable',
                'SEG',
                { type: 'Field', id: field.id, setId: set.id },
                { previousType: 'FORMULA', newType: targetType, fieldId: field.id, fieldName: field.name, setId: set.id, summary: `Converted ${field.name} from formula to ${FIELD_TYPES[targetType].name}` }
            );

            closeChangeFieldTypeModal();
            renderCurrentView();
            showToast(`${field.name} converted to editable ${FIELD_TYPES[targetType].name} field`);
        }

        function revertFieldType(fieldId) {
            const set = getCurrentSet();
            const field = set.schema.find(f => f.id === fieldId);
            if (!field) return;

            const historyKey = `${set.id}:${fieldId}`;
            const historyStack = state.fieldTypeHistory.get(historyKey) || [];
            const last = historyStack.pop();

            if (!last) {
                showToast('No previous type to restore');
                return;
            }

            field.type = last.type;
            field.subtype = last.subtype;
            field.config = cloneConfig(last.config);
            if (last.values) {
                restoreFieldValues(set, fieldId, last.values);
            }
            if (historyStack.length === 0) {
                state.fieldTypeHistory.delete(historyKey);
            } else {
                state.fieldTypeHistory.set(historyKey, historyStack);
            }

            createEvent(
                'Revert Field Type',
                'SEG',
                { type: 'Field', id: fieldId, setId: set.id },
                { restoredType: last.type, fieldId, fieldName: field.name, setId: set.id, summary: `Reverted ${field.name} to ${FIELD_TYPES[last.type].name}` }
            );

            renderCurrentView();
            showToast(` ${field.name} restored to ${FIELD_TYPES[last.type].name}`);
        }

        function updateFieldConfig(typeId) {
            document.getElementById('selectConfig').classList.remove('visible');
            document.getElementById('linkToRecordConfig').classList.remove('visible');
            document.getElementById('formulaConfig').classList.remove('visible');
            document.getElementById('numberConfig').classList.remove('visible');
            document.getElementById('dateConfig').classList.remove('visible');
            if (typeId === 'SELECT') {
                document.getElementById('selectConfig').classList.add('visible');
                renderSelectOptions();
            } else if (typeId === 'LINK_RECORD') {
                document.getElementById('linkToRecordConfig').classList.add('visible');
                setupLinkCardinalityListeners('linkCardinality', 'linkLimitInput');
            } else if (typeId === 'FORMULA') {
                document.getElementById('formulaConfig').classList.add('visible');
                initFormulaAutocomplete();
            } else if (typeId === 'NUMBER' || typeId === 'CURRENCY') {
                document.getElementById('numberConfig').classList.add('visible');
                setupAddFieldNumberListeners();
                // Pre-select currency format if CURRENCY type
                if (typeId === 'CURRENCY') {
                    const currencyRadio = document.querySelector('input[name="numberFormat"][value="currency"]');
                    if (currencyRadio) currencyRadio.checked = true;
                    document.getElementById('currencyOptions')?.classList.remove('hidden');
                }
            } else if (typeId === 'DATE' || typeId === 'DATETIME' || typeId === 'TIME') {
                document.getElementById('dateConfig').classList.add('visible');
                setupAddFieldDateListeners();
                // Set initial mode based on type
                const modeRadio = document.querySelector(`input[name="dateMode"][value="${typeId.toLowerCase()}"]`);
                if (modeRadio) modeRadio.checked = true;
                updateAddFieldDateVisibility();
            }
        }

        function setupAddFieldNumberListeners() {
            // Show/hide currency options based on format selection
            const formatRadios = document.querySelectorAll('input[name="numberFormat"]');
            const currencyOptions = document.getElementById('currencyOptions');

            formatRadios.forEach(radio => {
                radio.addEventListener('change', () => {
                    if (radio.value === 'currency') {
                        currencyOptions.classList.remove('hidden');
                    } else {
                        currencyOptions.classList.add('hidden');
                    }
                });
            });
        }

        function setupAddFieldDateListeners() {
            // Show/hide time format based on mode selection
            const modeRadios = document.querySelectorAll('input[name="dateMode"]');
            const showTimezoneCheckbox = document.getElementById('showTimezone');
            const timezoneSelect = document.getElementById('timezone');

            modeRadios.forEach(radio => {
                radio.addEventListener('change', updateAddFieldDateVisibility);
            });

            // Toggle timezone select visibility
            if (showTimezoneCheckbox) {
                showTimezoneCheckbox.addEventListener('change', () => {
                    if (showTimezoneCheckbox.checked) {
                        timezoneSelect.classList.remove('hidden');
                    } else {
                        timezoneSelect.classList.add('hidden');
                    }
                });
            }
        }

        function updateAddFieldDateVisibility() {
            const mode = document.querySelector('input[name="dateMode"]:checked')?.value || 'date';
            const dateFormatSection = document.getElementById('dateFormatSection');
            const timeFormatSection = document.getElementById('timeFormatSection');

            if (mode === 'time') {
                dateFormatSection.classList.add('hidden');
                timeFormatSection.classList.remove('hidden');
            } else if (mode === 'date') {
                dateFormatSection.classList.remove('hidden');
                timeFormatSection.classList.add('hidden');
            } else {
                // datetime - show both
                dateFormatSection.classList.remove('hidden');
                timeFormatSection.classList.remove('hidden');
            }
        }

        function renderChangeFieldConfig(typeId) {
            document.getElementById('changeSelectConfig').classList.remove('visible');
            document.getElementById('changeLinkToRecordConfig').classList.remove('visible');
            document.getElementById('changeFormulaConfig').classList.remove('visible');
            document.getElementById('changeNumberConfig').classList.remove('visible');
            document.getElementById('changeDateConfig').classList.remove('visible');

            // Handle subtype selector
            const subtypeContainer = document.getElementById('changeFieldSubtypeConfig');
            if (subtypeContainer) {
                const fieldType = FIELD_TYPES[typeId];
                if (fieldType?.subtypes) {
                    const subtypeOptions = Object.values(fieldType.subtypes)
                        .map(st => `<option value="${st.id}">${st.name}</option>`)
                        .join('');
                    subtypeContainer.innerHTML = `
                        <div class="mb-4">
                            <label class="form-label">Field Subtype</label>
                            <select id="changeFieldSubtypeSelect" class="w-full">${subtypeOptions}</select>
                        </div>
                    `;
                    subtypeContainer.classList.add('visible');
                } else {
                    subtypeContainer.innerHTML = '';
                    subtypeContainer.classList.remove('visible');
                }
            }

            if (typeId === 'SELECT') {
                document.getElementById('changeSelectConfig').classList.add('visible');
                renderChangeSelectOptions();
            } else if (typeId === 'LINK_RECORD') {
                document.getElementById('changeLinkToRecordConfig').classList.add('visible');
            } else if (typeId === 'LOOKUP') {
                document.getElementById('changeLinkToRecordConfig').classList.add('visible');
                renderChangeLookupSelect();
            } else if (typeId === 'FORMULA') {
                document.getElementById('changeFormulaConfig').classList.add('visible');
                initChangeFormulaAutocomplete();
                // Show convert option only if original field was a FORMULA
                const convertSection = document.getElementById('convertToEditableSection');
                if (convertSection) {
                    if (state.changeFieldOriginalType === 'FORMULA') {
                        convertSection.classList.remove('hidden');
                    } else {
                        convertSection.classList.add('hidden');
                    }
                }
            } else if (typeId === 'NUMBER' || typeId === 'CURRENCY') {
                document.getElementById('changeNumberConfig').classList.add('visible');
                setupChangeNumberListeners();
                // Pre-select currency format if CURRENCY type
                if (typeId === 'CURRENCY') {
                    const currencyRadio = document.querySelector('input[name="changeNumberFormat"][value="currency"]');
                    if (currencyRadio) currencyRadio.checked = true;
                    document.getElementById('changeCurrencyOptions')?.classList.remove('hidden');
                }
            } else if (typeId === 'DATE' || typeId === 'DATETIME' || typeId === 'TIME') {
                document.getElementById('changeDateConfig').classList.add('visible');
                setupChangeDateListeners();
                // Set initial mode based on type
                const modeRadio = document.querySelector(`input[name="changeDateMode"][value="${typeId.toLowerCase()}"]`);
                if (modeRadio) modeRadio.checked = true;
                updateChangeDateVisibility();
            }
        }

        function setupChangeNumberListeners() {
            // Show/hide currency options based on format selection
            const formatRadios = document.querySelectorAll('input[name="changeNumberFormat"]');
            const currencyOptions = document.getElementById('changeCurrencyOptions');

            formatRadios.forEach(radio => {
                radio.addEventListener('change', () => {
                    if (radio.value === 'currency') {
                        currencyOptions.classList.remove('hidden');
                    } else {
                        currencyOptions.classList.add('hidden');
                    }
                });
            });
        }

        function setupChangeDateListeners() {
            // Show/hide time format based on mode selection
            const modeRadios = document.querySelectorAll('input[name="changeDateMode"]');
            const showTimezoneCheckbox = document.getElementById('changeShowTimezone');
            const timezoneSelect = document.getElementById('changeTimezone');

            modeRadios.forEach(radio => {
                radio.addEventListener('change', updateChangeDateVisibility);
            });

            // Toggle timezone select visibility
            if (showTimezoneCheckbox) {
                showTimezoneCheckbox.addEventListener('change', () => {
                    if (showTimezoneCheckbox.checked) {
                        timezoneSelect.classList.remove('hidden');
                    } else {
                        timezoneSelect.classList.add('hidden');
                    }
                });
            }
        }

        function updateChangeDateVisibility() {
            const mode = document.querySelector('input[name="changeDateMode"]:checked')?.value || 'date';
            const dateFormatSection = document.getElementById('changeDateFormatSection');
            const timeFormatSection = document.getElementById('changeTimeFormatSection');

            if (mode === 'time') {
                dateFormatSection.classList.add('hidden');
                timeFormatSection.classList.remove('hidden');
            } else if (mode === 'date') {
                dateFormatSection.classList.remove('hidden');
                timeFormatSection.classList.add('hidden');
            } else {
                // datetime - show both
                dateFormatSection.classList.remove('hidden');
                timeFormatSection.classList.remove('hidden');
            }
        }

        function renderChangeLookupSelect() {
            const changeLinkToSetContainer = document.getElementById('changeLinkToSetContainer');
            if (!changeLinkToSetContainer) return;

            const sets = getSetsForWorld(state.currentWorldId);
            const setOptions = sets.map(set => ({
                value: set.id,
                label: set.id === state.currentSetId ? `${set.name} (this set)` : set.name,
                icon: '<i class="ph ph-table"></i>'
            }));

            changeLinkToSetContainer.innerHTML = '';

            if (setOptions.length === 0) {
                state.changeLinkToSetDropdown = new EOCustomDropdown({
                    options: [{ value: '', label: 'No sets available', disabled: true }],
                    placeholder: 'No sets available',
                    disabled: true,
                    onChange: (value) => { state.changeLinkedSetId = value; }
                });
                state.changeLinkedSetId = '';
            } else {
                const defaultValue = state.changeLinkedSetId || (state.sets.has(state.currentSetId) ? state.currentSetId : setOptions[0].value);
                state.changeLinkToSetDropdown = new EOCustomDropdown({
                    options: setOptions,
                    value: defaultValue,
                    placeholder: 'Select a set...',
                    searchable: setOptions.length > 5,
                    onChange: (value) => { state.changeLinkedSetId = value; }
                });
                state.changeLinkedSetId = defaultValue;
            }
            changeLinkToSetContainer.appendChild(state.changeLinkToSetDropdown.create());
        }

        function renderChangeSelectOptions() {
            const container = document.getElementById('changeSelectOptionsList');
            container.innerHTML = state.changeSelectOptions.map((opt, i) => `
                <div class="option-row">
                    <input type="text" value="${opt.value}" onchange="changeUpdateSelectOption(${i}, this.value, '${opt.color}')" placeholder="Option ${i + 1}">
                    <div class="color-picker">
                        ${['blue', 'green', 'yellow', 'red', 'purple', 'gray'].map(c => `
                            <div class="color-option badge-${c} ${opt.color === c ? 'selected' : ''}"
                                 onclick="changeUpdateSelectOption(${i}, '${opt.value}', '${c}')"></div>
                        `).join('')}
                    </div>
                    ${state.changeSelectOptions.length > 1 ? `<button onclick="changeRemoveSelectOption(${i})" class="btn btn-secondary btn-sm"></button>` : ''}
                </div>
            `).join('');
        }

        function changeAddSelectOption() {
            state.changeSelectOptions.push({ value: `Option ${state.changeSelectOptions.length + 1}`, color: 'blue' });
            renderChangeSelectOptions();
        }

        function changeUpdateSelectOption(index, value, color) {
            state.changeSelectOptions[index] = { value, color };
            renderChangeSelectOptions();
        }

        function changeRemoveSelectOption(index) {
            state.changeSelectOptions.splice(index, 1);
            renderChangeSelectOptions();
        }

        function resetChangeFieldConfig(typeId, field = null) {
            if (typeId === 'SELECT') {
                if (field?.config?.options) {
                    state.changeSelectOptions = field.config.options.map(opt => ({
                        value: typeof opt === 'string' ? opt : opt.value,
                        color: field.config.colors?.[typeof opt === 'string' ? opt : opt.value] || opt.color || 'blue'
                    }));
                } else {
                    state.changeSelectOptions = [{ value: 'Option 1', color: 'blue' }];
                }
                // Set the accept new options checkbox
                const acceptNewOptionsCheckbox = document.getElementById('changeAcceptNewOptions');
                if (acceptNewOptionsCheckbox) {
                    acceptNewOptionsCheckbox.checked = field?.config?.acceptNewOptions ?? true;
                }
            } else if (typeId === 'LINK_RECORD') {
                state.changeLinkedSetId = field?.config?.linkedSetId || state.currentSetId;
            } else if (typeId === 'FORMULA') {
                // Populate formula configuration from existing field
                const formulaInput = document.getElementById('changeFormulaInput');
                const changeFormulaFormatContainer = document.getElementById('changeFormulaFormatContainer');
                const decimalsInput = document.getElementById('changeFormulaDecimals');

                if (formulaInput) formulaInput.value = field?.config?.formula || '';
                if (changeFormulaFormatContainer) {
                    changeFormulaFormatContainer.innerHTML = '';
                    state.changeFormulaFormatDropdown = new EOCustomDropdown({
                        options: [
                            { value: 'number', label: 'Number', icon: '<i class="ph ph-hash"></i>' },
                            { value: 'currency', label: 'Currency', icon: '<i class="ph ph-currency-dollar"></i>' },
                            { value: 'percentage', label: 'Percentage', icon: '<i class="ph ph-percent"></i>' },
                            { value: 'text', label: 'Text', icon: '<i class="ph ph-text-aa"></i>' }
                        ],
                        value: field?.config?.format || 'number',
                        placeholder: 'Select format...'
                    });
                    changeFormulaFormatContainer.appendChild(state.changeFormulaFormatDropdown.create());
                }
                if (decimalsInput) decimalsInput.value = field?.config?.decimals || 2;
            }
        }

        function renderChangeLinkSelect() {
            const changeLinkToSetContainer = document.getElementById('changeLinkToSetContainer');
            if (!changeLinkToSetContainer) return;

            const sets = getSetsForWorld(state.currentWorldId);
            const setOptions = sets.map(set => ({
                value: set.id,
                label: set.id === state.currentSetId ? `${set.name} (this set)` : set.name,
                icon: '<i class="ph ph-table"></i>'
            }));

            changeLinkToSetContainer.innerHTML = '';

            if (setOptions.length === 0) {
                state.changeLinkToSetDropdown = new EOCustomDropdown({
                    options: [{ value: '', label: 'No sets available', disabled: true }],
                    placeholder: 'No sets available',
                    disabled: true,
                    onChange: (value) => { state.changeLinkedSetId = value; }
                });
                state.changeLinkedSetId = '';
            } else {
                const defaultValue = state.changeLinkedSetId || (state.sets.has(state.currentSetId) ? state.currentSetId : setOptions[0].value);
                state.changeLinkToSetDropdown = new EOCustomDropdown({
                    options: setOptions,
                    value: defaultValue,
                    placeholder: 'Select a set...',
                    searchable: setOptions.length > 5,
                    onChange: (value) => { state.changeLinkedSetId = value; }
                });
                state.changeLinkedSetId = defaultValue;
            }
            changeLinkToSetContainer.appendChild(state.changeLinkToSetDropdown.create());
        }

        function renderSelectOptions() {
            const container = document.getElementById('selectOptionsList');
            container.innerHTML = state.selectOptions.map((opt, i) => `
                <div class="option-row">
                    <input type="text" value="${opt.value}" onchange="updateSelectOption(${i}, this.value, '${opt.color}')" placeholder="Option ${i + 1}">
                    <div class="color-picker">
                        ${['blue', 'green', 'yellow', 'red', 'purple', 'gray'].map(c => `
                            <div class="color-option badge-${c} ${opt.color === c ? 'selected' : ''}" 
                                 onclick="updateSelectOption(${i}, '${opt.value}', '${c}')"></div>
                        `).join('')}
                    </div>
                    ${state.selectOptions.length > 1 ? `<button onclick="removeSelectOption(${i})" class="btn btn-secondary btn-sm"></button>` : ''}
                </div>
            `).join('');
        }

        function addSelectOption() {
            state.selectOptions.push({ value: `Option ${state.selectOptions.length + 1}`, color: 'blue' });
            renderSelectOptions();
        }

        function updateSelectOption(index, value, color) {
            state.selectOptions[index] = { value, color };
            renderSelectOptions();
        }

        function removeSelectOption(index) {
            state.selectOptions.splice(index, 1);
            renderSelectOptions();
        }

      function saveField() {
          const nameInput = document.getElementById('newFieldName');
          const nameError = document.getElementById('fieldNameError');
          const name = nameInput.value.trim();
          const type = document.getElementById('newFieldType').value;

          if (!name) {
              if (nameError) {
                  nameError.textContent = 'Please add a field name to continue.';
                  nameError.classList.remove('hidden');
              }
              nameInput.classList.add('input-error');
              nameInput.setAttribute('aria-invalid', 'true');
              nameInput.focus();
              return;
          }

          resetFieldNameValidation();

          const set = getCurrentSet();
          const view = getCurrentView();
          const fieldId = name.toLowerCase().replace(/[^a-z0-9]/g, '_');
          const isKeyDerived = view && view.type === 'KEY_DERIVED';

            // Check for duplicate field ID in the appropriate schema
            const schemaToCheck = isKeyDerived ? (view.schema || []) : (set?.schema || []);
            if (schemaToCheck.find(f => f.id === fieldId)) {
                showConfirm('A field with this name already exists', () => {});
                return;
            }

            const subtype = document.getElementById('fieldManagerNewSubtype')?.value || null;
            const newField = { id: fieldId, name: name, type: type, subtype: subtype, width: '150px', config: {} };

            if (type === 'SELECT') {
                const acceptNewOptions = document.getElementById('acceptNewOptions')?.checked ?? true;
                newField.config = {
                    options: state.selectOptions.map(o => o.value),
                    colors: Object.fromEntries(state.selectOptions.map(o => [o.value, o.color])),
                    acceptNewOptions: acceptNewOptions
                };
            } else if (type === 'LINK_RECORD') {
                const linkedSetId = state.linkToSetDropdown?.getValue() || '';
                if (!linkedSetId) { showConfirm('Select a set to link to', () => {}); return; }
                const cardinalityRadio = document.querySelector('input[name="linkCardinality"]:checked');
                const cardinality = cardinalityRadio?.value || 'many';
                const limit = cardinality === 'limit' ? parseInt(document.getElementById('linkLimit')?.value || '3', 10) : null;
                newField.config = { linkedSetId, cardinality, limit };
            } else if (type === 'FORMULA') {
                const formula = document.getElementById('formulaInput').value.trim();
                const format = state.formulaFormatDropdown?.getValue() || 'number';
                const decimals = parseInt(document.getElementById('formulaDecimals').value) || 2;

                if (!formula) {
                    showConfirm('Please enter a formula', () => {});
                    return;
                }

                const validation = FormulaEngine.validateFormula(formula, set.schema);
                if (!validation.valid) {
                    showConfirm(`Formula error: ${validation.error}`, () => {});
                    return;
                }

                newField.config = { formula, format, decimals };
            } else if (type === 'NUMBER' || type === 'CURRENCY') {
                const formatRadio = document.querySelector('input[name="numberFormat"]:checked');
                const format = formatRadio?.value || 'decimal';
                const minVal = document.getElementById('numberMin')?.value;
                const maxVal = document.getElementById('numberMax')?.value;
                newField.config = {
                    format: format,
                    decimalPlaces: parseInt(document.getElementById('numberDecimals')?.value || '2'),
                    roundingMode: document.getElementById('numberRounding')?.value || 'round',
                    thousandSeparator: document.getElementById('thousandSep')?.checked ?? true,
                    allowNegative: document.getElementById('allowNegative')?.checked ?? true,
                    currencyCode: format === 'currency' ? (document.getElementById('currencyCode')?.value || 'USD') : null,
                    min: minVal !== '' ? parseFloat(minVal) : null,
                    max: maxVal !== '' ? parseFloat(maxVal) : null
                };
                // Set type to CURRENCY if currency format selected under NUMBER
                if (type === 'NUMBER' && format === 'currency') {
                    newField.type = 'CURRENCY';
                }
            } else if (type === 'DATE' || type === 'DATETIME' || type === 'TIME') {
                const modeRadio = document.querySelector('input[name="dateMode"]:checked');
                const mode = modeRadio?.value || 'date';
                const timeFormatRadio = document.querySelector('input[name="timeFormat"]:checked');
                newField.config = {
                    mode: mode,
                    dateFormat: document.getElementById('dateFormat')?.value || 'MM/DD/YYYY',
                    timeFormat: timeFormatRadio?.value || '12h_ampm',
                    includeSeconds: document.getElementById('includeSeconds')?.checked ?? false,
                    showTimezone: document.getElementById('showTimezone')?.checked ?? false,
                    timezone: document.getElementById('timezone')?.value || null
                };
                // Update the type based on the mode selected
                if (mode === 'datetime') {
                    newField.type = 'DATETIME';
                } else if (mode === 'time') {
                    newField.type = 'TIME';
                } else {
                    newField.type = 'DATE';
                }
            }

            // Handle KEY_DERIVED views differently - add to view.schema
            if (isKeyDerived) {
                if (!view.schema) {
                    view.schema = [];
                }
                view.schema.push(newField);
            } else {
                set.schema.push(newField);
                // Add field to current view so it appears immediately
                addFieldToCurrentView(fieldId);
                set.records.forEach(r => r[fieldId] = FIELD_TYPES[type].defaultValue);
            }

            closeModal('addFieldModal');
            renderCurrentView();
            
            // Scroll to new field
            setTimeout(() => {
                const header = document.querySelector(`[data-field-id="${fieldId}"]`);
                if (header) {
                    header.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'end' });
                    header.style.animation = 'flash-yellow 0.5s ease-out';
                }
            }, 100);
            
            showToast(' Field added');

            // Auto-create lookup fields for LINK_RECORD
            if (type === 'LINK_RECORD' && newField.config?.linkedSetId) {
                autoCreateLookupFieldsForLink(set, view, newField);
            }
        }

        /**
         * Auto-create lookup fields for all fields in a linked set
         * These are added as hidden by default for a "full merge" experience
         */
        function autoCreateLookupFieldsForLink(set, view, linkField) {
            const linkedSetId = linkField.config?.linkedSetId;
            if (!linkedSetId) return;

            const linkedSet = state.sets.get(linkedSetId);
            if (!linkedSet || !linkedSet.schema) return;

            // Use configured cardinality, or detect from data as fallback
            let cardinality = linkField.config?.cardinality || 'many';

            // If cardinality is 'limit' with a value > 1, treat as 'many' for lookup/rollup purposes
            if (cardinality === 'limit') {
                const limit = linkField.config?.limit || 1;
                cardinality = limit > 1 ? 'many' : 'one';
            }

            // Fallback: detect from existing data if not configured
            if (!linkField.config?.cardinality) {
                set.records.forEach(record => {
                    const value = record[linkField.id];
                    if (Array.isArray(value) && value.length > 1) {
                        cardinality = 'many';
                    }
                });
            }

            // Initialize view arrays if needed
            if (!view.relationships) view.relationships = [];
            if (!view.rollups) view.rollups = [];
            if (!view.hiddenFields) view.hiddenFields = [];

            // Get already added lookups to avoid duplicates
            const existingLookups = view.relationships
                .filter(r => r.sourceFieldId === linkField.id && r.targetSetId === linkedSetId)
                .map(r => r.targetFieldId);
            const existingRollups = view.rollups
                .filter(r => r.sourceFieldId === linkField.id && r.targetSetId === linkedSetId)
                .map(r => r.targetFieldId);

            let addedCount = 0;

            // Add lookup/rollup for each field in the linked set
            linkedSet.schema.forEach(targetField => {
                // Skip if already added
                if (existingLookups.includes(targetField.id) || existingRollups.includes(targetField.id)) return;

                const uniqueId = `linked_${Date.now()}_${Math.random().toString(36).slice(2, 9)}`;

                if (cardinality === 'one') {
                    // Add as lookup
                    view.relationships.push({
                        id: uniqueId,
                        type: 'lookup',
                        sourceFieldId: linkField.id,
                        targetSetId: linkedSetId,
                        targetFieldId: targetField.id,
                        displayName: `${linkedSet.name}  ${targetField.name}`,
                        direction: 'outgoing',
                        sourceSetId: null,
                        createdAt: Date.now()
                    });
                } else {
                    // Add as rollup with appropriate aggregation
                    const aggregation = targetField.type === 'NUMBER' ? 'sum' :
                                        targetField.type === 'DATE' ? 'max' : 'arrayjoin';
                    view.rollups.push({
                        id: uniqueId,
                        type: 'rollup',
                        sourceFieldId: linkField.id,
                        targetSetId: linkedSetId,
                        targetFieldId: targetField.id,
                        aggregation: aggregation,
                        displayName: `${linkedSet.name}  ${targetField.name} (${aggregation})`,
                        direction: 'outgoing',
                        sourceSetId: null,
                        createdAt: Date.now()
                    });
                }

                // Add to hidden fields by default
                view.hiddenFields.push(uniqueId);
                addedCount++;
            });

            if (addedCount > 0) {
                view.isDirty = true;
                showToast(` Auto-added ${addedCount} lookup field${addedCount !== 1 ? 's' : ''} from ${linkedSet.name} (hidden by default)`);
            }
        }

        /**
         * Get count of hidden fields in a view
         * Includes both schema hidden fields and computed hidden fields (lookups/rollups)
         */
        function getHiddenFieldsCount(view, set) {
            if (!view) return 0;

            let count = 0;

            // Count hidden schema fields
            const hiddenFields = view.hiddenFields || [];
            const schemaFieldIds = (set?.schema || []).map(f => f.id);
            count += hiddenFields.filter(id => schemaFieldIds.includes(id)).length;

            // Count hidden computed fields (lookups and rollups)
            const relationships = view.relationships || [];
            const rollups = view.rollups || [];
            const computedIds = [...relationships.map(r => r.id), ...rollups.map(r => r.id)];
            count += hiddenFields.filter(id => computedIds.includes(id)).length;

            return count;
        }

        /**
         * Open the fields explorer with a specific filter pre-selected
         */
        function openFieldsExplorerWithFilter(filterType = 'hidden') {
            const view = getCurrentView();
            const set = getCurrentSet();

            if (!view || !set) {
                showToast(' No active view or set');
                return;
            }

            // Check if EOAvailableFieldsExplorer is loaded
            if (!window.EOAvailableFieldsExplorer) {
                showToast(' Fields Explorer not loaded');
                return;
            }

            const explorer = new window.EOAvailableFieldsExplorer();
            explorer.show(view, set, state);

            // Pre-select the filter after a short delay to ensure DOM is ready
            setTimeout(() => {
                explorer.setFilterType(filterType);
            }, 50);
        }

        // FILTERING (simplified for space)
        function openFilterModal() {
            renderFilterBuilder();
            openModal('filterModal');
        }

        function renderFilterBuilder() {
            const view = getCurrentView();
            const container = document.getElementById('filterGroupsContainer');
            if (!view.filters || view.filters.length === 0) view.filters = [[{ field: '', operator: 'equals', value: '' }]];
            container.innerHTML = view.filters.map((group, groupIndex) => `
                <div class="filter-group">
                    <div class="filter-group-header">
                        <div class="filter-operator-toggle">
                            <button class="${group.operator !== 'OR' ? 'active' : ''}" onclick="setGroupOperator(${groupIndex}, 'AND')">AND</button>
                            <button class="${group.operator === 'OR' ? 'active' : ''}" onclick="setGroupOperator(${groupIndex}, 'OR')">OR</button>
                        </div>
                        <button onclick="removeFilterGroup(${groupIndex})" class="text-red-600 text-sm">Remove Group</button>
                    </div>
                    ${group.map((rule, ruleIndex) => renderFilterRule(groupIndex, ruleIndex, rule)).join('')}
                    <button onclick="addFilterRule(${groupIndex})" class="btn btn-secondary btn-sm mt-2">+ Add Rule</button>
                </div>
            `).join('');
        }

        function renderFilterRule(groupIndex, ruleIndex, rule) {
            const schema = getCurrentSet().schema;
            const selectedField = schema.find(f => f.id === rule.field);
            const inputType = getInputTypeForField(selectedField);
            return `
                <div class="filter-rule">
                    <select onchange="updateFilterField(${groupIndex}, ${ruleIndex}, this.value)">
                        <option value="">Select field...</option>
                        ${schema.map(f => `<option value="${f.id}" ${f.id === rule.field ? 'selected' : ''}>${f.name}</option>`).join('')}
                    </select>
                    <select><option>equals</option></select>
                    <input type="${inputType}" value="${rule.value || ''}" onchange="updateFilterValue(${groupIndex}, ${ruleIndex}, this.value)">
                    <button onclick="removeFilterRule(${groupIndex}, ${ruleIndex})" class="text-red-600"></button>
                </div>
            `;
        }

        function getInputTypeForField(field) {
            if (!field) return 'text';
            switch (field.type) {
                case 'DATE':
                case 'DATETIME':
                    return 'date';
                case 'NUMBER':
                case 'CURRENCY':
                    return 'number';
                default:
                    return 'text';
            }
        }

        // Helper to get nested property values using dot notation (e.g., '_provenance.importId')
        function getNestedValue(obj, path) {
            if (!path || !obj) return undefined;
            const parts = path.split('.');
            let value = obj;
            for (const part of parts) {
                if (value === null || value === undefined) return undefined;
                value = value[part];
            }
            return value;
        }

        function applyFilterGroups(records, filterGroups, schema) {
            return records.filter(record => {
                return filterGroups.some(group => {
                    const operator = group.operator || 'AND';
                    const rules = group.filter(r => r.field);
                    if (operator === 'AND') return rules.every(rule => getNestedValue(record, rule.field) === rule.value);
                    else return rules.some(rule => getNestedValue(record, rule.field) === rule.value);
                });
            });
        }

        function getSortableValue(value, field) {
            if (value === undefined || value === null) return '';
            switch(field?.type) {
                case 'NUMBER':
                case 'CURRENCY':
                    return Number(value) || 0;
                case 'DATE':
                    return new Date(value).getTime() || 0;
                case 'CHECKBOX':
                    return value ? 1 : 0;
                case 'LINKED_LOOKUP':
                    // Linked lookup values are strings
                    return String(value).toLowerCase();
                case 'LINKED_ROLLUP':
                    // Rollup values can be numbers (SUM, COUNT, etc.) or strings (CONCAT)
                    const agg = field._linkedConfig?.aggregation;
                    if (agg === 'SUM' || agg === 'COUNT' || agg === 'AVG' || agg === 'MIN' || agg === 'MAX') {
                        return Number(value) || 0;
                    }
                    return String(value).toLowerCase();
                default:
                    return String(value).toLowerCase();
            }
        }

        // Helper to get field value, handling computed linked fields
        function getFieldValue(record, field) {
            if (!field) return undefined;

            // Handle LINKED_LOOKUP fields - compute value using evaluateLinkedLookup
            if (field.type === 'LINKED_LOOKUP' && field._linkedConfig) {
                return evaluateLinkedLookup(field._linkedConfig, record, state);
            }

            // Handle LINKED_ROLLUP fields - compute value using rollup engine
            if (field.type === 'LINKED_ROLLUP' && field._linkedConfig && window.EOCRollupEngine) {
                return window.EOCRollupEngine.evaluate(field._linkedConfig, record, state);
            }

            // Regular field - get value directly from record
            return record[field.id];
        }

        function applySorts(records, sorts, schema) {
            if (!sorts || sorts.length === 0) return records;
            const schemaMap = new Map(schema.map(f => [f.id, f]));
            const activeSorts = sorts.filter(sort => schemaMap.has(sort.fieldId));
            if (activeSorts.length === 0) return records;

            return [...records].sort((a, b) => {
                for (const sort of activeSorts) {
                    const field = schemaMap.get(sort.fieldId);
                    const aVal = getSortableValue(getFieldValue(a, field), field);
                    const bVal = getSortableValue(getFieldValue(b, field), field);

                    if (aVal < bVal) return sort.direction === 'desc' ? 1 : -1;
                    if (aVal > bVal) return sort.direction === 'desc' ? -1 : 1;
                }
                return 0;
            });
        }

        function toggleColumnSort(fieldId) {
            const view = getCurrentView();
            if (!view) return;

            ensureViewDefaults(view);
            const existingIndex = view.sorts.findIndex(s => s.fieldId === fieldId);
            if (existingIndex === -1) {
                view.sorts.unshift({ fieldId, direction: 'asc' });
            } else if (view.sorts[existingIndex].direction === 'asc') {
                view.sorts[existingIndex].direction = 'desc';
            } else {
                view.sorts.splice(existingIndex, 1);
            }

            renderCurrentView();
        }

        function openSortModal() {
            const view = getCurrentView();
            if (!view) return;

            ensureViewDefaults(view);
            renderSortBuilder();
            openModal('sortModal');
        }

        function getFieldIcon(fieldType) {
            const icons = {
                'TEXT': 'ph-text-aa',
                'LONG_TEXT': 'ph-article',
                'NUMBER': 'ph-hash',
                'CURRENCY': 'ph-currency-dollar',
                'DATE': 'ph-calendar',
                'DATETIME': 'ph-calendar-blank',
                'CHECKBOX': 'ph-check-square',
                'SELECT': 'ph-list-bullets',
                'MULTI_SELECT': 'ph-list-checks',
                'URL': 'ph-link',
                'EMAIL': 'ph-envelope',
                'PHONE': 'ph-phone',
                'USER': 'ph-user',
                'ATTACHMENT': 'ph-paperclip',
                'LINKED_RECORD': 'ph-link-simple',
                'LINKED_LOOKUP': 'ph-eye',
                'LINKED_ROLLUP': 'ph-calculator',
                'FORMULA': 'ph-function',
                'AUTONUMBER': 'ph-number-circle-one',
                'CREATED_TIME': 'ph-clock',
                'LAST_MODIFIED_TIME': 'ph-clock-clockwise',
                'CREATED_BY': 'ph-user-plus',
                'LAST_MODIFIED_BY': 'ph-user-switch'
            };
            return icons[fieldType] || 'ph-textbox';
        }

        function renderSortBuilder() {
            const set = getCurrentSet();
            const view = getCurrentView();
            if (!set || !view) return;

            const container = document.getElementById('sortRulesContainer');
            const schema = set.schema;

            if (!view.sorts || view.sorts.length === 0) {
                container.innerHTML = `
                    <div class="sort-empty-state">
                        <i class="ph ph-sort-ascending"></i>
                        <p>No sorts configured. Click "Add Sort" to start sorting your data.</p>
                    </div>
                `;
                return;
            }

            container.innerHTML = view.sorts.map((sort, index) => {
                const selectedField = schema.find(f => f.id === sort.fieldId);
                const fieldName = selectedField ? selectedField.name : 'Select field...';
                const fieldIcon = selectedField ? getFieldIcon(selectedField.type) : 'ph-textbox';
                const isPlaceholder = !selectedField;

                return `
                    <div class="sort-rule" data-sort-index="${index}">
                        <div class="sort-rule-number">${index + 1}</div>
                        <div class="sort-dropdown" data-dropdown-index="${index}">
                            <div class="sort-dropdown-trigger" onclick="toggleSortDropdown(${index})">
                                <span class="${isPlaceholder ? 'placeholder' : ''}">
                                    ${!isPlaceholder ? `<i class="ph ${fieldIcon}" style="margin-right: 6px;"></i>` : ''}${fieldName}
                                </span>
                                <i class="ph ph-caret-down"></i>
                            </div>
                            <div class="sort-dropdown-menu" id="sortDropdown-${index}">
                                ${schema.map(f => `
                                    <div class="sort-dropdown-option ${f.id === sort.fieldId ? 'selected' : ''}"
                                         onclick="selectSortField(${index}, '${f.id}')">
                                        <i class="ph ${getFieldIcon(f.type)}"></i>
                                        <span>${f.name}</span>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                        <div class="sort-direction-toggle">
                            <button class="sort-direction-btn ${sort.direction === 'asc' ? 'active' : ''}"
                                    onclick="updateSortDirection(${index}, 'asc')">
                                <i class="ph ph-sort-ascending"></i>
                                A-Z
                            </button>
                            <button class="sort-direction-btn ${sort.direction === 'desc' ? 'active' : ''}"
                                    onclick="updateSortDirection(${index}, 'desc')">
                                <i class="ph ph-sort-descending"></i>
                                Z-A
                            </button>
                        </div>
                        <div class="sort-rule-actions">
                            <button class="sort-action-btn" onclick="moveSort(${index}, -1)" ${index === 0 ? 'disabled' : ''} title="Move up">
                                <i class="ph ph-caret-up"></i>
                            </button>
                            <button class="sort-action-btn" onclick="moveSort(${index}, 1)" ${index === view.sorts.length - 1 ? 'disabled' : ''} title="Move down">
                                <i class="ph ph-caret-down"></i>
                            </button>
                            <button class="sort-action-btn danger" onclick="removeSortRule(${index})" title="Remove sort">
                                <i class="ph ph-x"></i>
                            </button>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function toggleSortDropdown(index) {
            const dropdown = document.getElementById(`sortDropdown-${index}`);
            const trigger = dropdown?.previousElementSibling;
            const isOpen = dropdown?.classList.contains('open');

            // Close all other dropdowns first
            closeSortDropdowns();

            if (!isOpen && dropdown) {
                dropdown.classList.add('open');
                trigger?.classList.add('open');
            }
        }

        function closeSortDropdowns() {
            document.querySelectorAll('.sort-dropdown-menu.open').forEach(menu => {
                menu.classList.remove('open');
                menu.previousElementSibling?.classList.remove('open');
            });
        }

        function selectSortField(index, fieldId) {
            updateSortField(index, fieldId);
            closeSortDropdowns();
        }

        // Close sort dropdowns when clicking outside
        document.addEventListener('click', function(e) {
            if (!e.target.closest('.sort-dropdown')) {
                closeSortDropdowns();
            }
        });

        function addSortRule() {
            const set = getCurrentSet();
            const view = getCurrentView();
            if (!set || !view) return;

            const defaultField = set.schema[0]?.id || '';
            view.sorts.push({ fieldId: defaultField, direction: 'asc' });
            renderSortBuilder();
        }

        function updateSortField(index, fieldId) {
            const view = getCurrentView();
            if (!view) return;
            view.sorts[index].fieldId = fieldId;
            renderSortBuilder();
        }

        function updateSortDirection(index, direction) {
            const view = getCurrentView();
            if (!view) return;
            view.sorts[index].direction = direction;
            renderSortBuilder();
        }

        function moveSort(index, delta) {
            const view = getCurrentView();
            if (!view) return;
            const newIndex = index + delta;
            if (newIndex < 0 || newIndex >= view.sorts.length) return;
            const [item] = view.sorts.splice(index, 1);
            view.sorts.splice(newIndex, 0, item);
            renderSortBuilder();
        }

        function removeSortRule(index) {
            const view = getCurrentView();
            if (!view) return;
            view.sorts.splice(index, 1);
            renderSortBuilder();
        }

        function clearSorts() {
            const view = getCurrentView();
            if (!view) return;
            view.sorts = [];
            renderSortBuilder();
            renderCurrentView();
        }

        function applySortsFromModal() {
            closeModal('sortModal');
            renderCurrentView();
        }

        function setGroupOperator(groupIndex, operator) {
            const view = getCurrentView();
            view.filters[groupIndex].operator = operator;
            renderFilterBuilder();
        }

        function addFilterRule(groupIndex) {
            const view = getCurrentView();
            view.filters[groupIndex].push({ field: '', operator: 'equals', value: '' });
            renderFilterBuilder();
        }

        function removeFilterRule(groupIndex, ruleIndex) {
            const view = getCurrentView();
            view.filters[groupIndex].splice(ruleIndex, 1);
            if (view.filters[groupIndex].length === 0) view.filters.splice(groupIndex, 1);
            renderFilterBuilder();
        }

        function addFilterGroup() {
            const view = getCurrentView();
            view.filters.push([{ field: '', operator: 'equals', value: '' }]);
            renderFilterBuilder();
        }

        function removeFilterGroup(groupIndex) {
            const view = getCurrentView();
            view.filters.splice(groupIndex, 1);
            renderFilterBuilder();
        }

        function updateFilterField(groupIndex, ruleIndex, fieldId) {
            const view = getCurrentView();
            view.filters[groupIndex][ruleIndex].field = fieldId;
            renderFilterBuilder();
        }

        function updateFilterValue(groupIndex, ruleIndex, value) {
            const view = getCurrentView();
            view.filters[groupIndex][ruleIndex].value = value;
        }

        function applyFilters() {
            closeModal('filterModal');
            renderCurrentView();
            showToast(' Filters applied');
        }

        function clearFilters() {
            const view = getCurrentView();
            view.filters = [[{ field: '', operator: 'equals', value: '' }]];
            renderFilterBuilder();
        }

        // COLUMN WIDTH SETTINGS
        function showColumnWidthMenu(event) {
            event.stopPropagation();
            const btn = event.currentTarget;
            const view = getCurrentView();
            if (!view) return;

            // Remove any existing menu
            const existingMenu = document.querySelector('.column-width-dropdown');
            if (existingMenu) existingMenu.remove();

            const rect = btn.getBoundingClientRect();
            const menu = document.createElement('div');
            menu.className = 'context-menu column-width-dropdown';
            menu.style.cssText = `position: fixed; top: ${rect.bottom + 4}px; left: ${rect.left}px; z-index: 1000; min-width: 220px;`;

            const currentMode = view.columnWidthMode || 'auto';
            const currentOverflow = view.contentOverflow || 'clip';

            menu.innerHTML = `
                <div class="context-menu-header" style="padding: 8px 14px 6px; font-size: 11px; font-weight: 700; color: #64748b; text-transform: uppercase; letter-spacing: 0.05em;">Column Widths</div>
                <div class="context-menu-item ${currentMode === 'auto' ? 'active' : ''}" data-mode="auto">
                    <i class="ph ph-text-columns"></i>
                    <span>Auto-fit Content</span>
                </div>
                <div class="context-menu-item ${currentMode === 'fit-to-screen' ? 'active' : ''}" data-mode="fit-to-screen">
                    <i class="ph ph-arrows-out-line-horizontal"></i>
                    <span>Fit to Screen</span>
                </div>
                <div class="context-menu-item" data-submenu="uniform">
                    <i class="ph ph-equals"></i>
                    <span>Uniform Width</span>
                    <i class="ph ph-caret-right" style="margin-left: auto; font-size: 12px; opacity: 0.5;"></i>
                </div>
                <div class="context-menu-separator"></div>
                <div class="context-menu-header" style="padding: 8px 14px 6px; font-size: 11px; font-weight: 700; color: #64748b; text-transform: uppercase; letter-spacing: 0.05em;">Content Overflow</div>
                <div class="context-menu-item ${currentOverflow === 'clip' ? 'active' : ''}" data-overflow="clip">
                    <i class="ph ph-dots-three"></i>
                    <span>Clip (Ellipsis)</span>
                </div>
                <div class="context-menu-item ${currentOverflow === 'wrap' ? 'active' : ''}" data-overflow="wrap">
                    <i class="ph ph-text-align-left"></i>
                    <span>Wrap Text</span>
                </div>
                <div class="context-menu-item ${currentOverflow === 'expand' ? 'active' : ''}" data-overflow="expand">
                    <i class="ph ph-arrows-out-simple"></i>
                    <span>Expand Rows</span>
                </div>
                <div class="context-menu-separator"></div>
                <div class="context-menu-item" data-action="settings">
                    <i class="ph ph-gear-six"></i>
                    <span>Advanced Settings...</span>
                </div>
            `;

            document.body.appendChild(menu);

            // Add active class styling
            const activeStyle = document.createElement('style');
            activeStyle.id = 'column-width-menu-style';
            activeStyle.textContent = `
                .column-width-dropdown .context-menu-item.active {
                    background: #eff6ff;
                    color: #1d4ed8;
                }
                .column-width-dropdown .context-menu-item.active i {
                    color: #3b82f6;
                }
                .column-width-dropdown .context-menu-item {
                    display: flex;
                    align-items: center;
                    gap: 10px;
                }
                .column-width-dropdown .context-menu-item i {
                    font-size: 16px;
                    color: #64748b;
                    width: 20px;
                    text-align: center;
                }
            `;
            if (!document.getElementById('column-width-menu-style')) {
                document.head.appendChild(activeStyle);
            }

            // Wire up menu items
            menu.querySelectorAll('.context-menu-item[data-mode]').forEach(item => {
                item.onclick = () => {
                    const mode = item.dataset.mode;
                    if (typeof ColumnWidthSettings !== 'undefined') {
                        ColumnWidthSettings.applyColumnWidthMode(state, view.id, mode, {
                            onApply: () => renderCurrentView()
                        });
                    }
                    menu.remove();
                };
            });

            menu.querySelectorAll('.context-menu-item[data-overflow]').forEach(item => {
                item.onclick = () => {
                    const overflow = item.dataset.overflow;
                    if (typeof ColumnWidthSettings !== 'undefined') {
                        ColumnWidthSettings.setContentOverflowMode(state, view.id, overflow);
                        renderCurrentView();
                    }
                    menu.remove();
                };
            });

            // Uniform width submenu
            const uniformItem = menu.querySelector('[data-submenu="uniform"]');
            if (uniformItem) {
                uniformItem.onmouseenter = () => showUniformWidthSubmenu(uniformItem, view);
            }

            // Settings action
            const settingsItem = menu.querySelector('[data-action="settings"]');
            if (settingsItem) {
                settingsItem.onclick = () => {
                    menu.remove();
                    if (typeof ColumnWidthSettings !== 'undefined') {
                        ColumnWidthSettings.showColumnWidthSettingsModal(state, view.id);
                    }
                };
            }

            // Close on click outside
            setTimeout(() => {
                document.addEventListener('click', function closeMenu(e) {
                    if (!menu.contains(e.target) && e.target !== btn) {
                        menu.remove();
                        document.removeEventListener('click', closeMenu);
                    }
                });
            }, 0);
        }

        function showUniformWidthSubmenu(parentItem, view) {
            const existingSubmenu = document.querySelector('.uniform-width-submenu');
            if (existingSubmenu) existingSubmenu.remove();

            const rect = parentItem.getBoundingClientRect();
            const submenu = document.createElement('div');
            submenu.className = 'context-menu uniform-width-submenu';
            submenu.style.cssText = `position: fixed; top: ${rect.top}px; left: ${rect.right + 4}px; z-index: 1001; min-width: 180px;`;

            const currentMode = view.columnWidthMode || 'auto';

            submenu.innerHTML = `
                <div class="context-menu-item ${currentMode === 'uniform-min' ? 'active' : ''}" data-mode="uniform-min">
                    <i class="ph ph-arrow-line-left"></i>
                    <span>Minimum Width</span>
                </div>
                <div class="context-menu-item ${currentMode === 'uniform-avg' ? 'active' : ''}" data-mode="uniform-avg">
                    <i class="ph ph-equals"></i>
                    <span>Average Width</span>
                </div>
                <div class="context-menu-item ${currentMode === 'uniform-max' ? 'active' : ''}" data-mode="uniform-max">
                    <i class="ph ph-arrow-line-right"></i>
                    <span>Maximum Width</span>
                </div>
            `;

            document.body.appendChild(submenu);

            submenu.querySelectorAll('.context-menu-item').forEach(item => {
                item.onclick = () => {
                    const mode = item.dataset.mode;
                    if (typeof ColumnWidthSettings !== 'undefined') {
                        ColumnWidthSettings.applyColumnWidthMode(state, view.id, mode, {
                            onApply: () => renderCurrentView()
                        });
                    }
                    // Close both menus
                    document.querySelector('.column-width-dropdown')?.remove();
                    submenu.remove();
                };
            });

            // Close submenu when mouse leaves both items
            parentItem.onmouseleave = (e) => {
                setTimeout(() => {
                    if (!submenu.matches(':hover') && !parentItem.matches(':hover')) {
                        submenu.remove();
                    }
                }, 100);
            };

            submenu.onmouseleave = () => {
                setTimeout(() => {
                    if (!submenu.matches(':hover') && !parentItem.matches(':hover')) {
                        submenu.remove();
                    }
                }, 100);
            };
        }

        // VISUALIZATION
        function openVisualizationModal() {
            openModal('visualizationModal');
            setupVisualizationModal();
        }

        function setupVisualizationModal() {
            const closeBtn = document.getElementById('closeVisualizationBtn');
            const closeModalBtn = document.getElementById('closeVisualizationModalBtn');

            if (closeBtn) {
                closeBtn.onclick = () => closeModal('visualizationModal');
            }
            if (closeModalBtn) {
                closeModalBtn.onclick = () => closeModal('visualizationModal');
            }

            // Setup chart type buttons
            document.querySelectorAll('.viz-chart-type-btn').forEach(btn => {
                btn.onclick = () => {
                    const chartType = btn.dataset.chartType;
                    renderCurrentViewChart(chartType);
                };
            });
        }

        function renderCurrentViewChart(chartType) {
            const set = getCurrentSet();
            const view = getCurrentView();
            if (!set || !view) return;

            // Get and filter records using the same logic as the current view
            let records = Array.from(set.records.values());
            const schema = Array.from(set.fields.values());

            if (view && view.filters && view.filters.length > 0) {
                records = applyFilterGroups(records, view.filters, schema);
            }
            if (view?.sorts?.length) {
                records = applySorts(records, view.sorts, schema);
            }

            if (records.length === 0) {
                document.getElementById('visualizationChartContainer').innerHTML =
                    '<div class="text-center text-gray-500 py-12">No data available to visualize</div>';
                return;
            }

            // Prepare data for charts
            const fields = Array.from(set.fields.values());
            const numericFields = fields.filter(f =>
                f.type === 'number' || f.type === 'currency' || f.type === 'percent'
            );

            // Use first text field as label, first numeric field as value
            const labelField = fields.find(f => f.type === 'text' || f.type === 'singleSelect');
            const valueField = numericFields[0];

            if (!labelField || !valueField) {
                document.getElementById('visualizationChartContainer').innerHTML =
                    '<div class="text-center text-gray-500 py-12">View needs at least one text field and one numeric field for visualization</div>';
                return;
            }

            const chartData = records.slice(0, 20).map(record => ({
                name: String(record.data[labelField.id] || 'Untitled'),
                value: Number(record.data[valueField.id] || 0)
            }));

            const chartContainer = document.getElementById('visualizationChartContainer');
            chartContainer.innerHTML = '<div style="position: relative; height: 400px; width: 100%;"><canvas id="vizModalChartCanvas"></canvas></div>';

            renderChartJsVisualizationInModal(chartType, chartData);
        }

        // Store the current chart instance so we can destroy it before creating a new one
        let currentModalChart = null;

        function renderChartJsVisualizationInModal(chartType, data) {
            if (!window.Chart) {
                console.error('Chart.js library not loaded');
                document.getElementById('visualizationChartContainer').innerHTML =
                    '<div class="text-center text-red-500 py-12">Chart library failed to load. Please refresh the page.</div>';
                return;
            }

            // Destroy previous chart if it exists
            if (currentModalChart) {
                currentModalChart.destroy();
                currentModalChart = null;
            }

            const canvas = document.getElementById('vizModalChartCanvas');
            if (!canvas) {
                console.error('Canvas element not found');
                return;
            }

            const COLORS = ['#3b82f6', '#8b5cf6', '#ec4899', '#f59e0b', '#10b981', '#06b6d4', '#6366f1', '#f97316'];

            const labels = data.map(item => item.name);
            const values = data.map(item => item.value);
            const backgroundColors = data.map((_, index) => COLORS[index % COLORS.length]);

            let chartConfig;

            switch(chartType) {
                case 'bar':
                    chartConfig = {
                        type: 'bar',
                        data: {
                            labels: labels,
                            datasets: [{
                                label: 'Value',
                                data: values,
                                backgroundColor: '#3b82f6',
                                borderColor: '#2563eb',
                                borderWidth: 1
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    display: true,
                                    position: 'top'
                                }
                            },
                            scales: {
                                y: {
                                    beginAtZero: true
                                }
                            }
                        }
                    };
                    break;
                case 'line':
                    chartConfig = {
                        type: 'line',
                        data: {
                            labels: labels,
                            datasets: [{
                                label: 'Value',
                                data: values,
                                borderColor: '#3b82f6',
                                backgroundColor: 'rgba(59, 130, 246, 0.1)',
                                borderWidth: 2,
                                fill: false,
                                tension: 0.4
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    display: true,
                                    position: 'top'
                                }
                            },
                            scales: {
                                y: {
                                    beginAtZero: true
                                }
                            }
                        }
                    };
                    break;
                case 'pie':
                    chartConfig = {
                        type: 'pie',
                        data: {
                            labels: labels,
                            datasets: [{
                                data: values,
                                backgroundColor: backgroundColors,
                                borderColor: '#ffffff',
                                borderWidth: 2
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    display: true,
                                    position: 'right'
                                }
                            }
                        }
                    };
                    break;
                case 'area':
                    chartConfig = {
                        type: 'line',
                        data: {
                            labels: labels,
                            datasets: [{
                                label: 'Value',
                                data: values,
                                borderColor: '#1e40af',
                                backgroundColor: 'rgba(59, 130, 246, 0.5)',
                                borderWidth: 2,
                                fill: true,
                                tension: 0.4
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    display: true,
                                    position: 'top'
                                }
                            },
                            scales: {
                                y: {
                                    beginAtZero: true
                                }
                            }
                        }
                    };
                    break;
                default:
                    document.getElementById('visualizationChartContainer').innerHTML =
                        '<div class="text-center text-gray-500 py-12">Unknown chart type</div>';
                    return;
            }

            currentModalChart = new Chart(canvas, chartConfig);
        }

        // EXPANDED RECORD
        function getExpandedRecordSet() {
            // Returns the set for the currently expanded record
            // Uses expandedRecordSetId if set (from Explore), otherwise falls back to getCurrentSet()
            if (state.expandedRecordSetId && state.sets.has(state.expandedRecordSetId)) {
                return state.sets.get(state.expandedRecordSetId);
            }
            return getCurrentSet();
        }

        function openExpandedRecord(recordId, setId = null) {
            // Store the setId for use by other expanded record functions
            state.expandedRecordSetId = setId;
            const set = setId ? state.sets.get(setId) : getCurrentSet();
            if (!set) {
                showToast('Unable to open record: set not found', 'error');
                return;
            }
            const record = set.records.get(recordId);
            if (!record) {
                showToast('Unable to open record: record not found', 'error');
                return;
            }
            state.currentRecordTab = 'provenance';
            state.recordHistoryVisible = true;
            document.getElementById('expandedRecordTitle').textContent = getRecordDisplayName(record.id) || set.name || 'Record';
            renderExpandedRecordMain(recordId);
            renderRecordSidebar(recordId);
            updateRecordHistoryVisibility();
            openModal('expandedRecordModal');
        }

        function openCellHistory(recordId, fieldId) {
            openObservationModal({ recordId, fieldId, setId: getExpandedRecordSet()?.id });
        }

        function openObservationModal({ recordId = null, fieldId = null, setId = null, keyValue = null, field = null, items = [] }) {
            const modal = document.getElementById('cellHistoryModal');
            const targetSet = setId ? state.sets.get(setId) : getCurrentSet();
            const record = recordId ? targetSet?.records.get(recordId) : null;
            const schemaField = field || targetSet?.schema?.find(f => f.id === fieldId) || { id: fieldId, name: fieldId, type: 'TEXT' };

            const entries = state.eventStream
                .filter(e => e.op === 'SEG' && e.data?.fieldId === schemaField.id && (!recordId || e.data?.recordId === recordId))
                .sort((a, b) => new Date(a.published) - new Date(b.published));

            const supValues = [];
            const latestValue = record ? record[schemaField.id] : null;
            if (latestValue && latestValue._sup && Array.isArray(latestValue.value)) supValues.push(...latestValue.value);
            if (items.length > 0 && schemaField) {
                items.forEach(item => {
                    const candidate = item.record[schemaField.sourceFieldId || schemaField.id];
                    if (candidate && candidate._sup && Array.isArray(candidate.value)) supValues.push(...candidate.value);
                });
            }

            state.cellHistoryContext = {
                recordId,
                fieldId: schemaField.id,
                fieldName: schemaField.name || schemaField.id,
                recordName: record?.name || keyValue || recordId || 'Item',
                entries,
                index: entries.length > 0 ? entries.length - 1 : 0,
                selectedValueSource: 'new',
                supValues,
                latestValue,
                fieldType: schemaField.type,
                sourceSetName: targetSet?.name
            };

            renderCellHistoryModal();
            if (modal?.classList.contains('hidden')) openModal('cellHistoryModal');
        }

        function renderCellHistoryModal() {
            const container = document.getElementById('cellHistoryContent');
            const tabsContainer = document.getElementById('cellHistoryTabs');
            const title = document.getElementById('cellHistoryTitle');
            const subtitle = document.getElementById('cellHistorySubtitle');
            const ctx = state.cellHistoryContext;

            if (!ctx) return;
            ctx.activePanel = ctx.activePanel || 'provenance';

            // Title is just the field name (mirrors record modal)
            title.textContent = ctx.fieldName;
            subtitle.textContent = ctx.recordName ? `Item: ${ctx.recordName}` : '';

            // Tabs mirror the record modal: Provenance, History, Relations
            const tabs = [
                { id: 'provenance', label: 'Provenance', icon: 'ph-fingerprint' },
                { id: 'history', label: 'History', icon: 'ph-clock-counter-clockwise' },
                { id: 'relations', label: 'Relations', icon: 'ph-link' }
            ];
            tabsContainer.innerHTML = tabs.map(tab => `
                <div class="record-tab ${ctx.activePanel === tab.id ? 'active' : ''}" data-tab="${tab.id}" onclick="setObservationPanel('${tab.id}')">
                    <i class="ph ${tab.icon}"></i> ${tab.label}
                </div>
            `).join('');

            // Get value display info
            const activeEntry = ctx.entries[ctx.index] || {};
            const selectedValue = ctx.selectedValueSource === 'old'
                ? activeEntry.data?.oldValue
                : activeEntry.data?.newValue;
            const latestValue = ctx.latestValue ?? selectedValue;
            const displayValue = renderCellValue(latestValue, { type: ctx.fieldType || 'TEXT' }, {}) || '';

            // Get provenance context
            const valueContext = (latestValue && latestValue._sup && Array.isArray(latestValue.value) && latestValue.value[0])
                ? (latestValue.value[0].context || latestValue.value[0].context_schema || {})
                : {};
            const method = valueContext.method || 'declared';
            const scale = valueContext.scale || 'individual';
            const source = valueContext.source?.system || valueContext.source || ctx.sourceSetName || 'unknown';
            const agent = valueContext.agent?.name || valueContext.agent?.type || '';
            const definition = valueContext.definition || '';
            const methodIcons = { measured: 'ph-ruler', declared: 'ph-pencil-simple', aggregated: 'ph-chart-bar', inferred: 'ph-magic-wand', derived: 'ph-gear' };
            const methodIcon = methodIcons[method] || 'ph-pencil-simple';
            const hasContext = valueContext.method || valueContext.scale || valueContext.source;
            const hasMultipleValues = ctx.supValues && ctx.supValues.length > 1;

            // Build observation cards for multiple values
            const observationCards = (ctx.supValues || []).map((entry, index) => {
                const context = entry.context || entry.context_schema || {};
                const obsMethod = context.method || 'declared';
                const obsScale = context.scale || 'individual';
                const obsSource = context.source?.system || context.source || 'observation';
                const obsAgent = context.agent?.name || context.agent?.type || '';
                const obsMethodIcon = methodIcons[obsMethod] || 'ph-pencil-simple';
                return `
                <div class="sup-modal-card">
                    <div class="flex items-start justify-between">
                        <div class="flex items-start gap-3">
                            <div class="sup-modal-card-index">${index + 1}</div>
                            <div class="flex-1">
                                <div class="sup-modal-card-value">${entry.val ?? entry.value ?? ''}</div>
                                <div class="sup-modal-card-source text-xs text-gray-500 mt-1 space-y-1">
                                    <div class="flex items-center gap-2">
                                        <span title="Method"><i class="ph ${obsMethodIcon}"></i> ${obsMethod}</span>
                                        <span class="text-gray-300"></span>
                                        <span title="Scale"><i class="ph ph-arrows-out-cardinal"></i> ${obsScale}</span>
                                    </div>
                                    <div class="flex items-center gap-2">
                                        <i class="ph ph-info"></i>
                                        <span>${obsSource}</span>
                                        ${obsAgent ? `<span class="text-gray-300"></span><i class="ph ph-user"></i> ${obsAgent}` : ''}
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `}).join('');

            // Build history timeline
            const timeline = ctx.entries.map((entry, i) => `
                <div class="border rounded-lg p-3 ${i === ctx.index ? 'border-blue-500 bg-blue-50' : 'border-gray-200 bg-white'} cursor-pointer transition hover:border-gray-300" onclick="selectCellHistoryEntry(${i})">
                    <div class="flex items-center justify-between">
                        <div class="font-medium">${entry.data?.fieldName || ctx.fieldName}</div>
                        <div class="text-xs text-gray-500">${new Date(entry.published).toLocaleString()}</div>
                    </div>
                    <div class="text-sm text-gray-600 mt-1">${entry.data?.summary || 'Updated value'}</div>
                    <div class="text-sm mt-2 flex items-center gap-2">
                        <span class="text-red-600 line-through">${entry.data?.oldValue ?? ''}</span>
                        <span class="text-gray-400"></span>
                        <span class="text-green-600 font-medium">${entry.data?.newValue ?? ''}</span>
                    </div>
                </div>
            `).join('');

            // Value is always shown at top (not in a tab)
            container.innerHTML = `
                <div class="space-y-4">
                    <!-- Value always visible at top -->
                    <div class="text-2xl font-bold text-gray-900 pb-4 border-b border-gray-200">${displayValue}</div>

                    ${ctx.activePanel === 'provenance' ? `
                        <div class="space-y-6">
                            <!-- Origin section (mirrors record provenance) -->
                            <div class="provenance-section">
                                <h4 class="text-sm font-semibold text-gray-700 mb-3">Origin</h4>
                                ${hasContext ? `
                                <div class="space-y-2 text-sm">
                                    <div class="flex items-center gap-3">
                                        <span class="text-gray-600 w-20">Source:</span>
                                        <span class="flex items-center gap-2 font-medium"><i class="ph ph-database text-gray-400"></i> ${source}</span>
                                    </div>
                                    <div class="flex items-center gap-3">
                                        <span class="text-gray-600 w-20">Method:</span>
                                        <span class="flex items-center gap-2 font-medium"><i class="ph ${methodIcon} text-gray-400"></i> ${method}</span>
                                    </div>
                                    <div class="flex items-center gap-3">
                                        <span class="text-gray-600 w-20">Scale:</span>
                                        <span class="flex items-center gap-2 font-medium"><i class="ph ph-arrows-out-cardinal text-gray-400"></i> ${scale}</span>
                                    </div>
                                    ${agent ? `
                                    <div class="flex items-center gap-3">
                                        <span class="text-gray-600 w-20">Agent:</span>
                                        <span class="flex items-center gap-2 font-medium"><i class="ph ph-user text-gray-400"></i> ${agent}</span>
                                    </div>` : ''}
                                    ${definition ? `
                                    <div class="flex items-center gap-3">
                                        <span class="text-gray-600 w-20">Definition:</span>
                                        <span class="font-medium">${definition}</span>
                                    </div>` : ''}
                                </div>
                                ` : `<p class="text-sm text-gray-400 italic">No provenance information available</p>`}
                            </div>

                            ${hasMultipleValues ? `
                            <!-- Multiple observations section -->
                            <div class="provenance-section">
                                <h4 class="text-sm font-semibold text-gray-700 mb-3">Observations (${ctx.supValues.length})</h4>
                                <p class="text-xs text-gray-500 mb-3">This cell contains multiple values from different sources</p>
                                <div class="space-y-3">${observationCards}</div>
                            </div>
                            ` : ''}
                        </div>
                    ` : ''}

                    ${ctx.activePanel === 'history' ? `
                        <div>
                            <h4 class="text-sm font-semibold text-gray-700 mb-3">Change History</h4>
                            ${ctx.entries.length > 0 ? `
                                <div class="flex items-center justify-between mb-4">
                                    <div class="text-sm text-gray-600">${ctx.entries.length} change${ctx.entries.length === 1 ? '' : 's'}</div>
                                    <div class="flex items-center gap-2">
                                        <button class="btn btn-secondary btn-sm" ${ctx.index === 0 ? 'disabled' : ''} onclick="stepCellHistory(-1)">
                                            <i class="ph ph-caret-left"></i> Prev
                                        </button>
                                        <button class="btn btn-secondary btn-sm" ${ctx.index >= ctx.entries.length - 1 ? 'disabled' : ''} onclick="stepCellHistory(1)">
                                            Next <i class="ph ph-caret-right"></i>
                                        </button>
                                    </div>
                                </div>
                                <div class="space-y-3">${timeline}</div>
                            ` : '<p class="text-gray-500 text-sm italic">No changes yet</p>'}
                        </div>
                    ` : ''}

                    ${ctx.activePanel === 'relations' ? `
                        <div>
                            <h4 class="text-sm font-semibold text-gray-700 mb-3">Relations</h4>
                            <div class="space-y-2 text-sm">
                                <div class="flex items-center gap-3">
                                    <span class="text-gray-600 w-20">Source Set:</span>
                                    <span class="flex items-center gap-2 font-medium"><i class="ph ph-table text-gray-400"></i> ${ctx.sourceSetName || 'Unknown'}</span>
                                </div>
                                ${ctx.recordId ? `
                                <div class="flex items-center gap-3">
                                    <span class="text-gray-600 w-20">Record:</span>
                                    <span class="flex items-center gap-2 font-medium"><i class="ph ph-rows text-gray-400"></i> ${ctx.recordName || ctx.recordId}</span>
                                </div>` : ''}
                                <div class="flex items-center gap-3">
                                    <span class="text-gray-600 w-20">Field:</span>
                                    <span class="flex items-center gap-2 font-medium"><i class="ph ph-columns text-gray-400"></i> ${ctx.fieldName}</span>
                                </div>
                            </div>
                        </div>
                    ` : ''}
                </div>
            `;
        }

        function setObservationPanel(panel) {
            if (!state.cellHistoryContext) return;
            state.cellHistoryContext.activePanel = panel;
            renderCellHistoryModal();
        }

        function selectCellHistoryEntry(index) {
            if (!state.cellHistoryContext) return;
            state.cellHistoryContext.index = index;
            renderCellHistoryModal();
        }

        function stepCellHistory(direction) {
            if (!state.cellHistoryContext || state.cellHistoryContext.entries.length === 0) return;
            const newIndex = Math.min(Math.max(state.cellHistoryContext.index + direction, 0), state.cellHistoryContext.entries.length - 1);
            state.cellHistoryContext.index = newIndex;
            renderCellHistoryModal();
        }

        function chooseHistoryValue(source) {
            if (!state.cellHistoryContext) return;
            state.cellHistoryContext.selectedValueSource = source;
            renderCellHistoryModal();
        }

        function applySelectedHistoricalValue() {
            const ctx = state.cellHistoryContext;
            if (!ctx || ctx.entries.length === 0) return;

            const entry = ctx.entries[ctx.index];
            const selectedValue = ctx.selectedValueSource === 'old'
                ? entry.data?.oldValue
                : entry.data?.newValue;

            const set = getCurrentSet();
            const record = set.records.get(ctx.recordId);
            const currentValue = record ? record[ctx.fieldId] : undefined;

            updateRecord(ctx.recordId, ctx.fieldId, selectedValue, currentValue);

            if (!document.getElementById('expandedRecordModal').classList.contains('hidden')) {
                renderExpandedRecordMain(ctx.recordId);
                renderRecordSidebar(ctx.recordId);
            }

            openCellHistory(ctx.recordId, ctx.fieldId);
        }

        function ensurePopupRule(fieldId) {
            const view = getCurrentView();
            if (!view) return null;
            view.popupVisibilityRules = view.popupVisibilityRules || [];
            let rule = view.popupVisibilityRules.find(r => r.fieldId === fieldId);
            if (!rule) {
                rule = { fieldId, visibility: 'show', criteria: { type: 'always', value: '' } };
                view.popupVisibilityRules.push(rule);
            }
            return rule;
        }

        function evaluatePopupCriteria(criteria, value) {
            if (!criteria || criteria.type === 'always') return true;

            switch (criteria.type) {
                case 'equals':
                    return String(value ?? '').toLowerCase() === String(criteria.value ?? '').toLowerCase();
                case 'notEquals':
                    return String(value ?? '').toLowerCase() !== String(criteria.value ?? '').toLowerCase();
                case 'contains':
                    return String(value ?? '').toLowerCase().includes(String(criteria.value ?? '').toLowerCase());
                case 'empty':
                    return value === undefined || value === null || value === '';
                case 'notEmpty':
                    return !(value === undefined || value === null || value === '');
                default:
                    return true;
            }
        }

        function refreshOpenRecordModal() {
            const container = document.getElementById('expandedRecordMain');
            const recordId = container?.dataset?.recordId;
            if (recordId && !document.getElementById('expandedRecordModal').classList.contains('hidden')) {
                renderExpandedRecordMain(recordId);
            }
        }

        function shouldDisplayFieldInPopup(field, record) {
            const view = getCurrentView();
            if (!view) return true;
            view.popupVisibilityRules = view.popupVisibilityRules || [];
            const rule = view.popupVisibilityRules.find(r => r.fieldId === field.id);
            if (!rule) return true;

            const criteriaMet = evaluatePopupCriteria(rule.criteria, record[field.id]);
            if (!rule.criteria || criteriaMet) {
                return rule.visibility !== 'hide';
            }

            return true;
        }

        function renderExpandedRecordMain(recordId) {
            const set = getExpandedRecordSet();
            const view = getCurrentView();
            const record = set?.records.get(recordId);
            const container = document.getElementById('expandedRecordMain');
            container.dataset.recordId = recordId;

            const orderedFields = view ? getPopupOrderedFields(set, view) : set.schema;
            const visibleFields = orderedFields.filter(field => shouldDisplayFieldInPopup(field, record));

            container.innerHTML = visibleFields.length === 0
                ? '<p class="text-gray-500">No fields are visible in this modal based on the current view settings.</p>'
                : `
                <div class="space-y-4">
                    ${visibleFields.map(field => `
                        <div class="field-editor">
                            <label class="form-label cursor-pointer hover:text-blue-600 transition flex items-center gap-2" onclick="openCellHistory('${recordId}', '${field.id}')" title="Click to view field provenance">
                                ${field.name}
                                <svg class="w-3 h-3 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                                </svg>
                            </label>
                            ${renderFieldEditor(recordId, field, record[field.id])}
                        </div>
                    `).join('')}
                </div>
            `;
        }

        function renderFieldEditor(recordId, field, value) {
            // Get effective type and subtype (handle legacy fields)
            let effectiveType = field.type;
            let effectiveSubtype = field.subtype;

            // Map legacy types to new structure
            if (field.type === 'LONG_TEXT') {
                effectiveType = 'TEXT';
                effectiveSubtype = 'LONG';
            } else if (field.type === 'EMAIL' || field.type === 'URL' || field.type === 'PHONE') {
                effectiveType = 'CONTACT';
                effectiveSubtype = field.type;
            } else if (field.type === 'CURRENCY') {
                effectiveType = 'NUMBER';
                effectiveSubtype = 'CURRENCY';
            }

            // Handle TEXT with subtypes
            if (effectiveType === 'TEXT') {
                const subtype = effectiveSubtype || 'SHORT';
                if (subtype === 'RICH') {
                    return `<textarea rows="6" class="w-full" onchange="updateRecordField('${recordId}', '${field.id}', this.value)" placeholder="Use markdown: **bold**, *italic*, [link](url), # headers">${value || ''}</textarea>`;
                } else if (subtype === 'LONG') {
                    return `<textarea rows="4" onchange="updateRecordField('${recordId}', '${field.id}', this.value)">${value || ''}</textarea>`;
                } else {
                    return `<input type="text" value="${value || ''}" onchange="updateRecordField('${recordId}', '${field.id}', this.value)">`;
                }
            }

            // Handle NUMBER with subtypes
            if (effectiveType === 'NUMBER') {
                return `<input type="number" value="${value || 0}" onchange="updateRecordField('${recordId}', '${field.id}', parseFloat(this.value))">`;
            }

            // Handle CONTACT with subtypes
            if (effectiveType === 'CONTACT') {
                const subtype = effectiveSubtype || 'EMAIL';
                const inputType = subtype === 'EMAIL' ? 'email' : subtype === 'URL' ? 'url' : 'tel';
                const placeholder = subtype === 'EMAIL' ? 'email@example.com' : subtype === 'URL' ? 'https://example.com' : '+1234567890';
                return `<input type="${inputType}" value="${value || ''}" placeholder="${placeholder}" onchange="updateRecordField('${recordId}', '${field.id}', this.value)">`;
            }

            switch(effectiveType) {
                case 'DATE':
                    return `<input type="date" value="${value || ''}" onchange="updateRecordField('${recordId}', '${field.id}', this.value)">`;
                case 'CHECKBOX':
                    return `<input type="checkbox" ${value ? 'checked' : ''} onchange="updateRecordField('${recordId}', '${field.id}', this.checked)">`;
                case 'LINK_RECORD': {
                    const linkedSet = getLinkedSet(field);
                    const options = createLinkedRecordOptionList(field);
                    const disableSelect = !linkedSet || options.length === 0;
                    const selectId = `linked-record-select-${recordId}-${field.id}`;
                    const optionsDataAttr = encodeURIComponent(JSON.stringify(options));
                    const hint = !linkedSet
                        ? '<p class="text-xs text-gray-500 mt-1">Configure a linked set to enable selection.</p>'
                        : options.length === 0
                            ? '<p class="text-xs text-gray-500 mt-1">Add records to the linked set to select one.</p>'
                            : '';

                    // Check cardinality for multi-select
                    const cardinality = field.config?.cardinality || 'many';
                    const limit = field.config?.limit || null;
                    const allowMultiple = cardinality === 'many' || (cardinality === 'limit' && limit > 1);

                    if (allowMultiple) {
                        // Multi-select mode
                        const selectedIds = Array.isArray(value) ? value : (value ? [value] : []);
                        const limitInfo = limit ? ` (max ${limit})` : '';
                        const containerId = `modal-linked-${recordId}-${field.id}`;
                        return `
                            <div class="space-y-2 modal-multi-linked-record" id="${containerId}" data-record-id="${recordId}" data-field-id="${field.id}" data-limit="${limit || ''}">
                                <div class="text-xs text-gray-500">${selectedIds.length} selected${limitInfo}</div>
                                <input type="text" class="border rounded px-3 py-2 text-sm w-full modal-linked-search" placeholder="Search linked records..." ${!linkedSet ? 'disabled' : ''} oninput="filterModalLinkedRecords('${containerId}', this.value)">
                                <div class="border rounded max-h-48 overflow-y-auto modal-linked-options">
                                    ${options.map(opt => {
                                        const isSelected = selectedIds.includes(opt.id);
                                        return `
                                            <div class="modal-linked-option p-2 cursor-pointer hover:bg-gray-50 flex items-center gap-2 ${isSelected ? 'bg-blue-50' : ''}"
                                                 data-value="${opt.id}" data-label="${opt.label.replace(/"/g, '&quot;')}" onclick="toggleModalLinkedRecord(this)">
                                                <div class="modal-linked-checkbox w-4 h-4 border-2 rounded flex items-center justify-center ${isSelected ? 'bg-blue-500 border-blue-500 text-white' : 'border-gray-300'}">
                                                    ${isSelected ? '<i class="ph-bold ph-check text-xs"></i>' : ''}
                                                </div>
                                                <span class="text-sm">${opt.label}</span>
                                            </div>
                                        `;
                                    }).join('')}
                                </div>
                                ${hint}
                            </div>
                        `;
                    }

                    // Single select mode
                    return `
                        <div class="space-y-1">
                            <input type="text" class="border rounded px-3 py-2 text-sm w-full" placeholder="Search linked records..." ${!linkedSet ? 'disabled' : ''} oninput="filterLinkedRecordSelect('${selectId}', this.value)">
                            <select id="${selectId}" class="border rounded px-3 py-2 text-sm w-full" data-options="${optionsDataAttr}" ${disableSelect ? 'disabled' : ''} onchange="updateRecordField('${recordId}', '${field.id}', this.value)">
                                <option value="">Select a record</option>
                                ${options.map(opt => `<option value="${opt.id}" ${opt.id === value ? 'selected' : ''}>${opt.label}</option>`).join('')}
                            </select>
                            ${hint}
                        </div>
                    `;
                }
                case 'LOOKUP': {
                    const lookupSet = field.config?.lookupSetId ? state.sets.get(field.config.lookupSetId) : null;
                    const options = lookupSet ? Array.from(lookupSet.records.values()).map(rec => ({
                        id: rec.id,
                        label: getRecordDisplayName(rec.id) || lookupSet.name || 'Record'
                    })) : [];
                    const disableSelect = !lookupSet || options.length === 0;
                    const selectId = `lookup-select-${recordId}-${field.id}`;
                    const optionsDataAttr = encodeURIComponent(JSON.stringify(options));
                    const hint = !lookupSet
                        ? '<p class="text-xs text-gray-500 mt-1">Configure a lookup set to enable selection.</p>'
                        : options.length === 0
                            ? '<p class="text-xs text-gray-500 mt-1">Add records to the lookup set to select one.</p>'
                            : '';

                    return `
                        <div class="space-y-1">
                            <input type="text" class="border rounded px-3 py-2 text-sm w-full" placeholder="Search records..." ${!lookupSet ? 'disabled' : ''} oninput="filterLinkedRecordSelect('${selectId}', this.value)">
                            <select id="${selectId}" class="border rounded px-3 py-2 text-sm w-full" data-options="${optionsDataAttr}" ${disableSelect ? 'disabled' : ''} onchange="updateRecordField('${recordId}', '${field.id}', this.value)">
                                <option value="">Select a record</option>
                                ${options.map(opt => `<option value="${opt.id}" ${opt.id === value ? 'selected' : ''}>${opt.label}</option>`).join('')}
                            </select>
                            ${hint}
                        </div>
                    `;
                }
                case 'SELECT':
                    return `<select onchange="updateRecordField('${recordId}', '${field.id}', this.value)">
                        <option value="">Select...</option>
                        ${field.config.options.map(opt => `<option value="${opt}" ${opt === value ? 'selected' : ''}>${opt}</option>`).join('')}
                    </select>`;
                default:
                    return `<input type="text" value="${value || ''}" onchange="updateRecordField('${recordId}', '${field.id}', this.value)">`;
            }
        }

        function updateRecordField(recordId, fieldId, value) {
            const set = getExpandedRecordSet();
            const record = set?.records.get(recordId);
            const oldValue = record[fieldId];
            updateRecord(recordId, fieldId, value, oldValue);
            renderExpandedRecordMain(recordId);
        }

        function switchRecordTab(tab) {
            state.currentRecordTab = tab;
            const recordId = document.getElementById('expandedRecordMain').dataset.recordId;
            renderExpandedRecordMain(recordId);
            renderRecordSidebar(recordId);
            updateRecordHistoryVisibility();
        }

        function renderRecordSidebar(recordId) {
            const container = document.getElementById('expandedRecordSidebar');
            document.querySelectorAll('.record-tab').forEach(t => {
                t.classList.toggle('active', t.dataset.tab === state.currentRecordTab);
            });

            if (!container) return;

            switch (state.currentRecordTab) {
                case 'connections':
                    renderConnectionsSidebar(container, recordId);
                    break;
                case 'provenance':
                    renderProvenanceSidebar(container, recordId);
                    break;
                case 'history':
                default:
                    renderHistorySidebar(container, recordId);
                    break;
            }
        }

        function renderHistorySidebar(container, recordId) {
            const history = state.eventStream.filter(e => e.object?.id === recordId && e.op === 'SEG');
            container.innerHTML = `
                <h3 class="font-semibold mb-4">Change History</h3>
                ${history.length === 0 ? '<p class="text-gray-500">No changes yet</p>' : ''}
                ${history.map(e => `
                    <div class="history-entry">
                        <div class="font-medium">${e.data?.fieldName || 'Field change'}</div>
                        <div class="text-sm text-gray-500">${getTimeAgo(e.published)}</div>
                        <div class="text-sm mt-1">
                            <span class="text-red-600">${e.data?.oldValue}</span> 
                            <span class="text-green-600">${e.data?.newValue}</span>
                        </div>
                    </div>
                `).join('')}
            `;
        }

        function renderProvenanceSidebar(container, recordId) {
            const set = getExpandedRecordSet();
            const record = set?.records.get(recordId);

            // Get creation event from event stream
            const creationEvent = state.eventStream.find(e =>
                e.op === 'INS' && e.object?.id === recordId
            );

            // Get import/source metadata from set
            const importMetadata = set.importMetadata || {};
            const recordMetadata = record._metadata || {};

            // Get all events related to this record
            const recordEvents = state.eventStream.filter(e =>
                e.object?.id === recordId || e.data?.recordId === recordId
            );

            // Determine source information
            const sourceSystem = recordMetadata.source?.system || importMetadata.sourceSystem || 'Unknown';
            const sourceFile = recordMetadata.source?.file || importMetadata.filename || 'Unknown';
            const importDate = creationEvent?.published || record.created_at || 'Unknown';

            // Get field-level provenance information
            const fieldsWithProvenance = set.schema.filter(field => {
                const value = record[field.id];
                return value && (value._sup || recordEvents.some(e => e.data?.fieldId === field.id));
            });

            container.innerHTML = `
                <h3 class="font-semibold mb-4">Record Provenance</h3>

                <div class="space-y-4">
                    <div class="provenance-section">
                        <h4 class="text-sm font-semibold text-gray-700 mb-2">Origin</h4>
                        <div class="space-y-2 text-sm">
                            <div>
                                <span class="text-gray-600">Source:</span>
                                <span class="ml-2 font-medium">${sourceSystem}</span>
                            </div>
                            <div>
                                <span class="text-gray-600">File:</span>
                                <span class="ml-2 font-medium">${sourceFile}</span>
                            </div>
                            <div>
                                <span class="text-gray-600">Created:</span>
                                <span class="ml-2 font-medium">${formatTimestamp(importDate)}</span>
                            </div>
                            <div>
                                <span class="text-gray-600">Record ID:</span>
                                <span class="ml-2 font-mono text-xs">${recordId}</span>
                            </div>
                        </div>
                    </div>

                    ${importMetadata.jurisdiction || importMetadata.frame ? `
                        <div class="provenance-section">
                            <h4 class="text-sm font-semibold text-gray-700 mb-2">Context</h4>
                            <div class="space-y-2 text-sm">
                                ${importMetadata.jurisdiction ? `
                                    <div>
                                        <span class="text-gray-600">Jurisdiction:</span>
                                        <span class="ml-2 font-medium">${importMetadata.jurisdiction}</span>
                                    </div>
                                ` : ''}
                                ${importMetadata.frame ? `
                                    <div>
                                        <span class="text-gray-600">Frame:</span>
                                        <span class="ml-2 font-medium">${importMetadata.frame}</span>
                                    </div>
                                ` : ''}
                            </div>
                        </div>
                    ` : ''}

                    <div class="provenance-section">
                        <h4 class="text-sm font-semibold text-gray-700 mb-2">Field Provenance</h4>
                        <p class="text-xs text-gray-500 mb-3">Click on any field in the record to view its detailed provenance</p>
                        ${fieldsWithProvenance.length > 0 ? `
                            <div class="space-y-2">
                                ${fieldsWithProvenance.map(field => {
                                    const value = record[field.id];
                                    const hasSUP = value && value._sup;
                                    const eventCount = recordEvents.filter(e => e.data?.fieldId === field.id).length;
                                    return `
                                        <div class="flex items-center justify-between text-sm p-2 bg-white rounded border border-gray-200 hover:border-blue-300 cursor-pointer transition" onclick="openCellHistory('${recordId}', '${field.id}')">
                                            <span class="font-medium">${field.name}</span>
                                            <div class="flex items-center gap-2">
                                                ${hasSUP ? '<span class="text-xs px-2 py-0.5 bg-purple-100 text-purple-700 rounded">SUP</span>' : ''}
                                                ${eventCount > 0 ? `<span class="text-xs text-gray-500">${eventCount} ${eventCount === 1 ? 'event' : 'events'}</span>` : ''}
                                                <svg class="w-4 h-4 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>
                                                </svg>
                                            </div>
                                        </div>
                                    `;
                                }).join('')}
                            </div>
                        ` : '<p class="text-sm text-gray-500">No field provenance available</p>'}
                    </div>

                    <div class="provenance-section">
                        <h4 class="text-sm font-semibold text-gray-700 mb-2">Activity Summary</h4>
                        <div class="space-y-2 text-sm">
                            <div>
                                <span class="text-gray-600">Total Events:</span>
                                <span class="ml-2 font-medium">${recordEvents.length}</span>
                            </div>
                            <div>
                                <span class="text-gray-600">Last Modified:</span>
                                <span class="ml-2 font-medium">${record.updated_at ? formatTimestamp(record.updated_at) : 'Never'}</span>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        function formatTimestamp(timestamp) {
            if (!timestamp || timestamp === 'Unknown') return 'Unknown';
            try {
                const date = new Date(timestamp);
                return date.toLocaleString();
            } catch (e) {
                return timestamp;
            }
        }

        function getConnectionBuilder() {
            if (!state.connectionBuilder) {
                state.connectionBuilder = {
                    targetSetId: null,
                    targetRecordId: '',
                    searchQuery: '',
                    relationId: null,
                    selectedOperator: null,
                    selectedVerb: null,
                    params: {}
                };
            }
            return state.connectionBuilder;
        }

        function renderConnectionsSidebar(container, recordId) {
            const builder = getConnectionBuilder();
            const setEntries = getSetsForWorld().map(set => [set.id, set]);
            const selectedSetId = builder.targetSetId && state.sets.has(builder.targetSetId)
                ? builder.targetSetId
                : (setEntries[0]?.[0] || null);
            if (builder.targetSetId !== selectedSetId) builder.targetSetId = selectedSetId;

            // Get operator/verb options
            const operatorCodes = Object.keys(state.connectionModes || {}).filter(k => k !== 'operators' && k !== 'meta');
            const operators = state.connectionModes?.operators || {};

            // Determine selected operator and verb
            let selectedOperator = builder.selectedOperator;
            let selectedVerb = builder.selectedVerb;

            // If verb is selected but operator isn't, derive operator from verb
            if (selectedVerb && !selectedOperator) {
                selectedOperator = getOperatorForVerb(selectedVerb);
                if (selectedOperator) builder.selectedOperator = selectedOperator;
            }

            // Find matching relation ID from operator+verb combo
            const formatOptions = getConnectionRelationView();
            let sidebarRelationId = null;
            if (selectedOperator && selectedVerb) {
                const matchingRelation = formatOptions.find(rel => rel.operator === selectedOperator && rel.mode === selectedVerb);
                sidebarRelationId = matchingRelation?.id || null;
            }
            builder.relationId = sidebarRelationId;
            const selectedRelation = findConnectionRelation(sidebarRelationId);

            const selectedSet = selectedSetId ? state.sets.get(selectedSetId) : null;
            const allAvailableRecords = selectedSet ? Array.from(selectedSet.records.values()).filter(r => r.id !== recordId) : [];
            const search = builder.searchQuery?.trim().toLowerCase() || '';
            const availableRecords = search
                ? allAvailableRecords.filter(rec => {
                    const displayName = getRecordDisplayName(rec.id) || '';
                    return displayName.toLowerCase().includes(search);
                })
                : allAvailableRecords;
            const selectedRecordId = availableRecords.some(rec => rec.id === builder.targetRecordId) ? builder.targetRecordId : '';
            if (builder.targetRecordId !== selectedRecordId) builder.targetRecordId = selectedRecordId;

            const connections = getConnectionView(edge =>
                (edge.subject?.type === 'Record' && edge.subject?.id === recordId) ||
                (edge.operand?.type === 'Record' && edge.operand?.id === recordId)
            );

            // Get subject display name
            const subjectName = getRecordDisplayName(recordId) || 'This record';
            const operatorInfo = selectedOperator ? (operators[selectedOperator] || {}) : null;

            // Get quick picks and sorted connection types for the unified selector
            const quickPicks = getQuickPickConnectionTypes(6);
            const sortedTypes = getSortedConnectionTypes();

            // Build unified connection type options - grouped by operator, sorted by usage
            let connectionTypeOptionsHtml = '<option value="">Choose how to connect...</option>';
            // Group types by operator for better organization
            const typesByOperator = {};
            sortedTypes.forEach(type => {
                if (!typesByOperator[type.operator]) {
                    typesByOperator[type.operator] = [];
                }
                typesByOperator[type.operator].push(type);
            });

            // Add options grouped by operator, with CON first
            const operatorOrder = ['CON', 'SEG', 'INS', 'DES', 'ALT', 'SYN', 'SUP', 'REC', 'NUL'];
            operatorOrder.forEach(op => {
                const types = typesByOperator[op];
                if (types && types.length > 0) {
                    const opInfo = operators[op] || {};
                    connectionTypeOptionsHtml += `<optgroup label="${opInfo.symbol || ''} ${op} - ${opInfo.name || op}">`;
                    types.forEach(type => {
                        const isSelected = type.operator === selectedOperator && type.verb === selectedVerb;
                        const usageLabel = type.usageCount > 0 ? ` (${type.usageCount})` : '';
                        connectionTypeOptionsHtml += `<option value="${type.operator}::${type.verb}" ${isSelected ? 'selected' : ''} data-operator="${type.operator}" data-verb="${type.verb}">${type.verb}${usageLabel}</option>`;
                    });
                    connectionTypeOptionsHtml += '</optgroup>';
                }
            });

            // Check if we can add the connection
            const canAddConnection = selectedRecordId && selectedOperator && selectedVerb;
            const needsRelationType = selectedOperator && selectedVerb && !sidebarRelationId;

            container.innerHTML = `
                <div class="space-y-4">
                    <div>
                        <h3 class="font-semibold">Relationships</h3>
                        <p class="text-sm text-gray-600">Link this record to other records.</p>
                    </div>
                    <div class="border border-gray-200 bg-white rounded-lg p-4 space-y-3">
                        <!-- SPO Format: Subject - Predicate - Object -->

                        <!-- Subject (current record) -->
                        <div class="bg-gray-50 rounded p-2 text-sm">
                            <span class="text-gray-500 text-xs uppercase tracking-wide">Subject</span>
                            <div class="font-medium text-gray-900">${subjectName}</div>
                        </div>

                        <!-- Connection Type: Unified selector with quick picks -->
                        <div>
                            <label class="form-label">Connection type</label>

                            <!-- Quick picks: most used + defaults -->
                            <div class="flex flex-wrap gap-1.5 mb-2">
                                ${quickPicks.map(type => {
                                    const isSelected = type.operator === selectedOperator && type.verb === selectedVerb;
                                    return `<button
                                        type="button"
                                        class="inline-flex items-center gap-1 px-2 py-1 text-xs rounded-full border transition-colors ${isSelected
                                            ? 'bg-blue-100 border-blue-300 text-blue-800'
                                            : 'bg-gray-50 border-gray-200 text-gray-700 hover:bg-gray-100 hover:border-gray-300'}"
                                        onclick="selectConnectionType('${recordId}', '${type.operator}', '${type.verb}')"
                                        title="${type.operatorName}: ${type.verb}"
                                    >
                                        <span class="font-medium" style="color: ${type.operatorColor}">${type.operatorSymbol}</span>
                                        <span>${type.verb}</span>
                                    </button>`;
                                }).join('')}
                            </div>

                            <!-- Full selector dropdown -->
                            <select id="sidebarConnectionType" class="border rounded px-3 py-2 text-sm w-full">
                                ${connectionTypeOptionsHtml}
                            </select>
                            ${operatorInfo ? `<p class="text-xs text-gray-500 mt-1">${operatorInfo.description || ''}</p>` : ''}
                        </div>

                        <!-- Object: Set + Record selection -->
                        <div class="border-t pt-3 mt-3">
                            <span class="text-gray-500 text-xs uppercase tracking-wide">Object</span>
                        </div>

                        <div>
                            <label class="form-label">Select set</label>
                            <select id="newConnectionSet" class="border rounded px-3 py-2 text-sm w-full" onchange="handleConnectionSetChange('${recordId}', this.value)">
                                ${setEntries.length === 0 ? '<option value="">No sets available</option>' : ''}
                                ${setEntries.map(([id, set]) => `<option value="${id}" ${id === selectedSetId ? 'selected' : ''}>${set.name || id}</option>`).join('')}
                            </select>
                        </div>

                        <div>
                            <label class="form-label">Search records</label>
                            <input
                                type="text"
                                class="border rounded px-3 py-2 text-sm w-full"
                                placeholder="Search by name or ID"
                                value="${builder.searchQuery || ''}"
                                oninput="handleConnectionSearchChange('${recordId}', this.value)"
                                ${!selectedSetId ? 'disabled' : ''}
                            />
                        </div>

                        <div>
                            <label class="form-label">Connect to</label>
                            <select id="newConnectionTarget" class="border rounded px-3 py-2 text-sm w-full" onchange="handleConnectionRecordChange('${recordId}', this.value)" ${!selectedSetId ? 'disabled' : ''}>
                                <option value="">${selectedSetId ? 'Select a record' : 'Select a set first'}</option>
                                ${availableRecords.length === 0 && selectedSetId ? `<option value="" disabled>${allAvailableRecords.length === 0 ? 'No records available' : 'No matches found'}</option>` : ''}
                                ${availableRecords.map(rec => `<option value="${rec.id}" ${rec.id === selectedRecordId ? 'selected' : ''}>${getRecordDisplayName(rec.id) || selectedSet?.name || 'Record'}</option>`).join('')}
                            </select>
                        </div>

                        <!-- Preview -->
                        ${(selectedOperator && selectedVerb && selectedRecordId) ? `
                            <div class="bg-blue-50 border border-blue-200 rounded p-3 text-sm">
                                <span class="text-blue-600 font-medium">${subjectName}</span>
                                <span class="text-blue-800"> ${selectedVerb} </span>
                                <span class="text-blue-600 font-medium">${getRecordDisplayName(selectedRecordId) || 'Record'}</span>
                            </div>
                        ` : ''}

                        ${needsRelationType ? `
                            <div class="bg-blue-50 border border-blue-200 rounded p-2 text-xs text-blue-800">
                                A relation type for this operator/verb will be auto-created.
                                <button class="text-blue-600 underline ml-1" onclick="openModal('connectionRelationModal'); populateConnectionRelationOptions('${selectedOperator}');">Or create one manually</button>
                            </div>
                        ` : ''}

                        <label class="form-label">notes</label>
                        <input type="text" id="sidebarConnectionNotes" class="border rounded px-3 py-2 text-sm w-full" placeholder="" />

                        <div id="sidebarConnectionParams" class="grid grid-cols-1 gap-2"></div>

                        <button class="btn btn-primary btn-sm" onclick="createConnectionFromSidebar('${recordId}')" ${!canAddConnection ? 'disabled' : ''}>Add Connection</button>
                        ${availableRecords.length === 0
                            ? `<p class="text-xs text-gray-500">${allAvailableRecords.length === 0 ? 'Add records to the selected set to create connections.' : 'No records match your search.'}</p>`
                            : ''}
                    </div>
                    <div class="space-y-3">
                        ${connections.length === 0 ? '<p class="text-gray-500">No connections yet.</p>' : connections.map(edge => renderConnectionCard(edge, recordId)).join('')}
                    </div>
                </div>
            `;

            renderConnectionParamFields('sidebarConnectionParams', sidebarRelationId, builder.params || {});

            // Attach unified connection type change handler
            const connectionTypeSelect = document.getElementById('sidebarConnectionType');
            if (connectionTypeSelect) {
                connectionTypeSelect.onchange = (event) => {
                    const value = event.target.value;
                    if (value && value.includes('::')) {
                        const [op, verb] = value.split('::');
                        builder.selectedOperator = op;
                        builder.selectedVerb = verb;
                    } else {
                        builder.selectedOperator = null;
                        builder.selectedVerb = null;
                    }
                    builder.params = {};
                    renderConnectionsSidebar(container, recordId);
                };
            }

            const paramInputs = document.getElementById('sidebarConnectionParams')?.querySelectorAll('[data-param-name]') || [];
            paramInputs.forEach(input => {
                input.oninput = () => {
                    const name = input.dataset.paramName;
                    const raw = (input.value || '').trim();
                    if (!raw) {
                        delete builder.params[name];
                        return;
                    }
                    try {
                        builder.params[name] = JSON.parse(raw);
                    } catch (err) {
                        builder.params[name] = raw;
                    }
                };
            });
        }

        function selectConnectionType(recordId, operator, verb) {
            const builder = getConnectionBuilder();
            builder.selectedOperator = operator;
            builder.selectedVerb = verb;
            builder.params = {};
            renderRecordSidebar(recordId);
        }

        function handleConnectionSetChange(recordId, setId) {
            const builder = getConnectionBuilder();
            builder.targetSetId = setId || null;
            builder.targetRecordId = '';
            builder.searchQuery = '';
            renderRecordSidebar(recordId);
        }

        function handleConnectionRecordChange(recordId, targetId) {
            const builder = getConnectionBuilder();
            builder.targetRecordId = targetId || '';
            renderRecordSidebar(recordId);
        }

        function handleConnectionSearchChange(recordId, query) {
            const builder = getConnectionBuilder();
            builder.searchQuery = query;
            builder.targetRecordId = '';
            renderRecordSidebar(recordId);
        }

        function renderConnectionCard(edge, recordId) {
            const isSubject = edge.subject?.type === 'Record' && edge.subject?.id === recordId;
            const isOperand = edge.operand?.type === 'Record' && edge.operand?.id === recordId;
            const otherRef = isSubject ? edge.operand : edge.subject;
            const direction = isSubject ? '' : (isOperand ? '' : '');
            const timestamp = edge.updatedAt || edge.createdAt;

            // Get operator info for styling
            const operators = state.connectionModes?.operators || {};
            const operatorInfo = operators[edge.operator] || {};
            const operatorSymbol = operatorInfo.symbol || edge.operator || 'CON';

            // Format as SPO statement
            const subjectLabel = isSubject ? 'This record' : renderEntityLabel(edge.subject);
            const objectLabel = isSubject ? renderEntityLabel(otherRef) : 'This record';
            const verb = edge.mode || 'related to';

            return `
                <div class="border border-gray-200 rounded-lg p-3 bg-white">
                    <div class="flex items-start justify-between gap-3">
                        <div class="flex-1">
                            <!-- SPO Statement Display -->
                            <div class="text-sm mb-1">
                                <span class="font-medium">${direction} ${renderEntityLabel(otherRef)}</span>
                            </div>
                            <div class="text-xs text-gray-600 bg-gray-50 rounded px-2 py-1 inline-block">
                                <span class="font-mono text-gray-500">${operatorSymbol}</span>
                                <span class="text-gray-700">${edge.operator || 'CON'}</span>
                                <span class="mx-1"></span>
                                <span class="text-gray-800">${verb}</span>
                            </div>
                            <div class="text-xs text-gray-400 mt-1">${timestamp ? getTimeAgo(timestamp) : ''}</div>
                        </div>
                        <div class="flex items-center gap-2 text-xs">
                            <button class="text-blue-600 hover:underline" onclick="editConnectionParameters('${edge.id}', '${recordId}')">Edit parameters</button>
                            <button class="text-red-500 hover:underline" onclick="deleteConnectionFromSidebar('${edge.id}', '${recordId}')">Remove</button>
                        </div>
                    </div>
                    <div class="mt-2">
                        <div class="text-xs font-semibold text-gray-600 mb-1">Parameters</div>
                        ${renderConnectionParams(edge.params, edge.relationId)}
                    </div>
                </div>
            `;
        }

        function renderConnectionParams(params, relationId = null) {
            if (!params || !Object.keys(params).length) {
                return '<p class="text-xs text-gray-500 italic">No parameters set</p>';
            }

            // Get schema for type-aware rendering if available
            const relation = relationId ? findConnectionRelation(relationId) : null;
            const schema = relation?.parameterSchema || {};

            return `<dl class="text-xs space-y-1.5">
                ${Object.entries(params).map(([key, value]) => {
                    const fieldSchema = schema[key] || {};
                    const label = fieldSchema.label || key;
                    const formattedValue = formatParamValue(value, fieldSchema);

                    return `
                        <div class="flex justify-between gap-2 items-start">
                            <dt class="font-medium text-gray-600">${label}</dt>
                            <dd class="text-right text-gray-800">${formattedValue}</dd>
                        </div>
                    `;
                }).join('')}
            </dl>`;
        }

        function formatParamValue(value, schema = {}) {
            const { type = 'text', options = [] } = schema;

            if (value === null || value === undefined) {
                return '<span class="text-gray-400 italic">not set</span>';
            }

            switch (type) {
                case 'checkbox':
                    return value === true || value === 'true' || value === 1
                        ? '<span class="text-green-600">Yes</span>'
                        : '<span class="text-gray-500">No</span>';

                case 'select':
                    // Find label for the selected value if options have label/value format
                    if (Array.isArray(options)) {
                        const option = options.find(opt =>
                            typeof opt === 'object' ? opt.value === value : opt === value
                        );
                        if (option && typeof option === 'object' && option.label) {
                            return `<span class="bg-gray-100 px-1.5 py-0.5 rounded">${option.label}</span>`;
                        }
                    }
                    return `<span class="bg-gray-100 px-1.5 py-0.5 rounded">${value}</span>`;

                case 'date':
                    try {
                        const date = new Date(value);
                        return date.toLocaleDateString();
                    } catch {
                        return value;
                    }

                case 'number':
                    return `<span class="font-mono">${value}</span>`;

                default:
                    if (typeof value === 'object') {
                        return `<code class="text-xs bg-gray-100 px-1 rounded">${JSON.stringify(value)}</code>`;
                    }
                    // Truncate long text values
                    const strValue = String(value);
                    if (strValue.length > 50) {
                        return `<span title="${strValue.replace(/"/g, '&quot;')}">${strValue.substring(0, 47)}...</span>`;
                    }
                    return strValue;
            }
        }

        function parseConnectionParams(raw) {
            if (!raw || !raw.trim()) return {};

            let parsed;
            try {
                parsed = JSON.parse(raw);
            } catch (err) {
                throw new Error('Connection parameters must be valid JSON');
            }

            if (parsed === null || typeof parsed !== 'object' || Array.isArray(parsed)) {
                throw new Error('Connection parameters must be a JSON object');
            }

            return parsed;
        }

        // State for the connection parameter editor modal
        const connectionParamEditorState = {
            connectionId: null,
            recordId: null,
            currentParams: {},
            customParams: []
        };

        function editConnectionParameters(connectionId, recordId) {
            const existing = state.connections.get(connectionId);
            if (!existing) {
                showToast('Relationship not found');
                return;
            }

            // Store state for the modal
            connectionParamEditorState.connectionId = connectionId;
            connectionParamEditorState.recordId = recordId;
            connectionParamEditorState.currentParams = { ...(existing.params || {}) };
            connectionParamEditorState.customParams = [];

            // Get the relation to understand parameter schema
            const relation = findConnectionRelation(existing.relationId);

            // Render connection summary
            const summaryEl = document.getElementById('connectionParamEditorSummary');
            if (summaryEl) {
                const operatorInfo = state.connectionModes?.operators?.[existing.operator] || {};
                const subjectName = getRecordDisplayName(existing.subject?.id) || existing.subject?.id || 'Unknown';
                const operandName = getRecordDisplayName(existing.operand?.id) || existing.operand?.id || 'Unknown';
                summaryEl.innerHTML = `
                    <div class="flex items-center gap-2 text-sm">
                        <span class="font-medium text-gray-900">${subjectName}</span>
                        <span class="px-2 py-0.5 rounded bg-gray-200 text-gray-700 text-xs font-mono">
                            ${operatorInfo.symbol || ''} ${existing.mode || existing.operator}
                        </span>
                        <span class="font-medium text-gray-900">${operandName}</span>
                    </div>
                    ${relation ? `<div class="text-xs text-gray-500 mt-1">${relation.description || ''}</div>` : ''}
                `;
            }

            // Render parameter fields
            renderConnectionParamEditorFields(existing, relation);

            // Reset custom param section
            const customSection = document.getElementById('addCustomParamSection');
            if (customSection) customSection.classList.add('hidden');

            openModal('connectionParamEditorModal');
        }

        function renderConnectionParamEditorFields(connection, relation) {
            const container = document.getElementById('connectionParamEditorFields');
            if (!container) return;

            const schema = relation?.parameterSchema || {};
            const currentParams = connectionParamEditorState.currentParams || {};

            // Get all parameter names - from schema, existing params, and detect custom ones
            const schemaParamNames = Object.keys(schema);
            const existingParamNames = Object.keys(currentParams);
            const allParamNames = [...new Set([...schemaParamNames, ...existingParamNames])];

            if (allParamNames.length === 0) {
                container.innerHTML = '<p class="text-sm text-gray-500">No parameters defined for this connection type. Use "Add custom parameter" below to add data.</p>';
                return;
            }

            container.innerHTML = allParamNames.map(paramName => {
                const fieldSchema = schema[paramName] || { type: 'text', label: paramName, required: false };
                const currentValue = currentParams[paramName];
                const defaultValue = fieldSchema.default;
                const isFromSchema = schemaParamNames.includes(paramName);
                const isCustom = !isFromSchema;
                const hasOverride = currentValue !== undefined && currentValue !== defaultValue;

                return renderTypedParamField(paramName, fieldSchema, currentValue, defaultValue, isCustom, hasOverride);
            }).join('');
        }

        function renderTypedParamField(paramName, schema, currentValue, defaultValue, isCustom, hasOverride) {
            const { type = 'text', label = paramName, required = false, options = [], min, max, step, description } = schema;
            const value = currentValue !== undefined ? currentValue : (defaultValue !== undefined ? defaultValue : '');
            const safeValue = typeof value === 'object' ? JSON.stringify(value) : String(value ?? '');
            const escapedValue = safeValue
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;');

            // Generate label with indicators
            const labelHtml = `
                <label class="form-label flex items-center gap-2">
                    <span>${label}${required ? ' <span class="text-red-500">*</span>' : ''}</span>
                    ${isCustom ? '<span class="text-xs bg-purple-100 text-purple-700 px-1.5 py-0.5 rounded">custom</span>' : ''}
                    ${hasOverride && !isCustom ? '<span class="text-xs bg-blue-100 text-blue-700 px-1.5 py-0.5 rounded">modified</span>' : ''}
                </label>
            `;

            // Generate field based on type
            let fieldHtml = '';
            const commonAttrs = `data-param-name="${paramName}" data-param-type="${type}" class="border rounded px-3 py-2 w-full text-sm"`;

            switch (type) {
                case 'select':
                    const optionsList = Array.isArray(options) ? options : [];
                    fieldHtml = `
                        <select ${commonAttrs}>
                            <option value="">Select...</option>
                            ${optionsList.map(opt => {
                                const optVal = typeof opt === 'object' ? opt.value : opt;
                                const optLabel = typeof opt === 'object' ? opt.label : opt;
                                return `<option value="${optVal}" ${String(value) === String(optVal) ? 'selected' : ''}>${optLabel}</option>`;
                            }).join('')}
                        </select>
                    `;
                    break;

                case 'number':
                    fieldHtml = `
                        <input type="number" ${commonAttrs} value="${escapedValue}"
                            ${min !== undefined ? `min="${min}"` : ''}
                            ${max !== undefined ? `max="${max}"` : ''}
                            ${step !== undefined ? `step="${step}"` : ''} />
                    `;
                    break;

                case 'checkbox':
                    const isChecked = value === true || value === 'true' || value === 1;
                    fieldHtml = `
                        <div class="flex items-center gap-2">
                            <input type="checkbox" ${commonAttrs.replace('w-full', '')} ${isChecked ? 'checked' : ''} />
                            <span class="text-sm text-gray-600">${description || ''}</span>
                        </div>
                    `;
                    break;

                case 'date':
                    fieldHtml = `<input type="date" ${commonAttrs} value="${escapedValue}" />`;
                    break;

                case 'textarea':
                    fieldHtml = `<textarea ${commonAttrs} rows="3">${escapedValue}</textarea>`;
                    break;

                default: // text
                    fieldHtml = `<input type="text" ${commonAttrs} value="${escapedValue}" ${schema.placeholder ? `placeholder="${schema.placeholder}"` : ''} />`;
            }

            // Default value hint
            const defaultHint = defaultValue !== undefined && !isCustom
                ? `<span class="text-xs text-gray-400">Default: ${typeof defaultValue === 'object' ? JSON.stringify(defaultValue) : defaultValue}</span>`
                : '';

            // Remove button for custom params
            const removeBtn = isCustom
                ? `<button type="button" class="text-xs text-red-500 hover:text-red-700" onclick="removeCustomParamFromEditor('${paramName}')">Remove</button>`
                : '';

            return `
                <div class="param-field-group" data-param-name="${paramName}">
                    <div class="flex items-center justify-between">
                        ${labelHtml}
                        ${removeBtn}
                    </div>
                    ${fieldHtml}
                    ${description && type !== 'checkbox' ? `<p class="text-xs text-gray-500 mt-1">${description}</p>` : ''}
                    ${defaultHint}
                </div>
            `;
        }

        function toggleAddCustomParam() {
            const section = document.getElementById('addCustomParamSection');
            if (section) {
                section.classList.toggle('hidden');
                if (!section.classList.contains('hidden')) {
                    document.getElementById('customParamName')?.focus();
                }
            }
        }

        function addCustomParamToEditor() {
            const nameInput = document.getElementById('customParamName');
            const typeInput = document.getElementById('customParamType');
            const valueInput = document.getElementById('customParamValue');

            const name = nameInput?.value?.trim();
            const type = typeInput?.value || 'text';
            let value = valueInput?.value?.trim() || '';

            if (!name) {
                showToast('Parameter name is required');
                return;
            }

            // Check if already exists
            if (connectionParamEditorState.currentParams.hasOwnProperty(name)) {
                showToast('Parameter already exists');
                return;
            }

            // Convert value based on type
            if (type === 'number' && value) {
                value = parseFloat(value) || 0;
            } else if (type === 'checkbox') {
                value = value.toLowerCase() === 'true' || value === '1';
            }

            // Add to current params
            connectionParamEditorState.currentParams[name] = value;
            connectionParamEditorState.customParams.push(name);

            // Re-render fields
            const connection = state.connections.get(connectionParamEditorState.connectionId);
            const relation = connection ? findConnectionRelation(connection.relationId) : null;
            renderConnectionParamEditorFields(connection, relation);

            // Clear inputs
            nameInput.value = '';
            valueInput.value = '';
            document.getElementById('addCustomParamSection')?.classList.add('hidden');
        }

        function removeCustomParamFromEditor(paramName) {
            delete connectionParamEditorState.currentParams[paramName];
            connectionParamEditorState.customParams = connectionParamEditorState.customParams.filter(n => n !== paramName);

            // Re-render fields
            const connection = state.connections.get(connectionParamEditorState.connectionId);
            const relation = connection ? findConnectionRelation(connection.relationId) : null;
            renderConnectionParamEditorFields(connection, relation);
        }

        function closeConnectionParamEditor() {
            closeModal('connectionParamEditorModal');
            connectionParamEditorState.connectionId = null;
            connectionParamEditorState.recordId = null;
            connectionParamEditorState.currentParams = {};
            connectionParamEditorState.customParams = [];
        }

        function saveConnectionParams() {
            const { connectionId, recordId } = connectionParamEditorState;
            if (!connectionId) {
                showToast('No connection selected');
                return;
            }

            // Collect values from form fields
            const fieldsContainer = document.getElementById('connectionParamEditorFields');
            const params = {};

            if (fieldsContainer) {
                const inputs = fieldsContainer.querySelectorAll('[data-param-name]');
                inputs.forEach(input => {
                    const name = input.dataset.paramName;
                    const type = input.dataset.paramType || 'text';

                    let value;
                    if (type === 'checkbox') {
                        value = input.checked;
                    } else if (type === 'number') {
                        value = input.value ? parseFloat(input.value) : null;
                    } else if (input.tagName === 'TEXTAREA') {
                        value = input.value;
                    } else {
                        value = input.value;
                    }

                    // Only include non-empty values
                    if (value !== null && value !== '' && value !== undefined) {
                        params[name] = value;
                    }
                });
            }

            // Validate required fields
            const connection = state.connections.get(connectionId);
            const relation = connection ? findConnectionRelation(connection.relationId) : null;
            if (relation?.parameterSchema) {
                for (const [name, schema] of Object.entries(relation.parameterSchema)) {
                    if (schema.required && (params[name] === undefined || params[name] === '')) {
                        showToast(`Required field "${schema.label || name}" is missing`);
                        return;
                    }
                }
            }

            // Update the connection
            try {
                updateConnection(connectionId, { params });
                closeConnectionParamEditor();
                if (recordId) {
                    renderRecordSidebar(recordId);
                }
                showToast('Parameters updated');
            } catch (error) {
                showToast(error.message);
            }
        }

        function getRecordDisplayName(recordId) {
            const ref = getRecordById(recordId);
            if (!ref) return null;

            const identifierFieldId = getIdentifierFieldForSet(ref.set, ref.setId === state.currentSetId ? state.currentViewId : null);
            const identifierValue = identifierFieldId ? ref.record?.[identifierFieldId] : null;
            if (identifierValue) return identifierValue;

            // Check common name properties
            if (ref.record?.name) return ref.record.name;
            if (ref.record?.title) return ref.record.title;
            if (ref.record?.label) return ref.record.label;

            // Look for any text-like field value in the schema order
            if (ref.set?.schema) {
                for (const field of ref.set.schema) {
                    if (['TEXT', 'LONG_TEXT'].includes(field.type)) {
                        const val = ref.record?.[field.id];
                        if (val && typeof val === 'string' && val.trim()) return val;
                    }
                }
            }

            // Last resort: look for any non-empty string value
            for (const [key, val] of Object.entries(ref.record || {})) {
                if (key !== 'id' && typeof val === 'string' && val.trim() && !val.startsWith('rec_')) {
                    return val;
                }
            }

            return null;
        }

        function getIdentifierFieldForSet(set, preferredViewId = null) {
            if (!set) return null;

            if (preferredViewId && set.views.has(preferredViewId)) {
                const preferredView = set.views.get(preferredViewId);
                if (preferredView?.identifierField) return preferredView.identifierField;
            }

            for (const view of set.views.values()) {
                if (view?.identifierField) return view.identifierField;
            }

            return inferIdentifierFieldId(set);
        }

        function openLinkedRecord(recordId) {
            if (!recordId) return;
            const ref = getRecordById(recordId);
            if (!ref) {
                showToast('Linked record not found');
                return;
            }

            const firstViewId = ref.set.views.size ? Array.from(ref.set.views.keys())[0] : null;
            if (ref.setId !== state.currentSetId) {
                switchSet(ref.setId, firstViewId);
            }
            openExpandedRecord(recordId);
        }

        function createConnectionFromSidebar(recordId) {
            const builder = getConnectionBuilder();
            const target = builder.targetRecordId || document.getElementById('newConnectionTarget')?.value;
            if (!target) {
                showToast('Select a record to connect');
                return;
            }

            let relationId = builder.relationId || document.getElementById('sidebarConnectionRelation')?.value;

            // If no relation ID exists, try to find or create one based on operator/verb
            if (!relationId && builder.selectedOperator && builder.selectedVerb) {
                // Look for existing relation with this operator/verb combo
                const existingRelation = getConnectionRelationView().find(rel =>
                    rel.operator === builder.selectedOperator && rel.mode === builder.selectedVerb
                );

                if (existingRelation) {
                    relationId = existingRelation.id;
                } else {
                    // Auto-create a new relation type for this operator/verb combo
                    relationId = addConnectionRelation({
                        operator: builder.selectedOperator,
                        mode: builder.selectedVerb,
                        name: builder.selectedVerb,
                        description: `Auto-created relation for ${builder.selectedOperator} - ${builder.selectedVerb}`
                    });

                    if (!relationId) {
                        showToast('Failed to create connection relation');
                        return;
                    }
                }
                builder.relationId = relationId;
            }

            if (!relationId) {
                showToast('Select an operator and verb for the connection');
                return;
            }

            const relation = findConnectionRelation(relationId);
            if (!relation) {
                showToast('Selected connection relation not found');
                return;
            }

            let params = {};
            try {
                params = collectParamsFromInputs('sidebarConnectionParams', relation);
            } catch (error) {
                showToast(error.message);
                return;
            }

            // Track usage for this connection type (operator + verb)
            trackConnectionTypeUsage(builder.selectedOperator, builder.selectedVerb);

            builder.targetRecordId = '';
            builder.params = {};
            addConnection({
                subject: { type: 'Record', id: recordId },
                operand: { type: 'Record', id: target },
                relationId,
                params
            });
            renderRecordSidebar(recordId);
            showToast('Relationship created');
        }

        function deleteConnectionFromSidebar(connectionId, recordId) {
            deleteConnection(connectionId);
            renderRecordSidebar(recordId);
            showToast('Relationship removed');
        }

        function updateRecordHistoryVisibility() {
            const historyColumn = document.getElementById('expandedRecordHistoryColumn');
            const mainWrapper = document.getElementById('expandedRecordMainWrapper');
            const toggleBtn = document.getElementById('toggleHistorySidebarBtn');
            const isVisible = state.recordHistoryVisible;

            if (historyColumn) historyColumn.classList.toggle('hidden', !isVisible);
            if (mainWrapper) {
                mainWrapper.classList.toggle('md:col-span-3', !isVisible);
                mainWrapper.classList.toggle('md:col-span-2', isVisible);
                mainWrapper.classList.toggle('border-r', isVisible);
            }
            if (toggleBtn) {
                toggleBtn.disabled = false;
                toggleBtn.textContent = state.recordHistoryVisible ? 'Hide History' : 'Show History';
            }
        }

        function toggleRecordHistoryVisibility() {
            state.recordHistoryVisible = !state.recordHistoryVisible;
            updateRecordHistoryVisibility();
        }

        function getPopupLayout(view) {
            const defaults = { size: 'medium', columns: 4, rows: 4 };
            view.popupLayout = { ...defaults, ...(view.popupLayout || {}) };
            return view.popupLayout;
        }

        function getPopupOrderedFields(set, view) {
            const defaultOrder = set.schema.map(f => f.id);
            view.popupFieldOrder = Array.isArray(view.popupFieldOrder) && view.popupFieldOrder.length
                ? view.popupFieldOrder
                : defaultOrder;
            const orderMap = new Map(view.popupFieldOrder.map((id, idx) => [id, idx]));
            return [...set.schema].sort((a, b) => {
                const aIndex = orderMap.has(a.id) ? orderMap.get(a.id) : Number.MAX_SAFE_INTEGER;
                const bIndex = orderMap.has(b.id) ? orderMap.get(b.id) : Number.MAX_SAFE_INTEGER;
                return aIndex - bIndex;
            });
        }

        function renderPopupSettings(targetIds = ['popupSettingsFields', 'popupSettingsSidebar']) {
            const popupModal = document.getElementById('popupSettingsModal');
            const modalOpen = popupModal && !popupModal.classList.contains('hidden');
            if (modalOpen) {
                renderPopupConfigurator();
            }
            renderInlinePopupSettings(targetIds);
        }

        function renderInlinePopupSettings(targetIds = ['popupSettingsFields']) {
            const set = getCurrentSet();
            const view = getCurrentView();
            if (!set || !view) return;

            view.popupVisibilityRules = view.popupVisibilityRules || [];
            const fields = getPopupOrderedFields(set, view);
            const popupSettingsHtml = fields.map(field => {
                const rule = view.popupVisibilityRules.find(r => r.fieldId === field.id) || { visibility: 'show', criteria: { type: 'always', value: '' } };
                const criteriaType = rule.criteria?.type || 'always';
                const criteriaValue = rule.criteria?.value || '';
                const needsValue = ['equals', 'notEquals', 'contains'].includes(criteriaType);

                return `
                    <div class="border border-gray-200 rounded-lg p-4">
                        <div class="flex items-center justify-between gap-4 flex-wrap">
                            <div>
                                <div class="font-semibold text-gray-900">${field.name}</div>
                                <div class="text-sm text-gray-500">${field.type}</div>
                            </div>
                            <div class="flex items-center gap-3 flex-wrap">
                                <label class="text-sm text-gray-600 flex items-center gap-2">
                                    Visibility
                                    <select class="border rounded px-2 py-1" onchange="updatePopupVisibilityRule('${field.id}', this.value)">
                                        <option value="show" ${rule.visibility !== 'hide' ? 'selected' : ''}>Show</option>
                                        <option value="hide" ${rule.visibility === 'hide' ? 'selected' : ''}>Hide</option>
                                    </select>
                                </label>
                                <label class="text-sm text-gray-600 flex items-center gap-2">
                                    Criteria
                                    <select class="border rounded px-2 py-1" onchange="updatePopupCriteriaType('${field.id}', this.value)">
                                        <option value="always" ${criteriaType === 'always' ? 'selected' : ''}>Always</option>
                                        <option value="equals" ${criteriaType === 'equals' ? 'selected' : ''}>Value equals</option>
                                        <option value="notEquals" ${criteriaType === 'notEquals' ? 'selected' : ''}>Value not equal</option>
                                        <option value="contains" ${criteriaType === 'contains' ? 'selected' : ''}>Value contains</option>
                                        <option value="empty" ${criteriaType === 'empty' ? 'selected' : ''}>When empty</option>
                                        <option value="notEmpty" ${criteriaType === 'notEmpty' ? 'selected' : ''}>When not empty</option>
                                    </select>
                                </label>
                                <input
                                    type="text"
                                    class="border rounded px-3 py-1 text-sm ${needsValue ? '' : 'opacity-50'}"
                                    placeholder="Criteria value"
                                    value="${criteriaValue}"
                                    ${needsValue ? '' : 'disabled'}
                                    oninput="updatePopupCriteriaValue('${field.id}', this.value)">
                            </div>
                        </div>
                    </div>
                `;
            }).join('');

            const targets = Array.isArray(targetIds) ? targetIds : [targetIds];
            targets.forEach(id => {
                const container = document.getElementById(id);
                if (container) container.innerHTML = popupSettingsHtml;
            });
        }

        function openPopupSettingsModal() {
            state.popupUi = state.popupUi || { filter: 'all', activeTab: 'popupFields' };
            state.popupUi.filter = state.popupUi.filter || 'all';
            state.popupUi.activeTab = 'popupFields';
            renderPopupConfigurator();
            openModal('popupSettingsModal');
        }

        function updatePopupVisibilityRule(fieldId, visibility) {
            const rule = ensurePopupRule(fieldId);
            if (!rule) return;
            rule.visibility = visibility;
            logPopupEvent('visibility', { fieldId, visibility });
            renderPopupSettings();
            refreshOpenRecordModal();
        }

        function updatePopupCriteriaType(fieldId, type) {
            const rule = ensurePopupRule(fieldId);
            if (!rule) return;
            rule.criteria = rule.criteria || { type: 'always', value: '' };
            rule.criteria.type = type;
            if (!['equals', 'notEquals', 'contains'].includes(type)) {
                rule.criteria.value = '';
            }
            renderPopupSettings();
            logPopupEvent('criteriaType', { fieldId, type });
            refreshOpenRecordModal();
        }

        function updatePopupCriteriaValue(fieldId, value) {
            const rule = ensurePopupRule(fieldId);
            if (!rule) return;
            rule.criteria = rule.criteria || { type: 'always', value: '' };
            rule.criteria.value = value;
            logPopupEvent('criteriaValue', { fieldId, value });
            renderPopupSettings();
            refreshOpenRecordModal();
        }

        function setPopupTab(tab) {
            state.popupUi.activeTab = tab;
            document.querySelectorAll('.popup-config-tab').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.tab === tab);
            });
            document.querySelectorAll('.popup-tab-panel').forEach(panel => {
                panel.classList.toggle('active', panel.id === tab);
            });
            renderPopupConfigurator();
        }

        function setPopupFilter(filter) {
            state.popupUi.filter = filter;
            renderPopupConfigurator();
        }

        function renderPopupFilters() {
            const filters = [
                { id: 'all', label: 'All Fields' },
                { id: 'visible', label: ' Visible' },
                { id: 'hidden', label: ' Hidden' },
                { id: 'conditional', label: ' Conditional' }
            ];
            const container = document.getElementById('popupFilters');
            if (!container) return;
            container.innerHTML = filters.map(f => `
                <button class="popup-filter ${state.popupUi.filter === f.id ? 'active' : ''}" onclick="setPopupFilter('${f.id}')">${f.label}</button>
            `).join('');
        }

        function togglePopupFieldVisibility(fieldId) {
            const rule = ensurePopupRule(fieldId);
            if (!rule) return;
            const newVisibility = rule.visibility === 'hide' ? 'show' : 'hide';
            updatePopupVisibilityRule(fieldId, newVisibility);
        }

        function renderPopupFieldList() {
            const set = getCurrentSet();
            const view = getCurrentView();
            if (!set || !view) return;
            view.popupVisibilityRules = view.popupVisibilityRules || [];

            const fields = getPopupOrderedFields(set, view).filter(field => {
                const rule = view.popupVisibilityRules.find(r => r.fieldId === field.id);
                const isVisible = !rule || rule.visibility !== 'hide';
                const hasCondition = rule?.criteria?.type && rule.criteria.type !== 'always';
                if (state.popupUi.filter === 'visible') return isVisible;
                if (state.popupUi.filter === 'hidden') return !isVisible;
                if (state.popupUi.filter === 'conditional') return hasCondition;
                return true;
            });

            const container = document.getElementById('popupFieldList');
            if (!container) return;

            container.innerHTML = fields.map(field => {
                const rule = view.popupVisibilityRules.find(r => r.fieldId === field.id);
                const isVisible = !rule || rule.visibility !== 'hide';
                const hasCondition = rule?.criteria?.type && rule.criteria.type !== 'always';
                const typeMeta = FIELD_TYPES[field.type] || {};
                const typeLabel = typeMeta.name || field.type;
                return `
                    <div class="popup-field-card" draggable="true" data-field-id="${field.id}">
                        <div class="drag-handle"></div>
                        <div class="popup-field-icon">${renderIcon(typeMeta.icon || 'ph-app-window')}</div>
                        <div class="popup-field-meta">
                            <div class="popup-field-name">
                                ${field.name}
                                ${hasCondition ? '<span class="popup-badge warn">Conditional</span>' : ''}
                                ${!isVisible ? '<span class="popup-badge warn">Hidden</span>' : ''}
                            </div>
                            <div class="popup-field-type field-type">${typeLabel}</div>
                        </div>
                        <div class="flex items-center gap-2">
                            <div class="popup-toggle ${isVisible ? 'active' : ''}" onclick="togglePopupFieldVisibility('${field.id}')"></div>
                            <button class="btn btn-secondary btn-sm" onclick="focusPopupCondition('${field.id}')"><i class="ph ph-sliders-horizontal"></i></button>
                        </div>
                    </div>
                `;
            }).join('');

            const popupFieldCountBadge = document.getElementById('popupFieldCountBadge');
            if (popupFieldCountBadge) popupFieldCountBadge.textContent = fields.length;
            attachPopupFieldDragHandlers();
        }

        function attachPopupFieldDragHandlers() {
            document.querySelectorAll('.popup-field-card').forEach(card => {
                card.addEventListener('dragstart', handlePopupFieldDragStart);
                card.addEventListener('dragover', handlePopupFieldDragOver);
                card.addEventListener('drop', handlePopupFieldDrop);
                card.addEventListener('dragend', handlePopupFieldDragEnd);
            });
        }

        function handlePopupFieldDragStart(e) {
            state.popupDraggedField = e.currentTarget.dataset.fieldId;
            e.currentTarget.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
        }

        function handlePopupFieldDragOver(e) {
            e.preventDefault();
            const target = e.currentTarget;
            if (state.popupDraggedField && target.dataset.fieldId !== state.popupDraggedField) {
                target.classList.add('drag-over');
            }
        }

        function handlePopupFieldDrop(e) {
            e.preventDefault();
            const targetId = e.currentTarget.dataset.fieldId;
            if (state.popupDraggedField && targetId && targetId !== state.popupDraggedField) {
                updatePopupFieldOrder(state.popupDraggedField, targetId);
                logPopupEvent('reorder', { from: state.popupDraggedField, to: targetId });
            }
            document.querySelectorAll('.popup-field-card').forEach(el => el.classList.remove('drag-over'));
            state.popupDraggedField = null;
        }

        function handlePopupFieldDragEnd(e) {
            e.currentTarget.classList.remove('dragging');
            document.querySelectorAll('.popup-field-card').forEach(el => el.classList.remove('drag-over'));
            state.popupDraggedField = null;
        }

        function updatePopupFieldOrder(draggedId, targetId) {
            const set = getCurrentSet();
            const view = getCurrentView();
            if (!set || !view) return;

            const order = getPopupOrderedFields(set, view).map(f => f.id);
            const fromIndex = order.indexOf(draggedId);
            const toIndex = order.indexOf(targetId);
            if (fromIndex === -1 || toIndex === -1) return;

            order.splice(fromIndex, 1);
            order.splice(toIndex, 0, draggedId);
            view.popupFieldOrder = order;
            renderPopupConfigurator();
        }

        function renderPopupStats() {
            const set = getCurrentSet();
            const view = getCurrentView();
            if (!set || !view) return;
            view.popupVisibilityRules = view.popupVisibilityRules || [];
            const fields = getPopupOrderedFields(set, view);
            const visibleCount = fields.reduce((count, field) => {
                const rule = view.popupVisibilityRules.find(r => r.fieldId === field.id);
                return count + ((rule && rule.visibility === 'hide') ? 0 : 1);
            }, 0);
            const conditionalCount = view.popupVisibilityRules.filter(r => r.criteria?.type && r.criteria.type !== 'always').length;
            const popupVisibleCount = document.getElementById('popupVisibleCount');
            const popupConditionalCount = document.getElementById('popupConditionalCount');
            if (popupVisibleCount) popupVisibleCount.textContent = visibleCount;
            if (popupConditionalCount) popupConditionalCount.textContent = conditionalCount;
        }

        function renderPopupPreview() {
            const set = getCurrentSet();
            const view = getCurrentView();
            if (!set || !view) return;
            const layout = getPopupLayout(view);
            const preview = document.getElementById('popupPreview');
            if (!preview) return;

            const record = Array.from(set.records.values())[0] || {};
            const fields = getPopupOrderedFields(set, view)
                .filter(field => shouldDisplayFieldInPopup(field, record))
                .slice(0, (layout.rows || 1) * (layout.columns || 1));

            preview.innerHTML = `
                <div class="popup-preview-header">
                    <span>Record Preview</span>
                    <span class="popup-pill">${layout.size}  ${layout.columns} cols  ${layout.rows} rows</span>
                </div>
                <div class="popup-preview-fields cols-${layout.columns}">
                    ${fields.map(field => `
                        <div class="popup-preview-field">
                            <div class="label">${field.name}</div>
                            <div class="value">${record[field.id] ?? ''}</div>
                        </div>
                    `).join('')}
                </div>
            `;
        }

        function renderPopupLayoutOptions() {
            const view = getCurrentView();
            if (!view) return;
            const layout = getPopupLayout(view);

            const sizeOptions = [
                { id: 'small', label: 'Small', desc: 'Compact width' },
                { id: 'medium', label: 'Medium', desc: 'Balanced width' },
                { id: 'large', label: 'Large', desc: 'Full dialog' }
            ];
            const sizeContainer = document.getElementById('popupSizeOptions');
            if (sizeContainer) {
                sizeContainer.innerHTML = sizeOptions.map(opt => `
                    <div class="popup-layout-option ${layout.size === opt.id ? 'active' : ''}" onclick="updatePopupSize('${opt.id}')">
                        <div class="font-semibold">${opt.label}</div>
                        <div class="text-sm text-gray-600">${opt.desc}</div>
                    </div>
                `).join('');
            }

            const columnContainer = document.getElementById('popupColumnOptions');
            if (columnContainer) {
                columnContainer.innerHTML = [1, 2, 3, 4].map(cols => `
                    <div class="popup-layout-option ${layout.columns === cols ? 'active' : ''}" onclick="updatePopupColumns(${cols})">
                        <div class="font-semibold">${cols} Column${cols > 1 ? 's' : ''}</div>
                        <div class="text-sm text-gray-600">${cols === 1 ? 'Single stack' : cols === 2 ? 'Split view' : cols === 3 ? 'Dense grid' : 'Quartered grid'}</div>
                    </div>
                `).join('');
            }
        }

        function updatePopupSize(size) {
            const view = getCurrentView();
            if (!view) return;
            const layout = getPopupLayout(view);
            layout.size = size;
            logPopupEvent('size', { size });
            renderPopupConfigurator();
        }

        function updatePopupColumns(columns) {
            const view = getCurrentView();
            if (!view) return;
            const layout = getPopupLayout(view);
            layout.columns = columns;
            logPopupEvent('columns', { columns });
            renderPopupConfigurator();
        }

        function renderPopupConditions() {
            const set = getCurrentSet();
            const view = getCurrentView();
            if (!set || !view) return;
            view.popupVisibilityRules = view.popupVisibilityRules || [];
            const container = document.getElementById('popupConditionsList');
            if (!container) return;

            const fields = getPopupOrderedFields(set, view);
            container.innerHTML = fields.map(field => {
                const rule = view.popupVisibilityRules.find(r => r.fieldId === field.id) || { visibility: 'show', criteria: { type: 'always', value: '' } };
                const criteriaType = rule.criteria?.type || 'always';
                const needsValue = ['equals', 'notEquals', 'contains'].includes(criteriaType);
                return `
                    <div class="popup-condition-card" data-condition-field="${field.id}">
                        <div class="popup-condition-title">${field.name} <span class="popup-pill">${rule.visibility === 'hide' ? 'Hidden' : 'Shown'}</span></div>
                        <div class="popup-condition-row">
                            <label class="text-sm text-gray-600 flex items-center gap-2">Visibility
                                <select class="border rounded px-2 py-2 text-sm" onchange="updatePopupVisibilityRule('${field.id}', this.value)">
                                    <option value="show" ${rule.visibility !== 'hide' ? 'selected' : ''}>Show</option>
                                    <option value="hide" ${rule.visibility === 'hide' ? 'selected' : ''}>Hide</option>
                                </select>
                            </label>
                            <label class="text-sm text-gray-600 flex items-center gap-2">Criteria
                                <select class="border rounded px-2 py-2 text-sm" onchange="updatePopupCriteriaType('${field.id}', this.value)">
                                    <option value="always" ${criteriaType === 'always' ? 'selected' : ''}>Always</option>
                                    <option value="equals" ${criteriaType === 'equals' ? 'selected' : ''}>Value equals</option>
                                    <option value="notEquals" ${criteriaType === 'notEquals' ? 'selected' : ''}>Value not equal</option>
                                    <option value="contains" ${criteriaType === 'contains' ? 'selected' : ''}>Value contains</option>
                                    <option value="empty" ${criteriaType === 'empty' ? 'selected' : ''}>When empty</option>
                                    <option value="notEmpty" ${criteriaType === 'notEmpty' ? 'selected' : ''}>When not empty</option>
                                </select>
                            </label>
                            <input class="border rounded px-3 py-2 text-sm ${needsValue ? '' : 'opacity-50'}" placeholder="Criteria value" value="${rule.criteria?.value || ''}" ${needsValue ? '' : 'disabled'} oninput="updatePopupCriteriaValue('${field.id}', this.value)">
                        </div>
                    </div>
                `;
            }).join('');
        }

        function renderPopupEvents() {
            const container = document.getElementById('popupEventStream');
            if (!container) return;
            if (state.popupEventStream.length === 0) {
                container.innerHTML = '<p class="text-sm text-gray-600">No recent configuration changes yet.</p>';
                return;
            }
            container.innerHTML = state.popupEventStream.map(evt => `
                <div class="popup-event">
                    <div class="popup-event-header">
                        <span>${evt.type}</span>
                        <span class="popup-event-time">${new Date(evt.timestamp).toLocaleTimeString()}</span>
                    </div>
                    <div class="text-sm text-gray-600">${describePopupEvent(evt)}</div>
                </div>
            `).join('');
        }

        function describePopupEvent(event) {
            const name = event.data?.fieldId ? getFieldNameById(event.data.fieldId) : '';
            switch (event.action) {
                case 'visibility':
                    return `${name || 'Field'} set to ${event.data.visibility}`;
                case 'criteriaType':
                    return `${name || 'Field'} criteria: ${event.data.type}`;
                case 'criteriaValue':
                    return `${name || 'Field'} criteria value updated`;
                case 'reorder':
                    return `Reordered fields (${event.data.from}  ${event.data.to})`;
                case 'size':
                    return `Modal size changed to ${event.data.size}`;
                case 'columns':
                    return `Layout updated to ${event.data.columns} columns`;
                case 'template':
                    return `Applied ${event.data.template} template`;
                default:
                    return event.type;
            }
        }

        function renderPopupRecentChanges() {
            const container = document.getElementById('popupRecentChanges');
            if (!container) return;
            const items = state.popupEventStream.slice(0, 4);
            container.innerHTML = items.length === 0
                ? '<p class="text-sm text-gray-500">No changes yet.</p>'
                : items.map(evt => `<div> ${describePopupEvent(evt)}</div>`).join('');
        }

        function logPopupEvent(action, data = {}) {
            const entry = { id: Date.now(), action, data, type: action, timestamp: new Date().toISOString() };
            state.popupEventStream.unshift(entry);
            state.popupEventStream = state.popupEventStream.slice(0, 25);
            renderPopupEvents();
            renderPopupRecentChanges();
        }

        function resetPopupLayout() {
            const set = getCurrentSet();
            const view = getCurrentView();
            if (!set || !view) return;
            view.popupLayout = { size: 'medium', columns: 4, rows: 4 };
            view.popupFieldOrder = set.schema.map(f => f.id);
            view.popupVisibilityRules = [];
            logPopupEvent('reset', {});
            renderPopupConfigurator();
            refreshOpenRecordModal();
        }

        function applyPopupTemplate(template) {
            const set = getCurrentSet();
            const view = getCurrentView();
            if (!set || !view) return;
            const ordered = getPopupOrderedFields(set, view);
            const layout = getPopupLayout(view);

            if (template === 'minimal') {
                layout.size = 'small';
                layout.columns = 1;
                view.popupVisibilityRules = ordered.map((field, idx) => ({ fieldId: field.id, visibility: idx < 4 ? 'show' : 'hide', criteria: { type: 'always', value: '' } }));
            } else if (template === 'detailed') {
                layout.size = 'large';
                layout.columns = 3;
                view.popupVisibilityRules = ordered.map(field => ({ fieldId: field.id, visibility: 'show', criteria: { type: 'always', value: '' } }));
            } else if (template === 'compact') {
                layout.size = 'medium';
                layout.columns = 2;
                view.popupVisibilityRules = ordered.map((field, idx) => ({ fieldId: field.id, visibility: idx < 6 ? 'show' : 'hide', criteria: { type: 'always', value: '' } }));
            }
            logPopupEvent('template', { template });
            renderPopupConfigurator();
            refreshOpenRecordModal();
        }

        function focusPopupCondition(fieldId) {
            setPopupTab('popupConditions');
            requestAnimationFrame(() => {
                const el = document.querySelector(`[data-condition-field="${fieldId}"]`);
                if (el) el.scrollIntoView({ behavior: 'smooth', block: 'center' });
            });
        }

        function getFieldNameById(fieldId) {
            const set = getCurrentSet();
            return set?.schema.find(f => f.id === fieldId)?.name || fieldId;
        }

        function renderPopupConfigurator() {
            const activeTab = state.popupUi?.activeTab || 'popupFields';
            document.querySelectorAll('.popup-config-tab').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.tab === activeTab);
            });
            document.querySelectorAll('.popup-tab-panel').forEach(panel => {
                panel.classList.toggle('active', panel.id === activeTab);
            });
            renderPopupFilters();
            renderPopupFieldList();
            renderPopupStats();
            renderPopupLayoutOptions();
            renderPopupPreview();
            renderPopupConditions();
            renderPopupEvents();
            renderPopupRecentChanges();
        }

        // CONTEXT MENUS
        function showColumnMenu(e, field) {
            const currentView = getCurrentView();
            const set = getCurrentSet();
            const isIdentifier = currentView?.identifierField === field.id;
            const isRecordIdField = field.id === '__recordId';
            const hasCustomDisplayName = currentView?.columnDisplayNames?.[field.id];

            showContextMenu(e, [
                { label: 'Edit Display Name', action: () => editColumnDisplayName(field) },
                hasCustomDisplayName ? { label: 'Reset Display Name', action: () => resetColumnDisplayName(field.id) } : null,
                { label: 'separator' },
                { label: 'Auto-fit Column Width', icon: 'ph-arrows-in-line-horizontal', action: () => {
                    if (typeof ColumnWidthSettings !== 'undefined' && set) {
                        const width = ColumnWidthSettings.calculateContentWidth(state, set.id, field.id);
                        if (currentView) {
                            if (!currentView.columnWidths) currentView.columnWidths = {};
                            currentView.columnWidths[field.id] = width;
                            currentView.columnWidthMode = 'custom';
                            currentView.isDirty = true;
                        }
                        applyColumnWidth(field.id, width);
                    }
                }},
                { label: 'Set Column Width', icon: 'ph-text-columns', action: () => openSetColumnWidthDialog(field) },
                { label: 'separator' },
                { label: 'Create View from Column', action: () => createViewFromColumn(field) },
                // Don't allow setting Record ID as the identifier field - it's static
                !isRecordIdField ? { label: isIdentifier ? 'Clear Identifier' : 'Use as Identifier', action: () => setIdentifierField(isIdentifier ? null : field.id) } : null,
                { label: 'Change Field Type', action: () => openChangeFieldTypeModal(field) },
                hasFieldHistory(getCurrentSet()?.id, field.id) ? { label: 'Revert Last Type Change', action: () => revertFieldType(field.id) } : null,
                { label: 'Hide Field', action: () => hideField(field.id) },
                { label: 'Delete Field', action: () => confirmDelete('field', field.id), danger: true }
            ].filter(Boolean));
        }

        function openSetColumnWidthDialog(field) {
            const view = getCurrentView();
            const currentWidth = getFieldWidth(field, view);

            const width = prompt(`Set column width for "${field.name}" (${COLUMN_WIDTH_MIN}-${COLUMN_WIDTH_MAX}px):`, currentWidth);
            if (width === null) return;

            const numWidth = parseInt(width, 10);
            if (isNaN(numWidth) || numWidth < COLUMN_WIDTH_MIN || numWidth > COLUMN_WIDTH_MAX) {
                showToast(`Invalid width. Please enter a number between ${COLUMN_WIDTH_MIN} and ${COLUMN_WIDTH_MAX}.`);
                return;
            }

            if (view) {
                if (!view.columnWidths) view.columnWidths = {};
                view.columnWidths[field.id] = numWidth;
                view.columnWidthMode = 'custom';
                view.isDirty = true;
            }
            applyColumnWidth(field.id, numWidth);
        }

        function editColumnDisplayName(field) {
            const view = getCurrentView();
            const set = getCurrentSet();
            if (!view || !set) return;

            // Get the column header element
            const th = document.querySelector(`th.column-header[data-field-id="${field.id}"]`);
            if (!th) return;

            const columnTitle = th.querySelector('.column-title');
            if (!columnTitle) return;

            // Get current display name (could be custom or original field name)
            const currentDisplayName = view.columnDisplayNames?.[field.id] || field.name;

            // Store original HTML for restoration
            const originalHTML = columnTitle.innerHTML;

            // Create inline input
            const input = document.createElement('input');
            input.type = 'text';
            input.value = currentDisplayName;
            input.className = 'column-display-name-input';
            input.style.cssText = 'width: 100%; font-size: inherit; font-weight: inherit; padding: 2px 4px; border: 1px solid var(--accent); border-radius: 3px; background: var(--bg); color: var(--fg);';

            // Replace content with input
            columnTitle.innerHTML = '';
            columnTitle.appendChild(input);
            input.focus();
            input.select();

            const saveDisplayName = () => {
                const newName = input.value.trim();
                if (newName && newName !== currentDisplayName) {
                    // Initialize columnDisplayNames if it doesn't exist
                    if (!view.columnDisplayNames) {
                        view.columnDisplayNames = {};
                    }

                    // Get the original field name for comparison
                    const originalFieldName = set.schema?.find(f => f.id === field.id)?.name || field.name;

                    // If new name equals original field name, remove the custom display name
                    if (newName === originalFieldName) {
                        delete view.columnDisplayNames[field.id];
                    } else {
                        view.columnDisplayNames[field.id] = newName;
                    }

                    createEvent(
                        'Update Column Display Name',
                        'UPD',
                        { type: 'View', id: view.id, setId: set.id },
                        { fieldId: field.id, oldName: currentDisplayName, newName, summary: `Changed column display name from "${currentDisplayName}" to "${newName}"` },
                        { scale: 'collection' }
                    );

                    renderCurrentView();
                    showToast(`Column renamed to "${newName}"`);
                } else {
                    // Restore original HTML if no change
                    columnTitle.innerHTML = originalHTML;
                }
            };

            const cancelEdit = () => {
                columnTitle.innerHTML = originalHTML;
            };

            input.addEventListener('blur', saveDisplayName);
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    saveDisplayName();
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    cancelEdit();
                }
            });
        }

        function resetColumnDisplayName(fieldId) {
            const view = getCurrentView();
            const set = getCurrentSet();
            if (!view || !set) return;

            if (view.columnDisplayNames?.[fieldId]) {
                const oldName = view.columnDisplayNames[fieldId];
                delete view.columnDisplayNames[fieldId];

                // Get the original field name
                const originalName = set.schema?.find(f => f.id === fieldId)?.name || fieldId;

                createEvent(
                    'Reset Column Display Name',
                    'UPD',
                    { type: 'View', id: view.id, setId: set.id },
                    { fieldId, oldName, newName: originalName, summary: `Reset column display name to "${originalName}"` },
                    { scale: 'collection' }
                );

                renderCurrentView();
                showToast(`Column name reset to "${originalName}"`);
            }
        }

        function setIdentifierField(fieldId) {
            const set = getCurrentSet();
            const view = getCurrentView();
            if (!set || !view) return;

            view.identifierField = fieldId || null;

            createEvent(
                'View Identifier Update',
                'UPD',
                { type: 'View', id: view.id, setId: set.id },
                { identifierField: view.identifierField, summary: fieldId ? `Set ${fieldId} as identifier for ${view.name}` : `Cleared identifier for ${view.name}` },
                { scale: 'collection' }
            );

            renderCurrentView();
            showToast(fieldId ? ' Identifier updated' : 'Identifier cleared');
        }

        function openChangeFieldTypeModal(field) {
            state.changeFieldContext = field;
            state.changeFieldOriginalType = field?.type || null;
            const nameTarget = document.getElementById('changeFieldName');
            const input = document.getElementById('changeFieldTypeInput');
            if (nameTarget) nameTarget.textContent = field.name;
            if (input) input.value = field.type;
            renderChangeFieldTypeGrid(field.type);
            resetChangeFieldConfig(field.type, field);
            renderChangeFieldConfig(field.type);

            // Set initial subtype if field has one
            setTimeout(() => {
                const subtypeSelect = document.getElementById('changeFieldSubtypeSelect');
                if (subtypeSelect && field.subtype) {
                    subtypeSelect.value = field.subtype;
                }
            }, 0);

            renderChangeLinkSelect();
            updateChangeFieldTypeSummary(field.type);
            closeChangeFieldTypeDropdown();
            openModal('changeFieldTypeModal');
        }

        function showCellMenu(e, recordId, field) {
            showContextMenu(e, [
                { label: 'Copy Cell Value', icon: 'ph-clipboard-text', action: () => copyCellValue(recordId, field) },
                { label: 'separator' },
                { label: 'Create View from This Value', action: () => createViewFromValue(recordId, field) },
                { label: 'Open Cell History', action: () => openCellHistory(recordId, field.id) }
            ]);
        }

        /**
         * Copy cell value to clipboard
         * Formats linked records and lookups as clean comma-delimited values with quotes if needed
         */
        function copyCellValue(recordId, field) {
            const set = getCurrentSet();
            if (!set) return;

            const record = set.records.get(recordId);
            if (!record) return;

            const value = record[field.id];
            let copyText = '';

            // Format based on field type
            switch (field.type) {
                case 'LINK_RECORD': {
                    if (!value) break;
                    const linkedRecordIds = Array.isArray(value) ? value : [value];
                    const names = linkedRecordIds.map(id => {
                        const name = getRecordDisplayName(id) || 'Record';
                        // Quote if contains comma or quotes
                        return name.includes(',') || name.includes('"') ? `"${name.replace(/"/g, '""')}"` : name;
                    });
                    copyText = names.join(', ');
                    break;
                }
                case 'LINKED_LOOKUP': {
                    if (!field._linkedConfig) break;
                    const lookupValues = evaluateLinkedLookup(field._linkedConfig, record, state);
                    if (!lookupValues || lookupValues.length === 0) break;
                    const formattedValues = lookupValues.map(val => {
                        const str = String(val);
                        // Quote if contains comma or quotes
                        return str.includes(',') || str.includes('"') ? `"${str.replace(/"/g, '""')}"` : str;
                    });
                    copyText = formattedValues.join(', ');
                    break;
                }
                case 'SELECT':
                case 'MULTI_SELECT': {
                    if (Array.isArray(value)) {
                        const formattedValues = value.map(val => {
                            const str = String(val);
                            return str.includes(',') || str.includes('"') ? `"${str.replace(/"/g, '""')}"` : str;
                        });
                        copyText = formattedValues.join(', ');
                    } else {
                        copyText = value || '';
                    }
                    break;
                }
                case 'CHECKBOX':
                    copyText = value ? 'true' : 'false';
                    break;
                case 'DATE':
                    copyText = value ? new Date(value).toLocaleDateString() : '';
                    break;
                case 'NUMBER':
                case 'CURRENCY':
                    copyText = value != null ? String(value) : '';
                    break;
                default:
                    copyText = value != null ? String(value) : '';
            }

            navigator.clipboard.writeText(copyText).then(() => {
                showToast('Copied to clipboard');
            }).catch(err => {
                console.error('Failed to copy:', err);
                showToast('Failed to copy');
            });
        }

        function showContextMenu(e, items) {
            const menu = document.createElement('div');
            menu.className = 'context-menu';
            menu.style.top = `${e.clientY}px`;
            menu.style.left = `${e.clientX}px`;

            // Filter out null/separator items for action binding, but render separators
            const actionItems = items.filter(item => item && item.label !== 'separator');

            menu.innerHTML = items.map(item => {
                if (!item || item.label === 'separator') {
                    return '<div class="context-menu-separator"></div>';
                }
                const iconHtml = item.icon ? `<i class="ph ${item.icon}" style="font-size: 16px; color: #64748b; width: 20px; text-align: center; margin-right: 6px;"></i>` : '';
                return `<div class="context-menu-item ${item.danger ? 'danger' : ''}">${iconHtml}${item.label}</div>`;
            }).join('');

            // Bind click handlers only to actual menu items
            let actionIndex = 0;
            menu.querySelectorAll('.context-menu-item').forEach((el) => {
                const item = actionItems[actionIndex++];
                if (item && item.action) {
                    el.onclick = () => { item.action(); menu.remove(); };
                }
            });

            document.body.appendChild(menu);
            setTimeout(() => {
                document.addEventListener('click', function close() { menu.remove(); document.removeEventListener('click', close); });
            }, 0);
        }

        function showRecordContextMenu(e, recordId) {
            const set = getCurrentSet();
            if (!set) return;

            const record = set.records.get(recordId);
            if (!record) return;

            // Check if this record has tossed entries that can be picked up
            let hasTossedEntries = false;
            let tossActionId = null;
            if (typeof TossPile !== 'undefined') {
                const pile = TossPile.init(state);
                const tossedForRecord = Array.from(pile.entries.values())
                    .filter(e => e.recordId === recordId && e.status === 'tossed');
                hasTossedEntries = tossedForRecord.length > 0;
                if (hasTossedEntries && tossedForRecord[0]) {
                    tossActionId = tossedForRecord[0].actionId;
                }
            }

            const items = [
                { label: 'Open Record', icon: 'ph-arrow-square-out', action: () => openExpandedRecord(recordId) },
                { label: 'separator' },
                { label: 'Select Record', icon: 'ph-check-square', action: () => {
                    if (!state.selectedRecordIds) state.selectedRecordIds = new Set();
                    state.selectedRecordIds.add(recordId);
                    updateSelectionUI([...set.records.values()]);
                }},
                { label: 'Copy Record ID', icon: 'ph-clipboard-text', action: () => {
                    navigator.clipboard.writeText(recordId).then(() => {
                        showToast(' Record ID copied');
                    });
                }}
            ];

            // Add pick up option if record has tossed entries
            if (hasTossedEntries && tossActionId) {
                items.push({ label: 'separator' });
                items.push({ label: 'Pick Up Tossed Fields', icon: 'ph-arrow-u-up-left', action: () => {
                    if (typeof TossPileUI !== 'undefined') {
                        TossPileUI.pickUpRecord(tossActionId, recordId);
                    }
                }});
            }

            items.push({ label: 'separator' });
            items.push({ label: 'Toss Record', icon: 'ph-hand-fist', action: () => tossRecord(recordId), danger: true });

            showContextMenu(e, items);
        }

        function tossRecord(recordId) {
            const set = getCurrentSet();
            if (!set || !set.records.has(recordId)) return;

            showConfirm('Are you sure you want to toss this record? It can be restored from the toss pile.', () => {
                if (typeof TossPile !== 'undefined') {
                    const action = TossPile.tossRecord(state, recordId);
                    if (action) {
                        // Remove from selection if selected
                        if (state.selectedRecordIds?.has(recordId)) {
                            state.selectedRecordIds.delete(recordId);
                        }
                        renderCurrentView();
                        showToast(' Record tossed (can be restored)');
                        return;
                    }
                }

                // Fallback: hard delete
                set.records.delete(recordId);
                deleteEntity(recordId);
                if (state.selectedRecordIds?.has(recordId)) {
                    state.selectedRecordIds.delete(recordId);
                }
                renderCurrentView();
                showToast(' Record deleted');
            });
        }

        function showSetContextMenu(e, setId) {
            const set = state.sets.get(setId);
            if (!set) return;

            const tossPileStats = typeof TossPile !== 'undefined' ?
                TossPile.getTossPileStats(state, setId) : null;

            const items = [
                { label: 'Manage Set...', action: () => {
                    if (typeof SetManagement !== 'undefined') {
                        SetManagement.openSetManagementModal(setId);
                    } else {
                        openAddSetModal(setId);
                    }
                }},
                { label: 'Rename', action: () => openAddSetModal(setId) },
                { label: 'Duplicate Set', action: () => duplicateSet(setId) }
            ];

            if (tossPileStats && tossPileStats.totalEntries > 0) {
                items.push({ label: `View Toss Pile (${tossPileStats.totalEntries})`, action: () => {
                    state.currentSetId = setId;
                    TossPileUI.openPanel();
                }});
            }

            items.push({ label: 'separator' });
            items.push({ label: 'Toss Set...', action: () => {
                if (typeof SetManagement !== 'undefined') {
                    SetManagement.tossSet(setId);
                }
            }, danger: true });

            showContextMenu(e, items);
        }

        function duplicateSet(setId) {
            const set = state.sets.get(setId);
            if (!set) return;

            const newSetId = `set_${Date.now()}`;
            const newSet = {
                id: newSetId,
                name: `${set.name} (Copy)`,
                icon: set.icon,
                worldId: set.worldId,
                schema: JSON.parse(JSON.stringify(set.schema)),
                records: new Map(),
                views: new Map()
            };

            // Copy records
            set.records.forEach((record, recordId) => {
                const newRecordId = `rec_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                newSet.records.set(newRecordId, { ...record, id: newRecordId });
            });

            // Create default view
            const viewId = `view_${Date.now()}`;
            newSet.views.set(viewId, {
                id: viewId,
                name: 'Grid View',
                type: 'grid',
                columns: set.schema.map(f => ({ fieldId: f.id, visible: true })),
                filters: [],
                sorts: [],
                showRowNumbers: true
            });

            state.sets.set(newSetId, newSet);
            registerEntity({ id: newSetId, type: 'Set', name: newSet.name, worldId: newSet.worldId });

            createEvent('Duplicate Set', 'INS',
                { type: 'Set', id: newSetId },
                { sourceSetId: setId, summary: `Duplicated set "${set.name}"` }
            );

            renderSidebar();
            showToast(` Set duplicated`);
        }

        function confirmDelete(type, id) {
            const messages = {
                field: 'Delete this field? This will remove data from all records.',
                record: 'Toss this record? This can be reversed within your retention window.'
            };
            showConfirm(messages[type], () => {
                if (type === 'field') deleteField(id);
                if (type === 'record') tossRecord(id);
            });
        }

        function showConfirm(message, callback) {
            document.getElementById('confirmMessage').textContent = message;
            state.confirmCallback = callback;
            openModal('confirmModal');
        }

        function createViewFromColumn(field) {
            const set = getCurrentSet();
            if (!set) return;

            const keyRef = { setId: set.id, fieldId: field.id };
            const detection = autoDetectSchemaFromKey(keyRef);
            const viewName = `${field.name} Pivot`;
            const viewId = createView(set.id, viewName, {
                type: 'KEY_DERIVED',
                icon: 'ph-chart-pie',
                key: keyRef,
                schema: detection.schema,
                relationships: detection.relationships,
                rollups: detection.rollups,
                viewMode: 'sandbox',  // Pivot views start in sandbox mode for exploration
                pivotMetadata: {
                    pivotFieldId: field.id,
                    analysisTimestamp: Date.now(),
                    sourceSetId: set.id
                }
            });
            renderSidebar();
            switchSet(set.id, viewId);
            showToast(' Sandbox view created from column');
        }

        /**
         * Enhanced pivot view creation from a cell value
         * - Makes pivoted field first column
         * - Auto-hides redundant columns (same value across all matching records)
         * - Auto-applies smart merge rules based on field types
         * - Auto-sorts by date fields (newest first)
         * - Groups by categorical fields when useful
         */
        function createViewFromValue(recordId, field) {
            const set = getCurrentSet();
            const record = set?.records.get(recordId);
            if (!set || !record) return;

            const value = record[field.id];
            const filters = [[{ field: field.id, operator: 'equals', value }]];

            // Find all matching records to analyze for intelligent defaults
            const matchingRecords = Array.from(set.records.values()).filter(r => {
                const recordValue = r[field.id];
                if (value === null || value === undefined) {
                    return recordValue === null || recordValue === undefined;
                }
                if (typeof value === 'object') {
                    return JSON.stringify(recordValue) === JSON.stringify(value);
                }
                return recordValue === value;
            });

            const pivotAnalysis = analyzePivotData(set, matchingRecords, field.id);

            // Build column order: pivoted field first, then identifier, then rest
            const currentView = getCurrentView();
            const identifierFieldId = currentView?.identifierField || inferIdentifierFieldId(set);
            const baseOrder = (currentView?.columnOrder || set.schema.map(f => f.id))
                .filter(id => id !== field.id && id !== identifierFieldId);

            const columnOrder = [
                field.id,  // Pivoted field always first
                ...(identifierFieldId && identifierFieldId !== field.id ? [identifierFieldId] : []),
                ...baseOrder
            ];

            // Generate view name with count
            const displayValue = typeof value === 'object' ? JSON.stringify(value) : (value ?? 'Empty');
            const viewName = `${field.name}: ${String(displayValue).slice(0, 32)} (${matchingRecords.length})`;

            const viewId = createView(set.id, viewName, {
                type: 'grid',
                icon: 'ph-funnel-simple',
                filters,
                columnOrder,
                hiddenFields: pivotAnalysis.redundantFields,  // Hide fields with uniform values
                sorts: pivotAnalysis.suggestedSorts,
                groups: pivotAnalysis.suggestedGroups,
                columnRules: pivotAnalysis.suggestedColumnRules,
                viewMode: 'sandbox',  // Pivot views start in sandbox mode for exploration
                pivotMetadata: {
                    pivotFieldId: field.id,
                    pivotValue: value,
                    matchCount: matchingRecords.length,
                    redundantFields: pivotAnalysis.redundantFields,
                    analysisTimestamp: Date.now(),
                    sourceSetId: set.id
                }
            });

            renderSidebar();
            switchSet(set.id, viewId);

            const hiddenCount = pivotAnalysis.redundantFields.length;
            const toastMsg = hiddenCount > 0
                ? ` Sandbox view created (${hiddenCount} uniform column${hiddenCount > 1 ? 's' : ''} hidden)`
                : ' Sandbox view created';
            showToast(toastMsg);
        }

        /**
         * Analyze matching records to determine:
         * - Which fields have uniform values (redundant for this pivot)
         * - Best sort order (date fields)
         * - Potential grouping fields
         * - Smart column merge rules
         */
        function analyzePivotData(set, matchingRecords, pivotFieldId) {
            const schema = set.schema || [];
            const redundantFields = [];
            const suggestedSorts = [];
            const suggestedGroups = [];
            const suggestedColumnRules = {};

            if (matchingRecords.length === 0) {
                return { redundantFields, suggestedSorts, suggestedGroups, suggestedColumnRules };
            }

            // Always hide the pivot field itself since all values are identical
            redundantFields.push(pivotFieldId);

            // Analyze each field
            let bestDateField = null;
            let bestGroupField = null;
            let groupFieldCardinality = 0;

            for (const field of schema) {
                if (field.id === pivotFieldId) continue;

                // Collect all values for this field
                const values = matchingRecords.map(r => r[field.id]);
                const nonNullValues = values.filter(v => v !== null && v !== undefined && v !== '');
                const uniqueValues = new Set(nonNullValues.map(v =>
                    typeof v === 'object' ? JSON.stringify(v) : String(v)
                ));

                // Check if field is uniform (all same value) - candidate for hiding
                if (uniqueValues.size <= 1 && nonNullValues.length > 0) {
                    // Only hide if we have more than 1 record (otherwise nothing is "uniform")
                    if (matchingRecords.length > 1) {
                        redundantFields.push(field.id);
                    }
                }

                // Identify best date field for sorting
                if (field.type === 'DATE' || field.type === 'DATETIME' ||
                    field.name.toLowerCase().includes('date') ||
                    field.name.toLowerCase().includes('created') ||
                    field.name.toLowerCase().includes('updated')) {
                    if (!bestDateField) {
                        bestDateField = field;
                    }
                }

                // Identify good grouping candidates (categorical with reasonable cardinality)
                const isCategorial = field.type === 'SELECT' || field.type === 'TEXT' ||
                    field.type === 'SINGLE_SELECT' || field.type === 'STATUS';
                const cardinality = uniqueValues.size;

                // Good grouping: 2-10 unique values, and less than half of total records
                if (isCategorial && cardinality >= 2 && cardinality <= 10 &&
                    cardinality < matchingRecords.length * 0.5) {
                    if (cardinality > groupFieldCardinality) {
                        bestGroupField = field;
                        groupFieldCardinality = cardinality;
                    }
                }

                // Suggest column rules based on field type
                if (field.type === 'NUMBER' || field.type === 'CURRENCY') {
                    // Numeric fields: could aggregate
                    if (uniqueValues.size > 1) {
                        suggestedColumnRules[field.id] = { rule: 'sup_all' };
                    }
                } else if (field.type === 'DATE' || field.type === 'DATETIME') {
                    // Date fields: prefer newest
                    suggestedColumnRules[field.id] = { rule: 'prefer_newest' };
                } else if (field.type === 'LONG_TEXT' || field.type === 'RICH_TEXT') {
                    // Long text: show all
                    suggestedColumnRules[field.id] = { rule: 'sup_all' };
                }
            }

            // Add date sort if found
            if (bestDateField) {
                suggestedSorts.push({ fieldId: bestDateField.id, direction: 'desc' });
            }

            // Add grouping if found a good candidate (but only if we have enough records)
            if (bestGroupField && matchingRecords.length >= 4) {
                suggestedGroups.push({ fieldId: bestGroupField.id });
            }

            return { redundantFields, suggestedSorts, suggestedGroups, suggestedColumnRules };
        }

        // SEARCH DATA FUNCTIONALITY
        function getRecordDisplayLabel(record, set) {
            if (!record || !set) return '';

            const identifierFieldId = getIdentifierFieldForSet(set);
            const identifierValue = identifierFieldId ? record[identifierFieldId] : null;

            return identifierValue || record.name || '';
        }

        // Global search state
        let currentFocusedItem = null;

        function openSearchDataModal() {
            openModal('searchDataModal');
            document.getElementById('searchDataInput').value = '';

            // Clear focus
            clearFocus();

            // Show zero-input search surface
            renderZeroInputSearch();

            // Set up event listeners
            const searchInput = document.getElementById('searchDataInput');
            const scopeRadios = document.querySelectorAll('input[name="searchScope"]');

            searchInput.oninput = () => performSearch();
            scopeRadios.forEach(radio => {
                radio.onchange = () => {
                    updateSearchScope();
                    performSearch();
                };
            });

            // Focus search input
            setTimeout(() => searchInput.focus(), 100);
        }

        function updateSearchScope() {
            const scope = document.querySelector('input[name="searchScope"]:checked').value;
            const scopeNames = {
                'everything': 'Everything',
                'fields': 'Fields',
                'records': 'Records',
                'values': 'Values'
            };
            document.getElementById('searchScopePill').textContent = `Scope: ${scopeNames[scope]}`;
        }

        // ZERO-INPUT SEARCH DATA HELPERS
        function getRecentItems(limit = 10) {
            const recent = [];
            const seen = new Set();

            // Get recent events from eventStream
            for (const event of state.eventStream) {
                if (recent.length >= limit) break;

                // Extract meaningful items from events
                if (event.object?.type === 'Set' && event.object?.id) {
                    const set = state.sets.get(event.object.id);
                    if (set && !seen.has(event.object.id)) {
                        recent.push({
                            label: set.name,
                            type: 'set',
                            setId: set.id,
                            action: () => {
                                navigateToSet(set.id);
                                closeModal('searchDataModal');
                            }
                        });
                        seen.add(event.object.id);
                    }
                } else if (event.object?.type === 'Field' && event.data?.setId && event.data?.fieldId) {
                    const set = state.sets.get(event.data.setId);
                    const field = set?.schema.find(f => f.id === event.data.fieldId);
                    if (field && !seen.has(`${event.data.setId}-${event.data.fieldId}`)) {
                        recent.push({
                            label: `${field.name} (${set.name})`,
                            type: 'field',
                            setId: event.data.setId,
                            fieldId: event.data.fieldId,
                            action: () => {
                                navigateToSet(set.id);
                                closeModal('searchDataModal');
                            }
                        });
                        seen.add(`${event.data.setId}-${event.data.fieldId}`);
                    }
                } else if (event.object?.type === 'Record' && event.data?.setId) {
                    const set = state.sets.get(event.data.setId);
                    const recordId = event.object.id.split('/')[1] || event.object.id;
                    const record = set?.records.get(recordId);
                    if (record && !seen.has(event.object.id)) {
                        const label = getRecordDisplayLabel(record, set);
                        recent.push({
                            label: `${label} (${set.name})`,
                            type: 'record',
                            setId: set.id,
                            recordId: recordId,
                            action: () => {
                                navigateToSet(set.id);
                                closeModal('searchDataModal');
                            }
                        });
                        seen.add(event.object.id);
                    }
                } else if (event.object?.type === 'View' && event.data?.setId && event.data?.viewId) {
                    const set = state.sets.get(event.data.setId);
                    const view = set?.views.get(event.data.viewId);
                    if (view && !seen.has(event.object.id)) {
                        const viewIcon = view.icon || '';
                        recent.push({
                            label: `${viewIcon} ${view.name} (${set.name})`,
                            type: 'view',
                            setId: set.id,
                            viewId: event.data.viewId,
                            action: () => {
                                switchSet(set.id, event.data.viewId);
                                closeModal('searchDataModal');
                            }
                        });
                        seen.add(event.object.id);
                    }
                }
            }

            return recent;
        }

        function getFrequentFields(limit = 8) {
            // Track field access frequency from eventStream
            const fieldFrequency = new Map();

            state.eventStream.forEach(event => {
                if (event.data?.fieldId && event.data?.setId) {
                    const key = `${event.data.setId}/${event.data.fieldId}`;
                    fieldFrequency.set(key, (fieldFrequency.get(key) || 0) + 1);
                }
            });

            // Sort by frequency and take top N
            const sorted = Array.from(fieldFrequency.entries())
                .sort((a, b) => b[1] - a[1])
                .slice(0, limit);

            return sorted.map(([key]) => {
                const [setId, fieldId] = key.split('/');
                const set = state.sets.get(setId);
                const field = set?.schema.find(f => f.id === fieldId);
                return field ? {
                    label: `${field.name} (${set.name})`,
                    type: 'field',
                    setId,
                    fieldId,
                    action: () => {
                        navigateToSet(setId);
                        closeModal('searchDataModal');
                    }
                } : null;
            }).filter(Boolean);
        }

        function getRecentChanges(limit = 5) {
            const changes = [];
            const today = new Date();
            today.setHours(0, 0, 0, 0);

            // Count events by type for today
            const todayEvents = state.eventStream.filter(event => {
                const eventDate = new Date(event.published || event.t);
                eventDate.setHours(0, 0, 0, 0);
                return eventDate.getTime() === today.getTime();
            });

            const recordCreateEvents = todayEvents.filter(e => e.verb === 'Create Record' || e.op === 'INS' && e.object?.type === 'Record');
            const fieldUpdateEvents = todayEvents.filter(e => e.verb === 'Update Field' || e.op === 'UPD' && e.object?.type === 'Field');
            const setCreateEvents = todayEvents.filter(e => e.verb === 'Create Set' || e.op === 'INS' && e.object?.type === 'Set');

            if (recordCreateEvents.length > 0) {
                changes.push({
                    label: `${recordCreateEvents.length} new record${recordCreateEvents.length > 1 ? 's' : ''} today`,
                    type: null,
                    action: () => {
                        // Show records created today
                        const results = { fields: [], records: [], values: [] };
                        const worldSets = getSetsForWorld();

                        recordCreateEvents.forEach(event => {
                            const setId = event.object?.setId || event.actor?.setId;
                            const recordId = event.object?.id;
                            if (setId && recordId) {
                                const set = worldSets.find(s => s.id === setId);
                                if (set && set.records && set.records.has(recordId)) {
                                    const record = set.records.get(recordId);
                                    const recordLabel = getRecordDisplayLabel(record, set);
                                    results.records.push({
                                        record,
                                        recordId,
                                        setId: set.id,
                                        setName: set.name,
                                        label: recordLabel
                                    });
                                }
                            }
                        });

                        renderSearchResults(results, 'new records today', 'records');
                    }
                });
            }

            if (fieldUpdateEvents.length > 0) {
                changes.push({
                    label: `${fieldUpdateEvents.length} field update${fieldUpdateEvents.length > 1 ? 's' : ''} today`,
                    type: null,
                    action: () => {
                        // Show fields updated today
                        const results = { fields: [], records: [], values: [] };
                        const worldSets = getSetsForWorld();
                        const processedFields = new Set();

                        fieldUpdateEvents.forEach(event => {
                            const setId = event.object?.setId || event.actor?.setId;
                            const fieldId = event.object?.id || event.object?.fieldId;
                            const fieldKey = `${setId}:${fieldId}`;

                            if (setId && fieldId && !processedFields.has(fieldKey)) {
                                processedFields.add(fieldKey);
                                const set = worldSets.find(s => s.id === setId);
                                if (set && set.schema) {
                                    const field = set.schema.find(f => f.id === fieldId);
                                    if (field) {
                                        results.fields.push({
                                            field,
                                            setId: set.id,
                                            setName: set.name
                                        });
                                    }
                                }
                            }
                        });

                        renderSearchResults(results, 'field updates today', 'fields');
                    }
                });
            }

            if (setCreateEvents.length > 0) {
                changes.push({
                    label: `${setCreateEvents.length} new set${setCreateEvents.length > 1 ? 's' : ''} today`,
                    type: null,
                    action: () => {
                        // Navigate to Sets view (main sidebar)
                        renderSidebar();
                        closeModal('searchDataModal');
                    }
                });
            }

            // If no changes today, show recent from this week
            if (changes.length === 0) {
                const weekAgo = new Date(today);
                weekAgo.setDate(weekAgo.getDate() - 7);
                const recentEvents = state.eventStream.filter(e => {
                    const eventDate = new Date(e.published || e.t);
                    return eventDate >= weekAgo;
                });

                if (recentEvents.length > 0) {
                    changes.push({
                        label: `${recentEvents.length} change${recentEvents.length > 1 ? 's' : ''} this week`,
                        type: null,
                        action: () => {
                            // Could show activity log or recent changes view
                            alert('Activity log view coming soon');
                        }
                    });
                }
            }

            return changes.slice(0, limit);
        }

        function getStructuralHighlights() {
            const highlights = [];
            const worldSets = getSetsForWorld();

            // Fields with definitions
            const fieldsWithDefinitions = [];
            worldSets.forEach(set => {
                set.schema?.forEach(field => {
                    if (field.definitionId) {
                        fieldsWithDefinitions.push({
                            field,
                            setId: set.id,
                            setName: set.name
                        });
                    }
                });
            });
            if (fieldsWithDefinitions.length > 0) {
                highlights.push({
                    label: `${fieldsWithDefinitions.length} field${fieldsWithDefinitions.length > 1 ? 's' : ''} with definitions`,
                    type: null,
                    action: () => {
                        const results = { fields: fieldsWithDefinitions, records: [], values: [] };
                        renderSearchResults(results, 'fields with definitions', 'fields');
                    }
                });
            }

            // Fields with connections
            const connections = getConnectionView();
            if (connections.length > 0) {
                highlights.push({
                    label: `${connections.length} connection${connections.length > 1 ? 's' : ''} defined`,
                    type: null,
                    action: () => {
                        openConnectionsPage();
                        closeModal('searchDataModal');
                    }
                });
            }

            // Large sets
            const largeSets = worldSets.filter(set => set.records?.size > 50);
            if (largeSets.length > 0) {
                highlights.push({
                    label: `${largeSets.length} set${largeSets.length > 1 ? 's' : ''} with 50+ records`,
                    type: null,
                    action: () => {
                        // Show large sets in the main view
                        renderSidebar();
                        closeModal('searchDataModal');
                    }
                });
            }

            // Shared fields (fields with same name across sets)
            const fieldNames = new Map();
            worldSets.forEach(set => {
                set.schema?.forEach(field => {
                    if (!fieldNames.has(field.name)) {
                        fieldNames.set(field.name, []);
                    }
                    fieldNames.get(field.name).push({ setId: set.id, setName: set.name, field });
                });
            });

            const sharedFieldsArray = Array.from(fieldNames.entries())
                .filter(([name, occurrences]) => occurrences.length > 1);

            if (sharedFieldsArray.length > 0) {
                highlights.push({
                    label: `${sharedFieldsArray.length} shared field${sharedFieldsArray.length > 1 ? 's' : ''} across sets`,
                    type: null,
                    action: () => {
                        // Show shared fields
                        const results = { fields: [], records: [], values: [] };
                        sharedFieldsArray.forEach(([name, occurrences]) => {
                            // Just show the first occurrence of each shared field
                            const first = occurrences[0];
                            results.fields.push({
                                field: first.field,
                                setId: first.setId,
                                setName: first.setName
                            });
                        });
                        renderSearchResults(results, 'shared fields across sets', 'fields');
                    }
                });
            }

            return highlights.slice(0, 4);
        }

        function getExploreSlices() {
            return [
                { label: 'All Definitions ', type: null, action: () => { openDefinitionsPage(); closeModal('searchDataModal'); } },
                { label: 'All Relations ', type: null, action: () => { openRelationsPage(); closeModal('searchDataModal'); } }
            ];
        }

        function renderZeroInputSearch() {
            const container = document.getElementById('searchDataResults');

            let html = '<div class="zero-input-section">';

            // Recent Items
            const recentItems = getRecentItems(8);
            if (recentItems.length > 0) {
                html += '<h3 class="zero-input-section-title">Recent</h3>';
                recentItems.forEach((item, idx) => {
                    html += `
                        <div class="zero-input-item" onclick="zeroInputActions[${idx}]()">
                            <span class="zero-input-item-label">${item.label}</span>
                            ${item.type ? `<span class="zero-input-type-label">${item.type}</span>` : ''}
                        </div>
                    `;
                });
                // Store actions
                window.zeroInputActions = recentItems.map(item => item.action || (() => {}));
            }

            // Frequently Used Fields
            const frequentFields = getFrequentFields(6);
            if (frequentFields.length > 0) {
                html += '<h3 class="zero-input-section-title">Frequently Used Fields</h3>';
                const startIdx = window.zeroInputActions?.length || 0;
                frequentFields.forEach((item, idx) => {
                    html += `
                        <div class="zero-input-item" onclick="zeroInputActions[${startIdx + idx}]()">
                            <span class="zero-input-item-label">${item.label}</span>
                            ${item.type ? `<span class="zero-input-type-label">${item.type}</span>` : ''}
                        </div>
                    `;
                });
                window.zeroInputActions = [...(window.zeroInputActions || []), ...frequentFields.map(item => item.action || (() => {}))];
            }

            // Recent Changes
            const recentChanges = getRecentChanges(4);
            if (recentChanges.length > 0) {
                html += '<h3 class="zero-input-section-title">New & Updated</h3>';
                const startIdx = window.zeroInputActions?.length || 0;
                recentChanges.forEach((item, idx) => {
                    html += `
                        <div class="zero-input-item" onclick="zeroInputActions[${startIdx + idx}]()">
                            <span class="zero-input-item-label">${item.label}</span>
                        </div>
                    `;
                });
                window.zeroInputActions = [...(window.zeroInputActions || []), ...recentChanges.map(item => item.action || (() => {}))];
            }

            // Structural Highlights
            const structuralHighlights = getStructuralHighlights();
            if (structuralHighlights.length > 0) {
                html += '<h3 class="zero-input-section-title">Structural Highlights</h3>';
                const startIdx = window.zeroInputActions?.length || 0;
                structuralHighlights.forEach((item, idx) => {
                    html += `
                        <div class="zero-input-item" onclick="zeroInputActions[${startIdx + idx}]()">
                            <span class="zero-input-item-label">${item.label}</span>
                        </div>
                    `;
                });
                window.zeroInputActions = [...(window.zeroInputActions || []), ...structuralHighlights.map(item => item.action || (() => {}))];
            }

            // Explore
            const exploreSlices = getExploreSlices();
            if (exploreSlices.length > 0) {
                html += '<h3 class="zero-input-section-title">Explore</h3>';
                const startIdx = window.zeroInputActions?.length || 0;
                exploreSlices.forEach((item, idx) => {
                    html += `
                        <div class="zero-input-item" onclick="zeroInputActions[${startIdx + idx}]()">
                            <span class="zero-input-item-label">${item.label}</span>
                        </div>
                    `;
                });
                window.zeroInputActions = [...(window.zeroInputActions || []), ...exploreSlices.map(item => item.action || (() => {}))];
            }

            // Browse
            html += '<h3 class="zero-input-section-title">Browse</h3>';
            html += '<div class="browse-grid">';

            const worldSets = getSetsForWorld();
            const totalFields = worldSets.reduce((sum, set) => sum + (set.schema?.length || 0), 0);
            const totalRecords = worldSets.reduce((sum, set) => sum + (set.records?.size || 0), 0);
            const definitions = getDefinitionView();
            const connections = getConnectionView();

            html += `
                <div class="browse-item" onclick="renderSidebar(); closeModal('searchDataModal');">
                    Sets (${worldSets.length})
                </div>
                <div class="browse-item" onclick="alert('Fields browse coming soon');">
                    Fields (${totalFields})
                </div>
                <div class="browse-item" onclick="alert('Records browse coming soon');">
                    Records (${totalRecords})
                </div>
                <div class="browse-item" onclick="openDefinitionsPage(); closeModal('searchDataModal');">
                    Definitions (${definitions.length})
                </div>
                <div class="browse-item" onclick="openRelationsPage(); closeModal('searchDataModal');">
                    Relations (${connections.length})
                </div>
                <div class="browse-item" onclick="alert('Values browse coming soon');">
                    Values
                </div>
            `;

            html += '</div></div>';

            container.innerHTML = html;
        }

        function clearFocus() {
            currentFocusedItem = null;
            document.getElementById('focusPanel').classList.add('hidden');
            // Remove focused class from all items
            document.querySelectorAll('.result-item.focused').forEach(el => {
                el.classList.remove('focused');
            });
        }

        function performSearch() {
            const query = document.getElementById('searchDataInput').value;
            const scope = document.querySelector('input[name="searchScope"]:checked').value;

            if (!query || query.trim().length === 0) {
                renderZeroInputSearch();
                return;
            }

            const results = searchData(query, scope);
            renderSearchResults(results, query, scope);
        }

        function searchData(query, scope = 'everything') {
            const q = query.trim().toLowerCase();
            if (!q) return { fields: [], records: [], values: [], views: [] };

            const results = {
                fields: [],
                records: [],
                values: [],
                views: []
            };

            // Get all sets in current world
            const worldSets = getSetsForWorld();

            worldSets.forEach(set => {
                if (!set || !set.schema) return;

                // Search views - simple substring match
                if (scope === 'everything') {
                    if (set.views && set.views.size > 0) {
                        set.views.forEach((viewRef, viewId) => {
                            // Get full view data from state.views (viewRef may be lightweight)
                            const view = state.views?.get(viewId) || viewRef;
                            if (view && view.name && view.name.toLowerCase().includes(q)) {
                                results.views.push({
                                    view,
                                    viewId,
                                    setId: set.id,
                                    setName: set.name
                                });
                            }
                        });
                    }
                }

                // Search fields - simple substring match
                if (scope === 'everything' || scope === 'fields') {
                    set.schema.forEach(field => {
                        if (field && field.name && field.name.toLowerCase().includes(q)) {
                            results.fields.push({
                                field,
                                setId: set.id,
                                setName: set.name
                            });
                        }
                    });
                }

                // Search records and values
                if (scope === 'everything' || scope === 'records' || scope === 'values') {
                    if (!set.records) return;

                    set.records.forEach((record, recordId) => {
                        if (!record) return;

                        // Get record label for searching
                        const recordLabel = getRecordDisplayLabel(record, set);

                        // Search record labels - simple substring match
                        if ((scope === 'everything' || scope === 'records') && recordLabel && recordLabel.toLowerCase().includes(q)) {
                            results.records.push({
                                record,
                                recordId,
                                setId: set.id,
                                setName: set.name,
                                label: recordLabel
                            });
                        }

                        // Search cell values - simple substring match
                        if (scope === 'everything' || scope === 'values') {
                            set.schema.forEach(field => {
                                if (!field) return;

                                const value = record[field.id];
                                if (value != null && value !== '') {
                                    const valueStr = String(value).toLowerCase();
                                    if (valueStr.includes(q)) {
                                        results.values.push({
                                            recordId,
                                            fieldId: field.id,
                                            fieldName: field.name,
                                            value,
                                            setId: set.id,
                                            setName: set.name,
                                            recordLabel
                                        });
                                    }
                                }
                            });
                        }
                    });
                }
            });

            return results;
        }

        function renderSearchResults(results, query, scope) {
            const container = document.getElementById('searchDataResults');
            const totalResults = results.fields.length + results.records.length + results.values.length + (results.views?.length || 0);

            if (totalResults === 0) {
                container.innerHTML = `<p class="text-sm text-gray-400 px-5 pt-2">No results found for "${query}"</p>`;
                return;
            }

            let html = '';

            // Render Views
            if (results.views && results.views.length > 0) {
                html += `<div class="results-section">
                    <div class="results-section-title">Views</div>`;
                results.views.forEach((item, index) => {
                    if (index < 20) { // Limit display
                        const itemId = `view-${item.setId}-${item.viewId}`;
                        const viewIcon = item.view.icon || '';
                        html += `
                            <div class="result-item" id="${itemId}">
                                <div class="result-main">
                                    <div class="result-label">${viewIcon} ${escapeHtml(item.view.name)}</div>
                                    <div class="result-meta">View  ${escapeHtml(item.setName)}</div>
                                </div>
                                <button class="focus-btn" onclick='focusOnView(${JSON.stringify(item)}, "${itemId}")'>Focus</button>
                            </div>
                        `;
                    }
                });
                if (results.views.length > 20) {
                    html += `<p class="text-xs text-gray-500 px-3">...and ${results.views.length - 20} more</p>`;
                }
                html += `</div>`;
            }

            // Render Fields
            if (results.fields.length > 0) {
                html += `<div class="results-section">
                    <div class="results-section-title">Fields</div>`;
                results.fields.forEach((item, index) => {
                    if (index < 20) { // Limit display
                        const itemId = `field-${item.setId}-${item.field.id}`;
                        const usageCount = getFieldUsageCount(item.setId, item.field.id);
                        html += `
                            <div class="result-item" id="${itemId}">
                                <div class="result-main">
                                    <div class="result-label">${escapeHtml(item.field.name)}</div>
                                    <div class="result-meta">Field  ${item.field.type}  ${usageCount} record${usageCount !== 1 ? 's' : ''}</div>
                                </div>
                                <button class="focus-btn" onclick='focusOnField(${JSON.stringify(item)}, "${itemId}")'>Focus</button>
                            </div>
                        `;
                    }
                });
                if (results.fields.length > 20) {
                    html += `<p class="text-xs text-gray-500 px-3">...and ${results.fields.length - 20} more</p>`;
                }
                html += `</div>`;
            }

            // Render Records
            if (results.records.length > 0) {
                html += `<div class="results-section">
                    <div class="results-section-title">Records</div>`;
                results.records.forEach((item, index) => {
                    if (index < 20) {
                        const itemId = `record-${item.setId}-${item.recordId}`;
                        html += `
                            <div class="result-item" id="${itemId}">
                                <div class="result-main">
                                    <div class="result-label">${escapeHtml(item.label)}</div>
                                    <div class="result-meta">Record  ${escapeHtml(item.setName)}</div>
                                </div>
                                <button class="focus-btn" onclick='focusOnRecord(${JSON.stringify(item)}, "${itemId}")'>Focus</button>
                            </div>
                        `;
                    }
                });
                if (results.records.length > 20) {
                    html += `<p class="text-xs text-gray-500 px-3">...and ${results.records.length - 20} more</p>`;
                }
                html += `</div>`;
            }

            // Render Values
            if (results.values.length > 0) {
                // Group values by field
                const valuesByField = {};
                results.values.forEach(item => {
                    const key = `${item.setId}:${item.fieldId}`;
                    if (!valuesByField[key]) {
                        valuesByField[key] = {
                            fieldName: item.fieldName,
                            setName: item.setName,
                            setId: item.setId,
                            fieldId: item.fieldId,
                            values: []
                        };
                    }
                    valuesByField[key].values.push(item);
                });

                html += `<div class="results-section">
                    <div class="results-section-title">Values</div>`;

                Object.values(valuesByField).forEach((group, index) => {
                    if (index < 20) {
                        const itemId = `value-${group.setId}-${group.fieldId}`;
                        const displayValue = String(group.values[0].value).slice(0, 50);
                        html += `
                            <div class="result-item" id="${itemId}">
                                <div class="result-main">
                                    <div class="result-label">"${escapeHtml(displayValue)}"</div>
                                    <div class="result-meta">Value  appears in ${group.values.length} record${group.values.length !== 1 ? 's' : ''}</div>
                                </div>
                                <button class="focus-btn" onclick='focusOnValue(${JSON.stringify(group)}, "${itemId}")'>Focus</button>
                            </div>
                        `;
                    }
                });
                if (Object.keys(valuesByField).length > 20) {
                    html += `<p class="text-xs text-gray-500 px-3">...and ${Object.keys(valuesByField).length - 20} more</p>`;
                }
                html += `</div>`;
            }

            container.innerHTML = html;
        }

        function getFieldUsageCount(setId, fieldId) {
            const set = state.sets.get(setId);
            if (!set || !set.records) return 0;
            let count = 0;
            set.records.forEach(record => {
                if (record && record[fieldId] != null && record[fieldId] !== '') {
                    count++;
                }
            });
            return count;
        }

        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function focusOnField(item, itemId) {
            currentFocusedItem = { type: 'field', data: item, itemId };

            // Remove previous focused class
            document.querySelectorAll('.result-item.focused').forEach(el => el.classList.remove('focused'));
            // Add focused class to clicked item
            const itemEl = document.getElementById(itemId);
            if (itemEl) itemEl.classList.add('focused');

            // Show focus panel
            document.getElementById('focusPanel').classList.remove('hidden');

            // Update header
            document.getElementById('focusTitle').textContent = item.field.name;
            document.getElementById('focusSubtitle').textContent = `Field  ${item.field.type}  from ${item.setName}`;
            document.getElementById('focusTag').textContent = 'Field';

            // Build provenance section
            let bodyHtml = '';

            // Provenance section
            bodyHtml += `<div class="focus-section">
                <h4>Provenance</h4>
                <div class="focus-kv"><span class="focus-kv-label">Set:</span> <span class="focus-kv-value">${escapeHtml(item.setName)}</span></div>
                <div class="focus-kv"><span class="focus-kv-label">Type:</span> <span class="focus-kv-value">${item.field.type}</span></div>`;

            if (item.field.description) {
                bodyHtml += `<div class="focus-kv"><span class="focus-kv-label">Description:</span> <span class="focus-kv-value">${escapeHtml(item.field.description)}</span></div>`;
            }

            const usageCount = getFieldUsageCount(item.setId, item.field.id);
            bodyHtml += `<div class="focus-kv"><span class="focus-kv-label">Usage:</span> <span class="focus-kv-value">${usageCount} record${usageCount !== 1 ? 's' : ''}</span></div>`;

            // Check for metadata from provenance
            const set = state.sets.get(item.setId);
            if (set && set.metadata) {
                if (set.metadata.sourceSystem) {
                    bodyHtml += `<div class="focus-kv"><span class="focus-kv-label">Source System:</span> <span class="focus-kv-value">${escapeHtml(set.metadata.sourceSystem)}</span></div>`;
                }
                if (set.metadata.frame) {
                    bodyHtml += `<div class="focus-kv"><span class="focus-kv-label">Frame:</span> <span class="focus-kv-value">${escapeHtml(set.metadata.frame)}</span></div>`;
                }
            }

            bodyHtml += `</div>`;

            // Context Frame section
            bodyHtml += `<div class="focus-section">
                <h4>Context</h4>`;

            if (item.field.options) {
                bodyHtml += `<div class="focus-kv"><span class="focus-kv-label">Options:</span> <span class="focus-kv-value">${item.field.options.length} defined option${item.field.options.length !== 1 ? 's' : ''}</span></div>`;
            }

            if (item.field.format) {
                bodyHtml += `<div class="focus-kv"><span class="focus-kv-label">Format:</span> <span class="focus-kv-value">${escapeHtml(item.field.format)}</span></div>`;
            }

            bodyHtml += `</div>`;

            document.getElementById('focusBody').innerHTML = bodyHtml;

            // Action buttons
            let actionsHtml = `
                <button class="focus-action-btn" onclick="createViewFromSearchField('${item.setId}', '${item.field.id}'); clearFocus();">Create View with this Field</button>
                <button class="focus-action-btn" onclick="navigateToSet('${item.setId}'); closeModal('searchDataModal');">Open Set</button>
            `;
            document.getElementById('focusActions').innerHTML = actionsHtml;
        }

        function focusOnRecord(item, itemId) {
            currentFocusedItem = { type: 'record', data: item, itemId };

            // Remove previous focused class
            document.querySelectorAll('.result-item.focused').forEach(el => el.classList.remove('focused'));
            // Add focused class to clicked item
            const itemEl = document.getElementById(itemId);
            if (itemEl) itemEl.classList.add('focused');

            // Show focus panel
            document.getElementById('focusPanel').classList.remove('hidden');

            // Update header
            document.getElementById('focusTitle').textContent = item.label;
            document.getElementById('focusSubtitle').textContent = `Record  from ${item.setName}`;
            document.getElementById('focusTag').textContent = 'Record';

            // Build provenance section
            let bodyHtml = '';

            // Provenance section
            bodyHtml += `<div class="focus-section">
                <h4>Provenance</h4>
                <div class="focus-kv"><span class="focus-kv-label">Set:</span> <span class="focus-kv-value">${escapeHtml(item.setName)}</span></div>
                <div class="focus-kv"><span class="focus-kv-label">Record ID:</span> <span class="focus-kv-value">${escapeHtml(item.recordId)}</span></div>`;

            // Get record details
            const set = state.sets.get(item.setId);
            const record = set ? set.records.get(item.recordId) : null;

            if (record) {
                // Show a few key fields
                let fieldCount = 0;
                if (set.schema) {
                    set.schema.forEach(field => {
                        if (fieldCount < 5 && record[field.id] != null && record[field.id] !== '') {
                            const value = String(record[field.id]).slice(0, 100);
                            bodyHtml += `<div class="focus-kv"><span class="focus-kv-label">${escapeHtml(field.name)}:</span> <span class="focus-kv-value">${escapeHtml(value)}</span></div>`;
                            fieldCount++;
                        }
                    });
                }
            }

            bodyHtml += `</div>`;

            // Context section
            bodyHtml += `<div class="focus-section">
                <h4>Context</h4>`;

            // Count connections
            const fullRecordId = `${item.setId}/${item.recordId}`;
            let connectionCount = 0;
            state.connections.forEach(conn => {
                if ((conn.subject.type === 'Record' && conn.subject.id === fullRecordId) ||
                    (conn.operand && conn.operand.type === 'Record' && conn.operand.id === fullRecordId)) {
                    connectionCount++;
                }
            });

            bodyHtml += `<div class="focus-kv"><span class="focus-kv-label">Relationships:</span> <span class="focus-kv-value">${connectionCount} relationship${connectionCount !== 1 ? 's' : ''}</span></div>`;
            bodyHtml += `</div>`;

            document.getElementById('focusBody').innerHTML = bodyHtml;

            // Action buttons
            let actionsHtml = `
                <button class="focus-action-btn" onclick="createViewFromSearchRecord('${item.setId}', '${item.recordId}'); clearFocus();">Create View from this Record</button>
                <button class="focus-action-btn" onclick="navigateToSet('${item.setId}'); closeModal('searchDataModal');">Open Set</button>
            `;
            if (connectionCount > 0) {
                actionsHtml += `<button class="focus-action-btn" onclick="showRecordConnections('${item.setId}', '${item.recordId}');">View Relationships</button>`;
            }
            document.getElementById('focusActions').innerHTML = actionsHtml;
        }

        function focusOnValue(group, itemId) {
            currentFocusedItem = { type: 'value', data: group, itemId };

            // Remove previous focused class
            document.querySelectorAll('.result-item.focused').forEach(el => el.classList.remove('focused'));
            // Add focused class to clicked item
            const itemEl = document.getElementById(itemId);
            if (itemEl) itemEl.classList.add('focused');

            // Show focus panel
            document.getElementById('focusPanel').classList.remove('hidden');

            const displayValue = String(group.values[0].value).slice(0, 50);

            // Update header
            document.getElementById('focusTitle').textContent = `"${displayValue}"`;
            document.getElementById('focusSubtitle').textContent = `Value  appears in ${group.values.length} record${group.values.length !== 1 ? 's' : ''}`;
            document.getElementById('focusTag').textContent = 'Value';

            // Build provenance section
            let bodyHtml = '';

            // Provenance section
            bodyHtml += `<div class="focus-section">
                <h4>Provenance</h4>
                <div class="focus-kv"><span class="focus-kv-label">Field:</span> <span class="focus-kv-value">${escapeHtml(group.fieldName)}</span></div>
                <div class="focus-kv"><span class="focus-kv-label">Set:</span> <span class="focus-kv-value">${escapeHtml(group.setName)}</span></div>
                <div class="focus-kv"><span class="focus-kv-label">Occurrences:</span> <span class="focus-kv-value">${group.values.length} record${group.values.length !== 1 ? 's' : ''}</span></div>`;

            // Show full value if it was truncated
            const fullValue = String(group.values[0].value);
            if (fullValue.length > 50) {
                bodyHtml += `<div class="focus-kv"><span class="focus-kv-label">Full Value:</span> <span class="focus-kv-value">${escapeHtml(fullValue)}</span></div>`;
            }

            bodyHtml += `</div>`;

            // Context section - show which records contain this value
            bodyHtml += `<div class="focus-section">
                <h4>Found In</h4>`;

            const recordCount = Math.min(5, group.values.length);
            for (let i = 0; i < recordCount; i++) {
                const val = group.values[i];
                bodyHtml += `<div class="focus-kv"><span class="focus-kv-value">${escapeHtml(val.recordLabel || val.recordId)}</span></div>`;
            }

            if (group.values.length > 5) {
                bodyHtml += `<div class="focus-kv"><span class="focus-kv-label">...and ${group.values.length - 5} more</span></div>`;
            }

            bodyHtml += `</div>`;

            document.getElementById('focusBody').innerHTML = bodyHtml;

            // Action buttons
            let actionsHtml = `
                <button class="focus-action-btn" onclick="createViewFromSearchValue('${group.setId}', '${group.fieldId}', '${encodeURIComponent(JSON.stringify(group.values[0].value))}'); clearFocus();">Create View with this Value</button>
                <button class="focus-action-btn" onclick="navigateToSet('${group.setId}'); closeModal('searchDataModal');">Open Set</button>
            `;
            document.getElementById('focusActions').innerHTML = actionsHtml;
        }

        function focusOnView(item, itemId) {
            currentFocusedItem = { type: 'view', data: item, itemId };

            // Remove previous focused class
            document.querySelectorAll('.result-item.focused').forEach(el => el.classList.remove('focused'));
            // Add focused class to clicked item
            const itemEl = document.getElementById(itemId);
            if (itemEl) itemEl.classList.add('focused');

            // Show focus panel
            document.getElementById('focusPanel').classList.remove('hidden');

            const viewIcon = item.view.icon || '';

            // Update header
            document.getElementById('focusTitle').textContent = `${viewIcon} ${item.view.name}`;
            document.getElementById('focusSubtitle').textContent = `View  from ${item.setName}`;
            document.getElementById('focusTag').textContent = 'View';

            // Build provenance section
            let bodyHtml = '';

            // Provenance section
            bodyHtml += `<div class="focus-section">
                <h4>Details</h4>
                <div class="focus-kv"><span class="focus-kv-label">Set:</span> <span class="focus-kv-value">${escapeHtml(item.setName)}</span></div>
                <div class="focus-kv"><span class="focus-kv-label">Type:</span> <span class="focus-kv-value">${item.view.type || 'table'}</span></div>`;

            if (item.view.description) {
                bodyHtml += `<div class="focus-kv"><span class="focus-kv-label">Description:</span> <span class="focus-kv-value">${escapeHtml(item.view.description)}</span></div>`;
            }

            // Count included fields
            const fieldCount = item.view.fields?.length || 0;
            bodyHtml += `<div class="focus-kv"><span class="focus-kv-label">Fields:</span> <span class="focus-kv-value">${fieldCount} field${fieldCount !== 1 ? 's' : ''}</span></div>`;

            // Check for filters
            if (item.view.filters && item.view.filters.length > 0) {
                bodyHtml += `<div class="focus-kv"><span class="focus-kv-label">Filters:</span> <span class="focus-kv-value">${item.view.filters.length} filter${item.view.filters.length !== 1 ? 's' : ''} applied</span></div>`;
            }

            // Check for sorting
            if (item.view.sorts && item.view.sorts.length > 0) {
                bodyHtml += `<div class="focus-kv"><span class="focus-kv-label">Sorting:</span> <span class="focus-kv-value">${item.view.sorts.length} sort${item.view.sorts.length !== 1 ? 's' : ''} applied</span></div>`;
            }

            bodyHtml += `</div>`;

            document.getElementById('focusBody').innerHTML = bodyHtml;

            // Action buttons
            let actionsHtml = `
                <button class="focus-action-btn" onclick="switchSet('${item.setId}', '${item.viewId}'); closeModal('searchDataModal');">Open View</button>
                <button class="focus-action-btn" onclick="navigateToSet('${item.setId}'); closeModal('searchDataModal');">Open Set</button>
            `;
            document.getElementById('focusActions').innerHTML = actionsHtml;
        }

        function navigateToSet(setId) {
            // Save any pending cell edits before navigating
            if (state.editingCell) {
                exitEditMode(true);
            }

            // Get the set and its first view
            const set = state.sets.get(setId);
            if (!set) return;

            // Use switchSet to properly create tabs and update state
            const firstViewId = set.views.size > 0 ? Array.from(set.views.keys())[0] : null;
            switchSet(setId, firstViewId);
        }

        function expandOneLevel(setId, recordIds) {
            const linkedRecordIds = new Set();
            const recordIdArray = Array.isArray(recordIds) ? recordIds : [recordIds];

            // Find all connections involving these records
            state.connections.forEach(conn => {
                recordIdArray.forEach(recordId => {
                    const fullRecordId = `${setId}/${recordId}`;

                    // Check if this record is the subject
                    if (conn.subject.type === 'Record' && conn.subject.id === fullRecordId) {
                        if (conn.operand.type === 'Record') {
                            // Extract setId and recordId from operand
                            const parts = conn.operand.id.split('/');
                            if (parts.length === 2) {
                                linkedRecordIds.add({ setId: parts[0], recordId: parts[1] });
                            }
                        }
                    }

                    // Check if this record is the operand
                    if (conn.operand.type === 'Record' && conn.operand.id === fullRecordId) {
                        if (conn.subject.type === 'Record') {
                            // Extract setId and recordId from subject
                            const parts = conn.subject.id.split('/');
                            if (parts.length === 2) {
                                linkedRecordIds.add({ setId: parts[0], recordId: parts[1] });
                            }
                        }
                    }
                });
            });

            return Array.from(linkedRecordIds);
        }

        function createViewFromSearchField(setId, fieldId) {
            const set = state.sets.get(setId);
            if (!set) return;

            const field = set.schema.find(f => f.id === fieldId);
            if (!field) return;

            // Create a pivot/grouped view by this field
            const keyRef = { setId, fieldId };
            const detection = autoDetectSchemaFromKey(keyRef);
            const viewName = `${field.name} Pivot`;
            const viewId = createView(set.id, viewName, {
                type: 'KEY_DERIVED',
                icon: 'ph-chart-pie',
                key: keyRef,
                schema: detection.schema,
                relationships: detection.relationships,
                showRecordId: false,
                hiddenFields: ['__recordId']
            });

            closeModal('searchDataModal');
            renderSidebar();
            switchSet(set.id, viewId);
            showToast(' View created from field');
        }

        function createViewFromSearchRecord(setId, recordId) {
            const set = state.sets.get(setId);
            const record = set?.records.get(recordId);
            if (!set || !record) return;

            // Get linked records (1 level deep)
            const linkedRecords = expandOneLevel(setId, recordId);
            const recordLabel = getRecordDisplayLabel(record, set);

            // Create a filtered view showing this record and linked records
            const filters = [[{ field: 'id', operator: 'equals', value: recordId }]];

            // Add linked records to filter if any
            if (linkedRecords.length > 0) {
                linkedRecords.forEach(linked => {
                    if (linked.setId === setId) {
                        filters.push([{ field: 'id', operator: 'equals', value: linked.recordId }]);
                    }
                });
            }

            const viewName = `Record: ${recordLabel}`;
            const viewId = createView(set.id, viewName, {
                type: 'grid',
                icon: 'ph-file-text',
                filters,
                showRecordId: false,
                hiddenFields: ['__recordId']
            });

            closeModal('searchDataModal');
            renderSidebar();
            switchSet(set.id, viewId);
            showToast(` View created with record and ${linkedRecords.length} linked record${linkedRecords.length !== 1 ? 's' : ''}`);
        }

        function createViewFromSearchValue(setId, fieldId, encodedValue) {
            const set = state.sets.get(setId);
            if (!set) return;

            const field = set.schema.find(f => f.id === fieldId);
            if (!field) return;

            const value = JSON.parse(decodeURIComponent(encodedValue));
            const filters = [[{ field: fieldId, operator: 'equals', value }]];

            // Find all matching records to analyze for intelligent defaults
            const matchingRecords = Array.from(set.records.values()).filter(r => {
                const recordValue = r[fieldId];
                if (value === null || value === undefined) {
                    return recordValue === null || recordValue === undefined;
                }
                if (typeof value === 'object') {
                    return JSON.stringify(recordValue) === JSON.stringify(value);
                }
                return recordValue === value;
            });

            const pivotAnalysis = analyzePivotData(set, matchingRecords, fieldId);

            // Build column order: pivoted field first, then identifier, then rest
            const identifierFieldId = inferIdentifierFieldId(set);
            const baseOrder = set.schema.map(f => f.id)
                .filter(id => id !== fieldId && id !== identifierFieldId);

            const columnOrder = [
                fieldId,  // Pivoted field always first
                ...(identifierFieldId && identifierFieldId !== fieldId ? [identifierFieldId] : []),
                ...baseOrder
            ];

            // Merge hidden fields (include __recordId plus analyzed redundant fields)
            const hiddenFields = [...new Set(['__recordId', ...pivotAnalysis.redundantFields])];

            const displayValue = typeof value === 'object' ? JSON.stringify(value) : (value ?? 'Empty');
            const viewName = `${field.name}: ${String(displayValue).slice(0, 32)} (${matchingRecords.length})`;

            const viewId = createView(set.id, viewName, {
                type: 'grid',
                icon: 'ph-funnel-simple',
                filters,
                columnOrder,
                showRecordId: false,
                hiddenFields,
                sorts: pivotAnalysis.suggestedSorts,
                groups: pivotAnalysis.suggestedGroups,
                columnRules: pivotAnalysis.suggestedColumnRules,
                viewMode: 'sandbox',  // Pivot views start in sandbox mode for exploration
                pivotMetadata: {
                    pivotFieldId: fieldId,
                    pivotValue: value,
                    matchCount: matchingRecords.length,
                    redundantFields: pivotAnalysis.redundantFields,
                    analysisTimestamp: Date.now(),
                    sourceSetId: set.id
                }
            });

            closeModal('searchDataModal');
            renderSidebar();
            switchSet(set.id, viewId);

            const hiddenCount = pivotAnalysis.redundantFields.length;
            const toastMsg = hiddenCount > 0
                ? ` Sandbox view created (${hiddenCount} uniform column${hiddenCount > 1 ? 's' : ''} hidden)`
                : ' Sandbox view created';
            showToast(toastMsg);
        }

        function registerInterpretationRule(rule, options = {}) {
            const normalizedRule = {
                rule_id: rule.rule_id || `rule_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`,
                applies_to_op: rule.applies_to_op || null,
                description: rule.description || '',
                effect: rule.effect || 'none',
                frame: rule.frame || 'system',
                scale: rule.scale || 'system'
            };

            state.interpretationRules.push(normalizedRule);

            if (!options.skipEvent) {
                createEvent(
                    'Define Rule',
                    'REC',
                    { type: 'InterpretationRule', id: normalizedRule.rule_id },
                    { rule: normalizedRule, summary: normalizedRule.description },
                    { frame: normalizedRule.frame, scale: normalizedRule.scale }
                );
            }

            return normalizedRule;
        }

        function hideField(fieldId) {
            const view = getCurrentView();
            if (!view) return;

            view.hiddenFields = view.hiddenFields || [];
            if (!view.hiddenFields.includes(fieldId)) view.hiddenFields.push(fieldId);
            if (fieldId === '__recordId') view.showRecordId = false;
            renderCurrentView();
            showToast(' Field hidden');
        }

        function showField(fieldId) {
            const view = getCurrentView();
            if (!view) return;

            view.hiddenFields = view.hiddenFields || [];
            const index = view.hiddenFields.indexOf(fieldId);
            if (index > -1) {
                view.hiddenFields.splice(index, 1);
            }
            if (fieldId === '__recordId') view.showRecordId = true;
            renderCurrentView();
            showToast(' Field shown');
        }

        function deleteField(fieldId) {
            const set = getCurrentSet();
            if (!set) return;
            const fieldIndex = set.schema.findIndex(f => f.id === fieldId);
            if (fieldIndex === -1) return;

            // Use TossPile for soft delete with restoration capability
            if (typeof TossPile !== 'undefined') {
                const action = TossPile.tossColumn(state, fieldId);
                if (action) {
                    renderCurrentView();
                    const valueCount = action.metadata.valueCount || 0;
                    showToast(` Column tossed (${valueCount} values can be restored)`);
                    return;
                }
            }

            // Fallback to hard delete if TossPile not available
            const [field] = set.schema.splice(fieldIndex, 1);
            set.records.forEach(record => delete record[fieldId]);
            createEvent(
                'Delete Field',
                'NUL',
                { type: 'Field', id: fieldId, setId: set.id },
                { setId: set.id, fieldId, fieldName: field?.name, summary: `Deleted field ${field?.name || fieldId}` },
                { frame: 'schema', scale: 'collection' }
            );
            renderCurrentView();
            showToast(' Field deleted');
        }

        function tossRecord(recordId) {
            const set = getCurrentSet();
            if (!set || !set.records.has(recordId)) return;

            // Use TossPile for soft delete with restoration capability
            if (typeof TossPile !== 'undefined') {
                const action = TossPile.tossRecord(state, recordId);
                if (action) {
                    renderCurrentView();
                    showToast(' Record tossed (can be restored from toss pile)');
                    return;
                }
            }

            // Fallback to hard delete if TossPile not available
            set.records.delete(recordId);
            if (state.selectedRecordIds) state.selectedRecordIds.delete(recordId);
            if (!state.selectedRecordIds || state.selectedRecordIds.size === 0) state.lastSelectedRecordId = null;
            createEvent(
                'Toss Record',
                'NUL',
                { type: 'Record', id: recordId, setId: set.id },
                { setId: set.id, recordId, summary: 'Record tossed' }
            );
            renderCurrentView();
            showToast(' Record tossed');
        }

        // UTILITIES
        function applyInterpretationRules(event) {
            const appliedRules = [];

            state.interpretationRules.forEach(rule => {
                if (rule.applies_to_op && rule.applies_to_op !== event.op) return;

                switch (rule.effect) {
                    case 'require_actor':
                        if (!event.actor || !event.actor.id) throw new Error('Events require an actor');
                        appliedRules.push(rule.rule_id);
                        break;
                    case 'require_object_id':
                        if (!event.object || !event.object.id) throw new Error('Operations require an object reference with an id');
                        appliedRules.push(rule.rule_id);
                        break;
                    case 'require_connection_endpoints':
                        if (!event.data?.edge?.subject || !event.data?.edge?.operand) throw new Error('Connections require both subject and operand');
                        appliedRules.push(rule.rule_id);
                        break;
                    case 'mark_deleted':
                        event.data = { ...event.data, deleted: true };
                        appliedRules.push(rule.rule_id);
                        break;
                    default:
                        break;
                }
            });

            return { ...event, appliedRules };
        }

        function createEvent(verb, op, object, data = {}, options = {}) {
            if (!state.operatorSet[op]) {
                throw new Error(`Invalid operator ${op}. Expected one of ${Object.keys(state.operatorSet).join(', ')}`);
            }

            const eventData = { ...data };

            if (options.summary && !eventData.summary) {
                eventData.summary = options.summary;
            }

            // Use lean context for compact event creation if available
            if (state.leanContext && options.useLeanContext !== false) {
                const compactEvent = state.leanContext.createCompactEvent(verb, op, object, eventData, options);
                // Add standard fields for backward compatibility
                compactEvent.frame = options.frame || 'ui';
                compactEvent.scale = options.scale || 'object';
                compactEvent.published = new Date(compactEvent.t).toISOString();
                compactEvent.actor = { type: state.currentUser.type, id: state.currentUser.id };
                compactEvent.verb = verb; // Keep full verb for compatibility
                compactEvent.data = eventData; // Keep full data for compatibility

                const interpretedEvent = applyInterpretationRules(compactEvent);
                state.eventStream.unshift(interpretedEvent);

                // Limit event history to prevent unbounded growth
                if (state.eventStream.length > 10000) {
                    state.eventStream = state.eventStream.slice(0, 5000);
                }

                return interpretedEvent;
            }

            // Fallback to standard event creation
            const event = {
                id: `event-${state.eventIdCounter++}`,
                verb: verb,
                op: op,
                frame: options.frame || 'ui',
                scale: options.scale || 'object',
                published: new Date().toISOString(),
                actor: { type: state.currentUser.type, id: state.currentUser.id },
                object: object,
                data: eventData
            };

            const interpretedEvent = applyInterpretationRules(event);
            state.eventStream.unshift(interpretedEvent);
            return interpretedEvent;
        }

        function getTimeAgo(timestamp) {
            const seconds = Math.floor((new Date() - new Date(timestamp)) / 1000);
            if (seconds < 60) return 'just now';
            if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
            if (seconds < 86400) return `${Math.floor(seconds / 3600)}h ago`;
            return `${Math.floor(seconds / 86400)}d ago`;
        }

        function showToast(message) {
            const toast = document.createElement('div');
            toast.className = 'toast';
            toast.innerHTML = `
                <div class="flex items-center gap-3">
                    <svg class="w-5 h-5 text-green-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>
                    </svg>
                    <span class="font-medium">${message}</span>
                </div>
            `;
            document.body.appendChild(toast);
            setTimeout(() => toast.remove(), 3000);
        }

        function closeAllContextMenus() {
            document.querySelectorAll('.context-menu').forEach(menu => menu.remove());
        }

        function closeAllModals(exceptId = null) {
            const remaining = [];
            state.modalStack.forEach(id => {
                if (id === exceptId) {
                    remaining.push(id);
                    return;
                }

                const modalEl = document.getElementById(id);
                if (modalEl) modalEl.classList.add('hidden');
            });
            state.modalStack = remaining;
        }

        function openModal(modalId) {
            closeAllContextMenus();
            closeAllModals(modalId);

            const modal = document.getElementById(modalId);
            if (!modal) return;

            modal.classList.remove('hidden');
            if (!state.modalStack.includes(modalId)) {
                state.modalStack.push(modalId);
            }
        }

        function closeModal(modalId) {
            closeAllContextMenus();
            const modal = document.getElementById(modalId);
            if (modal) {
                modal.classList.add('hidden');
                // Remove dynamically created modals from DOM after closing
                if (['importPreviewModal', 'addImportToSetModal'].includes(modalId)) {
                    modal.remove();
                }
            }
            state.modalStack = state.modalStack.filter(id => id !== modalId);
        }

        function exportJSON() {
            const world = getWorld();
            const worldSets = getSetsForWorld(world?.id);
            const connections = getConnectionView();
            const definitions = getDefinitionView();
            const data = {
                world: world ? { ...world, setIds: Array.from(world.setIds || []) } : null,
                sets: worldSets.map(s => ({
                    ...s,
                    setIds: undefined,
                    records: Array.from(s.records.values()),
                    views: Array.from(s.views.values()),
                    profiles: Array.from(s.profiles.values())
                })),
                definitions,
                connectionRelations: getConnectionRelationView(),
                connections,
                eventStream: state.eventStream
            };
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            const nameToken = world?.name ? world.name.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/(^-|-$)/g, '') : 'workbase';
            a.download = `${nameToken || 'workbase'}-export.json`;
            a.click();
            URL.revokeObjectURL(url);
            showToast(' Exported data');
        }

        function importWorldFromJson(payload) {
            if (!payload) return;

            try {
                const data = typeof payload === 'string' ? JSON.parse(payload) : payload;
                const world = data.world || null;
                if (!world) throw new Error('No world data found in file');

                state.worlds = new Map();
                state.sets = new Map();
                state.definitions = new Map();
                state.connectionRelations = new Map();
                state.connections = new Map();
                state.expandedSets = new Set();
                state.openTabs = [];
                state.currentSpecialView = null;
                state.selectedRecordIds.clear();
                state.lastSelectedRecordId = null;
                state.selectedCell = null;
                state.lastSelectedCell = null;
                state.editingCell = null;
                state.csvImportState = { headers: [], rows: [], mappings: {}, previewRows: [], matches: [], targetMode: 'existing', targetSetId: null, newSetName: '' };
                state.fuzzyPanelState = { threshold: 0.65, matches: [] };

                const worldId = world.id || `world_${Date.now()}`;
                const normalizedWorld = { ...world, id: worldId, setIds: new Set(world.setIds || []) };
                state.worlds.set(worldId, normalizedWorld);

                (data.sets || []).forEach(rawSet => {
                    const setId = rawSet.id || `set_${Date.now()}_${Math.random().toString(36).slice(2, 6)}`;
                    const records = new Map();
                    (rawSet.records || []).forEach(rec => {
                        const recId = rec.id || `rec_${Date.now()}_${Math.random().toString(36).slice(2, 6)}`;
                        records.set(recId, { ...rec, id: recId });
                    });

                    const views = new Map();
                    (rawSet.views || []).forEach(view => {
                        const viewId = view.id || `view_${Date.now()}_${Math.random().toString(36).slice(2, 6)}`;
                        views.set(viewId, { ...view, id: viewId });
                    });

                    const profiles = new Map();
                    (rawSet.profiles || []).forEach(profile => {
                        const profileId = profile.id || 'default';
                        profiles.set(profileId, { ...profile, id: profileId });
                    });

                    const normalizedSet = {
                        ...rawSet,
                        id: setId,
                        worldId: rawSet.worldId || worldId,
                        records,
                        views,
                        profiles
                    };

                    state.sets.set(setId, normalizedSet);
                    normalizedWorld.setIds.add(setId);
                    state.expandedSets.add(setId);
                });

                (data.definitions || []).forEach(def => {
                    const id = def.id || `def_${Date.now()}_${Math.random().toString(36).slice(2, 6)}`;
                    state.definitions.set(id, { ...def, id });
                });

                (data.connectionRelations || []).forEach(rel => {
                    const id = rel.id || `REL_${Date.now()}_${Math.random().toString(36).slice(2, 6)}`;
                    try {
                        const normalized = validateConnectionRelationPayload({ ...rel, id });
                        state.connectionRelations.set(id, normalized);
                    } catch (error) {
                        console.warn('Skipping invalid connection relation during import', error);
                    }
                });

                (data.connections || []).forEach(conn => {
                    const id = conn.id || `conn_${Date.now()}_${Math.random().toString(36).slice(2, 6)}`;
                    try {
                        const normalized = validateConnectionPayload({ ...conn, id });
                        state.connections.set(id, normalized);
                    } catch (error) {
                        console.warn('Skipping invalid connection during import', error);
                    }
                });

                state.eventStream = Array.isArray(data.eventStream) ? data.eventStream : [];
                const numericIds = state.eventStream
                    .map(e => typeof e.id === 'string' && e.id.startsWith('event-') ? parseInt(e.id.replace('event-', '')) : null)
                    .filter(n => Number.isFinite(n));
                const maxId = numericIds.length ? Math.max(...numericIds) : state.eventStream.length;
                state.eventIdCounter = (maxId || 0) + 1;

                state.currentWorldId = worldId;
                state.currentSetId = Array.from(normalizedWorld.setIds)[0] || null;
                state.currentViewId = state.currentSetId ? Array.from(state.sets.get(state.currentSetId).views.keys())[0] || null : null;

                renderWorldSelector();
                renderSidebar();
                if (state.currentSetId) switchSet(state.currentSetId, state.currentViewId);
                renderHistory();
                showToast(' World imported');
            } catch (error) {
                console.error('Failed to import world JSON', error);
                showToast(' Could not import world JSON');
            }
        }

        function triggerWorldImport() {
            const input = document.getElementById('worldJsonInput');
            if (input) {
                input.value = '';
                input.click();
            }
        }

        function handleWorldFileSelected(event) {
            const file = event.target.files?.[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => importWorldFromJson(e.target?.result || '');
            reader.readAsText(file);
        }

        function convertSetToCsv(set) {
            const headers = ['id', ...set.schema.map(f => f.id)];
            const escapeValue = (value) => {
                if (value === null || value === undefined) return '';
                const str = typeof value === 'object' ? JSON.stringify(value) : String(value);
                if (str.includes(',') || str.includes('"') || str.includes('\n')) {
                    return '"' + str.replace(/"/g, '""') + '"';
                }
                return str;
            };
            const rows = Array.from(set.records.values()).map(record => headers.map(h => escapeValue(record[h])).join(','));
            return [headers.join(','), ...rows].join('\n');
        }

        function exportWorldCSVs() {
            const world = getWorld();
            const sets = getSetsForWorld();
            if (!sets.length) {
                showToast(' No sets to export in this world');
                return;
            }
            sets.forEach(set => {
                const csv = convertSetToCsv(set);
                const blob = new Blob([csv], { type: 'text/csv' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                const prefix = world?.name ? world.name.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/(^-|-$)/g, '') : 'world';
                const setToken = set.name ? set.name.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/(^-|-$)/g, '') : set.id;
                a.href = url;
                a.download = `${prefix || 'world'}-${setToken || set.id}.csv`;
                a.click();
                URL.revokeObjectURL(url);
            });
            showToast(' Exported CSV files for this world');
        }

        function renderHistory() {
            const container = document.getElementById('historyContent');
            container.innerHTML = state.eventStream.map(e => `
                <div class="history-entry">
                    <div class="font-medium">${e.verb} <span class="text-xs text-gray-500">(${e.op})</span></div>
                    <div class="text-sm text-gray-500">${getTimeAgo(e.published)}  Frame: ${e.frame}  Scale: ${e.scale}</div>
                    <div class="text-sm">${e.data?.summary || e.verb}</div>
                    ${e.appliedRules?.length ? `<div class="text-xs text-gray-400">Rules: ${e.appliedRules.join(', ')}</div>` : ''}
                </div>
            `).join('');
        }

        // Edit History Modal functions
        function openEditHistoryModal() {
            state.editHistoryState = {
                searchQuery: '',
                filterOp: 'all'
            };
            renderEditHistoryModal();
            openModal('editHistoryModal');
        }

        function renderEditHistoryModal() {
            const container = document.getElementById('editHistoryContent');
            if (!container) return;

            const searchQuery = state.editHistoryState?.searchQuery?.toLowerCase() || '';
            const filterOp = state.editHistoryState?.filterOp || 'all';

            // Filter and sort events (most recent first)
            let events = [...state.eventStream].reverse();

            if (filterOp !== 'all') {
                events = events.filter(e => e.op === filterOp);
            }

            if (searchQuery) {
                events = events.filter(e => {
                    const verb = (e.verb || '').toLowerCase();
                    const summary = (e.data?.summary || '').toLowerCase();
                    const fieldName = (e.data?.fieldName || '').toLowerCase();
                    return verb.includes(searchQuery) || summary.includes(searchQuery) || fieldName.includes(searchQuery);
                });
            }

            const subtitle = document.getElementById('editHistorySubtitle');
            if (subtitle) {
                subtitle.textContent = `${events.length} change${events.length !== 1 ? 's' : ''} recorded`;
            }

            if (events.length === 0) {
                container.innerHTML = `
                    <div class="text-center py-12 text-gray-500">
                        <i class="ph ph-clock-counter-clockwise text-4xl mb-3 opacity-50"></i>
                        <p>No changes found</p>
                    </div>
                `;
                return;
            }

            const opIcons = {
                SEG: 'ph-pencil-simple',
                INS: 'ph-plus-circle',
                DES: 'ph-trash',
                SYN: 'ph-tree-structure',
                CON: 'ph-git-merge',
                REC: 'ph-recycle',
                ALT: 'ph-arrows-left-right',
                SUP: 'ph-stack'
            };

            const opColors = {
                SEG: 'text-blue-600 bg-blue-50',
                INS: 'text-green-600 bg-green-50',
                DES: 'text-red-600 bg-red-50',
                SYN: 'text-purple-600 bg-purple-50',
                CON: 'text-amber-600 bg-amber-50',
                REC: 'text-teal-600 bg-teal-50',
                ALT: 'text-indigo-600 bg-indigo-50',
                SUP: 'text-pink-600 bg-pink-50'
            };

            container.innerHTML = events.map((e, idx) => {
                const icon = opIcons[e.op] || 'ph-note';
                const colorClass = opColors[e.op] || 'text-gray-600 bg-gray-50';
                const canRevert = e.op === 'SEG' && e.data?.recordId && e.data?.fieldId && e.data?.oldValue !== undefined;
                const setName = e.object?.setId ? (state.sets.get(e.object.setId)?.name || 'Unknown Set') : '';
                const recordLabel = e.data?.recordId ? getRecordLabelById(e.data.recordId) : '';

                return `
                    <div class="edit-history-entry border border-gray-200 rounded-lg p-4 mb-3 hover:border-gray-300 transition-colors">
                        <div class="flex items-start gap-3">
                            <div class="p-2 rounded-lg ${colorClass}">
                                <i class="ph ${icon} text-lg"></i>
                            </div>
                            <div class="flex-1 min-w-0">
                                <div class="flex items-center justify-between gap-2">
                                    <div class="font-semibold text-gray-900">${e.verb || 'Change'}</div>
                                    <div class="text-xs text-gray-500">${getTimeAgo(e.published)}</div>
                                </div>
                                <div class="text-sm text-gray-600 mt-1">${e.data?.summary || ''}</div>
                                ${e.data?.fieldName ? `<div class="text-xs text-gray-500 mt-1"><span class="font-medium">Field:</span> ${e.data.fieldName}</div>` : ''}
                                ${recordLabel ? `<div class="text-xs text-gray-500"><span class="font-medium">Record:</span> ${recordLabel}</div>` : ''}
                                ${setName ? `<div class="text-xs text-gray-500"><span class="font-medium">Set:</span> ${setName}</div>` : ''}
                                ${e.data?.oldValue !== undefined || e.data?.newValue !== undefined ? `
                                    <div class="mt-2 p-2 bg-gray-50 rounded-lg text-sm">
                                        <div class="flex items-center gap-2">
                                            ${e.data?.oldValue !== undefined ? `<span class="text-red-600 line-through">${formatHistoryValue(e.data.oldValue)}</span>` : ''}
                                            ${e.data?.oldValue !== undefined && e.data?.newValue !== undefined ? `<span class="text-gray-400"></span>` : ''}
                                            ${e.data?.newValue !== undefined ? `<span class="text-green-600">${formatHistoryValue(e.data.newValue)}</span>` : ''}
                                        </div>
                                    </div>
                                ` : ''}
                                <div class="flex items-center gap-2 mt-2 text-xs text-gray-400">
                                    <span>Frame: ${e.frame || 'current'}</span>
                                    <span></span>
                                    <span>Scale: ${e.scale || 'individual'}</span>
                                    <span></span>
                                    <span>Op: ${e.op}</span>
                                </div>
                            </div>
                            ${canRevert ? `
                                <button class="btn btn-secondary btn-sm flex items-center gap-1" onclick="revertHistoryChange(${idx})" title="Revert this change">
                                    <i class="ph ph-arrow-counter-clockwise"></i>
                                    Revert
                                </button>
                            ` : ''}
                        </div>
                    </div>
                `;
            }).join('');
        }

        function formatHistoryValue(value) {
            if (value === null || value === undefined) return '<em class="text-gray-400">empty</em>';
            if (typeof value === 'object') {
                if (value._sup && Array.isArray(value.value)) {
                    return value.value.map(v => v.val ?? v.value ?? v).join(', ');
                }
                return JSON.stringify(value);
            }
            return String(value);
        }

        function getRecordLabelById(recordId) {
            for (const set of state.sets.values()) {
                const record = set.records?.get(recordId);
                if (record) {
                    return getRecordDisplayLabel(record);
                }
            }
            return recordId;
        }

        function revertHistoryChange(eventIndex) {
            const events = [...state.eventStream].reverse();
            const event = events[eventIndex];

            if (!event || event.op !== 'SEG') {
                showToast(' This change cannot be reverted');
                return;
            }

            const { recordId, fieldId, oldValue } = event.data || {};
            if (!recordId || !fieldId || oldValue === undefined) {
                showToast(' Missing data to revert this change');
                return;
            }

            // Find the set and record
            let targetSet = null;
            let targetRecord = null;
            for (const set of state.sets.values()) {
                const record = set.records?.get(recordId);
                if (record) {
                    targetSet = set;
                    targetRecord = record;
                    break;
                }
            }

            if (!targetRecord) {
                showToast(' Record not found');
                return;
            }

            const currentValue = targetRecord[fieldId];
            updateRecord(recordId, fieldId, oldValue, currentValue);

            showToast(' Change reverted');
            renderEditHistoryModal();
            renderCurrentView();
        }

        function setupEditHistoryListeners() {
            const searchInput = document.getElementById('editHistorySearch');
            const filterSelect = document.getElementById('editHistoryFilter');

            if (searchInput) {
                let debounceTimer;
                searchInput.oninput = () => {
                    clearTimeout(debounceTimer);
                    debounceTimer = setTimeout(() => {
                        if (state.editHistoryState) {
                            state.editHistoryState.searchQuery = searchInput.value;
                        }
                        renderEditHistoryModal();
                    }, 150);
                };
            }

            if (filterSelect) {
                filterSelect.onchange = () => {
                    if (state.editHistoryState) {
                        state.editHistoryState.filterOp = filterSelect.value;
                    }
                    renderEditHistoryModal();
                };
            }
        }

        // EVENT LISTENERS
        function setupEventListeners() {
            setupToolbarMenu();
            setupGlobeMenu();

            const fieldTypeTrigger = document.getElementById('fieldTypeTrigger');
            if (fieldTypeTrigger) fieldTypeTrigger.onclick = (event) => { event.preventDefault(); toggleFieldTypeDropdown(); };

            const changeFieldTypeTrigger = document.getElementById('changeFieldTypeTrigger');
            if (changeFieldTypeTrigger) changeFieldTypeTrigger.onclick = (event) => { event.preventDefault(); toggleChangeFieldTypeDropdown(); };

            document.getElementById('saveChangeFieldTypeBtn').onclick = saveChangeFieldType;
            document.getElementById('cancelChangeFieldTypeBtn').onclick = closeChangeFieldTypeModal;
            document.getElementById('closeChangeFieldTypeBtn').onclick = closeChangeFieldTypeModal;
            // Note: changeLinkToSet is now handled by EOCustomDropdown with its onChange callback

            const filterBtn = document.getElementById('filterBtn');
            if (filterBtn) filterBtn.onclick = openFilterModal;
            const sortBtn = document.getElementById('sortBtn');
            if (sortBtn) sortBtn.onclick = openSortModal;
            const visualizeBtn = document.getElementById('visualizeBtn');
            if (visualizeBtn) visualizeBtn.onclick = openVisualizationModal;
            document.getElementById('parseCsvTextBtn').onclick = previewCsvFromText;
            document.getElementById('csvFileInput').onchange = handleCsvFileSelected;
            document.getElementById('refreshCsvPreviewBtn').onclick = renderCsvPreview;
            document.getElementById('runCsvImportBtn').onclick = importCsvRecords;
            document.getElementById('cancelCsvImportBtn').onclick = () => closeModal('csvImportModal');
            document.getElementById('closeCsvImportBtn').onclick = () => closeModal('csvImportModal');

            // Type assessment event listeners
            document.getElementById('acceptAllTypesBtn').onclick = acceptAllTypes;

            // Provenance review modal event listeners
            document.getElementById('closeProvenanceReviewBtn').onclick = closeProvenanceReviewModal;
            document.getElementById('continueToMappingBtn').onclick = continueToColumnMapping;
            document.getElementById('skipProvenanceBtn').onclick = skipProvenanceReview;
            document.getElementById('provenanceFrame').onchange = (event) => {
                const customInput = document.getElementById('provenanceFrameCustom');
                if (event.target.value === 'custom') {
                    customInput.classList.remove('hidden');
                } else {
                    customInput.classList.add('hidden');
                }
            };
            document.getElementById('provenanceEnableExternalLink').onchange = (event) => {
                const urlInput = document.getElementById('provenanceExternalLinkUrl');
                if (event.target.checked) {
                    urlInput.classList.remove('hidden');
                } else {
                    urlInput.classList.add('hidden');
                }
            };

            document.querySelectorAll('input[name="csvImportTargetMode"]').forEach(input => {
                input.onchange = (event) => {
                    state.csvImportState.targetMode = event.target.value;
                    handleCsvTargetChange();
                };
            });
            document.getElementById('csvTargetSetSelect').onchange = (event) => {
                state.csvImportState.targetSetId = event.target.value || null;
                handleCsvTargetChange();
            };
            document.getElementById('csvNewSetName').oninput = (event) => {
                state.csvImportState.newSetName = event.target.value;
            };

            // JSON Import event listeners
            document.getElementById('parseJsonTextBtn').onclick = previewJsonFromText;
            document.getElementById('jsonFileInput').onchange = handleJsonFileSelected;
            document.getElementById('refreshJsonPreviewBtn').onclick = renderJsonPreview;
            document.getElementById('runJsonImportBtn').onclick = importJsonRecords;
            document.getElementById('cancelJsonImportBtn').onclick = () => closeModal('jsonImportModal');
            document.getElementById('closeJsonImportBtn').onclick = () => closeModal('jsonImportModal');

            document.querySelectorAll('input[name="jsonImportTargetMode"]').forEach(input => {
                input.onchange = (event) => {
                    state.jsonImportState.targetMode = event.target.value;
                    handleJsonTargetChange();
                };
            });
            document.getElementById('jsonTargetSetSelect').onchange = (event) => {
                state.jsonImportState.targetSetId = event.target.value || null;
                handleJsonTargetChange();
            };
            document.getElementById('jsonNewSetName').oninput = (event) => {
                state.jsonImportState.newSetName = event.target.value;
            };

            document.getElementById('closeFuzzyPanelBtn').onclick = closeFuzzyPanel;
            document.getElementById('refreshFuzzyMatchesBtn').onclick = renderFuzzyPanel;
            document.getElementById('fuzzyThresholdInput').oninput = renderFuzzyPanel;
            document.getElementById('closeHistoryBtn').onclick = () => document.getElementById('historyPanel').classList.remove('open');
            document.getElementById('toggleHistorySidebarBtn').onclick = toggleRecordHistoryVisibility;
            document.getElementById('closeExpandedRecordBtn').onclick = () => closeModal('expandedRecordModal');
            bindIconSelector('newSetIcon');
            bindIconSelector('newViewIcon');
            // Clear view name validation error on input
            document.getElementById('newViewName').addEventListener('input', () => {
                document.getElementById('newViewNameError').classList.add('hidden');
                document.getElementById('newViewName').classList.remove('input-error');
            });
            document.getElementById('closeIconPickerBtn').onclick = () => closeModal('iconPickerModal');
            document.getElementById('iconPickerSearch').oninput = (event) => {
                state.iconPickerQuery = event.target.value;
                state.iconPickerPage = 1;
                renderIconPickerOptions();
            };
            setupEditHistoryListeners();
            document.getElementById('closeFilterBtn').onclick = () => closeModal('filterModal');
            document.getElementById('closePopupSettingsBtn').onclick = () => closeModal('popupSettingsModal');
            document.getElementById('applyFiltersBtn').onclick = applyFilters;
            document.getElementById('clearFiltersBtn').onclick = clearFilters;
            document.getElementById('addFilterGroupBtn').onclick = addFilterGroup;
            document.getElementById('confirmCancelBtn').onclick = () => {
                state.confirmCallback = null;
                closeModal('confirmModal');
            };
            document.getElementById('confirmOkBtn').onclick = () => {
                if (state.confirmCallback) state.confirmCallback();
                state.confirmCallback = null;
                closeModal('confirmModal');
            };
            wireViewStageActions();
            document.getElementById('addSortRuleBtn').onclick = addSortRule;
            document.getElementById('clearSortsBtn').onclick = clearSorts;
            document.getElementById('applySortsBtn').onclick = applySortsFromModal;
            document.getElementById('closeSortBtn').onclick = () => closeModal('sortModal');
            const fieldNameInput = document.getElementById('newFieldName');
            if (fieldNameInput) fieldNameInput.addEventListener('input', resetFieldNameValidation);
          document.getElementById('saveAddFieldBtn').onclick = saveField;
          document.getElementById('cancelAddFieldBtn').onclick = () => closeModal('addFieldModal');
          document.getElementById('closeAddFieldBtn').onclick = () => closeModal('addFieldModal');
          document.getElementById('closeColumnRulesBtn').onclick = () => closeModal('columnRulesModal');
          document.getElementById('columnRulesRuleSelect').onchange = (e) => {
                document.getElementById('columnRulesSetPicker').classList.toggle('hidden', e.target.value !== 'prefer_set');
                updateColumnRulesSummary();
            };
            document.getElementById('columnRulesFieldSelect').onchange = updateColumnRulesSummary;
            document.getElementById('columnRulesPreferredSet').onchange = updateColumnRulesSummary;

          // Record ID toggle switch
          const recordIdToggle = document.getElementById('recordIdToggle');
          const recordIdCheckbox = document.getElementById('recordIdVisibilityToggle');
          if (recordIdToggle && recordIdCheckbox) {
            recordIdToggle.onclick = () => {
              recordIdCheckbox.checked = !recordIdCheckbox.checked;
              recordIdToggle.classList.toggle('active', recordIdCheckbox.checked);
              toggleRecordIdVisibility(recordIdCheckbox.checked);
            };
          }

          // Row Numbers toggle switch
          const rowNumbersToggle = document.getElementById('rowNumbersToggle');
          const rowNumbersCheckbox = document.getElementById('rowNumbersVisibilityToggle');
          if (rowNumbersToggle && rowNumbersCheckbox) {
            rowNumbersToggle.onclick = () => {
              rowNumbersCheckbox.checked = !rowNumbersCheckbox.checked;
              rowNumbersToggle.classList.toggle('active', rowNumbersCheckbox.checked);
              toggleRowNumbers(rowNumbersCheckbox.checked);
            };
          }

          document.getElementById('saveColumnRuleBtn').onclick = saveColumnRule;
          document.getElementById('deleteColumnRuleBtn').onclick = deleteColumnRule;
          const addWorldBtn = document.getElementById('addWorldBtn');
          if (addWorldBtn) addWorldBtn.onclick = openAddWorldModal;
          document.getElementById('saveAddWorldBtn').onclick = saveWorldFromModal;
          document.getElementById('cancelAddWorldBtn').onclick = () => closeModal('addWorldModal');
          const worldSelect = document.getElementById('worldSelect');
          if (worldSelect) worldSelect.onchange = (e) => switchWorld(e.target.value);
          document.getElementById('exportWorldBtn').onclick = exportJSON;
          document.getElementById('viewWorldJsonBtn').onclick = openJsonViewer;
          document.getElementById('importWorldBtn').onclick = triggerWorldImport;
          document.getElementById('worldJsonInput').onchange = handleWorldFileSelected;
          document.getElementById('globalHistoryBtn').onclick = () => {
                openEditHistoryModal();
          };
          document.getElementById('saveAddSetBtn').onclick = () => {
                const nameInput = document.getElementById('newSetName');
                const name = nameInput.value.trim();
                const icon = extractIconToken(document.getElementById('newSetIcon').value.trim() || 'ph-squares-four');
                const worldId = document.getElementById('newSetWorld').value || state.currentWorldId;
                if (!name) { showToast(' Please enter a set name'); nameInput?.focus(); return; }
                if (state.setEditorContext?.setId) {
                    const set = state.sets.get(state.setEditorContext.setId);
                    const previousWorldId = set.worldId;
                    set.name = name;
                    set.icon = icon;
                    set.worldId = worldId;
                    if (previousWorldId && previousWorldId !== worldId) {
                        getWorld(previousWorldId)?.setIds?.delete(set.id);
                    }
                    getWorld(worldId)?.setIds?.add(set.id);
                    closeModal('addSetModal');
                    state.setEditorContext = null;
                    state.currentWorldId = worldId;
                    renderSidebar();
                    renderCurrentView();
                    showToast(' Set updated');
                } else {
                    const setId = createSet(name, icon, worldId);
                    closeModal('addSetModal');
                    document.getElementById('newSetName').value = '';
                    document.getElementById('newSetIcon').value = 'ph-squares-four';
                    syncIconSelector('newSetIcon');
                    createView(setId, 'All ' + name, { type: 'grid' });
                    state.expandedSets.add(setId);
                    state.currentWorldId = worldId;
                    renderSidebar();
                    switchSet(setId, null);
                    showToast(' Set created');
                    showConfirm('Import CSV into this set now?', () => {
                        openCsvImportModal(setId);
                    });
                }
            };
            document.getElementById('cancelAddSetBtn').onclick = () => { state.setEditorContext = null; closeModal('addSetModal'); };

            // Add Record modal handlers
            document.getElementById('cancelAddRecordBtn').onclick = () => { closeModal('addRecordModal'); };
            document.getElementById('saveAddRecordBtn').onclick = () => {
                const viewSelect = document.getElementById('addRecordViewSelect');
                if (!viewSelect || !viewSelect.value) {
                    showToast('Please select a view');
                    return;
                }

                try {
                    const { setId, viewId } = JSON.parse(viewSelect.value);
                    const set = state.sets.get(setId);
                    if (!set) {
                        showToast('Set not found');
                        return;
                    }

                    // Create a new record with default values based on schema
                    const record = { id: `rec_${Date.now()}` };
                    set.schema.forEach(f => record[f.id] = FIELD_TYPES[f.type].defaultValue);

                    // If the selected view has filters, pre-populate the record with filter values
                    // so it's immediately visible after creation
                    const view = state.views?.get(viewId) || set.views.get(viewId);
                    if (view && view.filters && view.filters.length > 0) {
                        const firstGroup = view.filters[0];
                        const rules = firstGroup.filter(r => r.field);
                        rules.forEach(rule => {
                            if (rule.field && rule.value !== undefined) {
                                record[rule.field] = rule.value;
                            }
                        });
                    }

                    set.records.set(record.id, record);

                    // Switch to the selected view and show the new record
                    switchSet(setId, viewId);
                    closeModal('addRecordModal');
                    showToast(' Record added');
                } catch (e) {
                    console.error('Error adding record:', e);
                    showToast('Error adding record');
                }
            };

            document.getElementById('saveAddViewBtn').onclick = () => {
                const nameInput = document.getElementById('newViewName');
                const nameError = document.getElementById('newViewNameError');
                const name = nameInput.value.trim();
                const icon = extractIconToken(document.getElementById('newViewIcon').value.trim() || 'ph-table');
                const parentId = document.getElementById('newViewParent').value || null;
                const creationMode = document.querySelector('input[name="viewCreationMode"]:checked')?.value || 'blank';
                const viewType = document.querySelector('input[name="newViewType"]:checked')?.value || 'grid';
                const keyCandidate = document.getElementById('keyCandidateSelect')?.value || '';
                if (!name) {
                    nameError.classList.remove('hidden');
                    nameInput.classList.add('input-error');
                    nameInput.focus();
                    return;
                }
                nameError.classList.add('hidden');
                nameInput.classList.remove('input-error');
                const set = state.sets.get(state.viewEditorContext?.setId || state.currentSetId);
                const setId = set?.id;
                if (!setId) {
                    showToast(' Could not find set. Please try again.');
                    closeModal('addViewModal');
                    return;
                }
                if (state.viewEditorContext?.viewId && parentId && isViewDescendant(set, parentId, state.viewEditorContext.viewId)) {
                    showConfirm('You cannot nest a view under its own descendant.', () => {});
                    return;
                }

                if (state.viewEditorContext?.viewId) {
                    const view = set.views.get(state.viewEditorContext.viewId);
                    if (view) {
                        view.name = name;
                        view.icon = icon;
                        view.parentId = parentId;
                    }
                    closeModal('addViewModal');
                    state.viewEditorContext = null;
                    renderSidebar();
                    switchSet(setId, view?.id || state.currentViewId);
                    showToast(' View updated');
                } else {
                    if (creationMode === 'key' && keyCandidate.includes(':')) {
                        const [keySetId, fieldId] = keyCandidate.split(':');
                        const keyRef = { setId: keySetId, fieldId };
                        const detection = autoDetectSchemaFromKey(keyRef);
                        const viewId = createView(keySetId, name, {
                            type: 'KEY_DERIVED',
                            icon: 'ph-key',
                            parentId,
                            key: keyRef,
                            schema: detection.schema,
                            relationships: detection.relationships,
                            rollups: detection.rollups,
                            filters: [{ field: fieldId, operator: 'notEmpty' }]
                        });
                        createEvent(
                            'View Schema Update',
                            'SEG',
                            { type: 'View', id: viewId, setId: keySetId },
                            { viewId, changes: { schema: detection.schema, relationships: detection.relationships, rollups: detection.rollups }, summary: 'Auto-generated schema from key' },
                            { scale: 'collection' }
                        );
                        closeModal('addViewModal');
                        document.getElementById('newViewName').value = '';
                        document.getElementById('newViewIcon').value = 'ph-table';
                        syncIconSelector('newViewIcon');
                        state.viewEditorContext = null;
                        renderSidebar();
                        switchSet(keySetId, viewId);
                        showToast(' Generated view from key');
                    } else {
                        const viewId = createView(setId, name, { type: viewType, icon, parentId });
                        closeModal('addViewModal');
                        document.getElementById('newViewName').value = '';
                        document.getElementById('newViewIcon').value = 'ph-table';
                        syncIconSelector('newViewIcon');
                        state.viewEditorContext = null;
                        renderSidebar();
                        switchSet(setId, viewId);
                        showToast(' View created');
                    }
                }
            };
            document.getElementById('cancelAddViewBtn').onclick = () => { state.viewEditorContext = null; closeModal('addViewModal'); };
            document.getElementById('closeAddViewModalBtn').onclick = () => { state.viewEditorContext = null; closeModal('addViewModal'); };
            const viewCreationModes = document.querySelectorAll('input[name="viewCreationMode"]');
            viewCreationModes.forEach(radio => {
                radio.onchange = (e) => {
                    const select = document.getElementById('keyCandidateSelect');
                    const enableKey = e.target.value === 'key';
                    if (select) select.disabled = !enableKey || select.options.length === 0;
                };
            });
            document.getElementById('saveKanbanConfigBtn').onclick = saveKanbanConfig;
            document.getElementById('cancelKanbanConfigBtn').onclick = () => closeModal('kanbanConfigModal');
            document.getElementById('closeJsonViewerBtn').onclick = () => closeModal('jsonViewerModal');
            document.getElementById('copyJsonBtn').onclick = copyJsonToClipboard;
            document.getElementById('closeSearchDataBtn').onclick = () => closeModal('searchDataModal');
        }

        document.addEventListener('click', (event) => {
            // Close Add Field Modal dropdown if clicking outside
            const addFieldSelector = document.querySelector('#addFieldModal .field-type-select');
            if (addFieldSelector && !addFieldSelector.contains(event.target)) {
                closeFieldTypeDropdown();
            }

            // Close Field Manager dropdown if clicking outside
            const fieldManagerSelector = document.querySelector('#fieldManagerModal .field-type-select');
            if (fieldManagerSelector && !fieldManagerSelector.contains(event.target)) {
                closeFieldManagerTypeDropdown();
            }

            // Close Change Field Type Modal dropdown if clicking outside
            const changeFieldSelector = document.querySelector('#changeFieldTypeModal .field-type-select');
            if (changeFieldSelector && !changeFieldSelector.contains(event.target)) {
                closeChangeFieldTypeDropdown();
            }
        });

        // Close modals when clicking outside (on overlay)
        document.addEventListener('click', (event) => {
            if (event.target.classList.contains('modal-overlay')) {
                const modalId = event.target.id;
                if (modalId) {
                    // Clear any editor context when closing modals
                    if (modalId === 'addViewModal') state.viewEditorContext = null;
                    if (modalId === 'addSetModal') state.setEditorContext = null;
                    closeModal(modalId);
                }
            }
        });

        // JSON VIEWER
        let currentJsonTab = 'all';
        
        function openJsonViewer() {
            currentJsonTab = 'all';
            renderJsonContent();
            openModal('jsonViewerModal');
        }
        
        function switchJsonTab(tab) {
            currentJsonTab = tab;
            document.querySelectorAll('.json-tab').forEach(t => t.classList.remove('active'));
            document.querySelector(`.json-tab[data-tab="${tab}"]`).classList.add('active');
            renderJsonContent();
        }
        
        function renderJsonContent() {
            let data;

            switch(currentJsonTab) {
                case 'all': {
                    const world = getWorld();
                    const worldSets = getSetsForWorld();
                    const definitions = getDefinitionView();
                    const connections = getConnectionView();
                    data = {
                        world: world ? { ...world, setIds: Array.from(world.setIds || []) } : null,
                        worlds: Array.from(state.worlds.values()).map(w => ({ ...w, setIds: Array.from(w.setIds || []) })),
                        sets: worldSets.map(s => ({
                            ...s,
                            records: Array.from(s.records.values()),
                            views: Array.from(s.views.values()),
                            profiles: Array.from(s.profiles.values())
                        })),
                        definitions,
                        connections,
                        eventStream: state.eventStream,
                        operatorSet: state.operatorSet,
                        interpretationRules: state.interpretationRules,
                        currentSetId: state.currentSetId,
                        currentViewId: state.currentViewId
                    };
                    break;
                }
                case 'sets': {
                    data = getSetsForWorld().map(s => ({
                        id: s.id,
                        name: s.name,
                        icon: s.icon,
                        schema: s.schema,
                        recordCount: s.records.size,
                        viewCount: s.views.size,
                        records: Array.from(s.records.values()),
                        views: Array.from(s.views.values())
                    }));
                    break;
                }
                case 'current': {
                    const set = getCurrentSet();
                    const setRecordIds = set ? new Set(Array.from(set.records.keys())) : new Set();
                    data = set ? {
                        id: set.id,
                        name: set.name,
                        icon: set.icon,
                        schema: set.schema,
                        records: Array.from(set.records.values()),
                        views: Array.from(set.views.values()),
                        profiles: Array.from(set.profiles.values()),
                        definitions: getDefinitionView(def =>
                            (def.entity?.type === 'Record' && setRecordIds.has(def.entity?.id)) ||
                            (def.entity?.type === 'Field' && set.schema.some(f => f.id === def.entity?.id))
                        ),
                        connections: getConnectionView(conn => (
                            conn.subject?.type === 'Record' && setRecordIds.has(conn.subject?.id)
                        ) || (
                            conn.operand?.type === 'Record' && setRecordIds.has(conn.operand?.id)
                        ))
                    } : null;
                    break;
                }
                case 'events':
                    data = state.eventStream;
                    break;
            }
            
            const jsonString = JSON.stringify(data, null, 2);
            const highlighted = syntaxHighlight(jsonString);
            document.getElementById('jsonContent').innerHTML = highlighted;
        }
        
        function syntaxHighlight(json) {
            json = json.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
            return json.replace(/("(\\u[a-zA-Z0-9]{4}|\\[^u]|[^\\"])*"(\s*:)?|\b(true|false|null)\b|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?)/g, function (match) {
                let cls = 'json-number';
                if (/^"/.test(match)) {
                    if (/:$/.test(match)) {
                        cls = 'json-key';
                    } else {
                        cls = 'json-string';
                    }
                } else if (/true|false/.test(match)) {
                    cls = 'json-boolean';
                } else if (/null/.test(match)) {
                    cls = 'json-null';
                }
                return '<span class="' + cls + '">' + match + '</span>';
            });
        }
        
        function copyJsonToClipboard() {
            const content = document.getElementById('jsonContent').textContent;
            navigator.clipboard.writeText(content).then(() => {
                const btn = document.getElementById('copyJsonBtn');
                const originalText = btn.textContent;
                btn.textContent = ' Copied!';
                btn.classList.add('btn-primary');
                btn.classList.remove('btn-secondary');
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.classList.remove('btn-primary');
                    btn.classList.add('btn-secondary');
                }, 2000);
            }).catch(err => {
                showToast(' Failed to copy');
            });
        }

        function setupKeyboardShortcuts() {
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    if (state.editingCell) {
                        exitEditMode(false);
                        return;
                    }

                    if (state.selectedCell) {
                        state.selectedCell.td.classList.remove('cell-selected');
                        state.selectedCell = null;
                        state.lastSelectedCell = null;
                        return;
                    }

                    const openMenus = document.querySelectorAll('.context-menu');
                    if (openMenus.length) {
                        openMenus.forEach(menu => menu.remove());
                        return;
                    }

                    if (state.modalStack.length > 0) {
                        closeModal(state.modalStack[state.modalStack.length - 1]);
                    }
                }

                // Ctrl+1-9: Navigate to saved shortcuts
                if ((e.ctrlKey || e.metaKey) && e.key >= '1' && e.key <= '9' && !e.shiftKey && !e.altKey) {
                    const shortcutIndex = parseInt(e.key) - 1;
                    const shortcuts = getTabShortcuts();
                    if (shortcuts[shortcutIndex]) {
                        e.preventDefault();
                        navigateToShortcut(shortcuts[shortcutIndex]);
                        return;
                    }
                }

                // Helper: check if any modal is open (tracked or overlay-based)
                const isModalOpen = () => state.modalStack.length > 0 || document.querySelector('.modal-overlay');

                // Ctrl+Z: Undo (pick up/grab the most recent toss action)
                if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z' && !e.shiftKey && !e.altKey && !isModalOpen() && !state.editingCell) {
                    e.preventDefault();
                    const set = getCurrentSet();
                    if (set && typeof TossPile !== 'undefined') {
                        const action = TossPile.getLatestUndoableAction(state, set.id);
                        if (action) {
                            const result = TossPile.pickUpAction(state, action.id);
                            if (result && result.restoredEntries.length > 0) {
                                renderTable();
                                showToast(`Restored ${result.restoredEntries.length} item(s)`);
                            }
                        } else {
                            showToast('Nothing to undo');
                        }
                    }
                    return;
                }

                // Ctrl+Shift+Z: Redo (re-toss the most recently picked up action)
                if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z' && e.shiftKey && !e.altKey && !isModalOpen() && !state.editingCell) {
                    e.preventDefault();
                    if (typeof TossPile !== 'undefined') {
                        const result = TossPile.redoToss(state);
                        if (result && result.retossedEntries.length > 0) {
                            renderTable();
                            showToast(`Re-tossed ${result.retossedEntries.length} item(s)`);
                        } else {
                            showToast('Nothing to redo');
                        }
                    }
                    return;
                }

                // Skip Enter/Tab handling if a modal is open
                if (e.key === 'Enter' && state.selectedCell && !state.editingCell && !isModalOpen()) {
                    e.preventDefault();
                    const { td, recordId, fieldId } = state.selectedCell;
                    const set = getCurrentSet();
                    const field = set?.schema.find(f => f.id === fieldId);
                    if (field) enterEditMode(td, recordId, field);
                }

                if (e.key === 'Tab' && state.selectedCell && !state.editingCell && !isModalOpen()) {
                    e.preventDefault();
                    navigateToNextCell(e.shiftKey ? -1 : 1);
                }

                // Handle printable characters - start editing when user types in a selected cell
                // Skip if a modal is open to allow typing in modal inputs (like notes)
                if (state.selectedCell && !state.editingCell && !e.ctrlKey && !e.metaKey && !e.altKey && !isModalOpen()) {
                    const isPrintable = e.key.length === 1;
                    const isSpecialKey = ['Tab', 'Enter', 'Escape', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Delete', 'Backspace'].includes(e.key);

                    if (isPrintable && !isSpecialKey) {
                        const { td, recordId, fieldId } = state.selectedCell;
                        const set = getCurrentSet();
                        const field = set?.schema.find(f => f.id === fieldId);

                        if (field && field.type !== 'FORMULA' && field.type !== 'RECORD_ID') {
                            e.preventDefault();
                            // For special field types, just enter edit mode
                            if (field.type === 'SELECT' || field.type === 'LINK_RECORD' || field.type === 'CHECKBOX' || field.type === 'DATE') {
                                enterEditMode(td, recordId, field);
                            } else {
                                // For text/number fields, enter edit mode with the typed character
                                enterEditMode(td, recordId, field);
                                // Clear the cell and insert the typed character
                                setTimeout(() => {
                                    if (td.contentEditable === 'true') {
                                        td.textContent = e.key;
                                        // Move cursor to end
                                        const range = document.createRange();
                                        range.selectNodeContents(td);
                                        range.collapse(false);
                                        const selection = window.getSelection();
                                        selection.removeAllRanges();
                                        selection.addRange(range);
                                    }
                                }, 0);
                            }
                        }
                    }
                }

                // Handle Delete/Backspace to clear cell content (skip if modal is open)
                if ((e.key === 'Delete' || e.key === 'Backspace') && state.selectedCell && !state.editingCell && !isModalOpen()) {
                    e.preventDefault();
                    const { recordId, fieldId } = state.selectedCell;
                    const set = getCurrentSet();
                    const record = set?.records.get(recordId);
                    const field = set?.schema.find(f => f.id === fieldId);

                    if (record && field && field.type !== 'FORMULA' && field.type !== 'RECORD_ID') {
                        const currentValue = record[fieldId];
                        if (currentValue !== null && currentValue !== undefined && currentValue !== '') {
                            updateRecord(recordId, fieldId, '', currentValue);
                        }
                    }
                }
            });

            // Add paste event handler for creating new records
            document.addEventListener('paste', (e) => {
                // Don't intercept paste if we're in edit mode or in a modal
                if (state.editingCell || state.modalStack.length > 0) return;

                // Don't intercept paste if the target is an input, textarea, or contentEditable
                const target = e.target;
                if (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.contentEditable === 'true') {
                    return;
                }

                const set = getCurrentSet();
                if (!set) return;

                e.preventDefault();

                const clipboardData = e.clipboardData || window.clipboardData;
                const pastedData = clipboardData.getData('text');

                if (!pastedData || !pastedData.trim()) return;

                handlePasteData(pastedData);
            });
        }

        function handlePasteData(pastedData) {
            const set = getCurrentSet();
            if (!set) return;

            // Parse the pasted data - split by lines and tabs
            const lines = pastedData.split(/\r?\n/).filter(line => line.trim());
            if (lines.length === 0) return;

            // Get visible schema fields (excluding record ID)
            const view = getCurrentView();
            const profile = getCurrentProfile();
            const visibleFields = set.schema.filter(f =>
                f.type !== 'RECORD_ID' &&
                (!profile || profile.visibleFields.length === 0 || profile.visibleFields.includes(f.id))
            );

            if (visibleFields.length === 0) {
                showToast(' No editable fields available');
                return;
            }

            let recordsCreated = 0;

            lines.forEach((line, lineIndex) => {
                const values = line.split('\t');

                // Create a new record
                const recordId = `rec_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                const record = { id: recordId };

                // Set default values for all fields
                set.schema.forEach(f => record[f.id] = FIELD_TYPES[f.type].defaultValue);

                // Fill in values from pasted data
                values.forEach((value, colIndex) => {
                    if (colIndex < visibleFields.length) {
                        const field = visibleFields[colIndex];
                        const trimmedValue = value.trim();

                        // Convert value based on field type
                        if (field.type === 'NUMBER' || field.type === 'CURRENCY') {
                            record[field.id] = parseFloat(trimmedValue) || 0;
                        } else if (field.type === 'CHECKBOX') {
                            record[field.id] = trimmedValue.toLowerCase() === 'true' || trimmedValue === '1';
                        } else if (field.type === 'DATE') {
                            record[field.id] = trimmedValue;
                        } else {
                            record[field.id] = trimmedValue;
                        }
                    }
                });

                set.records.set(recordId, record);
                recordsCreated++;
            });

            renderCurrentView();

            const recordLabel = recordsCreated === 1 ? 'record' : 'records';
            showToast(` ${recordsCreated} ${recordLabel} added from paste`);
        }

        function navigateToNextCell(direction) {
            if (!state.selectedCell) return;

            const currentTd = state.selectedCell.td;
            const row = currentTd.parentElement;
            const cells = Array.from(row.querySelectorAll('.cell-editable'));
            const currentIndex = cells.indexOf(currentTd);

            const nextIndex = currentIndex + direction;
            if (nextIndex >= 0 && nextIndex < cells.length) {
                const nextTd = cells[nextIndex];
                const recordId = nextTd.dataset.recordId;
                const fieldId = nextTd.dataset.fieldId;
                selectCell(nextTd, recordId, fieldId);
                return;
            }

            const tbody = row.parentElement;
            const rows = Array.from(tbody.querySelectorAll('tr'));
            const rowIndex = rows.indexOf(row);
            const nextRowIndex = direction > 0 ? rowIndex + 1 : rowIndex - 1;

            if (nextRowIndex >= 0 && nextRowIndex < rows.length) {
                const nextRow = rows[nextRowIndex];
                const targetIndex = direction > 0 ? 0 : cells.length - 1;
                const nextTd = nextRow.querySelectorAll('.cell-editable')[targetIndex];
                if (nextTd) {
                    const recordId = nextTd.dataset.recordId;
                    const fieldId = nextTd.dataset.fieldId;
                    selectCell(nextTd, recordId, fieldId);
                }
            }
        }

        function openAddSetModal(setId = null) {
            const titleEl = document.getElementById('addSetModalTitle');
            const saveBtn = document.getElementById('saveAddSetBtn');
            const nameInput = document.getElementById('newSetName');
            const iconInput = document.getElementById('newSetIcon');
            const worldSelect = document.getElementById('newSetWorld');

            if (worldSelect) {
                worldSelect.innerHTML = '';
                state.worlds.forEach((world, id) => {
                    const opt = document.createElement('option');
                    opt.value = id;
                    opt.textContent = world.name;
                    worldSelect.appendChild(opt);
                });
            }

            if (setId) {
                const set = state.sets.get(setId);
                state.setEditorContext = { setId };
                if (titleEl) titleEl.textContent = 'Edit Set';
                if (saveBtn) saveBtn.textContent = 'Save';
                if (nameInput) nameInput.value = set?.name || '';
                if (iconInput) iconInput.value = extractIconToken(set?.icon || 'ph-squares-four');
                if (worldSelect && set?.worldId) worldSelect.value = set.worldId;
            } else {
                state.setEditorContext = null;
                if (titleEl) titleEl.textContent = 'Create Set';
                if (saveBtn) saveBtn.textContent = 'Create';
                if (nameInput) nameInput.value = '';
                if (iconInput) iconInput.value = 'ph-squares-four';
                if (worldSelect) worldSelect.value = state.currentWorldId || worldSelect.options[0]?.value || '';
            }
            syncIconSelector('newSetIcon');
            openModal('addSetModal');
        }

        // LEAN CONTEXT TESTING
        function testLeanContextEfficiency() {
            if (!state.leanContext) {
                console.warn('Lean context not initialized');
                return;
            }

            console.log('=== LEAN CONTEXT EFFICIENCY TEST ===');

            // Get current state size
            const currentStateSize = JSON.stringify({
                sets: Array.from(state.sets.entries()),
                eventStream: state.eventStream
            }).length;

            // Get lean context overhead
            const leanContextSize = state.leanContext.estimateStorageSize();

            console.log('\n STORAGE METRICS:');
            console.log(`Current state size: ${(currentStateSize / 1024).toFixed(2)} KB`);
            console.log(`\nLean Context Overhead:`);
            console.log(`  - Templates: ${(leanContextSize.templates / 1024).toFixed(2)} KB (${leanContextSize.templateCount} templates)`);
            console.log(`  - String table: ${(leanContextSize.strings / 1024).toFixed(2)} KB (${leanContextSize.stringCount} strings)`);
            console.log(`  - Total overhead: ${(leanContextSize.total / 1024).toFixed(2)} KB`);

            // Calculate overhead percentage
            const overheadPercent = (leanContextSize.total / currentStateSize * 100).toFixed(2);
            console.log(`\n Context overhead: ${overheadPercent}% of state size`);

            // Count records with lean context
            let leanRecordCount = 0;
            let totalRecordCount = 0;

            state.sets.forEach(set => {
                set.records.forEach(record => {
                    totalRecordCount++;
                    if (record.__ctx) {
                        leanRecordCount++;
                    }
                });
            });

            console.log(`\n RECORD METRICS:`);
            console.log(`  - Total records: ${totalRecordCount}`);
            console.log(`  - Lean records: ${leanRecordCount}`);
            console.log(`  - Coverage: ${totalRecordCount > 0 ? ((leanRecordCount / totalRecordCount) * 100).toFixed(1) : 0}%`);

            // Event compression stats
            const compactEventCount = state.eventStream.filter(e => e.v && e.o && e.t && !e.id.startsWith('event-')).length;
            console.log(`\n EVENT METRICS:`);
            console.log(`  - Total events: ${state.eventStream.length}`);
            console.log(`  - Compact events: ${compactEventCount}`);
            console.log(`  - Compression rate: ${state.eventStream.length > 0 ? ((compactEventCount / state.eventStream.length) * 100).toFixed(1) : 0}%`);

            console.log('\n GOAL: Keep overhead < 15% for optimal performance');
            console.log(`${overheadPercent < 15 ? ' PASSED' : '  REVIEW NEEDED'}: Current overhead is ${overheadPercent}%`);

            return {
                stateSize: currentStateSize,
                overhead: leanContextSize.total,
                overheadPercent: parseFloat(overheadPercent),
                recordCoverage: totalRecordCount > 0 ? (leanRecordCount / totalRecordCount) * 100 : 0,
                eventCompression: state.eventStream.length > 0 ? (compactEventCount / state.eventStream.length) * 100 : 0
            };
        }

        // Export test function to global scope
        window.testLeanContextEfficiency = testLeanContextEfficiency;

        // ============================================
        // IMPORT SYSTEM FUNCTIONS
        // ============================================

        /**
         * Initialize the sidebar drop zone for file imports
         */
        function initializeImportDropZone() {
            const dropZone = document.getElementById('sidebarDropZone');
            if (!dropZone) return;

            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                dropZone.addEventListener(eventName, (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                });
            });

            ['dragenter', 'dragover'].forEach(eventName => {
                dropZone.addEventListener(eventName, () => {
                    dropZone.style.borderColor = '#3b82f6';
                    dropZone.style.background = 'rgba(59, 130, 246, 0.1)';
                });
            });

            ['dragleave', 'drop'].forEach(eventName => {
                dropZone.addEventListener(eventName, () => {
                    dropZone.style.borderColor = '#334155';
                    dropZone.style.background = 'transparent';
                });
            });

            dropZone.addEventListener('drop', async (e) => {
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    for (const file of files) {
                        await handleFileImport(file);
                    }
                }
            });
        }

        // ============================================================================
        // IMPORT & TAB MANAGEMENT
        // Functions for handling file imports, import tabs, and import views
        // ============================================================================

        /**
         * Show the import loading overlay with customizable message
         * @param {object} options - Options for the loading screen
         * @param {string} options.filename - Name of the file being imported
         * @param {number} options.rowCount - Number of rows being processed (optional)
         */
        function showImportLoadingScreen(options = {}) {
            const { filename = 'data', rowCount = null } = options;

            // Get the view container to position the overlay relative to it
            const viewContainer = document.getElementById('viewContainer');
            if (!viewContainer) return;

            // Remove any existing overlay
            hideImportLoadingScreen();

            // Create the loading overlay
            const overlay = document.createElement('div');
            overlay.id = 'importLoadingOverlay';
            overlay.className = 'import-loading-overlay';

            const subtext = rowCount
                ? `Processing ${rowCount.toLocaleString()} records...`
                : 'Preparing your data...';

            overlay.innerHTML = `
                <div class="import-loading-spinner"></div>
                <div class="import-loading-text">Loading ${filename}</div>
                <div class="import-loading-subtext">${subtext}</div>
                <div class="import-loading-progress">
                    <div class="import-loading-progress-bar indeterminate"></div>
                </div>
            `;

            viewContainer.appendChild(overlay);

            // Trigger visibility animation
            requestAnimationFrame(() => {
                overlay.classList.add('visible');
            });
        }

        /**
         * Hide the import loading overlay
         */
        function hideImportLoadingScreen() {
            const overlay = document.getElementById('importLoadingOverlay');
            if (overlay) {
                overlay.classList.remove('visible');
                // Remove after fade out transition
                setTimeout(() => {
                    overlay.remove();
                }, 200);
            }
        }

        /**
         * Update the loading screen progress (for future use with determinate progress)
         * @param {number} percent - Progress percentage (0-100)
         * @param {string} message - Optional message to display
         */
        function updateImportLoadingProgress(percent, message = null) {
            const overlay = document.getElementById('importLoadingOverlay');
            if (!overlay) return;

            const progressBar = overlay.querySelector('.import-loading-progress-bar');
            if (progressBar) {
                progressBar.classList.remove('indeterminate');
                progressBar.style.width = `${percent}%`;
            }

            if (message) {
                const subtext = overlay.querySelector('.import-loading-subtext');
                if (subtext) subtext.textContent = message;
            }
        }

        /**
         * Trigger file input for import
         */
        function triggerFileImport() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.csv,.json,.xlsx,.xls,.tsv';
            input.multiple = true;
            input.onchange = async (e) => {
                for (const file of e.target.files) {
                    await handleFileImport(file);
                }
            };
            input.click();
        }

        /**
         * Handle a file import
         */
        async function handleFileImport(file) {
            if (!state.importManager) {
                showToast(' Import system not initialized');
                return;
            }

            showToast(` Importing ${file.name}...`);

            const result = await state.importManager.createImportFromFile(file);

            if (result.success) {
                renderImportsInSidebar();
                // Automatically open the import as a tab for immediate access
                openImportAsTab(result.import.id);
            } else {
                showToast(` Import failed: ${result.error}`);
            }
        }

        /**
         * Render imports in sidebar
         */
        function renderImportsInSidebar() {
            const container = document.getElementById('navImportsContainer');
            if (!container || !state.importManager) return;

            const imports = state.importManager.getAllImports();

            if (imports.length === 0) {
                container.innerHTML = '<div style="color: #9ca3af; font-size: 0.75rem; padding: 0.25rem 0;">No imports yet</div>';
                return;
            }

            // Check which imports have open tabs
            const getImportViewInfo = (importId) => {
                let viewInfo = null;
                if (state.views) {
                    state.views.forEach((view) => {
                        if (view.importMetadata?.importId === importId) {
                            viewInfo = view;
                        }
                    });
                }
                return viewInfo;
            };

            container.innerHTML = imports.map(imp => {
                const formatIcons = {
                    'csv': 'ph-file-csv',
                    'json': 'ph-file-js',
                    'xlsx': 'ph-file-xls',
                    'xls': 'ph-file-xls'
                };
                const icon = formatIcons[imp.source.format] || 'ph-file';
                const timeAgo = getTimeAgo(imp.createdAt);
                const viewInfo = getImportViewInfo(imp.id);
                const isOpenAsTab = viewInfo && state.openTabs.some(tab => tab.viewId === viewInfo.id);
                const isActive = isOpenAsTab && state.currentViewId === viewInfo?.id;

                return `
                    <div class="nav-item${isActive ? ' active' : ''}" style="display: flex; align-items: center; gap: 8px; padding: 6px 8px;${isOpenAsTab ? ' background: rgba(34, 197, 94, 0.1);' : ''}"
                         onclick="openImportAsTab('${imp.id}')"
                         draggable="true"
                         ondragstart="handleImportDragStart(event, '${imp.id}')"
                         ondragend="handleImportDragEnd(event)">
                        <i class="ph ${icon}" style="font-size: 14px; color: #22c55e;"></i>
                        <div style="flex: 1; min-width: 0;">
                            <div style="font-size: 12px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">
                                ${imp.name}
                            </div>
                            <div style="font-size: 10px; opacity: 0.6;">${imp.rowCount} rows  ${timeAgo}${isOpenAsTab ? '  <span style="color: #22c55e;">Open</span>' : ''}</div>
                        </div>
                        ${imp.usedIn.length > 0 ? `<span style="background: #334155; padding: 2px 6px; border-radius: 10px; font-size: 10px;">${imp.usedIn.length}</span>` : ''}
                    </div>
                `;
            }).join('');
        }

        /**
         * Get time ago string
         */
        function getTimeAgo(dateStr) {
            const date = new Date(dateStr);
            const now = new Date();
            const diffMs = now - date;
            const diffMins = Math.floor(diffMs / 60000);
            const diffHours = Math.floor(diffMs / 3600000);
            const diffDays = Math.floor(diffMs / 86400000);

            if (diffMins < 1) return 'just now';
            if (diffMins < 60) return `${diffMins}m ago`;
            if (diffHours < 24) return `${diffHours}h ago`;
            if (diffDays < 7) return `${diffDays}d ago`;
            return date.toLocaleDateString();
        }

        /**
         * Handle import drag start
         */
        function handleImportDragStart(e, importId) {
            e.dataTransfer.setData('text/plain', importId);
            e.dataTransfer.setData('application/x-import-id', importId);
            e.dataTransfer.effectAllowed = 'copy';
            e.target.style.opacity = '0.5';
        }

        /**
         * Handle import drag end
         */
        function handleImportDragEnd(e) {
            e.target.style.opacity = '1';
        }

        /**
         * Open import as a tab (instead of modal)
         * Creates a temporary staging set if needed
         */
        function openImportAsTab(importId) {
            const imp = state.importManager?.getImport(importId);
            if (!imp) {
                showToast(' Import not found');
                return;
            }

            // Check if there's already a view for this import
            let existingView = null;
            if (state.views) {
                state.views.forEach((view) => {
                    if (view.importMetadata?.importId === importId) {
                        existingView = view;
                    }
                });
            }

            if (existingView) {
                // Switch to existing view (no loading screen needed, just switching)
                switchSet(existingView.setId, existingView.id);
                return;
            }

            // Create a new staging set + view for this import
            if (!state.importIntegration) {
                showToast(' Import system not initialized');
                return;
            }

            // Show loading screen before heavy processing
            const filename = imp.fileMetadata?.filenameAnalysis?.baseName || imp.name;
            showImportLoadingScreen({
                filename: filename,
                rowCount: imp.rowCount || imp.rows?.length
            });

            // Use setTimeout to allow the loading screen to render before blocking the main thread
            setTimeout(() => {
                try {
                    // Use the import filename as the set name
                    const setName = imp.fileMetadata?.filenameAnalysis?.baseName || imp.name.replace(/\.[^/.]+$/, '');

                    // Add import to a new set (this creates the set, records, and view)
                    const result = state.importIntegration.addImportToSet(importId, null, setName);

                    if (result.success) {
                        renderSidebar();
                        // The switchSet is already called by addImportToSet
                    } else {
                        showToast(` Failed to open import: ${result.error}`);
                    }
                } finally {
                    // Hide loading screen after processing completes
                    hideImportLoadingScreen();
                }
            }, 50); // Small delay to ensure loading screen is visible
        }

        /**
         * Show save import as view dialog
         * Allows user to save a temporary import view permanently
         */
        function showSaveImportAsViewDialog() {
            const view = getCurrentView();
            const set = getCurrentSet();

            if (!view || !view.isTemporary || !view.importMetadata) {
                showToast(' This view is not a temporary import');
                return;
            }

            const allSets = Array.from(state.sets.values()).filter(s => s.id !== set.id);
            const suggestedName = view.name.replace('Import: ', '');

            const dialog = document.createElement('div');
            dialog.className = 'modal-overlay';
            dialog.id = 'saveImportViewDialog';
            dialog.style.display = 'flex';

            dialog.innerHTML = `
                <div class="modal" style="width: 450px;">
                    <div class="modal-header">
                        <div class="modal-title-group">
                            <div class="modal-icon" style="background: #10b981;">
                                <i class="ph ph-floppy-disk"></i>
                            </div>
                            <h2>Save as View</h2>
                        </div>
                        <button class="modal-close" onclick="closeModal('saveImportViewDialog')">
                            <i class="ph ph-x"></i>
                        </button>
                    </div>
                    <div class="modal-body">
                        <p style="color: var(--text-secondary); margin-bottom: 1rem;">
                            Save this import as a permanent view to keep it organized in your workspace.
                        </p>

                        <div class="form-group">
                            <label>View Name</label>
                            <input type="text" id="saveImportViewName" class="input" value="${escapeHtml(suggestedName)}" placeholder="Enter view name">
                        </div>

                        <div class="form-group" style="margin-top: 1rem;">
                            <label>Location</label>
                            <div style="margin-top: 0.5rem;">
                                <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; margin-bottom: 0.5rem;">
                                    <input type="radio" name="saveLocation" value="current" checked>
                                    <span>Keep in current set (<strong>${escapeHtml(set.name)}</strong>)</span>
                                </label>
                                ${allSets.length > 0 ? `
                                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                                        <input type="radio" name="saveLocation" value="move">
                                        <span>Move to different set:</span>
                                    </label>
                                    <select id="moveToSetId" class="input" style="margin-left: 24px; margin-top: 0.5rem; width: calc(100% - 24px);" disabled>
                                        ${allSets.map(s => `<option value="${s.id}">${s.name}</option>`).join('')}
                                    </select>
                                ` : ''}
                            </div>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button class="btn btn-secondary" onclick="closeModal('saveImportViewDialog')">Cancel</button>
                        <button class="btn btn-primary" onclick="executeSaveImportAsView()">
                            <i class="ph ph-floppy-disk"></i>
                            Save View
                        </button>
                    </div>
                </div>
            `;

            document.body.appendChild(dialog);

            // Handle radio button changes
            dialog.querySelectorAll('input[name="saveLocation"]').forEach(radio => {
                radio.addEventListener('change', () => {
                    const moveSelect = dialog.querySelector('#moveToSetId');
                    if (moveSelect) {
                        moveSelect.disabled = radio.value !== 'move';
                    }
                });
            });

            // Focus the name input
            setTimeout(() => {
                dialog.querySelector('#saveImportViewName')?.focus();
            }, 100);
        }

        /**
         * Execute saving import as permanent view
         */
        function executeSaveImportAsView() {
            const view = getCurrentView();
            const set = getCurrentSet();

            if (!view || !view.isTemporary) return;

            const viewName = document.getElementById('saveImportViewName')?.value.trim() || view.name.replace('Import: ', '');
            const saveLocation = document.querySelector('input[name="saveLocation"]:checked')?.value || 'current';
            const moveToSetId = document.getElementById('moveToSetId')?.value;

            // Update view properties
            view.name = viewName;
            view.isTemporary = false;
            const importMetadata = view.importMetadata;
            delete view.importMetadata;

            // If moving to a different set, we need to move the records too
            if (saveLocation === 'move' && moveToSetId && moveToSetId !== set.id) {
                const targetSet = state.sets.get(moveToSetId);
                if (targetSet) {
                    // Ensure views maps exist (defensive check)
                    if (!set.views) set.views = new Map();
                    if (!targetSet.views) targetSet.views = new Map();

                    // Move records that came from this import
                    const recordsToMove = [];
                    set.records.forEach((record, recordId) => {
                        if (record._provenance?.importId === importMetadata?.importId) {
                            recordsToMove.push({ id: recordId, record });
                        }
                    });

                    // Add records to target set
                    recordsToMove.forEach(({ id, record }) => {
                        targetSet.records.set(id, record);
                        set.records.delete(id);
                    });

                    // Move view to target set
                    set.views.delete(view.id);
                    view.setId = targetSet.id;
                    targetSet.views.set(view.id, { id: view.id });

                    // Update visible fields for new set
                    view.visibleFields = targetSet.schema.map(f => f.id);

                    showToast(` Moved ${recordsToMove.length} records to ${targetSet.name}`);
                }
            }

            // Log the event
            createEvent(
                'Import Saved as View',
                'UPD',
                { type: 'View', id: view.id },
                {
                    setId: view.setId,
                    viewName: view.name,
                    wasMoved: saveLocation === 'move'
                }
            );

            closeModal('saveImportViewDialog');
            showToast(` Saved view "${viewName}"`);
            renderSidebar();
            renderViewTabs();
            renderCurrentView();
        }

        /**
         * Render the field types tab content for import preview
         */
        function renderFieldTypesTab(imp) {
            if (!imp.typeAssessment) {
                return `<div style="text-align: center; padding: 40px; color: var(--text-secondary);">
                    <i class="ph ph-warning" style="font-size: 32px; margin-bottom: 12px;"></i>
                    <p>Type assessment not available for this import.</p>
                </div>`;
            }

            const assessment = imp.typeAssessment;
            const needsReviewCount = assessment.summary.needsReview?.length || 0;

            // Get available field types for the dropdown
            const fieldTypeOptions = Object.entries(FIELD_TYPES)
                .filter(([key]) => !['LINK_RECORD', 'LOOKUP', 'FORMULA', 'ROLLUP'].includes(key))
                .map(([key, ft]) => `<option value="${key}">${ft.name}</option>`)
                .join('');

            return `
                <div style="margin-bottom: 16px; display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <h4 style="margin: 0 0 4px 0; font-size: 14px; font-weight: 600;">Review Field Types</h4>
                        <p style="margin: 0; font-size: 12px; color: var(--text-secondary);">
                            ${needsReviewCount > 0
                                ? `<span style="color: #ef4444; font-weight: 500;">${needsReviewCount} field${needsReviewCount > 1 ? 's' : ''} need${needsReviewCount === 1 ? 's' : ''} review</span> - verify or change the detected types below`
                                : '<span style="color: #22c55e;">All field types look good!</span> You can still adjust them if needed.'}
                        </p>
                    </div>
                    <div style="display: flex; gap: 8px;">
                        <button class="btn btn-sm btn-secondary" onclick="acceptAllFieldTypesUI('${imp.id}')">
                            <i class="ph ph-checks"></i> Accept All
                        </button>
                    </div>
                </div>

                <div style="display: flex; flex-direction: column; gap: 8px; max-height: 400px; overflow-y: auto;">
                    ${imp.headers.map(header => {
                        const fieldAssessment = assessment.fields[header] || {};
                        const detectedType = fieldAssessment.detectedType || imp.schema.inferredTypes[header] || 'TEXT';
                        const confidence = fieldAssessment.confidence || 0;
                        const confidenceLevel = fieldAssessment.confidenceLevel || 'uncertain';
                        const needsReview = fieldAssessment.needsReview !== false && (confidence < 0.8 || (fieldAssessment.alternatives || []).length > 0);
                        const isAccepted = fieldAssessment.acceptedAt || fieldAssessment.userOverride;
                        const alternatives = fieldAssessment.alternatives || [];
                        const samples = fieldAssessment.samples || imp.schema.columns[header]?.samples || [];

                        const confidenceColors = {
                            high: { bg: '#dcfce7', text: '#166534', border: '#86efac' },
                            medium: { bg: '#fef9c3', text: '#854d0e', border: '#fde047' },
                            low: { bg: '#fee2e2', text: '#991b1b', border: '#fca5a5' },
                            uncertain: { bg: '#f3f4f6', text: '#6b7280', border: '#d1d5db' }
                        };
                        const colors = confidenceColors[confidenceLevel] || confidenceColors.uncertain;

                        const fieldTypeInfo = FIELD_TYPES[detectedType] || { name: detectedType, icon: 'ph-question' };

                        return `
                            <div class="field-type-card" data-field="${header}" data-import-id="${imp.id}"
                                style="padding: 12px 16px; background: ${needsReview && !isAccepted ? '#fffbeb' : 'var(--muted-surface)'};
                                       border: 1px solid ${needsReview && !isAccepted ? '#fcd34d' : 'var(--border)'};
                                       border-radius: 8px; display: flex; align-items: center; gap: 16px;">

                                <!-- Field name -->
                                <div style="flex: 1; min-width: 120px;">
                                    <div style="font-weight: 600; font-size: 13px;">${header}</div>
                                    <div style="font-size: 10px; color: var(--text-secondary); margin-top: 2px;">
                                        ${samples.slice(0, 2).map(s => `<code style="padding: 1px 4px; background: var(--surface); border-radius: 3px; margin-right: 4px;">${String(s).substring(0, 15)}${String(s).length > 15 ? '...' : ''}</code>`).join('')}
                                    </div>
                                </div>

                                <!-- Type selector -->
                                <div style="flex: 1; min-width: 140px;">
                                    <select class="input field-type-select" style="width: 100%; padding: 6px 10px; font-size: 12px;"
                                            onchange="overrideFieldTypeUI('${imp.id}', '${header}', this.value)">
                                        ${Object.entries(FIELD_TYPES)
                                            .filter(([key]) => !['LINK_RECORD', 'LOOKUP', 'FORMULA', 'ROLLUP'].includes(key))
                                            .map(([key, ft]) => `<option value="${key}" ${key === detectedType ? 'selected' : ''}>${ft.name}</option>`)
                                            .join('')}
                                    </select>
                                </div>

                                <!-- Confidence indicator -->
                                <div style="width: 100px; text-align: center;">
                                    <div style="display: inline-flex; align-items: center; gap: 4px; padding: 3px 8px;
                                                background: ${colors.bg}; color: ${colors.text}; border: 1px solid ${colors.border};
                                                border-radius: 12px; font-size: 10px; font-weight: 600;">
                                        <span style="width: 6px; height: 6px; border-radius: 50%; background: ${colors.text};"></span>
                                        ${Math.round(confidence * 100)}%
                                    </div>
                                </div>

                                <!-- Alternatives -->
                                <div style="flex: 1; min-width: 100px;">
                                    ${alternatives.length > 0 ? `
                                        <div style="font-size: 10px; color: var(--text-secondary);">
                                            Also: ${alternatives.slice(0, 2).map(alt => `<span style="cursor: pointer; text-decoration: underline;" onclick="overrideFieldTypeUI('${imp.id}', '${header}', '${alt.type}')">${FIELD_TYPES[alt.type]?.name || alt.type}</span>`).join(', ')}
                                        </div>
                                    ` : ''}
                                </div>

                                <!-- Status/Action -->
                                <div style="width: 80px; text-align: right;">
                                    ${isAccepted ? `
                                        <span style="display: inline-flex; align-items: center; gap: 4px; color: #22c55e; font-size: 11px; font-weight: 500;">
                                            <i class="ph ph-check-circle-fill"></i> OK
                                        </span>
                                    ` : needsReview ? `
                                        <button class="btn btn-sm" style="padding: 4px 10px; font-size: 11px; background: #22c55e; color: white; border: none;"
                                                onclick="acceptFieldTypeUI('${imp.id}', '${header}')">
                                            <i class="ph ph-check"></i> Accept
                                        </button>
                                    ` : `
                                        <span style="display: inline-flex; align-items: center; gap: 4px; color: #22c55e; font-size: 11px; font-weight: 500;">
                                            <i class="ph ph-check-circle"></i> Auto
                                        </span>
                                    `}
                                </div>
                            </div>
                        `;
                    }).join('')}
                </div>

                <div style="margin-top: 16px; padding: 12px; background: var(--muted-surface); border-radius: 8px; font-size: 11px; color: var(--text-secondary);">
                    <i class="ph ph-info" style="margin-right: 6px;"></i>
                    Field types determine how data is displayed and validated. Fields with low confidence (<80%) or alternatives are flagged for review.
                </div>
            `;
        }

        /**
         * Accept a field type in the UI
         */
        function acceptFieldTypeUI(importId, fieldName) {
            if (state.importManager?.acceptFieldType(importId, fieldName)) {
                // Update the card UI
                const card = document.querySelector(`.field-type-card[data-field="${fieldName}"][data-import-id="${importId}"]`);
                if (card) {
                    card.style.background = 'var(--muted-surface)';
                    card.style.borderColor = 'var(--border)';
                    const statusDiv = card.querySelector('div:last-child');
                    if (statusDiv) {
                        statusDiv.innerHTML = `
                            <span style="display: inline-flex; align-items: center; gap: 4px; color: #22c55e; font-size: 11px; font-weight: 500;">
                                <i class="ph ph-check-circle-fill"></i> OK
                            </span>
                        `;
                    }
                }
                // Update the tab badge
                updateFieldTypesTabBadge(importId);
            }
        }

        /**
         * Override a field type in the UI
         */
        function overrideFieldTypeUI(importId, fieldName, newType) {
            if (state.importManager?.overrideFieldType(importId, fieldName, newType)) {
                // Update the card UI
                const card = document.querySelector(`.field-type-card[data-field="${fieldName}"][data-import-id="${importId}"]`);
                if (card) {
                    card.style.background = 'var(--muted-surface)';
                    card.style.borderColor = 'var(--border)';
                    const statusDiv = card.querySelector('div:last-child');
                    if (statusDiv) {
                        statusDiv.innerHTML = `
                            <span style="display: inline-flex; align-items: center; gap: 4px; color: #22c55e; font-size: 11px; font-weight: 500;">
                                <i class="ph ph-check-circle-fill"></i> OK
                            </span>
                        `;
                    }
                }
                // Update the tab badge
                updateFieldTypesTabBadge(importId);
                showToast(` ${fieldName} set to ${FIELD_TYPES[newType]?.name || newType}`);
            }
        }

        /**
         * Accept all field types
         */
        function acceptAllFieldTypesUI(importId) {
            if (state.importManager?.acceptAllFieldTypes(importId)) {
                // Update all cards
                document.querySelectorAll(`.field-type-card[data-import-id="${importId}"]`).forEach(card => {
                    card.style.background = 'var(--muted-surface)';
                    card.style.borderColor = 'var(--border)';
                    const statusDiv = card.querySelector('div:last-child');
                    if (statusDiv) {
                        statusDiv.innerHTML = `
                            <span style="display: inline-flex; align-items: center; gap: 4px; color: #22c55e; font-size: 11px; font-weight: 500;">
                                <i class="ph ph-check-circle-fill"></i> OK
                            </span>
                        `;
                    }
                });
                // Update the tab badge
                updateFieldTypesTabBadge(importId);
                showToast(' All field types accepted');
            }
        }

        /**
         * Update the Field Types tab badge count
         */
        function updateFieldTypesTabBadge(importId) {
            const imp = state.importManager?.getImport(importId);
            if (!imp) return;

            const needsReviewCount = imp.typeAssessment?.summary?.needsReview?.length || 0;
            const tabBtn = document.querySelector('.import-tab[data-tab="fieldtypes"]');
            if (tabBtn) {
                const badge = tabBtn.querySelector('span[style*="background: #ef4444"]');
                if (needsReviewCount > 0) {
                    if (badge) {
                        badge.textContent = needsReviewCount;
                    } else {
                        tabBtn.innerHTML = `
                            <i class="ph ph-sliders" style="margin-right: 4px;"></i>Field Types
                            <span style="background: #ef4444; color: white; padding: 1px 6px; font-size: 10px; font-weight: 600; border-radius: 10px; margin-left: 4px;">${needsReviewCount}</span>
                        `;
                    }
                } else {
                    if (badge) {
                        badge.remove();
                    }
                }
            }
        }

        // Export field type UI functions
        window.acceptFieldTypeUI = acceptFieldTypeUI;
        window.overrideFieldTypeUI = overrideFieldTypeUI;
        window.acceptAllFieldTypesUI = acceptAllFieldTypesUI;

        /**
         * Show import preview modal
         */
        function showImportPreviewModal(imp) {
            if (!imp) return;

            const modal = document.createElement('div');
            modal.className = 'modal-overlay';
            modal.id = 'importPreviewModal';
            modal.style.display = 'flex';

            const formatIcons = {
                'csv': 'ph-file-csv',
                'json': 'ph-file-js',
                'xlsx': 'ph-file-xls',
                'xls': 'ph-file-xls'
            };
            const icon = formatIcons[imp.source.format] || 'ph-file';

            modal.innerHTML = `
                <div class="modal" style="width: 90%; max-width: 1000px; max-height: 85vh; display: flex; flex-direction: column;">
                    <div class="modal-header">
                        <h3 style="display: flex; align-items: center; gap: 10px;">
                            <i class="ph ${icon}" style="color: #22c55e;"></i>
                            ${imp.name}
                        </h3>
                        <button class="modal-close" onclick="closeModal('importPreviewModal')"></button>
                    </div>
                    <div class="modal-body" style="flex: 1; overflow: auto; padding: 0;">
                        <!-- Tabs -->
                        <div style="display: flex; gap: 4px; padding: 12px 20px; border-bottom: 1px solid var(--border); background: var(--muted-surface);">
                            <button class="btn btn-sm import-tab active" data-tab="data" onclick="switchImportTab(this, 'data')">Data</button>
                            <button class="btn btn-sm import-tab" data-tab="schema" onclick="switchImportTab(this, 'schema')">Schema</button>
                            <button class="btn btn-sm import-tab" data-tab="fieldtypes" onclick="switchImportTab(this, 'fieldtypes')">
                                <i class="ph ph-sliders" style="margin-right: 4px;"></i>Field Types
                                ${imp.typeAssessment?.summary?.needsReview?.length > 0 ? `<span style="background: #ef4444; color: white; padding: 1px 6px; font-size: 10px; font-weight: 600; border-radius: 10px; margin-left: 4px;">${imp.typeAssessment.summary.needsReview.length}</span>` : ''}
                            </button>
                            <button class="btn btn-sm import-tab" data-tab="metadata" onclick="switchImportTab(this, 'metadata')">Metadata</button>
                            <button class="btn btn-sm import-tab" data-tab="quality" onclick="switchImportTab(this, 'quality')">Quality</button>
                            <button class="btn btn-sm import-tab" data-tab="storage" onclick="switchImportTab(this, 'storage')">
                                <i class="ph ph-hard-drives" style="margin-right: 4px;"></i>Storage
                            </button>
                        </div>

                        <!-- Data Tab -->
                        <div class="import-tab-content active" data-content="data" style="padding: 20px;">
                            <div style="overflow: auto; max-height: 400px; border: 1px solid var(--border); border-radius: 8px;">
                                <table style="width: 100%; border-collapse: collapse; font-size: 12px;">
                                    <thead>
                                        <tr style="background: var(--muted-surface); position: sticky; top: 0;">
                                            ${imp.headers.map(h => `<th style="padding: 10px 12px; text-align: left; font-weight: 600; border-bottom: 1px solid var(--border); white-space: nowrap;">${h}</th>`).join('')}
                                        </tr>
                                    </thead>
                                    <tbody>
                                        ${imp.rows.slice(0, 50).map(row => `
                                            <tr>
                                                ${imp.headers.map(h => `<td style="padding: 8px 12px; border-bottom: 1px solid var(--border); max-width: 200px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${row[h] ?? ''}</td>`).join('')}
                                            </tr>
                                        `).join('')}
                                    </tbody>
                                </table>
                            </div>
                            ${imp.rowCount > 50 ? `<div style="text-align: center; padding: 10px; font-size: 11px; color: var(--text-secondary);">Showing 50 of ${imp.rowCount} rows</div>` : ''}
                        </div>

                        <!-- Schema Tab -->
                        <div class="import-tab-content" data-content="schema" style="padding: 20px; display: none;">
                            <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(220px, 1fr)); gap: 12px;">
                                ${imp.headers.map(h => {
                                    const col = imp.schema.columns[h];
                                    const type = imp.schema.inferredTypes[h];
                                    const isPK = imp.schema.primaryKeyCandidate === h;
                                    const isFK = imp.schema.foreignKeyHints.some(fk => fk.column === h);

                                    return `
                                        <div style="padding: 12px; background: ${isPK ? '#fef3c7' : isFK ? '#dbeafe' : 'var(--muted-surface)'}; border: 1px solid ${isPK ? '#fcd34d' : isFK ? '#93c5fd' : 'var(--border)'}; border-radius: 8px;">
                                            <div style="display: flex; align-items: center; gap: 6px; margin-bottom: 4px;">
                                                <strong style="font-size: 13px;">${h}</strong>
                                                ${isPK ? '<span style="background: #fde68a; color: #92400e; padding: 2px 6px; font-size: 9px; font-weight: 700; border-radius: 4px;">PK</span>' : ''}
                                                ${isFK ? '<span style="background: #bfdbfe; color: #1e40af; padding: 2px 6px; font-size: 9px; font-weight: 700; border-radius: 4px;">FK</span>' : ''}
                                            </div>
                                            <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 6px;">${type}</div>
                                            <div style="font-size: 10px; color: var(--text-secondary);">
                                                ${col.uniqueCount} unique  ${col.nullCount} nulls
                                            </div>
                                            ${col.samples.length > 0 ? `
                                                <div style="display: flex; flex-wrap: wrap; gap: 4px; margin-top: 6px;">
                                                    ${col.samples.slice(0, 3).map(s => `<code style="padding: 2px 6px; font-size: 10px; background: var(--surface); border-radius: 4px;">${String(s).substring(0, 20)}</code>`).join('')}
                                                </div>
                                            ` : ''}
                                        </div>
                                    `;
                                }).join('')}
                            </div>
                        </div>

                        <!-- Field Types Tab -->
                        <div class="import-tab-content" data-content="fieldtypes" style="padding: 20px; display: none;">
                            ${renderFieldTypesTab(imp)}
                        </div>

                        <!-- Metadata Tab -->
                        <div class="import-tab-content" data-content="metadata" style="padding: 20px; display: none;">
                            <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 20px;">
                                <div style="padding: 16px; background: var(--muted-surface); border-radius: 8px;">
                                    <h4 style="margin: 0 0 12px 0; font-size: 12px; text-transform: uppercase; letter-spacing: 0.5px; color: var(--text-secondary);">File Information</h4>
                                    <dl style="display: grid; grid-template-columns: auto 1fr; gap: 6px 12px; margin: 0; font-size: 12px;">
                                        <dt style="color: var(--text-secondary);">Filename</dt><dd style="margin: 0; font-weight: 500;">${imp.source.filename}</dd>
                                        <dt style="color: var(--text-secondary);">Format</dt><dd style="margin: 0; font-weight: 500;">${imp.source.format.toUpperCase()}</dd>
                                        <dt style="color: var(--text-secondary);">Size</dt><dd style="margin: 0; font-weight: 500;">${imp.fileMetadata.sizeFormatted}</dd>
                                        <dt style="color: var(--text-secondary);">Imported</dt><dd style="margin: 0; font-weight: 500;">${new Date(imp.createdAt).toLocaleString()}</dd>
                                    </dl>
                                </div>

                                ${imp.fileMetadata.filenameAnalysis.timeframe ? `
                                    <div style="padding: 16px; background: var(--muted-surface); border-radius: 8px;">
                                        <h4 style="margin: 0 0 12px 0; font-size: 12px; text-transform: uppercase; letter-spacing: 0.5px; color: var(--text-secondary);">Detected Timeframe</h4>
                                        <dl style="display: grid; grid-template-columns: auto 1fr; gap: 6px 12px; margin: 0; font-size: 12px;">
                                            <dt style="color: var(--text-secondary);">Type</dt><dd style="margin: 0; font-weight: 500;">${imp.fileMetadata.filenameAnalysis.timeframe.type}</dd>
                                            <dt style="color: var(--text-secondary);">Label</dt><dd style="margin: 0; font-weight: 500;">${imp.fileMetadata.filenameAnalysis.timeframe.label}</dd>
                                        </dl>
                                    </div>
                                ` : ''}

                                ${imp.fileMetadata.filenameAnalysis.entityHints.length > 0 ? `
                                    <div style="padding: 16px; background: var(--muted-surface); border-radius: 8px;">
                                        <h4 style="margin: 0 0 12px 0; font-size: 12px; text-transform: uppercase; letter-spacing: 0.5px; color: var(--text-secondary);">Detected Entities</h4>
                                        <div style="display: flex; flex-wrap: wrap; gap: 6px;">
                                            ${imp.fileMetadata.filenameAnalysis.entityHints.map(e => `<span style="padding: 4px 10px; font-size: 11px; font-weight: 500; color: #7c3aed; background: #f3e8ff; border-radius: 12px;">${e}</span>`).join('')}
                                        </div>
                                    </div>
                                ` : ''}

                                ${imp.schema.foreignKeyHints.length > 0 ? `
                                    <div style="padding: 16px; background: var(--muted-surface); border-radius: 8px;">
                                        <h4 style="margin: 0 0 12px 0; font-size: 12px; text-transform: uppercase; letter-spacing: 0.5px; color: var(--text-secondary);">Foreign Key Hints</h4>
                                        <ul style="list-style: none; padding: 0; margin: 0;">
                                            ${imp.schema.foreignKeyHints.map(fk => `
                                                <li style="display: flex; align-items: center; gap: 8px; padding: 6px 0; font-size: 12px;">
                                                    <code style="padding: 2px 6px; background: var(--surface); border-radius: 4px;">${fk.column}</code>
                                                    <span></span>
                                                    <em style="color: #2563eb;">${fk.referencedEntity}</em>
                                                    <span style="margin-left: auto; font-size: 10px; color: var(--text-secondary);">${Math.round(fk.confidence * 100)}%</span>
                                                </li>
                                            `).join('')}
                                        </ul>
                                    </div>
                                ` : ''}
                            </div>
                        </div>

                        <!-- Quality Tab -->
                        <div class="import-tab-content" data-content="quality" style="padding: 20px; display: none;">
                            <div style="display: flex; align-items: center; gap: 40px; padding: 20px; background: var(--muted-surface); border-radius: 8px; margin-bottom: 20px;">
                                <div style="text-align: center;">
                                    <div style="width: 80px; height: 80px; border-radius: 50%; background: conic-gradient(#22c55e ${imp.quality.score * 3.6}deg, var(--border) ${imp.quality.score * 3.6}deg); display: flex; align-items: center; justify-content: center; position: relative;">
                                        <div style="width: 60px; height: 60px; background: var(--surface); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 24px; font-weight: 700; color: #22c55e;">${imp.quality.score}</div>
                                    </div>
                                    <div style="margin-top: 8px; font-size: 12px; color: var(--text-secondary);">Quality Score</div>
                                </div>
                                <div style="display: flex; gap: 32px;">
                                    <div style="text-align: center;">
                                        <div style="font-size: 24px; font-weight: 700;">${imp.quality.completenessPercent}</div>
                                        <div style="font-size: 11px; color: var(--text-secondary);">Completeness</div>
                                    </div>
                                    <div style="text-align: center;">
                                        <div style="font-size: 24px; font-weight: 700;">${imp.quality.uniqueRows}</div>
                                        <div style="font-size: 11px; color: var(--text-secondary);">Unique Rows</div>
                                    </div>
                                    <div style="text-align: center;">
                                        <div style="font-size: 24px; font-weight: 700;">${imp.quality.duplicateRows}</div>
                                        <div style="font-size: 11px; color: var(--text-secondary);">Duplicates</div>
                                    </div>
                                </div>
                            </div>

                            <h4 style="margin: 0 0 16px 0; font-size: 13px; font-weight: 600;">Column Completeness</h4>
                            <div style="display: flex; flex-direction: column; gap: 8px;">
                                ${imp.headers.map(h => {
                                    const col = imp.schema.columns[h];
                                    const pct = imp.rowCount > 0 ? ((imp.rowCount - col.nullCount) / imp.rowCount * 100) : 100;
                                    return `
                                        <div style="display: flex; align-items: center; gap: 12px;">
                                            <span style="width: 140px; font-size: 12px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${h}</span>
                                            <div style="flex: 1; height: 8px; background: var(--border); border-radius: 4px; overflow: hidden;">
                                                <div style="height: 100%; width: ${pct}%; background: #22c55e; border-radius: 4px;"></div>
                                            </div>
                                            <span style="width: 40px; font-size: 11px; color: var(--text-secondary); text-align: right;">${pct.toFixed(0)}%</span>
                                        </div>
                                    `;
                                }).join('')}
                            </div>
                        </div>

                        <!-- Storage Tab (Deduplication) -->
                        <div class="import-tab-content" data-content="storage" style="display: none;">
                            ${typeof EODeduplicationUI !== 'undefined' ? EODeduplicationUI.renderImportStorageTab(imp.id) : '<div style="padding: 40px; text-align: center; color: var(--text-secondary);">Storage optimization module not loaded</div>'}
                        </div>
                    </div>
                    <div class="modal-footer" style="display: flex; justify-content: space-between; align-items: center;">
                        <div style="font-size: 12px; color: var(--text-secondary);">
                            ${imp.usedIn.length > 0 ? `Used in ${imp.usedIn.length} set(s)` : 'Not used yet'}
                            ${imp.deduplicationStats ? `  <span style="color: #22c55e;"><i class="ph ph-hard-drives"></i> ${imp.deduplicationStats.compressionRatio}% storage saved</span>` : ''}
                        </div>
                        <div style="display: flex; gap: 8px;">
                            <button class="btn btn-secondary" onclick="closeModal('importPreviewModal')">Close</button>
                            <button class="btn btn-secondary" onclick="closeModal('importPreviewModal'); openImportAsTab('${imp.id}')">
                                <i class="ph ph-browser"></i>
                                Open as Tab
                            </button>
                            <button class="btn btn-primary" onclick="showAddImportToSetModal('${imp.id}')">
                                <i class="ph ph-plus"></i>
                                Add to Set
                            </button>
                        </div>
                    </div>
                </div>
            `;

            document.body.appendChild(modal);
        }

        /**
         * Switch import preview tab
         */
        function switchImportTab(btn, tabName) {
            const modal = btn.closest('.modal');
            modal.querySelectorAll('.import-tab').forEach(t => t.classList.remove('active'));
            modal.querySelectorAll('.import-tab-content').forEach(c => {
                c.style.display = 'none';
                c.classList.remove('active');
            });

            btn.classList.add('active');
            const content = modal.querySelector(`[data-content="${tabName}"]`);
            if (content) {
                content.style.display = 'block';
                content.classList.add('active');
            }
        }

        /**
         * Show add import to set modal
         */
        function showAddImportToSetModal(importId) {
            const imp = state.importManager?.getImport(importId);
            if (!imp) return;

            // Check if field types need review
            const needsReviewCount = imp.typeAssessment?.summary?.needsReview?.length || 0;
            if (needsReviewCount > 0) {
                // Show the field types tab instead and prompt user to review
                const fieldTypesTab = document.querySelector('.import-tab[data-tab="fieldtypes"]');
                if (fieldTypesTab) {
                    fieldTypesTab.click();
                }
                showToast(` Please review ${needsReviewCount} field type${needsReviewCount > 1 ? 's' : ''} before adding to set`, 'warning');
                return;
            }

            closeModal('importPreviewModal');

            const sets = Array.from(state.sets.values());
            const suggestedName = imp.fileMetadata.filenameAnalysis.baseName || imp.name.replace(/\.[^/.]+$/, '');

            const modal = document.createElement('div');
            modal.className = 'modal-overlay';
            modal.id = 'addImportToSetModal';
            modal.style.display = 'flex';

            modal.innerHTML = `
                <div class="modal" style="width: 400px;">
                    <div class="modal-header">
                        <h3>Add "${imp.name}" to Set</h3>
                        <button class="modal-close" onclick="closeModal('addImportToSetModal')"></button>
                    </div>
                    <div class="modal-body">
                        <div style="margin-bottom: 16px;">
                            <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 10px; cursor: pointer;">
                                <input type="radio" name="importTarget" value="new" checked onchange="toggleImportTargetInputs()">
                                <span>Create new set</span>
                            </label>
                            <input type="text" id="newImportSetName" class="input" value="${suggestedName}" placeholder="Set name" style="margin-left: 24px; width: calc(100% - 24px);">
                        </div>

                        ${sets.length > 0 ? `
                            <div>
                                <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 10px; cursor: pointer;">
                                    <input type="radio" name="importTarget" value="existing" onchange="toggleImportTargetInputs()">
                                    <span>Add to existing set</span>
                                </label>
                                <select id="existingImportSetId" class="input" disabled style="margin-left: 24px; width: calc(100% - 24px);">
                                    ${sets.map(s => `<option value="${s.id}">${s.name}</option>`).join('')}
                                </select>
                            </div>
                        ` : ''}
                    </div>
                    <div class="modal-footer">
                        <button class="btn btn-secondary" onclick="closeModal('addImportToSetModal')">Cancel</button>
                        <button class="btn btn-primary" onclick="executeAddImportToSet('${importId}')">
                            <i class="ph ph-plus"></i>
                            Add ${imp.rowCount} Records
                        </button>
                    </div>
                </div>
            `;

            document.body.appendChild(modal);
        }

        /**
         * Toggle import target inputs based on radio selection
         */
        function toggleImportTargetInputs() {
            const isNew = document.querySelector('input[name="importTarget"]:checked')?.value === 'new';
            const newInput = document.getElementById('newImportSetName');
            const existingSelect = document.getElementById('existingImportSetId');

            if (newInput) newInput.disabled = !isNew;
            if (existingSelect) existingSelect.disabled = isNew;
        }

        /**
         * Execute adding import to set
         */
        function executeAddImportToSet(importId) {
            if (!state.importIntegration) {
                showToast(' Import system not initialized');
                return;
            }

            const isNew = document.querySelector('input[name="importTarget"]:checked')?.value === 'new';
            const setId = isNew ? null : document.getElementById('existingImportSetId')?.value;
            const newSetName = isNew ? document.getElementById('newImportSetName')?.value : null;

            // Validate inputs before closing modal
            if (isNew && !newSetName?.trim()) {
                showToast(' Please enter a name for the new set');
                return;
            }

            if (!isNew && !setId) {
                showToast(' Please select an existing set');
                return;
            }

            closeModal('addImportToSetModal');

            // Remove the modal from DOM to ensure clean render
            const modal = document.getElementById('addImportToSetModal');
            if (modal) modal.remove();

            try {
                const result = state.importIntegration.addImportToSet(importId, setId, newSetName);

                if (result.success) {
                    renderSidebar();
                    // Force a repaint after the import completes to ensure the view is visible
                    requestAnimationFrame(() => {
                        renderCurrentView();
                    });
                } else {
                    showToast(` Failed to add records: ${result.error || 'Unknown error'}`);
                }
            } catch (error) {
                console.error('Error adding import to set:', error);
                showToast(` Error adding records: ${error.message || 'Unknown error'}`);
            }
        }

        /**
         * All Imports Tab Panel - slide-out panel for viewing all imports
         */
        const AllImportsTab = {
            isOpen: false,
            panel: null,
            overlay: null,

            init() {
                // Create panel if it doesn't exist
                if (!this.panel) {
                    this.panel = document.createElement('div');
                    this.panel.className = 'imports-tab-panel';
                    this.panel.id = 'allImportsTabPanel';
                    document.body.appendChild(this.panel);

                    this.overlay = document.createElement('div');
                    this.overlay.className = 'imports-tab-overlay';
                    this.overlay.id = 'allImportsTabOverlay';
                    this.overlay.onclick = () => this.close();
                    document.body.appendChild(this.overlay);
                }
            },

            open() {
                this.init();
                this.render();
                requestAnimationFrame(() => {
                    this.panel.classList.add('open');
                    this.overlay.classList.add('open');
                });
                this.isOpen = true;
            },

            close() {
                if (this.panel) {
                    this.panel.classList.remove('open');
                }
                if (this.overlay) {
                    this.overlay.classList.remove('open');
                }
                this.isOpen = false;
            },

            toggle() {
                if (this.isOpen) {
                    this.close();
                } else {
                    this.open();
                }
            },

            render() {
                if (!this.panel) return;

                const imports = state.importManager?.getAllImports() || [];

                const formatIcons = {
                    'csv': 'ph-file-csv',
                    'json': 'ph-file-js',
                    'xlsx': 'ph-file-xls',
                    'xls': 'ph-file-xls'
                };

                const tableRows = imports.length === 0
                    ? `<tr><td colspan="6">
                        <div class="imports-tab-empty">
                            <i class="ph ph-cloud-arrow-up"></i>
                            <p>No imports yet. Drop a file on the sidebar to import data.</p>
                        </div>
                       </td></tr>`
                    : imports.map(imp => {
                        const icon = formatIcons[imp.source.format] || 'ph-file';
                        const date = new Date(imp.createdAt || imp.source.importedAt);
                        const formattedDate = date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                        const fileSize = imp.source.size ? (imp.source.size / 1024).toFixed(1) + ' KB' : '-';
                        const statusClass = imp.usedIn && imp.usedIn.length > 0 ? 'in-use' : 'available';
                        const statusText = imp.usedIn && imp.usedIn.length > 0 ? `In Use (${imp.usedIn.length})` : 'Available';

                        return `
                            <tr onclick="AllImportsTab.close(); openImportAsTab('${imp.id}')">
                                <td>
                                    <div class="imports-tab-file-cell">
                                        <i class="ph ${icon}"></i>
                                        <div>
                                            <div class="imports-tab-file-name">${imp.name}</div>
                                            <div class="imports-tab-file-format">${imp.source.format.toUpperCase()}</div>
                                        </div>
                                    </div>
                                </td>
                                <td class="text-right">${imp.rowCount?.toLocaleString() || 0}</td>
                                <td class="text-right">${imp.columnCount || imp.headers?.length || 0}</td>
                                <td class="text-right">${fileSize}</td>
                                <td><span class="imports-tab-status-badge ${statusClass}">${statusText}</span></td>
                                <td class="imports-tab-date">${formattedDate}</td>
                            </tr>
                        `;
                    }).join('');

                this.panel.innerHTML = `
                    <div class="imports-tab-header">
                        <div class="imports-tab-header-left">
                            <i class="ph ph-table"></i>
                            <h2>All Imports</h2>
                            <span class="imports-count">${imports.length}</span>
                        </div>
                        <div class="imports-tab-header-right">
                            <button class="btn btn-primary btn-sm" onclick="AllImportsTab.close(); triggerFileImport()">
                                <i class="ph ph-plus"></i> Import File
                            </button>
                            <button class="imports-tab-close" onclick="AllImportsTab.close()">
                                <i class="ph ph-x"></i>
                            </button>
                        </div>
                    </div>
                    <div class="imports-tab-content">
                        <table class="imports-tab-table">
                            <thead>
                                <tr>
                                    <th>File</th>
                                    <th class="text-right">Rows</th>
                                    <th class="text-right">Columns</th>
                                    <th class="text-right">Size</th>
                                    <th>Status</th>
                                    <th>Imported</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${tableRows}
                            </tbody>
                        </table>
                    </div>
                `;
            }
        };

        // Make AllImportsTab globally accessible
        window.AllImportsTab = AllImportsTab;

        /**
         * Open Imports Table View - toggles the imports tab panel
         */
        function openImportsTableView() {
            AllImportsTab.toggle();
        }

        // Export import functions to global scope
        window.triggerFileImport = triggerFileImport;
        window.handleFileImport = handleFileImport;
        window.showImportPreviewModal = showImportPreviewModal;
        window.switchImportTab = switchImportTab;
        window.showAddImportToSetModal = showAddImportToSetModal;
        window.toggleImportTargetInputs = toggleImportTargetInputs;
        window.executeAddImportToSet = executeAddImportToSet;
        window.handleImportDragStart = handleImportDragStart;
        window.handleImportDragEnd = handleImportDragEnd;
        window.openImportsTableView = openImportsTableView;
        window.openImportAsTab = openImportAsTab;
        window.showSaveImportAsViewDialog = showSaveImportAsViewDialog;
        window.executeSaveImportAsView = executeSaveImportAsView;

        // ============================================================================
        // GLOBAL SEARCH BAR
        // ============================================================================

        const GlobalSearch = {
            searchTimeout: null,
            focusedIndex: -1,
            results: [],
            isOpen: false,

            init() {
                // Desktop search elements
                const input = document.getElementById('globalSearchInput');
                const clearBtn = document.getElementById('globalSearchClear');
                const searchBar = document.getElementById('globalSearchBar');
                const resultsContainer = document.getElementById('globalSearchResults');

                // Mobile search elements
                const mobileInput = document.getElementById('mobileSearchInput');
                const mobileClearBtn = document.getElementById('mobileSearchClear');
                const mobileSearchBar = document.getElementById('mobileSearchBar');
                const mobileResultsContainer = document.getElementById('mobileSearchResults');

                // Setup desktop search
                if (input) {
                    input.addEventListener('input', (e) => this.handleInput(e, 'desktop'));
                    input.addEventListener('focus', () => this.handleFocus('desktop'));
                    input.addEventListener('keydown', (e) => this.handleKeydown(e, 'desktop'));
                }
                clearBtn?.addEventListener('click', () => this.clearSearch('desktop'));

                // Setup mobile search
                if (mobileInput) {
                    mobileInput.addEventListener('input', (e) => this.handleInput(e, 'mobile'));
                    mobileInput.addEventListener('focus', () => this.handleFocus('mobile'));
                    mobileInput.addEventListener('keydown', (e) => this.handleKeydown(e, 'mobile'));
                }
                mobileClearBtn?.addEventListener('click', () => this.clearSearch('mobile'));

                // Click outside to close
                document.addEventListener('click', (e) => {
                    const desktopContainer = document.getElementById('globalSearchContainer');
                    const mobileContainer = document.getElementById('mobileSearchContainer');
                    if (desktopContainer && !desktopContainer.contains(e.target)) {
                        this.closeResults('desktop');
                    }
                    if (mobileContainer && !mobileContainer.contains(e.target)) {
                        this.closeResults('mobile');
                    }
                });

                // Global keyboard shortcut (/ to focus search)
                document.addEventListener('keydown', (e) => {
                    // Don't trigger if already in an input or textarea
                    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.isContentEditable) {
                        return;
                    }
                    if (e.key === '/') {
                        e.preventDefault();
                        // Focus the visible search input
                        const isMobile = window.innerWidth <= 1024;
                        const targetInput = isMobile ? mobileInput : input;
                        if (targetInput) {
                            targetInput.focus();
                            targetInput.select();
                        }
                    }
                });

                console.log(' Global Search initialized');
            },

            getElements(mode = 'desktop') {
                if (mode === 'mobile') {
                    return {
                        input: document.getElementById('mobileSearchInput'),
                        searchBar: document.getElementById('mobileSearchBar'),
                        resultsContainer: document.getElementById('mobileSearchResults')
                    };
                }
                return {
                    input: document.getElementById('globalSearchInput'),
                    searchBar: document.getElementById('globalSearchBar'),
                    resultsContainer: document.getElementById('globalSearchResults')
                };
            },

            currentMode: 'desktop',

            handleInput(e, mode = 'desktop') {
                this.currentMode = mode;
                const query = e.target.value.trim();
                const { searchBar } = this.getElements(mode);

                // Toggle has-value class
                if (query.length > 0) {
                    searchBar?.classList.add('has-value');
                } else {
                    searchBar?.classList.remove('has-value');
                }

                // Debounce search
                clearTimeout(this.searchTimeout);
                this.searchTimeout = setTimeout(() => {
                    if (query.length > 0) {
                        this.performSearch(query, mode);
                    } else {
                        this.showZeroInputResults(mode);
                    }
                }, 150);
            },

            handleFocus(mode = 'desktop') {
                this.currentMode = mode;
                const { input } = this.getElements(mode);
                const query = input?.value.trim() || '';

                if (query.length > 0) {
                    this.performSearch(query, mode);
                } else {
                    this.showZeroInputResults(mode);
                }
            },

            handleKeydown(e, mode = 'desktop') {
                const { resultsContainer } = this.getElements(mode);
                const items = resultsContainer?.querySelectorAll('.global-search-result-item') || [];

                switch (e.key) {
                    case 'ArrowDown':
                        e.preventDefault();
                        this.focusedIndex = Math.min(this.focusedIndex + 1, items.length - 1);
                        this.updateFocusedItem(items);
                        break;
                    case 'ArrowUp':
                        e.preventDefault();
                        this.focusedIndex = Math.max(this.focusedIndex - 1, -1);
                        this.updateFocusedItem(items);
                        break;
                    case 'Enter':
                        e.preventDefault();
                        if (this.focusedIndex >= 0 && items[this.focusedIndex]) {
                            items[this.focusedIndex].click();
                        }
                        break;
                    case 'Escape':
                        e.preventDefault();
                        this.closeResults(mode);
                        const { input } = this.getElements(mode);
                        input?.blur();
                        break;
                }
            },

            updateFocusedItem(items) {
                items.forEach((item, index) => {
                    item.classList.toggle('focused', index === this.focusedIndex);
                });
                if (this.focusedIndex >= 0 && items[this.focusedIndex]) {
                    items[this.focusedIndex].scrollIntoView({ block: 'nearest' });
                }
            },

            performSearch(query, mode = 'desktop') {
                const lowerQuery = query.toLowerCase();
                const results = {
                    sets: [],
                    views: [],
                    records: [],
                    fields: []
                };

                // Helper to get all views for a set
                const getViewsForSet = (setId) => {
                    const views = [];
                    if (state.views) {
                        state.views.forEach(view => {
                            if (view.setId === setId) {
                                views.push({
                                    viewId: view.id,
                                    viewName: view.name,
                                    viewType: view.type || 'grid'
                                });
                            }
                        });
                    }
                    return views;
                };

                // Helper to get views where a field is visible
                const getViewsForField = (setId, fieldId) => {
                    const views = [];
                    if (state.views) {
                        state.views.forEach(view => {
                            if (view.setId === setId) {
                                const hiddenFields = view.hiddenFields || [];
                                if (!hiddenFields.includes(fieldId)) {
                                    views.push({
                                        viewId: view.id,
                                        viewName: view.name,
                                        viewType: view.type || 'grid'
                                    });
                                }
                            }
                        });
                    }
                    return views;
                };

                // Search sets
                state.sets.forEach(set => {
                    if (set.name.toLowerCase().includes(lowerQuery)) {
                        const setViews = getViewsForSet(set.id);
                        results.sets.push({
                            type: 'set',
                            id: set.id,
                            name: set.name,
                            matchField: 'name',
                            recordCount: set.records?.size || 0,
                            locations: setViews.length > 0 ? setViews : [{ viewId: null, viewName: 'Set Overview', viewType: 'set' }]
                        });
                    }
                });

                // Search views
                if (state.views) {
                    state.views.forEach(view => {
                        if (view.name.toLowerCase().includes(lowerQuery)) {
                            const set = state.sets.get(view.setId);
                            results.views.push({
                                type: 'view',
                                id: view.id,
                                name: view.name,
                                setId: view.setId,
                                setName: set?.name || 'Unknown Set',
                                matchField: 'name',
                                locations: [{ viewId: view.id, viewName: view.name, viewType: view.type || 'grid' }]
                            });
                        }
                    });
                }

                // Search fields across all sets
                state.sets.forEach(set => {
                    (set.schema || []).forEach(field => {
                        if (field.name?.toLowerCase().includes(lowerQuery) || field.id.toLowerCase().includes(lowerQuery)) {
                            const fieldViews = getViewsForField(set.id, field.id);
                            results.fields.push({
                                type: 'field',
                                id: field.id,
                                name: field.name || field.id,
                                setId: set.id,
                                setName: set.name,
                                fieldType: field.type,
                                matchField: field.name?.toLowerCase().includes(lowerQuery) ? 'name' : 'id',
                                locations: fieldViews.length > 0 ? fieldViews : [{ viewId: null, viewName: 'No visible views', viewType: 'hidden' }]
                            });
                        }
                    });
                });

                // Search records - search through ALL field values
                const recordLimit = 20; // Limit to prevent performance issues
                let recordCount = 0;

                state.sets.forEach(set => {
                    if (recordCount >= recordLimit) return;

                    const schema = set.schema || [];
                    set.records.forEach((record, recordId) => {
                        if (recordCount >= recordLimit) return;

                        // Check each field value
                        for (const field of schema) {
                            const value = record[field.id];
                            if (value !== undefined && value !== null) {
                                const strValue = String(value).toLowerCase();
                                if (strValue.includes(lowerQuery)) {
                                    // Get display name for the record (first text field or ID)
                                    const displayField = schema.find(f => f.type === 'text' || f.type === 'string') || schema[0];
                                    const displayValue = displayField ? record[displayField.id] : recordId;

                                    // Get all views where this record could be seen
                                    const recordViews = getViewsForSet(set.id);

                                    results.records.push({
                                        type: 'record',
                                        id: recordId,
                                        displayValue: displayValue || recordId,
                                        matchedField: field.name || field.id,
                                        matchedFieldId: field.id,
                                        matchedValue: value,
                                        setId: set.id,
                                        setName: set.name,
                                        locations: recordViews.length > 0 ? recordViews : [{ viewId: null, viewName: 'Record Detail', viewType: 'detail' }]
                                    });
                                    recordCount++;
                                    break; // Only add record once
                                }
                            }
                        }
                    });
                });

                this.results = results;
                this.renderResults(results, query, mode);
            },

            showZeroInputResults(mode = 'desktop') {
                // Show recent items and suggestions
                const results = {
                    recent: [],
                    sets: [],
                    views: []
                };

                // Get recent items from event stream
                const events = state.eventStream || [];
                const seen = new Set();
                for (let i = events.length - 1; i >= 0 && results.recent.length < 5; i--) {
                    const event = events[i];
                    if (!event.entityType || !event.entityId) continue;

                    const key = `${event.entityType}:${event.entityId}`;
                    if (seen.has(key)) continue;
                    seen.add(key);

                    if (event.entityType === 'View') {
                        const view = state.views?.get(event.entityId);
                        if (view) {
                            const set = state.sets.get(view.setId);
                            results.recent.push({
                                type: 'view',
                                id: view.id,
                                name: view.name,
                                setId: view.setId,
                                setName: set?.name || 'Unknown'
                            });
                        }
                    } else if (event.entityType === 'Set') {
                        const set = state.sets.get(event.entityId);
                        if (set) {
                            results.recent.push({
                                type: 'set',
                                id: set.id,
                                name: set.name,
                                recordCount: set.records?.size || 0
                            });
                        }
                    }
                }

                // Add all sets
                state.sets.forEach(set => {
                    results.sets.push({
                        type: 'set',
                        id: set.id,
                        name: set.name,
                        recordCount: set.records?.size || 0
                    });
                });

                // Add all views (limited)
                if (state.views) {
                    let viewCount = 0;
                    state.views.forEach(view => {
                        if (viewCount >= 8) return;
                        const set = state.sets.get(view.setId);
                        results.views.push({
                            type: 'view',
                            id: view.id,
                            name: view.name,
                            setId: view.setId,
                            setName: set?.name || 'Unknown'
                        });
                        viewCount++;
                    });
                }

                this.renderZeroInputResults(results, mode);
            },

            renderZeroInputResults(data, mode = 'desktop') {
                const { resultsContainer: container } = this.getElements(mode);
                if (!container) return;

                let html = '<div class="global-search-results-header">Quick Access</div>';

                // Recent items
                if (data.recent.length > 0) {
                    html += '<div class="global-search-section">';
                    html += '<div class="global-search-section-title">Recently Viewed</div>';
                    data.recent.forEach(item => {
                        html += this.renderResultItem(item);
                    });
                    html += '</div>';
                }

                // All sets
                if (data.sets.length > 0) {
                    html += '<div class="global-search-section">';
                    html += '<div class="global-search-section-title">Sets</div>';
                    data.sets.forEach(item => {
                        html += this.renderResultItem(item);
                    });
                    html += '</div>';
                }

                // Views
                if (data.views.length > 0) {
                    html += '<div class="global-search-section">';
                    html += '<div class="global-search-section-title">Views</div>';
                    data.views.forEach(item => {
                        html += this.renderResultItem(item);
                    });
                    html += '</div>';
                }

                container.innerHTML = html;
                this.openResults(mode);
            },

            renderResults(results, query, mode = 'desktop') {
                const { resultsContainer: container } = this.getElements(mode);
                if (!container) return;

                const totalCount = results.sets.length + results.views.length + results.records.length + results.fields.length;

                if (totalCount === 0) {
                    container.innerHTML = `
                        <div class="global-search-empty">
                            <div class="global-search-empty-icon"><i class="ph ph-magnifying-glass"></i></div>
                            <div class="global-search-empty-text">No results found</div>
                            <div class="global-search-empty-hint">Try different keywords or check your spelling</div>
                        </div>
                    `;
                    this.openResults(mode);
                    return;
                }

                let html = `<div class="global-search-results-header">${totalCount} result${totalCount !== 1 ? 's' : ''} for "${this.escapeHtml(query)}"</div>`;

                // Render by category
                if (results.sets.length > 0) {
                    html += '<div class="global-search-section">';
                    html += '<div class="global-search-section-title">Sets</div>';
                    results.sets.forEach(item => {
                        html += this.renderResultItem(item, query);
                    });
                    html += '</div>';
                }

                if (results.views.length > 0) {
                    html += '<div class="global-search-section">';
                    html += '<div class="global-search-section-title">Views</div>';
                    results.views.forEach(item => {
                        html += this.renderResultItem(item, query);
                    });
                    html += '</div>';
                }

                if (results.fields.length > 0) {
                    html += '<div class="global-search-section">';
                    html += '<div class="global-search-section-title">Fields</div>';
                    results.fields.forEach(item => {
                        html += this.renderResultItem(item, query);
                    });
                    html += '</div>';
                }

                if (results.records.length > 0) {
                    html += '<div class="global-search-section">';
                    html += '<div class="global-search-section-title">Records</div>';
                    results.records.forEach(item => {
                        html += this.renderResultItem(item, query);
                    });
                    html += '</div>';
                }

                container.innerHTML = html;
                this.focusedIndex = -1;
                this.openResults(mode);
            },

            renderResultItem(item, query = '') {
                const icons = {
                    set: 'ph-database',
                    view: 'ph-table',
                    record: 'ph-file-text',
                    field: 'ph-tag'
                };

                const viewTypeIcons = {
                    grid: 'ph-table',
                    gallery: 'ph-grid-four',
                    kanban: 'ph-kanban',
                    calendar: 'ph-calendar',
                    set: 'ph-database',
                    detail: 'ph-file-text',
                    hidden: 'ph-eye-slash'
                };

                const icon = icons[item.type] || 'ph-file';
                const highlightedName = query ? this.highlightMatch(item.name || item.displayValue, query) : (item.name || item.displayValue);

                let meta = '';
                let badge = item.type.charAt(0).toUpperCase() + item.type.slice(1);

                switch (item.type) {
                    case 'set':
                        meta = `${item.recordCount} record${item.recordCount !== 1 ? 's' : ''}`;
                        break;
                    case 'view':
                        meta = `in ${item.setName}`;
                        break;
                    case 'field':
                        meta = `${item.fieldType || 'field'} in ${item.setName}`;
                        break;
                    case 'record':
                        meta = `${item.matchedField}: "${this.truncate(String(item.matchedValue), 30)}" in ${item.setName}`;
                        break;
                }

                const locations = item.locations || [];
                const hasMultipleLocations = locations.length > 1;
                const itemId = `search-result-${item.type}-${item.id}`.replace(/[^a-zA-Z0-9-]/g, '_');

                // Build locations HTML if multiple locations exist
                let locationsHtml = '';
                if (hasMultipleLocations) {
                    locationsHtml = `
                        <div class="global-search-locations" id="${itemId}-locations">
                            <div class="global-search-locations-header">
                                <i class="ph ph-map-pin"></i>
                                <span>Found in ${locations.length} views - choose where to go:</span>
                            </div>
                            <div class="global-search-locations-list">
                                ${locations.map(loc => {
                                    const locIcon = viewTypeIcons[loc.viewType] || 'ph-table';
                                    const locOnclick = this.getLocationOnclick(item, loc);
                                    return `
                                        <div class="global-search-location-item" onclick="${locOnclick}; event.stopPropagation();">
                                            <i class="ph ${locIcon}"></i>
                                            <span>${this.escapeHtml(loc.viewName)}</span>
                                            <span class="location-type">${loc.viewType}</span>
                                        </div>
                                    `;
                                }).join('')}
                            </div>
                        </div>
                    `;
                }

                // Create onclick handler - if multiple locations, toggle locations dropdown
                let onclick = '';
                if (hasMultipleLocations) {
                    onclick = `GlobalSearch.toggleLocations('${itemId}'); event.stopPropagation();`;
                } else if (locations.length === 1 && locations[0].viewId) {
                    onclick = this.getLocationOnclick(item, locations[0]);
                } else {
                    // Fallback to original behavior
                    switch (item.type) {
                        case 'set':
                            onclick = `GlobalSearch.navigateToSet('${item.id}')`;
                            break;
                        case 'view':
                            onclick = `GlobalSearch.navigateToView('${item.setId}', '${item.id}')`;
                            break;
                        case 'field':
                            onclick = `GlobalSearch.navigateToField('${item.setId}', '${item.id}')`;
                            break;
                        case 'record':
                            onclick = `GlobalSearch.navigateToRecord('${item.setId}', '${item.id}')`;
                            break;
                    }
                }

                // Show location count badge if multiple locations
                const locationBadge = hasMultipleLocations
                    ? `<div class="global-search-result-locations-badge"><i class="ph ph-map-pin"></i>${locations.length}</div>`
                    : '';

                return `
                    <div class="global-search-result-item ${hasMultipleLocations ? 'has-locations' : ''}" id="${itemId}" onclick="${onclick}">
                        <div class="global-search-result-icon ${item.type}">
                            <i class="ph ${icon}"></i>
                        </div>
                        <div class="global-search-result-content">
                            <div class="global-search-result-title">${highlightedName}</div>
                            <div class="global-search-result-meta">${meta}</div>
                        </div>
                        ${locationBadge}
                        <div class="global-search-result-badge">${badge}</div>
                        ${hasMultipleLocations ? '<i class="ph ph-caret-down global-search-expand-icon"></i>' : ''}
                    </div>
                    ${locationsHtml}
                `;
            },

            getLocationOnclick(item, location) {
                const viewId = location.viewId;
                const setId = item.setId || item.id;

                switch (item.type) {
                    case 'set':
                        if (viewId) {
                            return `GlobalSearch.navigateToViewWithHighlight('${setId}', '${viewId}', 'set', '${item.id}')`;
                        }
                        return `GlobalSearch.navigateToSet('${item.id}')`;
                    case 'view':
                        return `GlobalSearch.navigateToView('${setId}', '${item.id}')`;
                    case 'field':
                        if (viewId) {
                            return `GlobalSearch.navigateToViewWithHighlight('${setId}', '${viewId}', 'field', '${item.id}')`;
                        }
                        return `GlobalSearch.navigateToField('${setId}', '${item.id}')`;
                    case 'record':
                        if (viewId) {
                            return `GlobalSearch.navigateToViewWithHighlight('${setId}', '${viewId}', 'record', '${item.id}', '${item.matchedFieldId || ''}')`;
                        }
                        return `GlobalSearch.navigateToRecord('${setId}', '${item.id}')`;
                    default:
                        return '';
                }
            },

            toggleLocations(itemId) {
                const locationsEl = document.getElementById(`${itemId}-locations`);
                const itemEl = document.getElementById(itemId);
                if (locationsEl && itemEl) {
                    const isExpanded = locationsEl.classList.contains('expanded');
                    // Close all other expanded locations first
                    document.querySelectorAll('.global-search-locations.expanded').forEach(el => {
                        el.classList.remove('expanded');
                    });
                    document.querySelectorAll('.global-search-result-item.expanded').forEach(el => {
                        el.classList.remove('expanded');
                    });
                    // Toggle current
                    if (!isExpanded) {
                        locationsEl.classList.add('expanded');
                        itemEl.classList.add('expanded');
                    }
                }
            },

            navigateToSet(setId) {
                this.closeResults();
                this.clearSearch('desktop');
                this.clearSearch('mobile');

                // Expand set in sidebar and switch to it
                state.expandedSets.add(setId);
                const set = state.sets.get(setId);
                if (set && set.views && set.views.size > 0) {
                    const firstViewId = Array.from(set.views.keys())[0];
                    switchSet(setId, firstViewId);
                } else {
                    switchSet(setId);
                }
                renderSidebar();
            },

            navigateToView(setId, viewId) {
                this.closeResults();
                this.clearSearch('desktop');
                this.clearSearch('mobile');

                state.expandedSets.add(setId);
                switchSet(setId, viewId);
                renderSidebar();
            },

            navigateToField(setId, fieldId) {
                this.closeResults();
                this.clearSearch('desktop');
                this.clearSearch('mobile');

                // Navigate to the set and highlight the field somehow
                state.expandedSets.add(setId);
                const set = state.sets.get(setId);
                if (set && set.views && set.views.size > 0) {
                    const firstViewId = Array.from(set.views.keys())[0];
                    switchSet(setId, firstViewId);
                    // TODO: Could scroll to or highlight the field column
                }
                renderSidebar();
                showToast(`Field "${fieldId}" is in this view`, 'info');
            },

            navigateToRecord(setId, recordId) {
                this.closeResults();
                this.clearSearch('desktop');
                this.clearSearch('mobile');

                state.expandedSets.add(setId);
                const set = state.sets.get(setId);
                if (set && set.views && set.views.size > 0) {
                    const firstViewId = Array.from(set.views.keys())[0];
                    switchSet(setId, firstViewId);
                    // Trigger record detail view if available
                    setTimeout(() => {
                        if (typeof openRecordDetail === 'function') {
                            openRecordDetail(recordId);
                        }
                    }, 100);
                }
                renderSidebar();
            },

            // Navigate to a specific view with highlighting of the target element
            navigateToViewWithHighlight(setId, viewId, highlightType, targetId, fieldId = '') {
                this.closeResults();
                this.clearSearch('desktop');
                this.clearSearch('mobile');

                state.expandedSets.add(setId);
                switchSet(setId, viewId);
                renderSidebar();

                // Store highlight info in state for the renderer to use
                state.searchHighlight = {
                    type: highlightType,
                    targetId: targetId,
                    fieldId: fieldId,
                    timestamp: Date.now()
                };

                // Apply highlighting after the view renders
                setTimeout(() => {
                    this.applyHighlight(highlightType, targetId, fieldId);
                }, 150);
            },

            // Apply visual highlighting to the target element
            applyHighlight(highlightType, targetId, fieldId) {
                // Remove any existing highlights
                document.querySelectorAll('.search-highlight').forEach(el => {
                    el.classList.remove('search-highlight');
                });
                document.querySelectorAll('.search-highlight-pulse').forEach(el => {
                    el.classList.remove('search-highlight-pulse');
                });

                let targetElement = null;
                let scrollTarget = null;

                switch (highlightType) {
                    case 'field':
                        // Find the column header with this field ID
                        targetElement = document.querySelector(`[data-field-id="${targetId}"]`);
                        if (!targetElement) {
                            // Try finding by the th element in the grid header
                            const headers = document.querySelectorAll('.eo-grid th');
                            headers.forEach(th => {
                                if (th.dataset.fieldId === targetId || th.textContent.includes(targetId)) {
                                    targetElement = th;
                                }
                            });
                        }
                        scrollTarget = targetElement;
                        break;

                    case 'record':
                        // Find the row with this record ID
                        targetElement = document.querySelector(`tr[data-record-id="${targetId}"]`);
                        if (!targetElement) {
                            targetElement = document.querySelector(`[data-record-id="${targetId}"]`);
                        }
                        scrollTarget = targetElement;

                        // If we have a specific field, also try to highlight that cell
                        if (fieldId && targetElement) {
                            const cell = targetElement.querySelector(`td[data-field-id="${fieldId}"]`);
                            if (cell) {
                                cell.classList.add('search-highlight', 'search-highlight-pulse');
                            }
                        }
                        break;

                    case 'set':
                        // Highlight the entire view area briefly
                        targetElement = document.querySelector('.main-content');
                        break;
                }

                if (targetElement) {
                    targetElement.classList.add('search-highlight', 'search-highlight-pulse');

                    // Scroll into view
                    if (scrollTarget) {
                        scrollTarget.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'center' });
                    }

                    // Remove highlight after animation
                    setTimeout(() => {
                        targetElement.classList.remove('search-highlight-pulse');
                        // Keep subtle highlight for a bit longer
                        setTimeout(() => {
                            targetElement.classList.remove('search-highlight');
                            state.searchHighlight = null;
                        }, 3000);
                    }, 2000);
                }

                // Show a helpful toast
                const typeLabels = {
                    field: 'column',
                    record: 'row',
                    set: 'view'
                };
                const label = typeLabels[highlightType] || highlightType;
                if (targetElement) {
                    showToast(`Found ${label} - highlighted in view`, 'success');
                } else {
                    showToast(`Navigated to view`, 'info');
                }
            },

            highlightMatch(text, query) {
                if (!query || !text) return this.escapeHtml(text);
                const escaped = this.escapeHtml(text);
                const regex = new RegExp(`(${this.escapeRegex(query)})`, 'gi');
                return escaped.replace(regex, '<mark>$1</mark>');
            },

            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            },

            escapeRegex(string) {
                return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            },

            truncate(text, length) {
                if (text.length <= length) return text;
                return text.substring(0, length) + '...';
            },

            openResults(mode = 'desktop') {
                const { resultsContainer: container } = this.getElements(mode);
                container?.classList.add('active');
                this.isOpen = true;
            },

            closeResults(mode) {
                // If no mode specified, close both
                if (!mode) {
                    document.getElementById('globalSearchResults')?.classList.remove('active');
                    document.getElementById('mobileSearchResults')?.classList.remove('active');
                } else {
                    const { resultsContainer: container } = this.getElements(mode);
                    container?.classList.remove('active');
                }
                this.isOpen = false;
                this.focusedIndex = -1;
            },

            clearSearch(mode = 'desktop') {
                const { input, searchBar } = this.getElements(mode);
                if (input) {
                    input.value = '';
                }
                searchBar?.classList.remove('has-value');
                this.closeResults(mode);
            }
        };

        // Expose GlobalSearch to window
        window.GlobalSearch = GlobalSearch;

        // INITIALIZE
        document.addEventListener('DOMContentLoaded', async () => {
            applyTimeBasedBranding();
            await initializeApp();
            setInterval(applyTimeBasedBranding, 30 * 60 * 1000);
        });
    </script>
</body>
</html>
